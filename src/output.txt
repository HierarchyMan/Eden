Filename: .\main\java\io\github\epicgo\sconey\SconeyHandler.java
package io.github.epicgo.sconey;

import io.github.epicgo.sconey.element.SconeyElementAdapter;
import org.bukkit.entity.Player;
import org.bukkit.plugin.java.JavaPlugin;

import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

public class SconeyHandler {

    private final Map<UUID, SconeyPlayer> players = new HashMap<>();

    private final SconeyElementAdapter adapter;
    private SconeyThread sconeyThread;

    public SconeyHandler(final JavaPlugin plugin, final SconeyElementAdapter adapter) {
        this.adapter = adapter;

        plugin.getServer().getPluginManager().registerEvents(new SconeyListener(this), plugin);

        this.startThread();
    }

    /**
     * Starts the threads
     */
    public void startThread() {
        this.stopThread();

        this.sconeyThread = new SconeyThread(this);
        this.sconeyThread.start();
    }

    /**
     * Stops the threads
     */
    public void stopThread() {
        if (this.sconeyThread != null) {
            this.sconeyThread.stop();
            this.sconeyThread = null;
        }
    }

    /**
     * Handle a board to send to a player scoreboard
     *
     * @param player the player scoreboard to display the board for
     */
    public void addScoreboard(final Player player) {
        this.players.put(player.getUniqueId(), new SconeyPlayer(player, adapter));
    }

    /**
     * Clear the board from a player's scoreboard
     *
     * @param player the player scoreboard to clear the board for
     */
    public void removeScoreboard(final Player player) {
        this.players.remove(player.getUniqueId());
    }

    /**
     * Get the {@link SconeyPlayer} board of a player scoreboard
     *
     * @param player the player to get the board by
     * @return the board
     */
    public SconeyPlayer getScoreboard(final Player player) {
        return this.players.get(player.getUniqueId());
    }
}


Filename: .\main\java\io\github\epicgo\sconey\SconeyListener.java
package io.github.epicgo.sconey;

import lombok.RequiredArgsConstructor;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.Listener;
import org.bukkit.event.player.PlayerJoinEvent;
import org.bukkit.event.player.PlayerQuitEvent;
import org.bukkit.event.server.PluginDisableEvent;

@RequiredArgsConstructor
public class SconeyListener implements Listener {

    private final SconeyHandler sconeyHandler;

    @EventHandler
    public void onJoin(final PlayerJoinEvent event) {
        final Player player = event.getPlayer();
        this.sconeyHandler.addScoreboard(player);
    }

    @EventHandler
    public void onQuit(final PlayerQuitEvent event) {
        final Player player = event.getPlayer();
        this.sconeyHandler.removeScoreboard(player);
    }

    @EventHandler
    public void onPluginDisable(final PluginDisableEvent event) {
        this.sconeyHandler.stopThread();
    }
}


Filename: .\main\java\io\github\epicgo\sconey\SconeyPlayer.java
package io.github.epicgo.sconey;

import com.google.common.collect.ImmutableSet;
import io.github.epicgo.sconey.element.SconeyElement;
import io.github.epicgo.sconey.element.SconeyElementAdapter;
import io.github.epicgo.sconey.element.SconeyElementMode;
import io.github.epicgo.sconey.reflection.impl.RPacketScoreboardScore;
import io.github.epicgo.sconey.reflection.impl.RPacketScoreboardTeam;
import org.bukkit.Bukkit;
import org.bukkit.ChatColor;
import org.bukkit.entity.Player;
import org.bukkit.scoreboard.DisplaySlot;
import org.bukkit.scoreboard.Objective;
import org.bukkit.scoreboard.Scoreboard;
import rip.diamond.practice.util.CC;

import java.util.*;

public class SconeyPlayer {

    private final Map<String, Integer> displayedScores = new HashMap<>();
    private final Map<String, String> scorePrefixes = new HashMap<>();
    private final Map<String, String> scoreSuffixes = new HashMap<>();
    private final Set<String> sentTeamCreates = new HashSet<>();
    private final Set<String> recentlyUpdatedScores = new HashSet<>();

    private final Player player;
    private final SconeyElementAdapter adapter;
    private final Objective objective;
    private Objective healthObjective;

    public SconeyPlayer(final Player player, final SconeyElementAdapter adapter) {
        this.player = player;
        this.adapter = adapter;

        final Scoreboard scoreboard = this.getScoreboard(player);
        player.setScoreboard(scoreboard);

        this.objective = this.getObjective();
        this.healthObjective = null;
    }

    /**
     * Handle a sidebar to send to a player scoreboard
     */
    public void handleUpdate() {
        final SconeyElement boardElement = this.adapter.getElement(player);
        String title = ChatColor.translateAlternateColorCodes('&', boardElement.getTitle());
        if (title.length() > 32)
            title = title.substring(0, 32);

        List<String> lines = boardElement.getLines();
        if (lines.size() > 15) {
            final List<String> delimitedLines = new ArrayList<>();

            for (int index = 0; index < 15; index++) {
                delimitedLines.add(lines.get(index));
            }

            lines = delimitedLines;
        }

        recentlyUpdatedScores.clear();

        // Update the title if needed.
        if (!objective.getDisplayName().equals(title))
            objective.setDisplayName(title);

        // Reverse the lines because scoreboard scores are in descending order.
        if (!boardElement.getMode().isDescending())
            Collections.reverse(lines);

        int cache = boardElement.getMode().getStartNumber();
        for (int index = 0; index < lines.size(); index++) {
            final String line = lines.get(index);

            final int nextValue = (index + 1);
            final int displayValue = boardElement.getMode().isDescending() ? cache-- : cache++;

            final String[] attributes = this.splitText(ChatColor.translateAlternateColorCodes('&', line), nextValue);

            final String prefix = attributes[0];
            final String score = attributes[1];
            final String suffix = attributes[2];

            recentlyUpdatedScores.add(score);

            if (!this.sentTeamCreates.contains(score))
                this.createAndAddMember(score);


            if (!this.displayedScores.containsKey(score) || this.displayedScores.get(score) != displayValue)
                this.setScore(score, displayValue);


            if (!this.scorePrefixes.containsKey(score) || !(this.scorePrefixes.get(score)).equals(prefix) || !(this.scoreSuffixes.get(score)).equals(suffix))
                this.updateScore(score, prefix, suffix);

        }

        for (final String displayedScore : ImmutableSet.copyOf(this.displayedScores.keySet())) {
            if (this.recentlyUpdatedScores.contains(displayedScore))
                continue;

            removeScore(displayedScore);
        }
    }


    // This is here so that the score joins itself, this way
    // #updateScore will work as it should (that works on a 'player'), which technically we are adding to ourselves
    private void createAndAddMember(final String teamName) {
        final RPacketScoreboardTeam scoreboardTeamAdd = new RPacketScoreboardTeam(
                teamName, "_", "_", 0, new ArrayList<>());
        final RPacketScoreboardTeam scoreboardTeamAddMember = new RPacketScoreboardTeam(
                teamName, null, null, 3, Collections.singletonList(teamName));

        scoreboardTeamAdd.sendPacket(player);
        scoreboardTeamAddMember.sendPacket(player);

        this.sentTeamCreates.add(teamName);
    }

    private void setScore(final String teamName, int value) {
        final RPacketScoreboardScore scoreboardScore = new RPacketScoreboardScore(
                teamName, this.objective.getName(), value, RPacketScoreboardScore.EnumScoreAction.CHANGE);

        scoreboardScore.sendPacket(player);

        this.displayedScores.put(teamName, value);
    }

    private void removeScore(final String teamName) {
        final RPacketScoreboardScore scoreboardScore = new RPacketScoreboardScore(
                teamName, "", 0, RPacketScoreboardScore.EnumScoreAction.REMOVE);

        scoreboardScore.sendPacket(player);

        this.displayedScores.remove(teamName);
        this.scorePrefixes.remove(teamName);
        this.scoreSuffixes.remove(teamName);
    }

    private void updateScore(final String teamName, final String prefix, final String suffix) {
        final RPacketScoreboardTeam scoreboardTeam = new RPacketScoreboardTeam(
                teamName, prefix, suffix, 2, null);

        scoreboardTeam.sendPacket(player);

        this.scorePrefixes.put(teamName, prefix);
        this.scoreSuffixes.put(teamName, suffix);
    }

    /**
     * Split the text to display on the scoreboard
     *
     * @param text  the text to split
     * @param value the value to get by score
     * @return the split text
     */
    private String[] splitText(final String text, final int value) {
        // FrozenOrb - Here be dragons.
        // FrozenOrb - Good luck maintaining this code.
        // Actual - Fixed params prefix,suffix,name, god changed && values

        String prefix;
        String team = colorCharAt(value);
        String suffix = "";

        prefix = text;

        if (prefix.length() > 16) {
            prefix = text.substring(0, 16);

            if (prefix.charAt(15) == ChatColor.COLOR_CHAR) {
                prefix = prefix.substring(0, 15);
                team = colorCharAt(value) + lastColors(prefix) + text.substring(15, text.length());
            } else if (prefix.charAt(14) == ChatColor.COLOR_CHAR) {
                prefix = prefix.substring(0, 14);
                team = colorCharAt(value) + lastColors(prefix) + text.substring(14, text.length());
            } else {
                team = colorCharAt(value) + lastColors(prefix) + text.substring(16, text.length());
            }

            if (team.length() > 16) {
                team = team.substring(0, 16);

                int start = prefix.length() + (team.length() - colorCharAt(value).length() - lastColors(prefix).length());
                suffix = text.substring(start, text.length());

                if (suffix.length() > 16) {
                    suffix = suffix.substring(0, 16);
                }
            }
        }

        return new String[]{prefix, team, suffix};
    }

    /**
     * Get char format of color id
     *
     * @param colorId the color id
     * @return the color char
     */
    public String colorCharAt(final int colorId) {
        return ChatColor.COLOR_CHAR + String.valueOf(colorId / 10) + ChatColor.COLOR_CHAR + colorId % 10;
    }

    /**
     * Get the last color of the text
     *
     * @param text to get the last color
     * @return the last char color
     */
    public String lastColors(final String text) {
        final String lastColors = ChatColor.getLastColors(text);

        if (lastColors.length() > 0)
            return lastColors;

        return ChatColor.COLOR_CHAR + "r";
    }

    /**
     * Get the scoreboard of a player
     *
     * @param player the player to get the scoreboard by
     * @return the scoreboard
     */
    public Scoreboard getScoreboard(final Player player) {
        return player.getScoreboard().equals(Bukkit.getScoreboardManager().getMainScoreboard())
                ? Bukkit.getScoreboardManager().getNewScoreboard()
                : player.getScoreboard();
    }

    /**
     * Get the objective for the scoreboard
     *
     * @return the found objective or a newly registered objective
     */
    public Objective getObjective() {
        Scoreboard scoreboard = getScoreboard(player);
        Objective objective = scoreboard.getObjective("Sconey");

        if (objective == null) {
            objective = scoreboard.registerNewObjective("Sconey", "dummy");
            objective.setDisplaySlot(DisplaySlot.SIDEBAR);
        }

        return objective;
    }

    /**
     * Get the objective for the scoreboard
     */
    public void registerHealthObjective() {
        Scoreboard scoreboard = getScoreboard(player);
        Objective objective = scoreboard.getObjective("HealthDisplay");

        if (objective == null) {
            objective = scoreboard.registerNewObjective("HealthDisplay", "health");
            objective.setDisplaySlot(DisplaySlot.BELOW_NAME);
            objective.setDisplayName(CC.RED + "‚ù§");
        }

        this.healthObjective = objective;
    }

    /**
     * Remove/Unregister the health objective
     */
    public void unregisterHealthObjective() {
        try {
            if (this.healthObjective != null && this.healthObjective.getScoreboard() != null) {
                this.healthObjective.unregister();
                this.healthObjective = null;
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

}


Filename: .\main\java\io\github\epicgo\sconey\SconeyThread.java
package io.github.epicgo.sconey;

import org.bukkit.Bukkit;
import org.bukkit.entity.Player;
import rip.diamond.practice.util.Util;

public class SconeyThread extends Thread {

    private final SconeyHandler sconeyHandler;

    public SconeyThread(final SconeyHandler sconeyHandler) {
        super("Board - Thread tick");
        this.sconeyHandler = sconeyHandler;

        this.setDaemon(true);
    }

    @Override
    public void run() {
        while (true) {
            this.tick();
            try {
                Thread.sleep(50L);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }

    /**
     * Tick logic for thread.
     */
    private void tick() {
        for (final Player player : Util.getOnlinePlayers()) {
            try {
                final SconeyPlayer sconeyPlayer = this.sconeyHandler.getScoreboard(player);
                if (sconeyPlayer == null) return;

                sconeyPlayer.handleUpdate();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }

}


Filename: .\main\java\io\github\epicgo\sconey\element\SconeyElement.java
package io.github.epicgo.sconey.element;

import lombok.Getter;
import lombok.Setter;

import java.util.ArrayList;
import java.util.List;

/**
 * This class provides helper methods to create an elements containing the provided scoreboard
 */
@Getter
@Setter
public class SconeyElement {

    /**
    * List of format strings to place the scoreboard line on
    */
    private final List<String> lines = new ArrayList<>();

    /**
     * The format string to display on the scoreboard title
     */
    private String title;
    /**
     * The position numbers being displayed on the right column of the scoreboard
     */
    private SconeyElementMode mode = SconeyElementMode.UP;

    /**
     * Add a new line to the scoreboard element
     *
     * @param text the line to display
     */
    public void add(final String text) {
        this.lines.add(text);
    }

    /**
     * Add a new line to the scoreboard element on a certain spot in the list
     *
     * @param position  the index to place the line on
     * @param text the line to provide
     */
    public void add(final int position, final String text) {
        if (position > 16) return;

        this.lines.add(position, text);
    }

    /**
     * Add list of lines to the scoreboard element
     *
     * @param texts all the lines to display
     */
    public void addAll(final List<String> texts) {
        this.lines.addAll(texts);
    }
}

Filename: .\main\java\io\github\epicgo\sconey\element\SconeyElementAdapter.java
package io.github.epicgo.sconey.element;

import org.bukkit.entity.Player;

/**
 *
 * Sconey Element Adapter interface
 * the adapter that will provide the player with scoreboard element
 */
public interface SconeyElementAdapter {

    /**
     * This method returns the scoreboard element used by this instance
     * @param player the player containing the provided scoreboard
     * @return the scoreboard element used by this instance
     */
    SconeyElement getElement(final Player player);
}


Filename: .\main\java\io\github\epicgo\sconey\element\SconeyElementMode.java
package io.github.epicgo.sconey.element;


import lombok.Getter;

@Getter
public enum SconeyElementMode {

    DOWN(true, 15),
    NEGATIVE(true, -1),
    UP(false, 1),
    CUSTOM(false, 0);

    private boolean descending;
    private int startNumber;

    /**
     * Constructor a new SconeyElementMode instance
     *
     * @param descending  whether the positions are going down or up.
     * @param startNumber from where to loop from.
     */
    private SconeyElementMode(final boolean descending, final int startNumber) {
        this.descending = descending;
        this.startNumber = startNumber;
    }

    public SconeyElementMode reverse() {
        return descending(!this.descending);
    }

    public SconeyElementMode descending(boolean descending) {
        this.descending = descending;
        return this;
    }

    public SconeyElementMode startNumber(int startNumber) {
        this.startNumber = startNumber;
        return this;
    }
}


Filename: .\main\java\io\github\epicgo\sconey\reflection\Reflection.java
package io.github.epicgo.sconey.reflection;

import lombok.SneakyThrows;
import org.bukkit.Bukkit;

import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

/**
 * A utility class that simplifies reflection in Bukkit plugins
 */
public class Reflection {

    /**
     * Returns is a native 1.7 version
     * @return If is native 1.7 version
     */
    public boolean isNative17() {
        return getBuildVersion().contains("v1_7");
    }

    /**
     * The build version the server is running
     * @return the version of build R- of the server
     */
    public static String getBuildVersion() {
        return Bukkit.getServer().getClass().getPackage().getName().substring(23);
    }

    /**
     * Returns a specified class from its full name
     *
     * @param clazz the class name
     * @return the looked up class
     */
    @SneakyThrows
    public static Class<?> getClass(final String clazz) {
        return Class.forName(clazz);
    }

    /**
     * Returns a class in the net.minecraft.server.VERSION.* package
     *
     * @param clazz the name of the class, excluding the package
     * @return the looked up nms class
     */
    public static Class<?> getNMSClass(final String clazz) {
       return getClass("net.minecraft.server." + getBuildVersion() + "." + clazz);
    }

    /**
     * Returns a class in the org.bukkit.craftbukkit.VERSION.* package
     *
     * @param clazz the name of the class, excluding the package
     * @return the looked up obc class
     */
    public static Class<?> getOBCClass(final String clazz) {
        return getClass("org.bukkit.craftbukkit." + getBuildVersion() + "." + clazz);
    }

    /**
     * Returns a field object for a specific field  name
     *
     * @param target the class instance
     * @param fieldName the name of the field
     * @return the field object
     */
    @SneakyThrows
    public Object getField(final Object target, final String fieldName) {
        final Field field = target.getClass().getField(fieldName);
        field.setAccessible(true);

        return field.get(target);
    }

    /**
     * Returns a declared field object for a specific field  name
     *
     * @param target the class instance
     * @param fieldName the name of the field
     * @return the field object
     */
    @SneakyThrows
    public Object getDeclaredField(final Object target, final String fieldName) {
        final Field field = target.getClass().getDeclaredField(fieldName);
        field.setAccessible(true);

        return field.get(target);
    }

    /**
     * Sets a field object for a specific field objectValue
     *
     * @param target the class instance
     * @param fieldName the name of the field
     * @param objectValue the value to set
     */
    @SneakyThrows
    public void setField(final Object target, final String fieldName, final Object objectValue) {
        final Field field = target.getClass().getField(fieldName);
        field.setAccessible(true);
        field.set(target, objectValue);
    }

    /**
     * Sets a declared field object for a specific field objectValue
     *
     * @param target the class instance
     * @param fieldName the name of the field
     * @param objectValue the value to set
     */
    public void setDeclaredField(final Object target, final String fieldName, final Object objectValue) {
        try {
            final Field field = target.getClass().getDeclaredField(fieldName);
            field.setAccessible(true);
            field.set(target, objectValue);
        } catch (Exception e) {
            e.printStackTrace();
        }

    }

    /**
     * Invoke a method on a specific target object
     *
     * @param target the target object
     * @param methodName the method name
     * @param params the params to pass to the method
     * @return An object that invokes this specific method
     */
    @SneakyThrows
    public static Object method(final Object target, final String methodName, final Object... params) {
        final List<Method> methodList = Arrays.stream(target.getClass().getMethods())
                .filter(m -> m.getName().equals(methodName))
                .filter(m -> m.getParameters().length == params.length)
                .collect(Collectors.toList());

        return methodList.get(0).invoke(target, params);
    }

    /**
     * Invoke a method on a specific target object
     *
     * @param target the target class
     * @param methodName the method name
     * @param params the params to pass to the method
     * @return An object that invokes this specific method
     */
    @SneakyThrows
    public static Object method(final Class<?> target, final String methodName, final Object... params) {
        final List<Method> methodList = Arrays.stream(target.getDeclaredMethods())
                .filter(m -> m.getName().equals(methodName))
                .collect(Collectors.toList());

        return methodList.get(0).invoke(target, params);
    }


    /**
     * Invoke a method on a specific target object
     *
     * @param target the target class
     * @param methodName the method name
     * @param classes the expected parameters
     * @param params - the params to pass to the method
     * @return An object that invokes this specific method
     */
    @SneakyThrows
    public static Object method(final Object target, final String methodName, final Class<?>[] classes, final Object... params) {
        return target.getClass().getMethod(methodName, classes).invoke(target, params);
    }

    /**
     * Invoke a constructor for a specific class
     *
     * @param target the target class
     * @param params the expected parameters
     * @return An object that invokes this constructor
     */
    @SneakyThrows
    public static Object constructor(final Class<?> target, final Object... params) {
        final List<Constructor<?>> constructorList = Arrays.stream(target.getConstructors())
                .filter(constructor -> constructor.getParameters().length == params.length)
                .collect(Collectors.toList());

        return constructorList.get(0).newInstance(params);
    }
}


Filename: .\main\java\io\github\epicgo\sconey\reflection\impl\RPacketScoreboardScore.java
package io.github.epicgo.sconey.reflection.impl;

import io.github.epicgo.sconey.reflection.Reflection;
import lombok.AllArgsConstructor;
import lombok.Getter;
import org.bukkit.entity.Player;

/**
 * A simple instance class PacketPlayOutScoreboardScore via reflection
 */
@Getter
@AllArgsConstructor
public class RPacketScoreboardScore extends Reflection {

    /**
     * The teamName to update the score objective
     */
    private final String teamName;
    /**
     * The objectiveName to set for specific team
     */
    private final String objectiveName;
    /**
     * The score to set position of scoreboard index
     */
    private final int score;
    /**
     * The enumScoreAction enum CHANGE/REMOVE
     */
    private final EnumScoreAction enumScoreAction;

    public void sendPacket(final Player player) {
        final Object packet = constructor(getNMSClass("PacketPlayOutScoreboardScore"));

        if (teamName != null)
            setDeclaredField(packet, "a", teamName);
        if (objectiveName != null)
            setDeclaredField(packet, "b", objectiveName);

        if (isNative17()) {
            setDeclaredField(packet, "d", enumScoreAction.ordinal());
        } else {
            final Class<?> enumScoreboardAction = getNMSClass("PacketPlayOutScoreboardScore$EnumScoreboardAction");
            setDeclaredField(packet, "d", method(enumScoreboardAction, "valueOf", enumScoreAction.name()));
        }

        setDeclaredField(packet, "c", score);

        final Object craftPlayerHandle = method(player, "getHandle");
        final Object playerConnection = getField(craftPlayerHandle, "playerConnection");

        method(playerConnection, "sendPacket", packet);
    }

    public enum EnumScoreAction {
        CHANGE, REMOVE
    }
}


Filename: .\main\java\io\github\epicgo\sconey\reflection\impl\RPacketScoreboardTeam.java
package io.github.epicgo.sconey.reflection.impl;

import io.github.epicgo.sconey.reflection.Reflection;
import lombok.AllArgsConstructor;
import lombok.Getter;
import org.bukkit.entity.Player;

import java.util.List;

/**
 * A simple instance class PacketPlayOutScoreboardTeam via reflection
 */
@Getter
@AllArgsConstructor
public class RPacketScoreboardTeam extends Reflection {

    /**
     * The teamName to update the score objective
     */
    private final String teamName;
    /**
     * The prefix to update the score team
     */
    private final String prefix;
    /**
     * The suffix to update the score team
     */
    private final String suffix;
    /**
     * The optionData to update the score team
     */
    private final int optionData;
    /**
     * The playerNameSet to update the score team
     */
    private final List<String> playerNameSet;

    public void sendPacket(final Player player) {
        final Object packet = constructor(getNMSClass("PacketPlayOutScoreboardTeam"));
        if(teamName != null)
            setDeclaredField(packet, "a", teamName);
        if(prefix != null)
            setDeclaredField(packet, "c", prefix);
        if(suffix != null)
            setDeclaredField(packet, "d", suffix);

        if(isNative17()) {
            setDeclaredField(packet, "f", optionData);
            setDeclaredField(packet, "e", playerNameSet);
        } else {
            setDeclaredField(packet, "h", optionData);
            setDeclaredField(packet, "g", playerNameSet);
        }

        final Object craftPlayerHandle = method(player, "getHandle");
        final Object playerConnection = getField(craftPlayerHandle, "playerConnection");

        method(playerConnection, "sendPacket", packet);
    }
}


Filename: .\main\java\rip\diamond\practice\Eden.java
package rip.diamond.practice;

import com.google.gson.Gson;
import io.github.epicgo.sconey.SconeyHandler;
import lombok.Getter;
import org.bukkit.Bukkit;
import org.bukkit.World;
import org.bukkit.plugin.java.JavaPlugin;
import rip.diamond.practice.arenas.Arena;
import rip.diamond.practice.arenas.command.ArenaCommand;
import rip.diamond.practice.command.ReloadCommand;
import rip.diamond.practice.config.Config;
import rip.diamond.practice.config.MenusConfig;
import rip.diamond.practice.database.DatabaseManager;
import rip.diamond.practice.debug.TestCommand;
import rip.diamond.practice.debug.TestListener;
import rip.diamond.practice.duel.DuelRequest;
import rip.diamond.practice.duel.DuelRequestManager;
import rip.diamond.practice.duel.command.DuelCommand;
import rip.diamond.practice.events.command.EventCommand;
import rip.diamond.practice.events.command.JoinEventCommand;
import rip.diamond.practice.events.listener.EventListener;
import rip.diamond.practice.hook.HookManager;
import rip.diamond.practice.kiteditor.KitEditorListener;
import rip.diamond.practice.kiteditor.KitEditorManager;
import rip.diamond.practice.kiteditor.command.EditKitsCommand;
import rip.diamond.practice.kits.Kit;
import rip.diamond.practice.kits.KitListener;
import rip.diamond.practice.kits.command.EnchantCommand;
import rip.diamond.practice.kits.command.GoldenHeadCommand;
import rip.diamond.practice.kits.command.KitCommand;
import rip.diamond.practice.layout.NameTagAdapter;
import rip.diamond.practice.layout.ScoreboardAdapter;
import rip.diamond.practice.layout.TabAdapter;
import rip.diamond.practice.leaderboard.LeaderboardManager;
import rip.diamond.practice.leaderboard.command.ReloadLeaderboardCommand;
import rip.diamond.practice.lobby.LobbyManager;
import rip.diamond.practice.lobby.LobbyMovementHandler;
import rip.diamond.practice.match.Match;
import rip.diamond.practice.match.MatchMovementHandler;
import rip.diamond.practice.match.command.*;
import rip.diamond.practice.match.listener.MatchListener;
import rip.diamond.practice.match.listener.SpectateListener;
import rip.diamond.practice.misc.commands.*;
import rip.diamond.practice.misc.listeners.ChatListener;
import rip.diamond.practice.misc.listeners.GeneralListener;
import rip.diamond.practice.party.PartyListener;
import rip.diamond.practice.party.command.ChooseMatchTypeCommand;
import rip.diamond.practice.party.command.OtherPartiesCommand;
import rip.diamond.practice.party.command.PartyCommand;
import rip.diamond.practice.party.fight.PartyFightManager;
import rip.diamond.practice.profile.PlayerProfile;
import rip.diamond.practice.profile.command.SettingsCommand;
import rip.diamond.practice.profile.command.StatsCommand;
import rip.diamond.practice.profile.command.settings.*;
import rip.diamond.practice.profile.listener.ProfileListener;
import rip.diamond.practice.profile.procedure.ProcedureListener;
import rip.diamond.practice.queue.Queue;
import rip.diamond.practice.queue.QueueListener;
import rip.diamond.practice.queue.command.QueueCommand;
import rip.diamond.practice.util.BasicConfigFile;
import rip.diamond.practice.util.EntityHider;
import rip.diamond.practice.util.InventoryUtil;
import rip.diamond.practice.util.command.CommandManager;
import rip.diamond.practice.util.menu.Menu;
import rip.diamond.practice.util.menu.MenuListener;
import rip.diamond.practice.util.nametags.NameTagManager;
import rip.diamond.practice.util.tablist.ImanityTabHandler;
import rip.diamond.practice.spigot.spigotapi.SpigotAPI;

import java.text.DecimalFormat;
import java.util.Arrays;

@Getter
public class Eden extends JavaPlugin {

    public static Eden INSTANCE;
    public static DecimalFormat DECIMAL = new DecimalFormat("0.##");
    public static final Gson GSON = new Gson();

    private BasicConfigFile configFile;
    private BasicConfigFile languageFile;
    private BasicConfigFile locationFile;
    private BasicConfigFile itemFile;
    private BasicConfigFile arenaFile;
    private BasicConfigFile kitFile;
    private BasicConfigFile soundFile;
    private MenusConfig menusConfig;

    private CommandManager commandManager;
    private DatabaseManager databaseManager;
    private LobbyManager lobbyManager;
    private KitEditorManager kitEditorManager;
    private DuelRequestManager duelRequestManager;
    private PartyFightManager partyFightManager;
    private LeaderboardManager leaderboardManager;
    private HookManager hookManager;
    private NameTagManager nameTagManager;

    private SpigotAPI spigotAPI;
    private EntityHider entityHider;
    private SconeyHandler scoreboardHandler;
    private ImanityTabHandler tabHandler;
    private EdenCache cache;
    private EdenPlaceholder placeholder;

    @Override
    public void onEnable() {
        INSTANCE = this;

        spigotAPI = new SpigotAPI().init(this);

        if (getServer().getPluginManager().getPlugin("ProtocolLib") == null) {
            getLogger().severe("ProtocolLib not found! Disabling plugin...");
            getServer().getPluginManager().disablePlugin(this);
            return;
        }

        loadFiles();
        loadManagers();
        loadListeners();
        loadCommands();
        loadGeneral();
    }

    @Override
    public void onDisable() {
        // Stop all existing thread
        if (tabHandler != null)
            Eden.INSTANCE.getTabHandler().stop();
        if (databaseManager != null)
            databaseManager.shutdown();
        // Clean up matches
        for (Match match : Match.getMatches().values()) {
            match.getArenaDetail().restoreChunk(false, false);
            match.getEntities().forEach(matchEntity -> matchEntity.getEntity().remove());
        }
        // Save all kits
        Kit.getKits().forEach(Kit::autoSave);
        // Save all arenas
        Arena.getArenas().forEach(Arena::autoSave);
        // Save all profiles
        if (Config.PROFILE_SAVE_ON_SERVER_STOP.toBoolean()) {
            PlayerProfile.getProfiles().values().forEach(profile -> profile.save(false, (bool) -> {
            }));
        }
    }

    private void loadFiles() {
        this.configFile = new BasicConfigFile(this, "config.yml");
        this.languageFile = new BasicConfigFile(this, "language.yml");
        this.locationFile = new BasicConfigFile(this, "locations.yml");
        this.itemFile = new BasicConfigFile(this, "item.yml");
        this.arenaFile = new BasicConfigFile(this, "arena.yml");
        this.kitFile = new BasicConfigFile(this, "kit.yml");
        this.soundFile = new BasicConfigFile(this, "sound.yml");
        this.menusConfig = new MenusConfig(this);

        Config.loadDefault();
    }

    public void reload() {
        this.configFile.load();
        this.languageFile.load();
        this.locationFile.load();
        this.itemFile.load();
        this.arenaFile.load();
        this.kitFile.load();
        this.soundFile.load();
        this.menusConfig.reload();

        Config.loadDefault();
    }

    private void loadManagers() {
        this.commandManager = new CommandManager(this);
        this.databaseManager = new DatabaseManager(this);
        this.lobbyManager = new LobbyManager(this);
        this.kitEditorManager = new KitEditorManager(this);
        this.duelRequestManager = new DuelRequestManager();
        this.partyFightManager = new PartyFightManager();
        this.leaderboardManager = new LeaderboardManager();
        this.hookManager = new HookManager(this);
        this.nameTagManager = new NameTagManager(this);
    }

    private void loadListeners() {
        Arrays.asList(
                new MenuListener(this),
                new EventListener(this),
                new KitListener(),
                new MatchListener(this),
                new ChatListener(this),
                new GeneralListener(this),
                new ProfileListener(this),
                new ProcedureListener(),
                new KitEditorListener(this),
                new PartyListener(),
                new QueueListener(),
                new SpectateListener(),
                new rip.diamond.practice.match.listener.DynamicKitEditListener())
                .forEach(listener -> getServer().getPluginManager().registerEvents(listener, this));

        if (Config.DEBUG.toBoolean()) {
            getServer().getPluginManager().registerEvents(new TestListener(), this);
        }
    }

    private void loadCommands() {
        new ArenaCommand();
        new EnchantCommand();
        new GoldenHeadCommand();
        new KitCommand();
        new EdenCommand();
        new EloResetCommand();
        new LocationCommand();
        new ToggleItemFlagCommand();
        new QueueCommand();
        new EditKitsCommand();
        new ChooseMatchTypeCommand();
        new OtherPartiesCommand();
        new PartyCommand();
        new DuelCommand();
        new EventCommand();
        new JoinEventCommand();
        new StatsCommand();
        new ForceEndCommand();
        new GiveUpCommand();
        new LeaveSpectateCommand();
        new NoSpeedCommand();
        new RequeueCommand();
        new SpectateCommand();
        new TeleporterCommand();
        new ViewInventoryCommand();
        new ReloadLeaderboardCommand();
        new SettingsCommand();
        new AfternoonCommand();
        new DayCommand();
        new MidnightCommand();
        new NightCommand();
        new PingRangeCommand();
        new ToggleArenaSelectionCommand();
        new ToggleDuelRequestCommand();
        new ToggleEventAnnouncementCommand();
        new ToggleMatchScoreboardCommand();
        new TogglePartyInviteCommand();
        new ToggleSpectatorJoinLeaveMessageCommand();
        new ToggleSpectatorVisibilityCommand();

        new ReloadCommand();

        if (Config.DEBUG.toBoolean()) {
            new TestCommand();
        }
    }

    private void loadGeneral() {
        Menu.init();
        PlayerProfile.init();
        Kit.init();
        Arena.init();
        Match.init();
        Queue.init();
        DuelRequest.init();
        leaderboardManager.init();

        new LobbyMovementHandler(this);
        new MatchMovementHandler();

        this.entityHider = new EntityHider(this, EntityHider.Policy.BLACKLIST).init();
        this.scoreboardHandler = new SconeyHandler(this, new ScoreboardAdapter());
        this.cache = new EdenCache();
        this.placeholder = new EdenPlaceholder(this);
        if (Config.NAMETAG_ENABLED.toBoolean())
            this.nameTagManager.registerAdapter(new NameTagAdapter());
        if (Config.FANCY_TABLIST_ENABLED.toBoolean())
            tabHandler = new ImanityTabHandler(new TabAdapter());
        if (Config.DISABLE_SAVE_WORLD.toBoolean()) {
            for (World world : Bukkit.getWorlds()) {
                world.setAutoSave(false);
            }
        }

        InventoryUtil.handleRemoveCrafting();
    }
}


Filename: .\main\java\rip\diamond\practice\EdenCache.java
package rip.diamond.practice;

import lombok.Getter;
import org.bukkit.Bukkit;
import rip.diamond.practice.profile.PlayerProfile;
import rip.diamond.practice.profile.PlayerState;
import rip.diamond.practice.util.TaskTicker;

@Getter
public class EdenCache {

    private int playersSize;
    private int queuePlayersSize;
    private int matchPlayersSize;

    public EdenCache() {
        new TaskTicker(0, 5, true) {
            @Override
            public void onRun() {
                playersSize = Bukkit.getOnlinePlayers().size();
                queuePlayersSize = (int) PlayerProfile.getProfiles().values().stream().filter(p -> p.getPlayerState() == PlayerState.IN_QUEUE).count();
                matchPlayersSize = (int) PlayerProfile.getProfiles().values().stream().filter(p -> p.getPlayerState() == PlayerState.IN_MATCH || p.getPlayerState() == PlayerState.IN_SPECTATING).count();
            }

            @Override
            public TickType getTickType() {
                return TickType.NONE;
            }

            @Override
            public int getStartTick() {
                return 0;
            }
        };
    }

}


Filename: .\main\java\rip\diamond\practice\EdenItems.java
package rip.diamond.practice;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.minecraft.server.v1_8_R3.NBTTagCompound;
import net.minecraft.server.v1_8_R3.NBTTagString;
import org.bukkit.Material;
import org.bukkit.craftbukkit.v1_8_R3.inventory.CraftItemStack;
import org.bukkit.entity.Player;
import org.bukkit.inventory.ItemStack;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.kits.KitLoadout;
import rip.diamond.practice.util.BasicConfigFile;
import rip.diamond.practice.util.CC;
import rip.diamond.practice.util.ItemBuilder;

public class EdenItems {

    public static EdenItem LOBBY_UNRANKED_QUEUE = loadItem("items.lobby.unranked-queue");
    public static EdenItem LOBBY_RANKED_QUEUE = loadItem("items.lobby.ranked-queue");
    public static EdenItem LOBBY_CREATE_EVENT = loadItem("items.lobby.create-event");
    public static EdenItem LOBBY_JOIN_EVENT = loadItem("items.lobby.join-event");
    public static EdenItem LOBBY_PARTY_OPEN = loadItem("items.lobby.party-open");
    public static EdenItem LOBBY_LEADERBOARD = loadItem("items.lobby.leaderboard");
    public static EdenItem LOBBY_SETTINGS = loadItem("items.lobby.settings");
    public static EdenItem LOBBY_EDITOR = loadItem("items.lobby.editor");
    public static EdenItem PARTY_PARTY_LIST = loadItem("items.party.party-list");
    public static EdenItem PARTY_PARTY_FIGHT = loadItem("items.party.party-fight");
    public static EdenItem PARTY_OTHER_PARTIES = loadItem("items.party.other-parties");
    public static EdenItem PARTY_EDITOR = loadItem("items.party.editor");
    public static EdenItem PARTY_PARTY_LEAVE = loadItem("items.party.party-leave");
    public static EdenItem QUEUE_LEAVE_QUEUE = loadItem("items.queue.leave-queue");
    public static EdenItem MATCH_REQUEUE = loadItem("items.match.requeue");
    public static EdenItem SPECTATE_LEAVE_SPECTATE = loadItem("items.spectate.leave-spectate");
    public static EdenItem SPECTATE_TELEPORTER = loadItem("items.spectate.teleporter");
    public static EdenItem SPECTATE_TOGGLE_VISIBILITY_OFF = loadItem("items.spectate.toggle-visibility-off");
    public static EdenItem SPECTATE_TOGGLE_VISIBILITY_ON = loadItem("items.spectate.toggle-visibility-on");
    public static EdenItem INVALID = new EdenItem(true, new ItemBuilder(Material.BARRIER).name(CC.RED + "Invalid data!").build(), 0, "");

    public static void giveItem(Player player, EdenItem item) {
        if (!item.isEnabled()) {
            return;
        }

        ItemStack itemStack = item.getItemStack();
        net.minecraft.server.v1_8_R3.ItemStack nmsItem = CraftItemStack.asNMSCopy(itemStack);
        NBTTagCompound compound = (nmsItem.hasTag()) ? nmsItem.getTag() : new NBTTagCompound();
        compound.set("command", new NBTTagString(item.getCommand()));
        itemStack = CraftItemStack.asBukkitCopy(nmsItem);

        if (item.getSlot() == -1) {
            player.setItemInHand(itemStack);
            return;
        }
        player.getInventory().setItem(item.getSlot(), itemStack);
    }

    private static EdenItem loadItem(String path) {
        BasicConfigFile file = Eden.INSTANCE.getItemFile();
        try {
            ItemStack itemStack =  new ItemBuilder(Material.valueOf(file.getString(path + ".material")))
                    .durability(file.getInt(path + ".durability"))
                    .name(file.getString(path + ".name"))
                    .lore(file.getStringList(path + ".lore"))
                    .build();
            return new EdenItem(file.getBoolean(path + ".enabled"), itemStack, file.getInt(path + ".slot"), file.getString(path + ".command"));
        } catch (Exception e) {
            return INVALID;
        }
    }

    @Getter
    @RequiredArgsConstructor
    public static class EdenItem {
        private final boolean enabled;
        private final ItemStack itemStack;
        private final int slot;
        private final String command;
    }
}


Filename: .\main\java\rip\diamond\practice\EdenPlaceholder.java
package rip.diamond.practice;

import lombok.RequiredArgsConstructor;
import org.apache.commons.lang3.StringUtils;
import org.bukkit.entity.Player;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.events.EdenEvent;
import rip.diamond.practice.events.EventType;
import rip.diamond.practice.events.impl.SumoEvent;
import rip.diamond.practice.match.Match;
import rip.diamond.practice.match.MatchState;
import rip.diamond.practice.match.impl.FFAMatch;
import rip.diamond.practice.match.impl.SoloMatch;
import rip.diamond.practice.match.impl.TeamMatch;
import rip.diamond.practice.match.team.Team;
import rip.diamond.practice.match.team.TeamPlayer;
import rip.diamond.practice.party.Party;
import rip.diamond.practice.profile.PlayerProfile;
import rip.diamond.practice.profile.PlayerState;
import rip.diamond.practice.profile.ProfileSettings;
import rip.diamond.practice.queue.Queue;
import rip.diamond.practice.queue.QueueProfile;
import rip.diamond.practice.util.CC;
import rip.diamond.practice.util.TimeUtil;
import rip.diamond.practice.util.Util;
import rip.diamond.practice.util.exception.PracticeUnexpectedException;

import java.util.List;
import java.util.stream.Collectors;

@RequiredArgsConstructor
public class EdenPlaceholder {

        private final Eden plugin;
        public static final String SKIP_LINE = "<skip-line>";
        public static final String NEW_LINE = "<new-line>";

        public String translate(Player player, String str) {
                if (player != null) {
                        PlayerProfile profile = PlayerProfile.get(player);

                        if (profile == null) {
                                return str;
                        }

                        Party party = Party.getByPlayer(player);
                        QueueProfile qProfile = Queue.getPlayers().get(player.getUniqueId());
                        Match match = profile.getMatch();
                        EdenEvent event = EdenEvent.getOnGoingEvent();

                        // Check if the string has {event-information}, otherwise it will cause infinite
                        // loop
                        if (str.contains("{event-information}")) {
                                str = str
                                                .replace("{event-information}",
                                                                event != null ? StringUtils.join(
                                                                                event.getLobbyScoreboard(player),
                                                                                NEW_LINE)
                                                                                : SKIP_LINE);
                        }

                        if (party != null) {
                                str = str
                                                .replace("{party-leader}", party.getLeader().getUsername())
                                                .replace("{party-members}", party.getAllPartyMembers().size() + "")
                                                .replace("{party-max}", party.getMaxSize() + "");
                        }

                        if (event != null) {
                                str = str
                                                .replace("{event-uncolored-name}", event.getUncoloredEventName())
                                                .replace("{event-total-players}", event.getTotalPlayers().size() + "")
                                                .replace("{event-max-players}", event.getMaxPlayers() + "")
                                                .replace("{event-countdown}", event.getCountdown() == null ? "0.0"
                                                                : event.getCountdown().getMilliSecondsLeft(false) + "");
                        }

                        if (profile.getPlayerState() == PlayerState.IN_QUEUE && qProfile != null) {
                                str = str
                                                .replace("{queue-kit}", qProfile.getKit().getDisplayName())
                                                .replace("{queue-time}", TimeUtil.millisToTimer(qProfile.getPassed()))
                                                .replace("{queue-ranked-min}", qProfile.getMinRange() + "")
                                                .replace("{queue-ranked-max}", qProfile.getMaxRange() + "")
                                                .replace("{ping-range}", profile.getSettings()
                                                                .get(ProfileSettings.PING_RANGE).toString());
                        } else if (profile.getPlayerState() == PlayerState.IN_MATCH && match != null) {
                                str = str
                                                .replace("{match-kit}", match.getKit().getDisplayName())
                                                .replace("{match-duration}",
                                                                TimeUtil.millisToTimer(match.getElapsedDuration()))
                                                .replace("{match-build-limit}",
                                                                match.getArenaDetail().getArena().getBuildMax() + "")
                                                .replace("{match-build-limit-difference}", Util.renderBuildLimit(
                                                                player.getLocation().getBlockY(),
                                                                match.getArenaDetail().getArena().getBuildMax()));

                                for (int i = 0; i < match.getTeams().size(); i++) {
                                        Team team = match.getTeams().get(i);
                                        str = str.replace("{match-team" + (i + 1) + "-logo}",
                                                        team.getTeamColor().getTeamLogo())
                                                        .replace("{match-team" + (i + 1) + "-bed-status}",
                                                                        team.isBedDestroyed()
                                                                                        ? (team.getAliveCount() > 0
                                                                                                        ? CC.WHITE + team
                                                                                                                        .getAliveCount()
                                                                                                        : CC.RED + "‚úò")
                                                                                        : CC.GREEN + "‚úî")
                                                        .replace("{match-team" + (i + 1) + "-points}",
                                                                        Util.renderPointsAsBar(team, match.getKit()
                                                                                        .getGameRules()
                                                                                        .getMaximumPoints()));
                                }

                                switch (match.getMatchType()) {
                                        case SOLO:
                                                TeamPlayer self = match.getTeamPlayer(player);
                                                TeamPlayer opponent = match.getOpponent(self);
                                                int solo_x = self.getHits();
                                                int solo_y = opponent.getHits();
                                                int soloDifference = solo_x - solo_y;

                                                boolean selfComboing = self.getActiveCombo() > 0;
                                                boolean opponentComboing = opponent.getActiveCombo() > 0;

                                                str = str
                                                                .replace("{match-solo-opponent}",
                                                                                opponent.getUsername())
                                                                .replace("{match-solo-winner}",
                                                                                match.getState() == MatchState.ENDING
                                                                                                ? match.getWinningPlayers()
                                                                                                                .get(0)
                                                                                                                .getUsername()
                                                                                                : "")
                                                                .replace("{match-solo-loser}",
                                                                                match.getState() == MatchState.ENDING
                                                                                                ? match.getTeams()
                                                                                                                .stream()
                                                                                                                .filter(team -> team != match
                                                                                                                                .getWinningTeam())
                                                                                                                .map(team -> team
                                                                                                                                .getLeader()
                                                                                                                                .getUsername())
                                                                                                                .findFirst()
                                                                                                                .orElse("")
                                                                                                : "")
                                                                .replace("{match-solo-boxing-difference-text}",
                                                                                selfComboing
                                                                                                ? Language.SCOREBOARD_BOXING_COUNTER_TEXT_SOLO
                                                                                                                .toString(
                                                                                                                                CC.GREEN,
                                                                                                                                self.getActiveCombo())
                                                                                                : opponentComboing
                                                                                                                ? Language.SCOREBOARD_BOXING_COUNTER_TEXT_SOLO
                                                                                                                                .toString(
                                                                                                                                                CC.RED,
                                                                                                                                                opponent.getActiveCombo())
                                                                                                                : Language.SCOREBOARD_BOXING_COUNTER_NO_COMBO
                                                                                                                                .toString())
                                                                .replace("{match-solo-boxing-difference}",
                                                                                Math.abs(soloDifference) + "")
                                                                .replace("{match-solo-boxing-difference-number}",
                                                                                soloDifference + "")
                                                                .replace("{match-solo-boxing-difference-symbol}",
                                                                                soloDifference == 0 ? ""
                                                                                                : soloDifference > 0
                                                                                                                ? "+"
                                                                                                                : "-")
                                                                .replace("{match-solo-boxing-difference-color}",
                                                                                solo_x > solo_y ? CC.GREEN
                                                                                                : solo_x == solo_y
                                                                                                                ? CC.YELLOW
                                                                                                                : CC.RED)
                                                                .replace("{match-solo-boxing-self-hit}", solo_x + "")
                                                                .replace("{match-solo-boxing-opponent-hit}",
                                                                                solo_y + "")
                                                                .replace("{match-solo-boxing-combo}",
                                                                                self.getActiveCombo() + "")
                                                                .replace("{match-solo-self-ping}", self.getPing() + "")
                                                                .replace("{match-solo-opponent-ping}",
                                                                                opponent.getPing() + "");
                                                break;
                                        case SPLIT:
                                                Team team = match.getTeam(player);
                                                Team opponentTeam = match.getOpponentTeam(team);
                                                int teams_x = team.getHits();
                                                int teams_y = opponentTeam.getHits();
                                                int teamsDifference = teams_x - teams_y;

                                                boolean xComboing = team.getCombo() > 0;
                                                boolean yComboing = opponentTeam.getCombo() > 0;

                                                str = str
                                                                .replace("{match-team-self-alive}",
                                                                                team.getAliveCount() + "")
                                                                .replace("{match-team-self-size}",
                                                                                team.getTeamPlayers().size() + "")
                                                                .replace("{match-team-opponent-alive}",
                                                                                opponentTeam.getAliveCount() + "")
                                                                .replace("{match-team-opponent-size}",
                                                                                opponentTeam.getTeamPlayers().size()
                                                                                                + "")
                                                                .replace("{match-team-winner}",
                                                                                match.getState() != MatchState.ENDING
                                                                                                ? ""
                                                                                                : match.getWinningTeam() == null
                                                                                                                ? ""
                                                                                                                : match.getWinningTeam()
                                                                                                                                .getLeader()
                                                                                                                                .getUsername())
                                                                .replace("{match-team-loser}",
                                                                                match.getState() != MatchState.ENDING
                                                                                                ? ""
                                                                                                : match.getWinningTeam() == null
                                                                                                                ? ""
                                                                                                                : match.getTeams()
                                                                                                                                .stream()
                                                                                                                                .filter(t -> match
                                                                                                                                                .getWinningTeam() != t)
                                                                                                                                .map(t -> t.getLeader()
                                                                                                                                                .getUsername())
                                                                                                                                .findFirst()
                                                                                                                                .orElse(""))
                                                                .replace("{match-team-boxing-difference-text}",
                                                                                xComboing
                                                                                                ? Language.SCOREBOARD_BOXING_COUNTER_TEXT_TEAM
                                                                                                                .toString(
                                                                                                                                CC.GREEN,
                                                                                                                                team.getCombo())
                                                                                                : yComboing
                                                                                                                ? Language.SCOREBOARD_BOXING_COUNTER_TEXT_TEAM
                                                                                                                                .toString(
                                                                                                                                                CC.RED,
                                                                                                                                                opponentTeam.getCombo())
                                                                                                                : Language.SCOREBOARD_BOXING_COUNTER_NO_COMBO
                                                                                                                                .toString())
                                                                .replace("{match-team-boxing-difference}",
                                                                                Math.abs(teamsDifference) + "")
                                                                .replace("{match-team-boxing-difference-number}",
                                                                                teamsDifference + "")
                                                                .replace("{match-team-boxing-difference-symbol}",
                                                                                teamsDifference == 0 ? ""
                                                                                                : teamsDifference > 0
                                                                                                                ? "+"
                                                                                                                : "-")
                                                                .replace("{match-team-boxing-difference-color}",
                                                                                teams_x > teams_y ? CC.GREEN
                                                                                                : teams_x == teams_y
                                                                                                                ? CC.YELLOW
                                                                                                                : CC.RED)
                                                                .replace("{match-team-boxing-self-hit}", teams_x + "")
                                                                .replace("{match-team-boxing-opponent-hit}",
                                                                                teams_y + "")
                                                                .replace("{match-team-boxing-combo}",
                                                                                team.getCombo() + "");
                                                break;
                                        case FFA:
                                                List<Team> ffaTeams = match.getTeams();
                                                long aliveCount = ffaTeams.stream().filter(t -> !t.isEliminated())
                                                                .count();

                                                str = str
                                                                .replace("{match-ffa-alive}", aliveCount + "")
                                                                .replace("{match-ffa-player-size}",
                                                                                ffaTeams.size() + "")
                                                                .replace("{match-ffa-winner}",
                                                                                match.getState() != MatchState.ENDING
                                                                                                ? ""
                                                                                                : match.getWinningTeam() == null
                                                                                                                ? ""
                                                                                                                : match.getWinningTeam()
                                                                                                                                .getLeader()
                                                                                                                                .getUsername())
                                                                .replace("{match-ffa-loser}",
                                                                                match.getState() != MatchState.ENDING
                                                                                                ? ""
                                                                                                : match.getWinningTeam() == null
                                                                                                                ? ""
                                                                                                                : match.getTeams()
                                                                                                                                .stream()
                                                                                                                                .filter(t -> match
                                                                                                                                                .getWinningTeam() != t)
                                                                                                                                .map(t -> t.getLeader()
                                                                                                                                                .getUsername())
                                                                                                                                .collect(Collectors
                                                                                                                                                .joining(",")));
                                                break;
                                        case SUMO_EVENT:
                                                EdenEvent edenEvent = EdenEvent.getOnGoingEvent();
                                                if (edenEvent.getEventType() != EventType.SUMO_EVENT) {
                                                        throw new PracticeUnexpectedException(
                                                                        "MatchType is SUMO_EVENT but EventType isn't SUMO_EVENT");
                                                }
                                                SumoEvent sumoEvent = (SumoEvent) edenEvent;
                                                str = str
                                                                .replace("{match-event-type}",
                                                                                sumoEvent.getUncoloredEventName())
                                                                .replace("{match-event-round}",
                                                                                sumoEvent.getRound() + "")
                                                                .replace("{match-event-winner}",
                                                                                match.getState() == MatchState.ENDING
                                                                                                ? sumoEvent.getTeamName(
                                                                                                                match.getWinningTeam())
                                                                                                : "");
                                        default:
                                                break;
                                }
                        } else if (profile.getPlayerState() == PlayerState.IN_SPECTATING && match != null) {
                                str = str
                                                .replace("{spectate-kit}", match.getKit().getDisplayName())
                                                .replace("{spectate-duration}",
                                                                TimeUtil.millisToTimer(match.getElapsedDuration()))
                                                .replace("{spectate-build-limit}",
                                                                match.getArenaDetail().getArena().getBuildMax() + "")
                                                .replace("{spectate-build-limit-difference}", Util.renderBuildLimit(
                                                                player.getLocation().getBlockY(),
                                                                match.getArenaDetail().getArena().getBuildMax()));

                                for (int i = 0; i < match.getTeams().size(); i++) {
                                        Team team = match.getTeams().get(i);
                                        str = str.replace("{spectate-team" + (i + 1) + "-logo}",
                                                        team.getTeamColor().getTeamLogo())
                                                        .replace("{spectate-team" + (i + 1) + "-bed-status}",
                                                                        team.isBedDestroyed()
                                                                                        ? (team.getAliveCount() > 0
                                                                                                        ? CC.WHITE + team
                                                                                                                        .getAliveCount()
                                                                                                        : CC.RED + "‚úò")
                                                                                        : CC.GREEN + "‚úî")
                                                        .replace("{spectate-team" + (i + 1) + "-points}",
                                                                        Util.renderPointsAsBar(team, match.getKit()
                                                                                        .getGameRules()
                                                                                        .getMaximumPoints()));
                                }

                                switch (match.getMatchType()) {
                                        case SOLO:
                                                TeamPlayer playerA = ((SoloMatch) match).getPlayerA();
                                                TeamPlayer playerB = ((SoloMatch) match).getPlayerB();

                                                str = str
                                                                .replace("{spectate-solo-player1}",
                                                                                playerA.getUsername())
                                                                .replace("{spectate-solo-player2}",
                                                                                playerB.getUsername())
                                                                .replace("{spectate-solo-winner}",
                                                                                match.getState() == MatchState.ENDING
                                                                                                ? match.getWinningPlayers()
                                                                                                                .get(0)
                                                                                                                .getUsername()
                                                                                                : "")
                                                                .replace("{spectate-solo-loser}",
                                                                                match.getState() == MatchState.ENDING
                                                                                                ? match.getTeams()
                                                                                                                .stream()
                                                                                                                .filter(team -> team != match
                                                                                                                                .getWinningTeam())
                                                                                                                .map(team -> team
                                                                                                                                .getLeader()
                                                                                                                                .getUsername())
                                                                                                                .findFirst()
                                                                                                                .orElse("")
                                                                                                : "")
                                                                .replace("{spectate-solo-boxing-player1-hit}",
                                                                                playerA.getHits() + "")
                                                                .replace("{spectate-solo-boxing-player2-hit}",
                                                                                playerB.getHits() + "")
                                                                .replace("{spectate-solo-boxing-player1-combo}",
                                                                                playerA.getActiveCombo() + "")
                                                                .replace("{spectate-solo-boxing-player2-combo}",
                                                                                playerB.getActiveCombo() + "")
                                                                .replace("{spectate-solo-player1-ping}",
                                                                                playerA.getPing() + "")
                                                                .replace("{spectate-solo-player2-ping}",
                                                                                playerB.getPing() + "");
                                                break;
                                        case SPLIT:
                                                Team teamA = ((TeamMatch) match).getTeamA();
                                                Team teamB = ((TeamMatch) match).getTeamB();

                                                str = str
                                                                .replace("{spectate-team1-leader}",
                                                                                teamA.getLeader().getUsername() + "")
                                                                .replace("{spectate-team2-leader}",
                                                                                teamB.getLeader().getUsername() + "")
                                                                .replace("{spectate-team1-alive}",
                                                                                teamA.getAliveCount() + "")
                                                                .replace("{spectate-team2-alive}",
                                                                                teamB.getAliveCount() + "")
                                                                .replace("{spectate-team1-size}",
                                                                                teamA.getTeamPlayers().size() + "")
                                                                .replace("{spectate-team2-size}",
                                                                                teamB.getTeamPlayers().size() + "")
                                                                .replace("{spectate-team-winner}",
                                                                                match.getState() == MatchState.ENDING
                                                                                                ? ((TeamMatch) match)
                                                                                                                .getWinningTeam()
                                                                                                                .getLeader()
                                                                                                                .getUsername()
                                                                                                : "")
                                                                .replace("{spectate-team-loser}",
                                                                                match.getState() == MatchState.ENDING
                                                                                                ? match.getWinningTeam() == null
                                                                                                                ? ""
                                                                                                                : match.getTeams()
                                                                                                                                .stream()
                                                                                                                                .filter(t -> match
                                                                                                                                                .getWinningTeam() != t)
                                                                                                                                .map(t -> t.getLeader()
                                                                                                                                                .getUsername())
                                                                                                                                .findFirst()
                                                                                                                                .orElse("")
                                                                                                : "")
                                                                .replace("{spectate-team1-boxing-hit}",
                                                                                teamA.getHits() + "")
                                                                .replace("{spectate-team2-boxing-hit}",
                                                                                teamB.getHits() + "")
                                                                .replace("{spectate-team1-boxing-combo}",
                                                                                teamA.getCombo() + "")
                                                                .replace("{spectate-team2-boxing-combo}",
                                                                                teamB.getCombo() + "");
                                                break;
                                        case FFA:
                                                List<Team> ffaTeams = match.getTeams();
                                                long aliveCount = ffaTeams.stream().filter(t -> !t.isEliminated())
                                                                .count();

                                                str = str
                                                                .replace("{spectate-ffa-alive}", aliveCount + "")
                                                                .replace("{spectate-ffa-player-size}",
                                                                                ffaTeams.size() + "")
                                                                .replace("{spectate-ffa-winner}",
                                                                                ((FFAMatch) match).getWinningTeam()
                                                                                                .getLeader()
                                                                                                .getUsername())
                                                                .replace("{spectate-ffa-loser}",
                                                                                ((FFAMatch) match).getTeams().stream()
                                                                                                .filter(t -> match
                                                                                                                .getWinningTeam() != t)
                                                                                                .map(t -> t.getLeader()
                                                                                                                .getUsername())
                                                                                                .collect(Collectors
                                                                                                                .joining(",")));
                                                break;
                                        default:
                                                break;
                                }
                        }
                }

                if (str.contains(SKIP_LINE)) {
                        return null;
                } else {
                        return str
                                        .replace("{online-players}", plugin.getCache().getPlayersSize() + "")
                                        .replace("{queue-players}", plugin.getCache().getQueuePlayersSize() + "")
                                        .replace("{match-players}", plugin.getCache().getMatchPlayersSize() + "");
                }
        }

}


Filename: .\main\java\rip\diamond\practice\arenas\Arena.java
package rip.diamond.practice.arenas;

import lombok.Getter;
import lombok.Setter;
import org.bukkit.Location;
import org.bukkit.Material;
import org.bukkit.configuration.ConfigurationSection;
import org.bukkit.configuration.file.FileConfiguration;
import org.bukkit.inventory.ItemStack;
import rip.diamond.practice.Eden;
import rip.diamond.practice.config.Config;
import rip.diamond.practice.kits.Kit;
import rip.diamond.practice.util.Common;
import rip.diamond.practice.util.ItemBuilder;
import rip.diamond.practice.util.exception.PracticeUnexpectedException;
import rip.diamond.practice.util.serialization.BukkitSerialization;
import rip.diamond.practice.util.serialization.LocationSerialization;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

@Getter
@Setter
public class Arena {

    @Getter
    private static final List<Arena> arenas = new ArrayList<>();

    private final String name;
    private String displayName;
    private ItemStack icon = new ItemBuilder(Material.GRASS).build();
    private List<ArenaDetail> arenaDetails = new ArrayList<>();

    private int yLimit = 0;
    private int buildMax = -1;
    private int portalProtectionRadius = 3;
    private List<String> allowedKits = new ArrayList<>();
    private boolean enabled = false;
    private boolean edited = false;

    private boolean pendingReload = false;
    private Arena nextVersion = null;

    public boolean isUsing() {
        return arenaDetails.stream().anyMatch(ArenaDetail::isUsing);
    }

    public static void reload() {
        FileConfiguration fileConfig = Eden.INSTANCE.getArenaFile().getConfiguration();
        ConfigurationSection arenaSection = fileConfig.getConfigurationSection("arenas");

        List<Arena> loadedArenas = new ArrayList<>();

        if (arenaSection != null) {
            arenaSection.getKeys(false).forEach(name -> {
                String displayName = arenaSection.getString(name + ".display-name", name);
                ItemStack icon = BukkitSerialization.itemStackFromBase64(arenaSection.getString(name + ".icon"));
                int yLimit = arenaSection.getInt(name + ".y-limit");
                int buildMax = arenaSection.getInt(name + ".build-max");
                int portalProtectionRadius = arenaSection.getInt(name + ".portal-protection-radius");
                List<String> allowedKits = arenaSection.getStringList(name + ".kits");
                boolean enabled = arenaSection.getBoolean(name + ".enabled", false);

                Arena arena = new Arena(name);
                arena.setDisplayName(displayName);
                arena.setIcon(icon);
                arena.setYLimit(yLimit);
                arena.setBuildMax(buildMax);
                arena.setPortalProtectionRadius(portalProtectionRadius);
                arena.setAllowedKits(allowedKits);
                arena.setEnabled(enabled);

                ConfigurationSection details = arenaSection.getConfigurationSection(name + ".details");
                if (details != null) {
                    details.getKeys(false).forEach(id -> {
                        Location locCloneA = LocationSerialization.deserializeLocation(details.getString(id + ".a"));
                        Location locCloneB = LocationSerialization.deserializeLocation(details.getString(id + ".b"));
                        Location locCloneMin = LocationSerialization
                                .deserializeLocation(details.getString(id + ".min"));
                        Location locCloneMax = LocationSerialization
                                .deserializeLocation(details.getString(id + ".max"));
                        Location locCloneSpectator = LocationSerialization
                                .deserializeLocation(details.getString(id + ".spectator"));

                        ArenaDetail arenaDetail = new ArenaDetail(arena, locCloneA, locCloneB,
                                locCloneSpectator == null ? locCloneA : locCloneSpectator, locCloneMin, locCloneMax);
                        arenaDetail.copyChunk();
                        arena.getArenaDetails().add(arenaDetail);
                    });
                }
                loadedArenas.add(arena);
            });
        }

        // Process existing arenas
        List<Arena> toRemove = new ArrayList<>();
        for (Arena currentArena : new ArrayList<>(arenas)) {
            Arena newVersion = loadedArenas.stream().filter(a -> a.getName().equals(currentArena.getName())).findFirst()
                    .orElse(null);

            if (currentArena.isUsing()) {
                currentArena.setPendingReload(true);
                currentArena.setNextVersion(newVersion); // newVersion is null if deleted
                Common.log("&cArena " + currentArena.getName() + " is in use. Queued for reload.");
            } else {
                // Not in use, safe to update immediately
                toRemove.add(currentArena);
            }
        }

        arenas.removeAll(toRemove);

        // Add new/updated arenas (that weren't in use)
        for (Arena loadedArena : loadedArenas) {
            // Check if this arena is already in the list (meaning it was in use and kept)
            if (arenas.stream().noneMatch(a -> a.getName().equals(loadedArena.getName()))) {
                arenas.add(loadedArena);
            }
        }

        Common.log("&aReloaded arenas. " + arenas.size() + " arenas loaded.");
    }

    public static Arena getArena(String name) {
        return arenas.stream()
                .filter(arena -> arena.getName().equalsIgnoreCase(name))
                .findAny().orElse(null);
    }

    public static Arena getEnabledArena(String name, Kit kit) {
        Collections.shuffle(arenas);
        return arenas.stream()
                .filter(arena -> arena.isEnabled() &&
                        !arena.isLocked() &&
                        !arena.getArenaDetails().isEmpty() &&
                        arena.getAllowedKits().contains(kit.getName()) &&
                        arena.getName().equalsIgnoreCase(name))
                .findAny().orElse(null);
    }

    public static Arena getEnabledArena(Kit kit) {
        Collections.shuffle(arenas);
        return arenas.stream()
                .filter(Arena::isEnabled)
                .filter(arena -> arena.getAllowedKits().contains(kit.getName()))
                .findAny().orElse(null);
    }

    public static ArenaDetail getAvailableArenaDetail(Kit kit) {
        Collections.shuffle(arenas);
        Arena arena = arenas.stream()
                .filter(Arena::isEnabled)
                .filter(a -> a.getAllowedKits().contains(kit.getName()))
                .findAny().orElse(null);
        if (arena == null) {
            return null;
        }
        return getArenaDetail(arena);
    }

    public static ArenaDetail getArenaDetail(Arena arena) {
        return arena.getArenaDetails().stream()
                .filter(arenaDetail -> !arenaDetail.isUsing())
                .filter(arenaDetail -> {
                    if (Config.EXPERIMENT_DISABLE_ORIGINAL_ARENA.toBoolean()) {
                        return arena.getArenaDetails().get(0) != arenaDetail;
                    }
                    return true;
                })
                .findAny().orElse(null);
    }

    public Arena(String name) {
        this.name = name;
        this.displayName = name;
    }

    public ItemStack getIcon() {
        return icon.clone();
    }

    public boolean isFinishedSetup() {
        return arenaDetails.stream().allMatch(ArenaDetail::isFinishedSetup);
    }

    public boolean isEnabled() {
        return enabled && isFinishedSetup() && !edited;
    }

    // If an arena is locked, which means the arena can only be accessible by
    // special cases, like event
    public boolean isLocked() {
        return Config.EVENT_SUMO_EVENT_ARENAS.toStringList().contains(name);
    }

    public boolean hasClone() {
        return arenaDetails.size() > 1;
    }

    public Location getA() {
        return arenaDetails.get(0).getA();
    }

    public Location getB() {
        return arenaDetails.get(0).getB();
    }

    public Location getSpectator() {
        return arenaDetails.get(0).getSpectator();
    }

    public Location getMin() {
        return arenaDetails.get(0).getMin();
    }

    public Location getMax() {
        return arenaDetails.get(0).getMax();
    }

    public void setA(Location location) {
        arenaDetails.get(0).setA(location);
    }

    public void setB(Location location) {
        arenaDetails.get(0).setB(location);
    }

    public void setSpectator(Location location) {
        arenaDetails.get(0).setSpectator(location);
    }

    public void setMin(Location location) {
        arenaDetails.get(0).setMin(location);
    }

    public void setMax(Location location) {
        arenaDetails.get(0).setMax(location);
    }

    public void autoSave() {
        if (Config.ARENA_KIT_AUTO_SAVE.toBoolean()) {
            save();
        }
    }

    public static void init() {
        FileConfiguration fileConfig = Eden.INSTANCE.getArenaFile().getConfiguration();
        ConfigurationSection arenaSection = fileConfig.getConfigurationSection("arenas");
        if (arenaSection == null) {
            return;
        }

        arenaSection.getKeys(false).forEach(name -> {
            String displayName = arenaSection.getString(name + ".display-name", name); // Add default value if
                                                                                       // display-name not found for
                                                                                       // backwards compatibility
            ItemStack icon = BukkitSerialization.itemStackFromBase64(arenaSection.getString(name + ".icon"));
            int yLimit = arenaSection.getInt(name + ".y-limit");
            int buildMax = arenaSection.getInt(name + ".build-max");
            int portalProtectionRadius = arenaSection.getInt(name + ".portal-protection-radius");
            List<String> allowedKits = arenaSection.getStringList(name + ".kits");
            boolean enabled = arenaSection.getBoolean(name + ".enabled", false);

            Arena arena = new Arena(name);
            arena.setDisplayName(displayName);
            arena.setIcon(icon);
            arena.setYLimit(yLimit);
            arena.setBuildMax(buildMax);
            arena.setPortalProtectionRadius(portalProtectionRadius);
            arena.setAllowedKits(allowedKits);
            arena.setEnabled(enabled);

            // Â†¥Âú∞Âä†Ëºâ
            ConfigurationSection details = arenaSection.getConfigurationSection(name + ".details");
            if (details != null) {
                details.getKeys(false).forEach(id -> {
                    Location locCloneA = LocationSerialization.deserializeLocation(details.getString(id + ".a"));
                    Location locCloneB = LocationSerialization.deserializeLocation(details.getString(id + ".b"));
                    Location locCloneMin = LocationSerialization.deserializeLocation(details.getString(id + ".min"));
                    Location locCloneMax = LocationSerialization.deserializeLocation(details.getString(id + ".max"));
                    Location locCloneSpectator = LocationSerialization
                            .deserializeLocation(details.getString(id + ".spectator"));

                    ArenaDetail arenaDetail = new ArenaDetail(arena, locCloneA, locCloneB,
                            locCloneSpectator == null ? locCloneA : locCloneSpectator, locCloneMin, locCloneMax);
                    arenaDetail.copyChunk();
                    arena.getArenaDetails().add(arenaDetail);
                });
            }

            arenas.add(arena);
            Common.log("Loaded " + arena.getArenaDetails().size() + " " + arena.getName() + " arenas");
        });
    }

    public void save() {
        FileConfiguration fileConfig = Eden.INSTANCE.getArenaFile().getConfiguration();
        String arenaRoot = "arenas." + name;
        fileConfig.set(arenaRoot, null); // Remove everything related to that arena first, then add the details one by
                                         // one
        fileConfig.set(arenaRoot + ".display-name", displayName);
        fileConfig.set(arenaRoot + ".icon", BukkitSerialization.itemStackToBase64(icon));
        fileConfig.set(arenaRoot + ".y-limit", yLimit);
        fileConfig.set(arenaRoot + ".build-max", buildMax);
        fileConfig.set(arenaRoot + ".portal-protection-radius", portalProtectionRadius);
        fileConfig.set(arenaRoot + ".kits", allowedKits);
        fileConfig.set(arenaRoot + ".enabled", enabled);

        if (!arenaDetails.isEmpty()) {
            for (int i = 0; i < arenaDetails.size(); i++) {
                ArenaDetail arenaDetail = arenaDetails.get(i);
                String arenaDetailsRoot = arenaRoot + ".details." + i;
                fileConfig.set(arenaDetailsRoot + ".a", LocationSerialization.serializeLocation(arenaDetail.getA()));
                fileConfig.set(arenaDetailsRoot + ".b", LocationSerialization.serializeLocation(arenaDetail.getB()));
                fileConfig.set(arenaDetailsRoot + ".spectator",
                        LocationSerialization.serializeLocation(arenaDetail.getSpectator()));
                fileConfig.set(arenaDetailsRoot + ".min",
                        LocationSerialization.serializeLocation(arenaDetail.getMin()));
                fileConfig.set(arenaDetailsRoot + ".max",
                        LocationSerialization.serializeLocation(arenaDetail.getMax()));
            }
        }

        Eden.INSTANCE.getArenaFile().save();
    }

}


Filename: .\main\java\rip\diamond\practice\arenas\ArenaDetail.java
package rip.diamond.practice.arenas;

import lombok.Getter;
import lombok.Setter;
import org.bukkit.Location;
import rip.diamond.practice.arenas.chunk.ArenaChunk;
import rip.diamond.practice.arenas.chunk.IArenaChunk;
import rip.diamond.practice.util.Common;
import rip.diamond.practice.util.cuboid.Cuboid;
import rip.diamond.practice.config.Config;
import rip.diamond.practice.util.serialization.LocationSerialization;
import com.boydti.fawe.util.EditSessionBuilder;
import com.boydti.fawe.util.TaskManager;
import com.sk89q.worldedit.EditSession;
import com.sk89q.worldedit.Vector;

import java.util.ArrayList;
import java.util.List;

@Getter
@Setter
public class ArenaDetail {

    private final Arena arena;
    private final List<IArenaChunk> cachedChunks;

    private Location a;
    private Location b;
    private Location spectator;

    private Location min;
    private Location max;

    private boolean using = false;

    public ArenaDetail(Arena arena) {
        this.arena = arena;
        this.cachedChunks = new ArrayList<>();
    }

    public ArenaDetail(Arena arena, Location a, Location b, Location spectator, Location min, Location max) {
        this.arena = arena;
        this.cachedChunks = new ArrayList<>();
        this.a = a;
        this.b = b;
        this.spectator = spectator;
        this.min = min;
        this.max = max;
    }

    public boolean isFinishedSetup() {
        return a != null && b != null && min != null && max != null;
    }

    public Cuboid getCuboid() {
        return new Cuboid(min, max);
    }

    public void copyChunk() {
        if (Config.EXPERIMENT_DISABLE_ORIGINAL_ARENA.toBoolean()) {
            // If this is a copy (not the first one), do not cache chunks
            if (arena.getArenaDetails().indexOf(this) > 0) {
                return;
            }
        }

        cachedChunks.clear();
        Cuboid cuboid = new Cuboid(min, max);
        try {
            cuboid.getChunks().forEach(chunk -> cachedChunks.add(new ArenaChunk(chunk)));
        } catch (Exception e) {
            Common.log(
                    "&c[Eden] An error occurred while trying to copy your arena. This will cause arena will not reset and strongly recommend to fix it ASAP. (min:"
                            + LocationSerialization.toReadable(min) + " &cmax:" + LocationSerialization.toReadable(max)
                            + "&c)");
            e.printStackTrace();
        }
    }

    public void restoreChunk(boolean async, boolean releaseArena) {
        long started = System.currentTimeMillis();
        Common.debug("Ê≠£Âú®ÂòóË©¶ÈÇÑÂéüÂ†¥Âú∞...");

        if (Config.EXPERIMENT_DISABLE_ORIGINAL_ARENA.toBoolean()) {
            ArenaDetail originalDetail = arena.getArenaDetails().get(0);

            if (this != originalDetail) {
                Location origMinLoc = originalDetail.getMin();
                Location origMaxLoc = originalDetail.getMax();
                Location destMinLoc = this.getMin();
                Location destMaxLoc = this.getMax();

                // FAWE operations - fully async now
                Runnable faweRunnable = () -> {
                    try {
                        // Use proper min/max ordering for source
                        Vector sourceMin = new Vector(
                                Math.min(origMinLoc.getBlockX(), origMaxLoc.getBlockX()),
                                Math.min(origMinLoc.getBlockY(), origMaxLoc.getBlockY()),
                                Math.min(origMinLoc.getBlockZ(), origMaxLoc.getBlockZ()));
                        Vector sourceMax = new Vector(
                                Math.max(origMinLoc.getBlockX(), origMaxLoc.getBlockX()),
                                Math.max(origMinLoc.getBlockY(), origMaxLoc.getBlockY()),
                                Math.max(origMinLoc.getBlockZ(), origMaxLoc.getBlockZ()));

                        // 1. Copy from Original using modern API (FAWE handles chunk loading
                        // internally)
                        EditSession copySession = new EditSessionBuilder(origMinLoc.getWorld().getName())
                                .fastmode(true)
                                .allowedRegionsEverywhere()
                                .autoQueue(false)
                                .limitUnlimited()
                                .build();

                        com.sk89q.worldedit.regions.CuboidRegion sourceRegion = new com.sk89q.worldedit.regions.CuboidRegion(
                                sourceMin, sourceMax);
                        com.sk89q.worldedit.extent.clipboard.BlockArrayClipboard clipboard = new com.sk89q.worldedit.extent.clipboard.BlockArrayClipboard(
                                sourceRegion);

                        com.sk89q.worldedit.function.operation.ForwardExtentCopy copy = new com.sk89q.worldedit.function.operation.ForwardExtentCopy(
                                copySession, sourceRegion, clipboard, sourceMin);
                        com.sk89q.worldedit.function.operation.Operations.complete(copy);

                        // 2. Paste to Current location
                        EditSession pasteSession = new EditSessionBuilder(destMinLoc.getWorld().getName())
                                .fastmode(true)
                                .allowedRegionsEverywhere()
                                .autoQueue(false)
                                .limitUnlimited()
                                .build();

                        Vector destMin = new Vector(
                                Math.min(destMinLoc.getBlockX(), destMaxLoc.getBlockX()),
                                Math.min(destMinLoc.getBlockY(), destMaxLoc.getBlockY()),
                                Math.min(destMinLoc.getBlockZ(), destMaxLoc.getBlockZ()));

                        com.sk89q.worldedit.function.operation.ForwardExtentCopy paste = new com.sk89q.worldedit.function.operation.ForwardExtentCopy(
                                clipboard, clipboard.getRegion(), pasteSession, destMin);
                        com.sk89q.worldedit.function.operation.Operations.complete(paste);
                        pasteSession.flushQueue();

                        Common.debug("ÈÇÑÂéüÂ†¥Âú∞ËÄóÊôÇ: " + (System.currentTimeMillis() - started) + "ms");
                    } catch (Exception e) {
                        Common.log("&c[Eden] Error restoring arena: " + e.getMessage());
                        e.printStackTrace();
                    } finally {
                        if (releaseArena) {
                            TaskManager.IMP.task(() -> this.using = false);
                        }
                    }
                };

                if (async) {
                    TaskManager.IMP.async(faweRunnable);
                } else {
                    faweRunnable.run();
                }
            } else {
                // Original arena - just release if needed
                if (releaseArena) {
                    this.using = false;
                }
            }
        } else {
            // Legacy mode: use cached chunks (MUST run on main thread due to NMS)
            Runnable runnable = () -> {
                try {
                    cachedChunks.forEach(IArenaChunk::restore);
                    Common.debug("ÈÇÑÂéüÂ†¥Âú∞ËÄóÊôÇ: " + (System.currentTimeMillis() - started) + "ms");
                } catch (Exception e) {
                    Common.log("&c[Eden] Error restoring arena: " + e.getMessage());
                    e.printStackTrace();
                } finally {
                    if (releaseArena) {
                        this.using = false;
                    }
                }
            };

            // NMS chunk operations MUST run on main thread
            if (async) {
                TaskManager.IMP.task(runnable);
            } else {
                runnable.run();
            }
        }
    }
}


Filename: .\main\java\rip\diamond\practice\arenas\chunk\ArenaChunk.java
package rip.diamond.practice.arenas.chunk;

import com.boydti.fawe.FaweAPI;
import io.github.epicgo.sconey.reflection.Reflection;
import lombok.Getter;
import net.minecraft.server.v1_8_R3.ChunkSection;
import org.bukkit.Chunk;
import org.bukkit.World;
import org.bukkit.craftbukkit.v1_8_R3.CraftChunk;
import org.bukkit.craftbukkit.v1_8_R3.CraftWorld;
import rip.diamond.practice.util.Common;
import rip.diamond.practice.util.exception.PracticeUnexpectedException;

public class ArenaChunk extends Reflection implements IArenaChunk {

    private final World world;
    @Getter
    private final int x, z;
    private final ArenaChunkSection[] data;

    public ArenaChunk(Chunk chunk) {
        chunk.load();

        ChunkSection[] sections = ((CraftChunk) chunk).getHandle().getSections();

        this.world = chunk.getWorld();
        this.x = chunk.getX();
        this.z = chunk.getZ();
        this.data = new ArenaChunkSection[sections.length];

        for (int i = 0; i < sections.length; i++) {
            data[i] = new ArenaChunkSection(sections[i]);
        }
    }

    @Override
    public void restore() {
        restore(world, x, z);
    }

    public void restore(World world, int x, int z) {
        // Common.debug("Ê≠£Âú®ÈÇÑÂéü chunk (" + world.getName() + ":" + x + ":" + z + ")");

        CraftWorld craftWorld = (CraftWorld) world;

        craftWorld.getChunkAt(x, z).load();
        ChunkSection[] sections = new ChunkSection[data.length];
        for (int i = 0; i < data.length; i++) {
            sections[i] = data[i].toChunkSection();
        }
        setDeclaredField(((CraftChunk) world.getChunkAt(x, z)).getHandle(), "sections", sections);

        boolean success = craftWorld.refreshChunk(x, z);
        if (!success) {
            throw new PracticeUnexpectedException("Cannot refresh chunk (" + x + ":" + z + ")");
        }
    }

}


Filename: .\main\java\rip\diamond\practice\arenas\chunk\ArenaChunkSection.java
package rip.diamond.practice.arenas.chunk;

import io.github.epicgo.sconey.reflection.Reflection;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.minecraft.server.v1_8_R3.ChunkSection;
import net.minecraft.server.v1_8_R3.NibbleArray;

@Getter
@RequiredArgsConstructor
public class ArenaChunkSection extends Reflection {

    private final boolean setup;

    private int yPos;
    private int nonEmptyBlockCount;
    private int tickingBlockCount;
    private char[] blockIds;
    private NibbleArray emittedLight;
    private NibbleArray skyLight;
    private boolean isDirty; // PaperSpigot

    public ArenaChunkSection(ChunkSection section) {
        if (section == null) {
            this.setup = false;
            return;
        }
        this.yPos = section.getYPosition();
        this.nonEmptyBlockCount = (int) getDeclaredField(section, "nonEmptyBlockCount");
        this.tickingBlockCount = (int) getDeclaredField(section, "tickingBlockCount");
        this.blockIds = section.getIdArray().clone();
        this.emittedLight = clone(section.getEmittedLightArray());
        this.skyLight = clone(section.getSkyLightArray());
        this.isDirty = (boolean) getDeclaredField(section, "isDirty");

        this.setup = true;
    }

    public char[] getBlockIds() {
        return blockIds.clone();
    }

    public NibbleArray getEmittedLight() {
        return clone(emittedLight);
    }

    public NibbleArray getSkyLight() {
        return clone(skyLight);
    }

    private NibbleArray clone(NibbleArray array) {
        return new NibbleArray(array.a().clone());
    }

    public ChunkSection toChunkSection() {
        if (setup) {
            ChunkSection section = new ChunkSection(yPos, getSkyLight() != null);

            setDeclaredField(section, "yPos", yPos);
            setDeclaredField(section, "nonEmptyBlockCount", nonEmptyBlockCount);
            setDeclaredField(section, "tickingBlockCount", tickingBlockCount);
            setDeclaredField(section, "blockIds", getBlockIds());
            setDeclaredField(section, "emittedLight", getEmittedLight());
            setDeclaredField(section, "skyLight", getSkyLight());
            setDeclaredField(section, "isDirty", isDirty);

            return section;
        }
        return null;
    }
}


Filename: .\main\java\rip\diamond\practice\arenas\chunk\IArenaChunk.java
package rip.diamond.practice.arenas.chunk;

public interface IArenaChunk {

    void restore();

    void restore(org.bukkit.World world, int x, int z);

    int getX();

    int getZ();

}


Filename: .\main\java\rip\diamond\practice\arenas\command\ArenaCommand.java
package rip.diamond.practice.arenas.command;

import org.bukkit.block.Block;
import org.bukkit.entity.Player;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.arenas.Arena;
import rip.diamond.practice.arenas.ArenaDetail;
import rip.diamond.practice.arenas.menu.ArenaEditMenu;
import rip.diamond.practice.arenas.menu.ArenasMenu;
import rip.diamond.practice.profile.procedure.Procedure;
import rip.diamond.practice.profile.procedure.ProcedureType;
import rip.diamond.practice.util.CC;
import rip.diamond.practice.util.Checker;
import rip.diamond.practice.util.command.Command;
import rip.diamond.practice.util.command.CommandArgs;
import rip.diamond.practice.util.command.argument.CommandArguments;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;

public class ArenaCommand extends Command {
    @CommandArgs(name = "arena", permission = "eden.command.arena")
    public void execute(CommandArguments command) {
        Player player = command.getPlayer();
        String[] args = command.getArgs();
        if (args.length == 0) {
            new ArenasMenu().openMenu(player);
            return;
        }
        if (args.length == 1) {
            if (args[0].equalsIgnoreCase("list")) {
                new ArenasMenu().openMenu(player);
                return;
            } else if (args[0].equalsIgnoreCase("saveall")) {
                plugin.getArenaFile().getConfiguration().set("arenas", null);
                plugin.getArenaFile().save();

                Arena.getArenas().forEach(Arena::save);
                Language.ARENA_SAVED_ALL.sendMessage(player);
                return;
            }
        } else if (args.length == 2) {
            if (args[0].equalsIgnoreCase("create")) {
                String name = args[1];
                if (Arena.getArena(name) != null) {
                    Language.ARENA_ALREADY_EXISTS.sendMessage(player, name);
                    return;
                }
                Arena arena = new Arena(name);
                arena.getArenaDetails().add(new ArenaDetail(arena));
                Arena.getArenas().add(arena);
                arena.autoSave();
                Language.ARENA_CREATED.sendMessage(player, name);
                return;
            } else if (args[0].equalsIgnoreCase("edit")) {
                String name = args[1];
                Arena arena = Arena.getArena(name);
                if (arena == null) {
                    Language.ARENA_NOT_EXISTS.sendMessage(player, name);
                    return;
                }
                new ArenaEditMenu(arena).openMenu(player);
                return;
            } else if (args[0].equalsIgnoreCase("save")) {
                String name = args[1];
                Arena arena = Arena.getArena(name);
                if (arena == null) {
                    Language.ARENA_NOT_EXISTS.sendMessage(player, name);
                    return;
                }
                arena.save();
                Language.ARENA_SAVED.sendMessage(player, arena.getName());
                return;
            } else if (args[0].equalsIgnoreCase("storearena")) {
                if (!player.hasPermission("eden.command.storearena")) {
                    Language.NO_PERMISSION.sendMessage(player);
                    return;
                }

                String name = args[1];
                List<Arena> targetArenas = new ArrayList<>();

                if (name.equals("*")) {
                    targetArenas.addAll(Arena.getArenas());
                } else {
                    Arena arena = Arena.getArena(name);
                    if (arena == null) {
                        Language.ARENA_NOT_EXISTS.sendMessage(player, name);
                        return;
                    }
                    targetArenas.add(arena);
                }

                int count = 0;
                for (Arena arena : targetArenas) {
                    if (arena.getArenaDetails().isEmpty())
                        continue;

                    // Get original detail (index 0)
                    ArenaDetail originalDetail = arena.getArenaDetails().get(0);

                    // If disable-original-arena is enabled, we only care about the original arena's
                    // chunks
                    // Copies don't need storage as they copy from original on reset

                    // Force update the cached chunks for the original arena
                    originalDetail.copyChunk();
                    count++;
                }

                player.sendMessage(CC.GREEN + "Successfully updated stored chunks for " + count + " arenas.");
                return;
            }
        } else if (args.length == 3) {
            if (args[0].equalsIgnoreCase("setup")) {
                String name = args[1];
                Arena arena = Arena.getArena(name);
                if (arena == null) {
                    Language.ARENA_NOT_EXISTS.sendMessage(player, name);
                    return;
                }
                switch (args[2].toLowerCase()) {
                    case "a":
                        if (arena.hasClone()) {
                            Language.ARENA_CANNOT_SET_BECAUSE_CLONE_FOUND.sendMessage(player);
                            return;
                        }
                        arena.setA(player.getLocation());
                        Language.ARENA_SUCCESSFULLY_SET.sendMessage(player, "A");
                        arena.setEdited(true);
                        arena.autoSave();
                        return;
                    case "b":
                        if (arena.hasClone()) {
                            Language.ARENA_CANNOT_SET_BECAUSE_CLONE_FOUND.sendMessage(player);
                            return;
                        }
                        arena.setB(player.getLocation());
                        Language.ARENA_SUCCESSFULLY_SET.sendMessage(player, "B");
                        arena.setEdited(true);
                        arena.autoSave();
                        return;
                    case "spectator":
                        if (arena.hasClone()) {
                            Language.ARENA_CANNOT_SET_BECAUSE_CLONE_FOUND.sendMessage(player);
                            return;
                        }
                        arena.setSpectator(player.getLocation());
                        Language.ARENA_SUCCESSFULLY_SET.sendMessage(player, "Spectator");
                        arena.setEdited(true);
                        arena.autoSave();
                        return;
                    case "min":
                        if (arena.hasClone()) {
                            Language.ARENA_CANNOT_SET_BECAUSE_CLONE_FOUND.sendMessage(player);
                            return;
                        }
                        Procedure.buildProcedure(player, Language.ARENA_EDIT_MIN.toString(arena.getName()),
                                ProcedureType.BREAK_BLOCK, (b) -> {
                                    Block block = (Block) b;
                                    arena.setMin(block.getLocation());
                                    Language.ARENA_SUCCESSFULLY_SET.sendMessage(player, "min");
                                    arena.setEdited(true);
                                    arena.autoSave();
                                });
                        return;
                    case "max":
                        if (arena.hasClone()) {
                            Language.ARENA_CANNOT_SET_BECAUSE_CLONE_FOUND.sendMessage(player);
                            return;
                        }
                        Procedure.buildProcedure(player, Language.ARENA_EDIT_MAX.toString(arena.getName()),
                                ProcedureType.BREAK_BLOCK, (b) -> {
                                    Block block = (Block) b;
                                    arena.setMax(block.getLocation());
                                    Language.ARENA_SUCCESSFULLY_SET.sendMessage(player, "max");
                                    arena.setEdited(true);
                                    arena.autoSave();
                                });
                        return;
                    case "y-limit":
                        Procedure.buildProcedure(player, Language.ARENA_EDIT_Y_LIMIT.toString(arena.getName()),
                                ProcedureType.CHAT, (s) -> {
                                    String message = (String) s;
                                    if (!Checker.isInteger(message)) {
                                        Language.INVALID_SYNTAX.sendMessage(player);
                                        return;
                                    }
                                    int i = Integer.parseInt(message);
                                    arena.setYLimit(i);
                                    Language.ARENA_SUCCESSFULLY_SET.sendMessage(player, "y-limit");
                                    arena.setEdited(true);
                                    arena.autoSave();
                                });
                        return;
                    case "build-max":
                        Procedure.buildProcedure(player, Language.ARENA_EDIT_BUILD_MAX.toString(arena.getName()),
                                ProcedureType.CHAT, (s) -> {
                                    String message = (String) s;
                                    if (!Checker.isInteger(message)) {
                                        Language.INVALID_SYNTAX.sendMessage(player);
                                        return;
                                    }
                                    int i = Integer.parseInt(message);
                                    arena.setBuildMax(i);
                                    Language.ARENA_SUCCESSFULLY_SET.sendMessage(player, "build-max");
                                    arena.setEdited(true);
                                    arena.autoSave();
                                });
                        return;
                    case "portal-protection-radius":
                        Procedure.buildProcedure(player,
                                Language.ARENA_EDIT_PORTAL_PROTECTION_RADIUS.toString(arena.getName()),
                                ProcedureType.CHAT, (s) -> {
                                    String message = (String) s;
                                    if (!Checker.isInteger(message)) {
                                        Language.INVALID_SYNTAX.sendMessage(player);
                                        return;
                                    }
                                    int i = Integer.parseInt(message);
                                    arena.setPortalProtectionRadius(i);
                                    Language.ARENA_SUCCESSFULLY_SET.sendMessage(player, "portal-protection-radius");
                                    arena.setEdited(true);
                                    arena.autoSave();
                                });
                        return;
                    case "toggle":
                        if (!arena.isFinishedSetup()) {
                            Language.ARENA_EDIT_CANNOT_EDIT_NOT_FINISHED_SETUP.sendMessage(player);
                            return;
                        }
                        if (arena.isEdited()) {
                            boolean isInUse = arena.getArenaDetails().stream().anyMatch(ArenaDetail::isUsing);
                            if (isInUse) {
                                player.sendMessage(CC.RED + "Cannot enable arena while matches are in progress.");
                                return;
                            }

                            arena.getArenaDetails().forEach(ArenaDetail::copyChunk);
                            arena.setEdited(false);
                        }
                        arena.setEnabled(!arena.isEnabled());
                        Language.ARENA_SUCCESSFULLY_SET.sendMessage(player, "status " + CC.GRAY + "("
                                + (arena.isEnabled() ? Language.ENABLED.toString() : Language.DISABLED.toString())
                                + ")");
                        arena.autoSave();
                }
            }
        }
        Language.INVALID_SYNTAX.sendMessage(player);
    }

    @Override
    public List<String> getDefaultTabComplete(CommandArguments command) {
        return Arrays.asList("list", "create", "edit", "setup", "save", "saveall");
    }
}


Filename: .\main\java\rip\diamond\practice\arenas\menu\ArenaAllowedKitsMenu.java
package rip.diamond.practice.arenas.menu;

import lombok.RequiredArgsConstructor;
import org.bukkit.Material;
import org.bukkit.entity.Player;
import org.bukkit.event.inventory.ClickType;
import org.bukkit.inventory.ItemStack;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.arenas.Arena;
import rip.diamond.practice.kits.Kit;
import rip.diamond.practice.util.ItemBuilder;
import rip.diamond.practice.util.menu.Button;
import rip.diamond.practice.util.menu.Menu;
import rip.diamond.practice.util.menu.button.BackButton;
import rip.diamond.practice.util.menu.pagination.PaginatedMenu;

import java.util.HashMap;
import java.util.Map;

@RequiredArgsConstructor
public class ArenaAllowedKitsMenu extends PaginatedMenu {

    private final Arena arena;
    private final Menu backMenu;

    @Override
    public String getPrePaginatedTitle(Player player) {
        return Language.ARENA_ALLOWED_KITS_MENU_TITLE.toString();
    }

    @Override
    public Map<Integer, Button> getAllPagesButtons(Player player) {
        final Map<Integer, Button> buttons = new HashMap<>();

        for (Kit kit : Kit.getKits()) {
            buttons.put(buttons.size(), new Button() {
                @Override
                public ItemStack getButtonItem(Player player) {
                    return new ItemBuilder(kit.getDisplayIcon())
                            .name(kit.getDisplayName())
                            .lore("", arena.getAllowedKits().contains(kit.getName()) ? Language.ARENA_ALLOWED_KITS_MENU_LORE_SELECTED.toString() : Language.ARENA_ALLOWED_KITS_MENU_LORE_CLICK_TO_SELECT.toString())
                            .build();
                }

                @Override
                public void clicked(Player player, ClickType clickType) {
                    if (arena.getAllowedKits().contains(kit.getName())) {
                        arena.getAllowedKits().remove(kit.getName());
                        Language.ARENA_EDIT_ALLOWED_KITS_REMOVED.sendMessage(player, kit.getName(), arena.getName());
                    } else {
                        arena.getAllowedKits().add(kit.getName());
                        Language.ARENA_EDIT_ALLOWED_KITS_ADDED.sendMessage(player, kit.getName(), arena.getName());
                    }
                    arena.setEdited(true);
                    arena.autoSave();

                    openMenu(player);
                }
            });
        }

        return buttons;
    }

    @Override
    public Map<Integer, Button> getGlobalButtons(Player player) {
        final Map<Integer, Button> buttons = new HashMap<>();

        buttons.put(4, new BackButton(Material.STAINED_GLASS_PANE, 14, backMenu));

        return buttons;
    }
}


Filename: .\main\java\rip\diamond\practice\arenas\menu\ArenaDetailsMenu.java
package rip.diamond.practice.arenas.menu;

import lombok.RequiredArgsConstructor;
import org.bukkit.Material;
import org.bukkit.entity.Player;
import org.bukkit.event.inventory.ClickType;
import org.bukkit.inventory.ItemStack;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.arenas.Arena;
import rip.diamond.practice.arenas.ArenaDetail;
import rip.diamond.practice.arenas.menu.button.impl.ArenaDetailButton;
import rip.diamond.practice.arenas.task.ArenaGenerateTask;
import rip.diamond.practice.util.ItemBuilder;
import rip.diamond.practice.util.menu.Button;
import rip.diamond.practice.util.menu.pagination.PaginatedMenu;

import java.util.HashMap;
import java.util.Map;

@RequiredArgsConstructor
public class ArenaDetailsMenu extends PaginatedMenu {
    private final Arena arena;

    @Override
    public String getPrePaginatedTitle(Player player) {
        return Language.ARENA_DETAILS_MENU_TITLE.toString();
    }

    @Override
    public Map<Integer, Button> getAllPagesButtons(Player player) {
        final Map<Integer, Button> buttons = new HashMap<>();

        int i = 0;
        for (ArenaDetail arenaDetail : arena.getArenaDetails()) {
            buttons.put(buttons.size(), new ArenaDetailButton(arena, arenaDetail, i++));
        }

        return buttons;
    }

    @Override
    public Map<Integer, Button> getGlobalButtons(Player player) {
        final Map<Integer, Button> buttons = new HashMap<>();

        buttons.put(4, new Button() {
            @Override
            public ItemStack getButtonItem(Player player) {
                return new ItemBuilder(Material.GRASS)
                        .name(Language.ARENA_DETAILS_MENU_CREATE_DUPLICATE_NAME.toString())
                        .lore(Language.ARENA_DETAILS_MENU_CREATE_DUPLICATE_LORE.toStringList(player, arena.getName()))
                        .build();
            }

            @Override
            public void clicked(Player player, ClickType clickType) {
                player.closeInventory();
                new ArenaGenerateTask(player, arena);
            }
        });

        return buttons;
    }
}


Filename: .\main\java\rip\diamond\practice\arenas\menu\ArenaEditMenu.java
package rip.diamond.practice.arenas.menu;

import lombok.RequiredArgsConstructor;
import org.bukkit.entity.Player;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.arenas.Arena;
import rip.diamond.practice.arenas.menu.button.impl.*;
import rip.diamond.practice.util.menu.Button;
import rip.diamond.practice.util.menu.Menu;

import java.util.HashMap;
import java.util.Map;

@RequiredArgsConstructor
public class ArenaEditMenu extends Menu {

    private final Arena arena;

    @Override
    public String getTitle(Player player) {
        return Language.ARENA_EDIT_MENU_TITLE.toString(arena.getName());
    }

    @Override
    public Map<Integer, Button> getButtons(Player player) {
        final Map<Integer, Button> buttons = new HashMap<>();

        buttons.put(0, new ArenaCloneButton(arena));
        buttons.put(1, new ArenaToggleButton(arena));
        buttons.put(3, new ArenaDisplayNameButton(arena));
        buttons.put(5, new ArenaSetIconButton(arena));
        buttons.put(7, new ArenaSaveButton(arena));
        buttons.put(8, new ArenaDeleteButton(arena));

        buttons.put(18, new ArenaAPositionButton(arena));
        buttons.put(19, new ArenaBPositionButton(arena));
        buttons.put(20, new ArenaSpectatorPositionButton(arena));
        buttons.put(21, new ArenaMinPositionButton(arena));
        buttons.put(22, new ArenaMaxPositionButton(arena));
        buttons.put(23, new ArenaBuildMaxButton(arena));
        buttons.put(24, new ArenaYLimitButton(arena));
        buttons.put(25, new ArenaPortalProtectionRadiusButton(arena));
        buttons.put(26, new ArenaAllowedKitsButton(arena, this));

        return buttons;
    }
}


Filename: .\main\java\rip\diamond\practice\arenas\menu\ArenasMenu.java
package rip.diamond.practice.arenas.menu;

import org.bukkit.entity.Player;
import org.bukkit.event.inventory.ClickType;
import org.bukkit.inventory.ItemStack;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.arenas.Arena;
import rip.diamond.practice.util.ItemBuilder;
import rip.diamond.practice.util.Util;
import rip.diamond.practice.util.menu.Button;
import rip.diamond.practice.util.menu.pagination.PaginatedMenu;

import java.util.HashMap;
import java.util.Map;

public class ArenasMenu extends PaginatedMenu {
    @Override
    public String getPrePaginatedTitle(Player player) {
        return Language.ARENA_MENU_TITLE.toString();
    }

    @Override
    public Map<Integer, Button> getAllPagesButtons(Player player) {
        final Map<Integer, Button> buttons = new HashMap<>();

        for (Arena arena : Arena.getArenas()) {
            buttons.put(buttons.size(), new Button() {
                @Override
                public ItemStack getButtonItem(Player player) {
                    return new ItemBuilder(arena.getIcon())
                            .name(Language.ARENA_MENU_ARENA_EDIT_NAME.toString(arena.getDisplayName(), arena.getName()))
                            .lore(Language.ARENA_MENU_ARENA_EDIT_LORE.toStringList(player))
                            .build();
                }

                @Override
                public void clicked(Player player, ClickType clickType) {
                    Util.performCommand(player, "arena edit " + arena.getName());
                }
            });
        }

        return buttons;
    }
}


Filename: .\main\java\rip\diamond\practice\arenas\menu\button\ArenaButton.java
package rip.diamond.practice.arenas.menu.button;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import org.bukkit.Material;
import org.bukkit.entity.Player;
import org.bukkit.event.inventory.ClickType;
import org.bukkit.inventory.ItemStack;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.arenas.Arena;
import rip.diamond.practice.util.CC;
import rip.diamond.practice.util.ItemBuilder;
import rip.diamond.practice.util.menu.Button;

import java.util.ArrayList;
import java.util.List;

@Getter
@RequiredArgsConstructor
public abstract class ArenaButton extends Button {

    public final Arena arena;

    @Override
    public ItemStack getButtonItem(Player player) {
        return new ItemBuilder(getIcon())
                .durability(getDurability())
                .name(CC.AQUA + getName())
                .lore("", getDescription() == null ? null : CC.GRAY + getDescription(), getDescription() == null ? null : "")
                .lore(getActionDescription() == null ? null : CC.YELLOW + CC.UNDER_LINE + getActionDescription())
                .lore(getActionDescriptions())
                .build();
    }

    public Material getIcon() {
        return Material.LEVER;
    }

    public int getDurability() {
        return 0;
    }

    public abstract String getName();
    public abstract String getDescription();

    public String getActionDescription() {
        return Language.ARENA_EDIT_MENU_CLICK_TO_EDIT.toString(getName());
    }

    public List<String> getActionDescriptions() {
        return new ArrayList<>();
    }

    @Override
    public boolean shouldUpdate(Player player, ClickType clickType) {
        return true;
    }
}


Filename: .\main\java\rip\diamond\practice\arenas\menu\button\impl\ArenaAllowedKitsButton.java
package rip.diamond.practice.arenas.menu.button.impl;

import org.apache.commons.lang3.StringUtils;
import org.bukkit.entity.Player;
import org.bukkit.event.inventory.ClickType;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.arenas.Arena;
import rip.diamond.practice.arenas.menu.ArenaAllowedKitsMenu;
import rip.diamond.practice.arenas.menu.button.ArenaButton;
import rip.diamond.practice.util.menu.Menu;

public class ArenaAllowedKitsButton extends ArenaButton {

    private final Menu backMenu;

    public ArenaAllowedKitsButton(Arena arena, Menu backMenu) {
        super(arena);
        this.backMenu = backMenu;
    }

    @Override
    public String getName() {
        return Language.ARENA_EDIT_MENU_ALLOWED_KITS_NAME.toString();
    }

    @Override
    public String getDescription() {
        return Language.ARENA_EDIT_MENU_ALLOWED_KITS_DESCRIPTION.toString(StringUtils.join(getArena().getAllowedKits(), ", "));
    }

    @Override
    public void clicked(Player player, int slot, ClickType clickType, int hotbarSlot) {
        new ArenaAllowedKitsMenu(arena, backMenu).openMenu(player);
    }

    @Override
    public boolean shouldUpdate(Player player, ClickType clickType) {
        return false;
    }
}


Filename: .\main\java\rip\diamond\practice\arenas\menu\button\impl\ArenaAPositionButton.java
package rip.diamond.practice.arenas.menu.button.impl;

import org.bukkit.entity.Player;
import org.bukkit.event.inventory.ClickType;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.arenas.Arena;
import rip.diamond.practice.arenas.menu.button.ArenaButton;
import rip.diamond.practice.util.Util;
import rip.diamond.practice.util.serialization.LocationSerialization;

import java.util.List;

public class ArenaAPositionButton extends ArenaButton {
    public ArenaAPositionButton(Arena arena) {
        super(arena);
    }

    @Override
    public String getName() {
        return Language.ARENA_EDIT_MENU_A_POSITION_NAME.toString();
    }

    @Override
    public String getDescription() {
        return Language.ARENA_EDIT_MENU_A_POSITION_DESCRIPTION.toString(LocationSerialization.toReadable(getArena().getA()));
    }

    @Override
    public String getActionDescription() {
        return null;
    }

    @Override
    public List<String> getActionDescriptions() {
        return Language.ARENA_EDIT_MENU_A_POSITION_ACTION_DESCRIPTION.toStringList();
    }

    @Override
    public void clicked(Player player, int slot, ClickType clickType, int hotbarSlot) {
        if (clickType == ClickType.LEFT) {
            Util.performCommand(player, "arena setup " + getArena().getName() + " a");
        } else if (clickType == ClickType.RIGHT) {
            Util.teleport(player, arena.getA());
        }
    }
}


Filename: .\main\java\rip\diamond\practice\arenas\menu\button\impl\ArenaBPositionButton.java
package rip.diamond.practice.arenas.menu.button.impl;

import org.bukkit.entity.Player;
import org.bukkit.event.inventory.ClickType;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.arenas.Arena;
import rip.diamond.practice.arenas.menu.button.ArenaButton;
import rip.diamond.practice.util.Util;
import rip.diamond.practice.util.serialization.LocationSerialization;

import java.util.List;

public class ArenaBPositionButton extends ArenaButton {
    public ArenaBPositionButton(Arena arena) {
        super(arena);
    }

    @Override
    public String getName() {
        return Language.ARENA_EDIT_MENU_B_POSITION_NAME.toString();
    }

    @Override
    public String getDescription() {
        return Language.ARENA_EDIT_MENU_B_POSITION_DESCRIPTION.toString(LocationSerialization.toReadable(getArena().getB()));
    }

    @Override
    public String getActionDescription() {
        return null;
    }

    @Override
    public List<String> getActionDescriptions() {
        return Language.ARENA_EDIT_MENU_B_POSITION_ACTION_DESCRIPTION.toStringList();
    }

    @Override
    public void clicked(Player player, int slot, ClickType clickType, int hotbarSlot) {
        if (clickType == ClickType.LEFT) {
            Util.performCommand(player, "arena setup " + getArena().getName() + " b");
        } else if (clickType == ClickType.RIGHT) {
            Util.teleport(player, arena.getB());
        }
    }
}


Filename: .\main\java\rip\diamond\practice\arenas\menu\button\impl\ArenaBuildMaxButton.java
package rip.diamond.practice.arenas.menu.button.impl;

import org.bukkit.entity.Player;
import org.bukkit.event.inventory.ClickType;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.arenas.Arena;
import rip.diamond.practice.arenas.menu.button.ArenaButton;
import rip.diamond.practice.util.Util;

public class ArenaBuildMaxButton extends ArenaButton {
    public ArenaBuildMaxButton(Arena arena) {
        super(arena);
    }

    @Override
    public String getName() {
        return Language.ARENA_EDIT_MENU_BUILD_MAX_NAME.toString();
    }

    @Override
    public String getDescription() {
        return Language.ARENA_EDIT_MENU_BUILD_MAX_DESCRIPTION.toString(getArena().getBuildMax());
    }

    @Override
    public void clicked(Player player, int slot, ClickType clickType, int hotbarSlot) {
        player.closeInventory();
        Util.performCommand(player, "arena setup " + getArena().getName() + " build-max");
    }

    @Override
    public boolean shouldUpdate(Player player, ClickType clickType) {
        return false;
    }
}


Filename: .\main\java\rip\diamond\practice\arenas\menu\button\impl\ArenaCloneButton.java
package rip.diamond.practice.arenas.menu.button.impl;

import org.bukkit.Material;
import org.bukkit.entity.Player;
import org.bukkit.event.inventory.ClickType;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.arenas.Arena;
import rip.diamond.practice.arenas.menu.ArenaDetailsMenu;
import rip.diamond.practice.arenas.menu.button.ArenaButton;

public class ArenaCloneButton extends ArenaButton {

    public ArenaCloneButton(Arena arena) {
        super(arena);
    }

    @Override
    public String getName() {
        return Language.ARENA_EDIT_MENU_CLONE_NAME.toString();
    }

    @Override
    public Material getIcon() {
        return Material.GRASS;
    }

    @Override
    public String getDescription() {
        return Language.ARENA_EDIT_MENU_CLONE_DESCRIPTION.toString();
    }

    @Override
    public String getActionDescription() {
        return Language.ARENA_EDIT_MENU_CLONE_ACTION_DESCRIPTION.toString();
    }

    @Override
    public void clicked(Player player, ClickType clickType) {
        new ArenaDetailsMenu(arena).openMenu(player);
    }
}


Filename: .\main\java\rip\diamond\practice\arenas\menu\button\impl\ArenaDeleteButton.java
package rip.diamond.practice.arenas.menu.button.impl;

import org.bukkit.Material;
import org.bukkit.entity.Player;
import org.bukkit.event.inventory.ClickType;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.arenas.Arena;
import rip.diamond.practice.arenas.menu.button.ArenaButton;
import rip.diamond.practice.arenas.task.ArenaRemoveTask;
import rip.diamond.practice.util.menu.menus.ConfirmMenu;

public class ArenaDeleteButton extends ArenaButton {

    public ArenaDeleteButton(Arena arena) {
        super(arena);
    }

    @Override
    public String getName() {
        return Language.ARENA_EDIT_MENU_DELETE_NAME.toString();
    }

    @Override
    public Material getIcon() {
        return Material.REDSTONE;
    }

    @Override
    public String getDescription() {
        return Language.ARENA_EDIT_MENU_DELETE_DESCRIPTION.toString();
    }

    @Override
    public String getActionDescription() {
        return arena.hasClone() ? Language.ARENA_EDIT_MENU_DELETE_ACTION_DESCRIPTION_HAS_CLONE.toString() : Language.ARENA_EDIT_MENU_DELETE_ACTION_DESCRIPTION.toString();
    }

    @Override
    public void clicked(Player player, ClickType clickType) {
        if (arena.hasClone()) {
            Language.ARENA_EDIT_MENU_DELETE_ACTION_DESCRIPTION_HAS_CLONE.sendMessage(player);
            return;
        }

        new ConfirmMenu((bool) -> {
            new ArenaRemoveTask(player, arena, arena.getArenaDetails().get(0));
        }, true, null).openMenu(player);
    }

    @Override
    public boolean shouldUpdate(Player player, ClickType clickType) {
        return false;
    }
}


Filename: .\main\java\rip\diamond\practice\arenas\menu\button\impl\ArenaDetailButton.java
package rip.diamond.practice.arenas.menu.button.impl;

import org.bukkit.Material;
import org.bukkit.entity.Player;
import org.bukkit.event.inventory.ClickType;
import org.bukkit.inventory.ItemStack;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.arenas.Arena;
import rip.diamond.practice.arenas.ArenaDetail;
import rip.diamond.practice.arenas.task.ArenaRemoveTask;
import rip.diamond.practice.util.ItemBuilder;
import rip.diamond.practice.util.Util;
import rip.diamond.practice.util.menu.Button;
import rip.diamond.practice.util.serialization.LocationSerialization;

public class ArenaDetailButton extends Button {
    private final Arena arena;
    private final ArenaDetail arenaDetail;
    private final int number;
    public ArenaDetailButton(Arena arena, ArenaDetail arenaDetail, int number) {
        this.arena = arena;
        this.arenaDetail = arenaDetail;
        this.number = number;
    }

    @Override
    public ItemStack getButtonItem(Player player) {
        ItemBuilder builder =  new ItemBuilder(Material.MAP)
                .name(Language.ARENA_DETAILS_MENU_DETAIL_NAME.toString(number))
                .lore(Language.ARENA_DETAILS_MENU_DETAIL_LORE.toStringList(player, LocationSerialization.toReadable(arenaDetail.getA()), LocationSerialization.toReadable(arenaDetail.getB()), LocationSerialization.toReadable(arenaDetail.getMin()), LocationSerialization.toReadable(arenaDetail.getMax())));
        if (arena.getArenaDetails().get(0) == arenaDetail) {
            builder.lore(Language.ARENA_DETAILS_MENU_DETAIL_LORE_NOT_DUPLICATED.toString());
        } else {
            builder.lore(Language.ARENA_DETAILS_MENU_DETAIL_LORE_CLICK_TO_DELETE.toString());
        }
        builder.lore(Language.ARENA_DETAILS_MENU_DETAIL_LORE_CLICK_TO_TELEPORT.toString());
        return builder.build();
    }

    @Override
    public void clicked(Player player, ClickType clickType) {
        if (clickType == ClickType.LEFT) {
            if (arena.getArenaDetails().get(0) == arenaDetail) {
                Language.ARENA_DETAILS_MENU_DETAIL_LORE_NOT_DUPLICATED.sendMessage(player);
                return;
            }
            player.closeInventory();
            new ArenaRemoveTask(player, arena, arenaDetail);
        } else if (clickType == ClickType.RIGHT) {
            player.closeInventory();
            Util.teleport(player, arenaDetail.getA());
            Language.ARENA_DETAILS_MENU_DETAIL_TELEPORTED.sendMessage(player, arena.getName(), number);
        }
    }
}


Filename: .\main\java\rip\diamond\practice\arenas\menu\button\impl\ArenaDisplayNameButton.java
package rip.diamond.practice.arenas.menu.button.impl;

import org.bukkit.Material;
import org.bukkit.entity.Player;
import org.bukkit.event.inventory.ClickType;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.arenas.Arena;
import rip.diamond.practice.arenas.menu.ArenaEditMenu;
import rip.diamond.practice.arenas.menu.button.ArenaButton;
import rip.diamond.practice.profile.procedure.Procedure;
import rip.diamond.practice.profile.procedure.ProcedureType;
import rip.diamond.practice.util.Common;

public class ArenaDisplayNameButton extends ArenaButton {
    public ArenaDisplayNameButton(Arena arena) {
        super(arena);
    }

    @Override
    public String getName() {
        return Language.ARENA_EDIT_MENU_DISPLAY_NAME_NAME.toString();
    }

    @Override
    public Material getIcon() {
        return Material.ANVIL;
    }

    @Override
    public String getDescription() {
        return Language.ARENA_EDIT_MENU_DISPLAY_NAME_DESCRIPTION.toString(arena.getDisplayName());
    }

    @Override
    public String getActionDescription() {
        return Language.ARENA_EDIT_MENU_DISPLAY_NAME_ACTION_DESCRIPTION.toString();
    }

    @Override
    public void clicked(Player player, ClickType clickType) {
        player.closeInventory();
        Procedure.buildProcedure(player, Language.ARENA_EDIT_MENU_DISPLAY_NAME_PROCEDURE_MESSAGE.toString(), ProcedureType.CHAT, (s) -> {
            String message = (String) s;

            arena.setDisplayName(message);
            Common.sendMessage(player, Language.ARENA_EDIT_MENU_DISPLAY_NAME_PROCEDURE_SUCCESS.toString(arena.getName(), arena.getDisplayName()));
            arena.autoSave();
            new ArenaEditMenu(arena).openMenu(player);
        });
    }

    @Override
    public boolean shouldUpdate(Player player, ClickType clickType) {
        return false;
    }
}


Filename: .\main\java\rip\diamond\practice\arenas\menu\button\impl\ArenaMaxPositionButton.java
package rip.diamond.practice.arenas.menu.button.impl;

import org.bukkit.entity.Player;
import org.bukkit.event.inventory.ClickType;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.arenas.Arena;
import rip.diamond.practice.arenas.menu.button.ArenaButton;
import rip.diamond.practice.util.Util;
import rip.diamond.practice.util.serialization.LocationSerialization;

import java.util.List;

public class ArenaMaxPositionButton extends ArenaButton {
    public ArenaMaxPositionButton(Arena arena) {
        super(arena);
    }

    @Override
    public String getName() {
        return Language.ARENA_EDIT_MENU_MAX_NAME.toString();
    }

    @Override
    public String getDescription() {
        return Language.ARENA_EDIT_MENU_MAX_DESCRIPTION.toString(LocationSerialization.toReadable(getArena().getMax()));
    }

    @Override
    public String getActionDescription() {
        return null;
    }

    @Override
    public List<String> getActionDescriptions() {
        return Language.ARENA_EDIT_MENU_MAX_ACTION_DESCRIPTION.toStringList();
    }

    @Override
    public void clicked(Player player, int slot, ClickType clickType, int hotbarSlot) {
        if (clickType == ClickType.LEFT) {
            player.closeInventory();
            Util.performCommand(player, "arena setup " + getArena().getName() + " max");
        } else if (clickType == ClickType.RIGHT) {
            Util.teleport(player, arena.getMax());
        }
    }

    @Override
    public boolean shouldUpdate(Player player, ClickType clickType) {
        return false;
    }
}


Filename: .\main\java\rip\diamond\practice\arenas\menu\button\impl\ArenaMinPositionButton.java
package rip.diamond.practice.arenas.menu.button.impl;

import org.bukkit.entity.Player;
import org.bukkit.event.inventory.ClickType;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.arenas.Arena;
import rip.diamond.practice.arenas.menu.button.ArenaButton;
import rip.diamond.practice.util.Util;
import rip.diamond.practice.util.serialization.LocationSerialization;

import java.util.List;

public class ArenaMinPositionButton extends ArenaButton {
    public ArenaMinPositionButton(Arena arena) {
        super(arena);
    }

    @Override
    public String getName() {
        return Language.ARENA_EDIT_MENU_MIN_NAME.toString();
    }

    @Override
    public String getDescription() {
        return Language.ARENA_EDIT_MENU_MIN_DESCRIPTION.toString(LocationSerialization.toReadable(getArena().getMin()));
    }

    @Override
    public String getActionDescription() {
        return null;
    }

    @Override
    public List<String> getActionDescriptions() {
        return Language.ARENA_EDIT_MENU_MIN_ACTION_DESCRIPTION.toStringList();
    }

    @Override
    public void clicked(Player player, int slot, ClickType clickType, int hotbarSlot) {
        if (clickType == ClickType.LEFT) {
            player.closeInventory();
            Util.performCommand(player, "arena setup " + getArena().getName() + " min");
        } else if (clickType == ClickType.RIGHT) {
            Util.teleport(player, arena.getMin());
        }
    }

    @Override
    public boolean shouldUpdate(Player player, ClickType clickType) {
        return false;
    }
}


Filename: .\main\java\rip\diamond\practice\arenas\menu\button\impl\ArenaPortalProtectionRadiusButton.java
package rip.diamond.practice.arenas.menu.button.impl;

import org.bukkit.entity.Player;
import org.bukkit.event.inventory.ClickType;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.arenas.Arena;
import rip.diamond.practice.arenas.menu.button.ArenaButton;
import rip.diamond.practice.util.Util;

public class ArenaPortalProtectionRadiusButton extends ArenaButton {
    public ArenaPortalProtectionRadiusButton(Arena arena) {
        super(arena);
    }

    @Override
    public String getName() {
        return Language.ARENA_EDIT_MENU_PORTAL_PROTECTION_RADIUS_NAME.toString();
    }

    @Override
    public String getDescription() {
        return Language.ARENA_EDIT_MENU_PORTAL_PROTECTION_RADIUS_DESCRIPTION.toString(getArena().getPortalProtectionRadius());
    }

    @Override
    public void clicked(Player player, int slot, ClickType clickType, int hotbarSlot) {
        player.closeInventory();
        Util.performCommand(player, "arena setup " + getArena().getName() + " portal-protection-radius");
    }

    @Override
    public boolean shouldUpdate(Player player, ClickType clickType) {
        return false;
    }
}


Filename: .\main\java\rip\diamond\practice\arenas\menu\button\impl\ArenaSaveButton.java
package rip.diamond.practice.arenas.menu.button.impl;

import org.bukkit.Material;
import org.bukkit.entity.Player;
import org.bukkit.event.inventory.ClickType;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.arenas.Arena;
import rip.diamond.practice.arenas.menu.button.ArenaButton;
import rip.diamond.practice.util.Util;

public class ArenaSaveButton extends ArenaButton {
    public ArenaSaveButton(Arena arena) {
        super(arena);
    }

    @Override
    public String getName() {
        return Language.ARENA_EDIT_MENU_SAVE_NAME.toString();
    }

    @Override
    public Material getIcon() {
        return Material.EMERALD;
    }

    @Override
    public String getDescription() {
        return null;
    }

    @Override
    public String getActionDescription() {
        return Language.ARENA_EDIT_MENU_SAVE_ACTION_DESCRIPTION.toString();
    }

    @Override
    public void clicked(Player player, ClickType clickType) {
        player.closeInventory();
        Util.performCommand(player, "arena save " + getArena().getName());
    }

    @Override
    public boolean shouldUpdate(Player player, ClickType clickType) {
        return false;
    }
}


Filename: .\main\java\rip\diamond\practice\arenas\menu\button\impl\ArenaSetIconButton.java
package rip.diamond.practice.arenas.menu.button.impl;

import org.bukkit.Material;
import org.bukkit.entity.Player;
import org.bukkit.event.inventory.ClickType;
import org.bukkit.inventory.ItemStack;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.arenas.Arena;
import rip.diamond.practice.arenas.menu.button.ArenaButton;

public class ArenaSetIconButton extends ArenaButton {
    public ArenaSetIconButton(Arena arena) {
        super(arena);
    }

    @Override
    public String getName() {
        return Language.ARENA_EDIT_MENU_ICON_NAME.toString();
    }

    @Override
    public Material getIcon() {
        return arena.getIcon().getType();
    }

    @Override
    public int getDurability() {
        return arena.getIcon().getDurability();
    }

    @Override
    public String getDescription() {
        return Language.ARENA_EDIT_MENU_ICON_DESCRIPTION.toString(getIcon().name() + ":" + getDurability());
    }

    @Override
    public String getActionDescription() {
        return Language.ARENA_EDIT_MENU_ICON_ACTION_DESCRIPTION.toString();
    }

    @Override
    public void clicked(Player player, ClickType clickType) {
        ItemStack itemStack = player.getItemInHand();
        if (itemStack == null || itemStack.getType() == Material.AIR) {
            Language.ARENA_EDIT_MENU_ICON_CANNOT_BE_AIR.sendMessage(player);
            return;
        }
        arena.setIcon(itemStack);
        arena.autoSave();
    }
}


Filename: .\main\java\rip\diamond\practice\arenas\menu\button\impl\ArenaSpectatorPositionButton.java
package rip.diamond.practice.arenas.menu.button.impl;

import org.bukkit.entity.Player;
import org.bukkit.event.inventory.ClickType;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.arenas.Arena;
import rip.diamond.practice.arenas.menu.button.ArenaButton;
import rip.diamond.practice.util.Util;
import rip.diamond.practice.util.serialization.LocationSerialization;

import java.util.List;

public class ArenaSpectatorPositionButton extends ArenaButton {
    public ArenaSpectatorPositionButton(Arena arena) {
        super(arena);
    }

    @Override
    public String getName() {
        return Language.ARENA_EDIT_MENU_SPECTATOR_POSITION_NAME.toString();
    }

    @Override
    public String getDescription() {
        return Language.ARENA_EDIT_MENU_SPECTATOR_POSITION_DESCRIPTION.toString(LocationSerialization.toReadable(getArena().getSpectator()));
    }

    @Override
    public String getActionDescription() {
        return null;
    }

    @Override
    public List<String> getActionDescriptions() {
        return Language.ARENA_EDIT_MENU_SPECTATOR_POSITION_ACTION_DESCRIPTION.toStringList();
    }

    @Override
    public void clicked(Player player, int slot, ClickType clickType, int hotbarSlot) {
        if (clickType == ClickType.LEFT) {
            Util.performCommand(player, "arena setup " + getArena().getName() + " spectator");
        } else if (clickType == ClickType.RIGHT) {
            Util.teleport(player, arena.getSpectator());
        }
    }
}


Filename: .\main\java\rip\diamond\practice\arenas\menu\button\impl\ArenaToggleButton.java
package rip.diamond.practice.arenas.menu.button.impl;

import org.bukkit.Material;
import org.bukkit.entity.Player;
import org.bukkit.event.inventory.ClickType;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.arenas.Arena;
import rip.diamond.practice.arenas.menu.button.ArenaButton;
import rip.diamond.practice.util.CC;
import rip.diamond.practice.util.Util;

public class ArenaToggleButton extends ArenaButton {
    public ArenaToggleButton(Arena arena) {
        super(arena);
    }

    @Override
    public String getName() {
        return Language.ARENA_EDIT_MENU_TOGGLE_NAME.toString();
    }

    @Override
    public Material getIcon() {
        return getArena().isEnabled() ? Material.REDSTONE_TORCH_ON : Material.LEVER;
    }

    @Override
    public String getDescription() {
        return Language.ARENA_EDIT_MENU_TOGGLE_DESCRIPTION.toString((!getArena().isFinishedSetup() ? CC.YELLOW + "ÈúÄË¶ÅÊ≥®ÊÑè" : getArena().isEdited() ? Language.ARENA_EDIT_MENU_TOGGLE_NEED_RESTART.toString() : getArena().isEnabled() ? CC.GREEN + Language.ENABLED.toString() : CC.RED + Language.DISABLED.toString()));
    }

    @Override
    public String getActionDescription() {
        return !getArena().isFinishedSetup() ? Language.ARENA_EDIT_MENU_TOGGLE_ACTION_DESCRIPTION_NOT_FINISHED_SETUP.toString() : getArena().isEdited() ? Language.ARENA_EDIT_MENU_TOGGLE_ACTION_DESCRIPTION_NEED_RESTART.toString() : Language.ARENA_EDIT_MENU_TOGGLE_ACTION_DESCRIPTION.toString();
    }

    @Override
    public void clicked(Player player, ClickType clickType) {
        Util.performCommand(player, "arena setup " + getArena().getName() + " toggle");
    }
}


Filename: .\main\java\rip\diamond\practice\arenas\menu\button\impl\ArenaYLimitButton.java
package rip.diamond.practice.arenas.menu.button.impl;

import org.bukkit.entity.Player;
import org.bukkit.event.inventory.ClickType;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.arenas.Arena;
import rip.diamond.practice.arenas.menu.button.ArenaButton;
import rip.diamond.practice.util.Util;

public class ArenaYLimitButton extends ArenaButton {
    public ArenaYLimitButton(Arena arena) {
        super(arena);
    }

    @Override
    public String getName() {
        return Language.ARENA_EDIT_MENU_Y_LIMIT_NAME.toString();
    }

    @Override
    public String getDescription() {
        return Language.ARENA_EDIT_MENU_Y_LIMIT_DESCRIPTION.toString(getArena().getYLimit());
    }

    @Override
    public void clicked(Player player, int slot, ClickType clickType, int hotbarSlot) {
        player.closeInventory();
        Util.performCommand(player, "arena setup " + getArena().getName() + " y-limit");
    }

    @Override
    public boolean shouldUpdate(Player player, ClickType clickType) {
        return false;
    }
}


Filename: .\main\java\rip\diamond\practice\arenas\task\ArenaGenerateTask.java
package rip.diamond.practice.arenas.task;

import org.bukkit.Location;
import org.bukkit.World;
import org.bukkit.entity.Player;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.arenas.Arena;
import rip.diamond.practice.arenas.ArenaDetail;
import rip.diamond.practice.util.*;
import rip.diamond.practice.Eden;

public class ArenaGenerateTask extends TaskTicker {
    private final Player player;
    private final Arena arena;

    public ArenaGenerateTask(Player player, Arena arena) {
        super(0, 1, false);
        this.player = player;
        this.arena = arena;
    }

    @Override
    public void onRun() {
        cancel();
        new DuplicateArenaRunnable(arena, 10000, 10000, 500, 500) {
            @Override
            public void onComplete() {
                World world = arena.getMin().getWorld();

                double minX = arena.getMin().getX() + this.getOffsetX();
                double minZ = arena.getMin().getZ() + this.getOffsetZ();
                double maxX = arena.getMax().getX() + this.getOffsetX();
                double maxZ = arena.getMax().getZ() + this.getOffsetZ();

                double aX = arena.getA().getX() + this.getOffsetX();
                double aZ = arena.getA().getZ() + this.getOffsetZ();
                double bX = arena.getB().getX() + this.getOffsetX();
                double bZ = arena.getB().getZ() + this.getOffsetZ();
                double spectatorX = arena.getSpectator().getX() + this.getOffsetX();
                double spectatorZ = arena.getSpectator().getZ() + this.getOffsetZ();

                Location min = new Location(world, minX, arena.getMin().getY(), minZ, arena.getMin().getYaw(),
                        arena.getMin().getPitch());
                Location max = new Location(world, maxX, arena.getMax().getY(), maxZ, arena.getMax().getYaw(),
                        arena.getMax().getPitch());
                Location a = new Location(world, aX, arena.getA().getY(), aZ, arena.getA().getYaw(),
                        arena.getA().getPitch());
                Location b = new Location(world, bX, arena.getB().getY(), bZ, arena.getB().getYaw(),
                        arena.getB().getPitch());
                Location spectator = new Location(world, spectatorX, arena.getSpectator().getY(), spectatorZ,
                        arena.getSpectator().getYaw(), arena.getSpectator().getPitch());

                ArenaDetail arenaDetail = new ArenaDetail(arena, a, b, spectator, min, max);
                arena.getArenaDetails().add(arenaDetail);

                // Cache chunks and save async to prevent main thread lag
                com.boydti.fawe.util.TaskManager.IMP.async(() -> {
                    arenaDetail.copyChunk();
                    arena.save();
                });

                new Clickable(Language.ARENA_GENERATE_DISPLAY.toString(arena.getName(), minX, minZ),
                        Language.ARENA_GENERATE_HOVER.toString(), "/tp " + aX + " " + arena.getA().getY() + " " + aZ
                                + " " + arena.getA().getYaw() + " " + arena.getA().getPitch())
                        .sendToPlayer(player);
            }
        }.runTaskTimer(Eden.INSTANCE, 0L, 1L);
    }

    @Override
    public void preRun() {
        Language.ARENA_GENERATE_COPYING.sendMessage(player);
    }

    @Override
    public TickType getTickType() {
        return TickType.NONE;
    }

    @Override
    public int getStartTick() {
        return 0;
    }
}


Filename: .\main\java\rip\diamond\practice\arenas\task\ArenaRemoveTask.java
package rip.diamond.practice.arenas.task;

import com.boydti.fawe.util.EditSessionBuilder;
import com.boydti.fawe.util.TaskManager;
import com.sk89q.worldedit.EditSession;
import com.sk89q.worldedit.Vector;
import com.sk89q.worldedit.blocks.BaseBlock;
import com.sk89q.worldedit.blocks.BlockID;
import com.sk89q.worldedit.regions.CuboidRegion;
import org.bukkit.entity.Player;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.arenas.Arena;
import rip.diamond.practice.arenas.ArenaDetail;
import rip.diamond.practice.util.TaskTicker;

public class ArenaRemoveTask extends TaskTicker {
    private final Player player;
    private final Arena arena;
    private final ArenaDetail arenaDetail;

    public ArenaRemoveTask(Player player, Arena arena, ArenaDetail arenaDetail) {
        super(0, 1, true);
        this.player = player;
        this.arena = arena;
        this.arenaDetail = arenaDetail;
    }

    @Override
    public void onRun() {
        cancel();

        TaskManager.IMP.async(() -> {
            EditSession editSession = new EditSessionBuilder(arenaDetail.getA().getWorld().getName()).fastmode(true).allowedRegionsEverywhere().autoQueue(false).limitUnlimited().build();
            CuboidRegion copyRegion = new CuboidRegion(new Vector(arenaDetail.getMax().getX(), arenaDetail.getMax().getY(), arenaDetail.getMax().getZ()), new Vector(arenaDetail.getMin().getX(), arenaDetail.getMin().getY(), arenaDetail.getMin().getZ()));

            editSession.setBlocks(copyRegion, new BaseBlock(BlockID.AIR));
            editSession.flushQueue();
        });

        arena.getArenaDetails().remove(arenaDetail);

        if (arena.getArenaDetails().isEmpty()) {
            Arena.getArenas().remove(arena);
            Language.ARENA_REMOVE_SUCCESS_MAIN.sendMessage(player);
            arena.autoSave();
        } else {
            Language.ARENA_REMOVE_SUCCESS_DUPLICATE.sendMessage(player, arena.getName());
        }
    }

    @Override
    public void preRun() {

    }

    @Override
    public TickType getTickType() {
        return TickType.NONE;
    }

    @Override
    public int getStartTick() {
        return 0;
    }
}


Filename: .\main\java\rip\diamond\practice\arenas\task\DuplicateArenaRunnable.java
package rip.diamond.practice.arenas.task;

import com.boydti.fawe.util.EditSessionBuilder;
import com.boydti.fawe.util.TaskManager;
import com.sk89q.worldedit.EditSession;
import com.sk89q.worldedit.Vector;
import com.sk89q.worldedit.extent.clipboard.BlockArrayClipboard;
import com.sk89q.worldedit.function.operation.ForwardExtentCopy;
import com.sk89q.worldedit.function.operation.Operations;
import com.sk89q.worldedit.regions.CuboidRegion;
import lombok.Getter;
import org.bukkit.Location;
import org.bukkit.scheduler.BukkitRunnable;
import rip.diamond.practice.Eden;
import rip.diamond.practice.arenas.Arena;
import rip.diamond.practice.arenas.ArenaDetail;

/**
 * @since 11/25/2017
 * @author Zonix
 */

@Getter
public abstract class DuplicateArenaRunnable extends BukkitRunnable {

    private final Eden plugin = Eden.INSTANCE;
    private final Arena copiedArena;
    private int offsetX;
    private int offsetZ;
    private final int incrementX;
    private final int incrementZ;

    private BlockArrayClipboard clipboard;
    private Vector clipboardOrigin;

    public DuplicateArenaRunnable(Arena copiedArena, int offsetX, int offsetZ, int incrementX, int incrementZ) {
        this.copiedArena = copiedArena;
        this.offsetX = offsetX;
        this.offsetZ = offsetZ;
        this.incrementX = incrementX;
        this.incrementZ = incrementZ;
    }

    @Override
    public void run() {
        // Step 1: Copy the arena if not already copied
        if (this.clipboard == null) {
            ArenaDetail originalDetail = copiedArena.getArenaDetails().get(0);
            Location minLoc = originalDetail.getMin();
            Location maxLoc = originalDetail.getMax();

            // Ensure chunks are loaded at source
            int minChunkX = minLoc.getBlockX() >> 4;
            int minChunkZ = minLoc.getBlockZ() >> 4;
            int maxChunkX = maxLoc.getBlockX() >> 4;
            int maxChunkZ = maxLoc.getBlockZ() >> 4;

            for (int cx = minChunkX; cx <= maxChunkX; cx++) {
                for (int cz = minChunkZ; cz <= maxChunkZ; cz++) {
                    if (!minLoc.getWorld().isChunkLoaded(cx, cz)) {
                        minLoc.getWorld().loadChunk(cx, cz);
                    }
                }
            }

            // Use proper min/max ordering
            Vector min = new Vector(
                    Math.min(minLoc.getBlockX(), maxLoc.getBlockX()),
                    Math.min(minLoc.getBlockY(), maxLoc.getBlockY()),
                    Math.min(minLoc.getBlockZ(), maxLoc.getBlockZ()));
            Vector max = new Vector(
                    Math.max(minLoc.getBlockX(), maxLoc.getBlockX()),
                    Math.max(minLoc.getBlockY(), maxLoc.getBlockY()),
                    Math.max(minLoc.getBlockZ(), maxLoc.getBlockZ()));

            CuboidRegion region = new CuboidRegion(min, max);
            this.clipboard = new BlockArrayClipboard(region);
            this.clipboardOrigin = min;

            EditSession copySession = new EditSessionBuilder(minLoc.getWorld().getName())
                    .fastmode(true)
                    .allowedRegionsEverywhere()
                    .autoQueue(false)
                    .limitUnlimited()
                    .build();

            ForwardExtentCopy copy = new ForwardExtentCopy(copySession, region, this.clipboard, min);
            try {
                Operations.complete(copy);
            } catch (Exception e) {
                e.printStackTrace();
                this.cancel();
                return;
            }

            // Wait for next tick to start searching
            return;
        }

        // Step 2: Find a safe spot
        // We check if the proposed location overlaps with any existing arena
        ArenaDetail originalDetail = copiedArena.getArenaDetails().get(0);
        Location minLoc = originalDetail.getMin();
        Location maxLoc = originalDetail.getMax();

        double proposedMinX = minLoc.getX() + this.offsetX;
        double proposedMinZ = minLoc.getZ() + this.offsetZ;
        double proposedMaxX = maxLoc.getX() + this.offsetX;
        double proposedMaxZ = maxLoc.getZ() + this.offsetZ;

        boolean safe = true;

        // Check collision with all other arenas
        for (Arena arena : Arena.getArenas()) {
            for (ArenaDetail detail : arena.getArenaDetails()) {
                // Simple AABB collision check
                // We only care about X and Z overlap, Y is usually same or irrelevant if we
                // assume flat world
                // But let's check X and Z strictly

                double otherMinX = Math.min(detail.getMin().getX(), detail.getMax().getX());
                double otherMaxX = Math.max(detail.getMin().getX(), detail.getMax().getX());
                double otherMinZ = Math.min(detail.getMin().getZ(), detail.getMax().getZ());
                double otherMaxZ = Math.max(detail.getMin().getZ(), detail.getMax().getZ());

                double myMinX = Math.min(proposedMinX, proposedMaxX);
                double myMaxX = Math.max(proposedMinX, proposedMaxX);
                double myMinZ = Math.min(proposedMinZ, proposedMaxZ);
                double myMaxZ = Math.max(proposedMinZ, proposedMaxZ);

                boolean overlapX = myMinX <= otherMaxX && myMaxX >= otherMinX;
                boolean overlapZ = myMinZ <= otherMaxZ && myMaxZ >= otherMinZ;

                if (overlapX && overlapZ) {
                    safe = false;
                    break;
                }
            }
            if (!safe)
                break;
        }

        if (!safe) {
            this.offsetX += this.incrementX;
            this.offsetZ += this.incrementZ;
            return;
        }

        // Step 3: Paste
        this.cancel();

        final int finalOffsetX = this.offsetX;
        final int finalOffsetZ = this.offsetZ;

        TaskManager.IMP.async(() -> {
            try {
                EditSession pasteSession = new EditSessionBuilder(minLoc.getWorld().getName())
                        .fastmode(true)
                        .allowedRegionsEverywhere()
                        .autoQueue(false)
                        .limitUnlimited()
                        .build();

                Vector pasteLocation = new Vector(
                        clipboardOrigin.getX() + finalOffsetX,
                        clipboardOrigin.getY(),
                        clipboardOrigin.getZ() + finalOffsetZ);

                ForwardExtentCopy paste = new ForwardExtentCopy(
                        this.clipboard,
                        this.clipboard.getRegion(),
                        pasteSession,
                        pasteLocation);

                Operations.complete(paste);
                pasteSession.flushQueue();

                // Callback to main thread
                TaskManager.IMP.task(this::onComplete);
            } catch (Exception e) {
                e.printStackTrace();
            }
        });
    }

    public abstract void onComplete();
}


Filename: .\main\java\rip\diamond\practice\arenas\task\WorldEditRunnable.java
package rip.diamond.practice.arenas.task;

import com.boydti.fawe.util.EditSessionBuilder;
import com.boydti.fawe.util.TaskManager;
import com.sk89q.worldedit.EditSession;
import com.sk89q.worldedit.Vector;
import com.sk89q.worldedit.blocks.BaseBlock;
import lombok.Getter;
import org.bukkit.Location;
import org.bukkit.World;
import org.bukkit.block.Block;
import org.bukkit.scheduler.BukkitRunnable;

import java.util.Iterator;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

/**
 * @since 11/25/2017
 * @author Zonix
 */

@Getter
public abstract class WorldEditRunnable extends BukkitRunnable {

    private final ConcurrentMap<Location, Block> blocks;
    private final int totalBlocks;
    private final Iterator<Location> iterator;
    private final World world;
    private boolean completed = false;

    public WorldEditRunnable(World world, Map<Location, Block> blocks) {
        this.world = world;
        this.blocks = new ConcurrentHashMap<>();
        this.blocks.putAll(blocks);
        this.totalBlocks = blocks.keySet().size();
        this.iterator = blocks.keySet().iterator();
    }

    @Override
    public void run() {
        if (blocks.isEmpty() || !iterator.hasNext()) {
            finish();
            completed = true;
            cancel();
            return;
        }

        TaskManager.IMP.async(() -> {
            EditSession editSession = new EditSessionBuilder(this.world.getName()).fastmode(true).allowedRegionsEverywhere().autoQueue(false).limitUnlimited().build();
            for (Map.Entry<Location, Block> entry : this.blocks.entrySet()) {
                try {
                    editSession.setBlock(new Vector(entry.getKey().getBlockX(), entry.getKey().getBlockY(), entry.getKey().getZ()), new BaseBlock(entry.getValue().getTypeId(), entry.getValue().getData()));
                } catch (Exception ex) {
                    ex.printStackTrace();
                }
            }
            editSession.flushQueue();
            TaskManager.IMP.task(this.blocks::clear);
        });
    }

    public abstract void finish();
}


Filename: .\main\java\rip\diamond\practice\command\ReloadCommand.java
package rip.diamond.practice.command;

import org.bukkit.Bukkit;
import org.bukkit.command.CommandSender;
import org.bukkit.entity.Player;
import rip.diamond.practice.Eden;
import rip.diamond.practice.arenas.Arena;
import rip.diamond.practice.config.Config;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.kits.Kit;
import rip.diamond.practice.util.CC;
import rip.diamond.practice.util.command.Command;
import rip.diamond.practice.util.command.CommandArgs;
import rip.diamond.practice.util.command.argument.CommandArguments;

public class ReloadCommand extends Command {

    @CommandArgs(name = "eden reload", permission = "eden.command.reload", inGameOnly = false)
    public void execute(CommandArguments args) {
        CommandSender sender = args.getSender();

        sender.sendMessage(CC.translate("&eReloading EdenPractice..."));

        // Reload Configs
        Eden.INSTANCE.reload();

        // Reload Arenas
        Arena.reload();

        // Reload Kits
        Kit.reload();

        // Instantly reapply visual elements to all online players
        sender.sendMessage(CC.translate("&eReapplying visual elements to all players..."));

        for (Player player : Bukkit.getOnlinePlayers()) {
            // Reapply Scoreboard
            if (Eden.INSTANCE.getScoreboardHandler() != null) {
                Eden.INSTANCE.getScoreboardHandler().removeScoreboard(player);
                Eden.INSTANCE.getScoreboardHandler().addScoreboard(player);
            }

            // Reapply Tab List (if enabled)
            if (Config.FANCY_TABLIST_ENABLED.toBoolean() && Eden.INSTANCE.getTabHandler() != null) {
                Eden.INSTANCE.getTabHandler().removePlayerTablist(player);
                Eden.INSTANCE.getTabHandler().registerPlayerTablist(player);
            }

            // Reapply NameTags (if enabled)
            if (Config.NAMETAG_ENABLED.toBoolean() && Eden.INSTANCE.getNameTagManager() != null) {
                Eden.INSTANCE.getNameTagManager().reloadPlayer(player);
                Eden.INSTANCE.getNameTagManager().reloadOthersFor(player);
            }
        }

        sender.sendMessage(CC.translate("&aReload complete! All changes have been applied instantly."));
    }
}


Filename: .\main\java\rip\diamond\practice\config\Config.java
package rip.diamond.practice.config;

import com.google.common.collect.ImmutableList;
import lombok.AllArgsConstructor;
import lombok.Getter;
import org.bukkit.Material;
import rip.diamond.practice.Eden;
import rip.diamond.practice.util.BasicConfigFile;
import rip.diamond.practice.util.Common;
import rip.diamond.practice.util.Util;

import java.util.List;

@AllArgsConstructor
public enum Config {

    DEBUG("debug", false),
    ARENA_KIT_AUTO_SAVE("arena-kit-auto-save", false),
    DISABLE_SAVE_WORLD("disable-save-world", true),
    LOBBY_ONLY_COMMANDS("lobby-only-commands", ImmutableList.of()),
    // MongoDB
    MONGO_ENABLED("mongo.enabled", false),
    MONGO_URI_MODE("mongo.uri-mode", false),
    MONGO_NORMAL_HOST("mongo.normal.host", "127.0.0.1"),
    MONGO_NORMAL_PORT("mongo.normal.port", 27017),
    MONGO_NORMAL_AUTH_ENABLED("mongo.normal.auth.enabled", false),
    MONGO_NORMAL_AUTH_USERNAME("mongo.normal.auth.username", ""),
    MONGO_NORMAL_AUTH_PASSWORD("mongo.normal.auth.password", ""),
    MONGO_URI_DATABASE("mongo.uri.database", "Practice"),
    MONGO_URI_CONNECTION_STRING("mongo.uri.connection-string", ""),

    STORAGE_TYPE("storage-type", "FLATFILE"), // Options: MONGODB, FLATFILEmongodb://127.0.0.1:27017/Eden"),
    // Tablist Edit
    FANCY_TABLIST_ENABLED("fancy-tablist.enabled", true),
    FANCY_TABLIST_FORMAT("fancy-tablist.format", "&a{player-name}"),
    FANCY_TABLIST_UPDATE_TICKS("fancy-tablist.update-ticks", 20),
    // NameTag
    NAMETAG_ENABLED("nametag.enabled", true),
    NAMETAG_PREFIX_LOBBY("nametag.prefix.lobby", "&9"),
    NAMETAG_PREFIX_SPECTATOR("nametag.prefix.spectator", "&7"),
    NAMETAG_PREFIX_TEAMMATE("nametag.prefix.teammate", "&a"),
    NAMETAG_PREFIX_OPPONENT("nametag.prefix.opponent", "&c"),
    NAMETAG_PREFIX_OTHER("nametag.prefix.other", "&e"),
    // Party
    PARTY_DEFAULT_MAX_SIZE("party.default-max-size", 30),
    PARTY_ANNOUNCE_COOLDOWN("party.announce-cooldown", 10),
    // Lobby
    LOBBY_DISPLAY_PLAYERS("lobby.display-players", true),
    // Queue
    QUEUE_RANKED_REQUIRED_WINS("queue.ranked-required-wins", 10),
    // Match
    MATCH_ALLOW_PREFIRE("match.allow-prefire", true),
    MATCH_ALLOW_REQUEUE("match.allow-requeue", true),
    MATCH_OUTSIDE_CUBOID_INSTANT_DEATH("match.outside-cuboid-instant-death", true),
    MATCH_REMOVE_CACTUS_SUGAR_CANE_PHYSICS("match.remove-cactus-sugar-cane-physics", true),
    MATCH_DEATH_LIGHTNING("match.death-lightning", true),
    MATCH_DEATH_ANIMATION("match.death-animation", true),
    MATCH_TP_2_BLOCKS_UP_WHEN_DIE("match.tp-2-blocks-up-when-die", false),
    MATCH_RESPAWN_TELEPORT_TO_SPAWN_WHEN_DIE("match.respawn-teleport-to-spawn-when-die", true),
    MATCH_WIN_COMMANDS("match.win-commands", ImmutableList.of()),
    MATCH_LOSE_COMMANDS("match.lose-commands", ImmutableList.of()),
    MATCH_START_SATURATION("match.start-saturation", 15),
    MATCH_SPECTATE_EXPEND_CUBOID("match.spectate-expend-cuboid", 50),
    MATCH_GOLDEN_APPLE_INSTANT_GAPPLE_EFFECTS("match.golden-apple.instant-gapple-effects", true),
    MATCH_GOLDEN_APPLE_GIVE_ABSORPTION_HEARTS_EVERYTIME("match.golden-apple.give-absorption-hearts-everytime", false),
    MATCH_SNOW_SNOWBALL_DROP_CHANCE("match.snow.snowball-drop-chance", 50),
    MATCH_SNOW_SNOWBALL_DROP_AMOUNT("match.snow.snowball-drop-amount", 4),
    MATCH_TITLE_SCORE("match.title.score", true),
    MATCH_TITLE_END("match.title.end", true),
    MATCH_END_DURATION("match.end-duration", 100),
    MATCH_ALLOW_BREAKING_BLOCKS("match.allow-breaking-blocks",
            ImmutableList.of("DEAD_BUSH", "GRASS", "LONG_GRASS", "CACTUS")),
    MATCH_FIREBALL_ENABLED("match.fireball.enabled", true),
    MATCH_FIREBALL_DIVIDE_DAMAGE("match.fireball.divide-damage", 5.0),
    MATCH_FIREBALL_SPEED("match.fireball.speed", 2.0),
    MATCH_FIREBALL_YIELD("match.fireball.yield", 2.0),
    MATCH_FIREBALL_ALLOWED_BREAKING_BLOCKS("match.fireball.allowed-breaking-blocks",
            ImmutableList.of("WOOD", "BED_BLOCK")),
    MATCH_FIREBALL_KNOCKBACK_ENABLED("match.fireball.knockback.enabled", true),
    MATCH_FIREBALL_KNOCKBACK_VERTICAL("match.fireball.knockback.vertical", 1.1),
    MATCH_FIREBALL_KNOCKBACK_HORIZONTAL("match.fireball.knockback.horizontal", 1.2),
    MATCH_TNT_ENABLED("match.tnt.enabled", true),
    MATCH_TNT_DIVIDE_DAMAGE("match.tnt.divide-damage", 5.0),
    MATCH_TNT_SPEED("match.tnt.speed", 2.0),
    MATCH_TNT_YIELD("match.tnt.yield", 2.0),
    MATCH_TNT_FUSE_TICKS("match.tnt.fuse-ticks", 50),
    MATCH_TNT_ALLOWED_BREAKING_BLOCKS("match.tnt.allowed-breaking-blocks", ImmutableList.of("WOOD", "BED_BLOCK")),
    MATCH_TNT_KNOCKBACK_ENABLED("match.tnt.knockback.enabled", true),
    MATCH_TNT_KNOCKBACK_VERTICAL("match.tnt.knockback.vertical", 1.1),
    MATCH_TNT_KNOCKBACK_HORIZONTAL("match.tnt.knockback.horizontal", 1.2),
    MATCH_GOLDEN_HEAD_EFFECTS("match.golden-head.effects",
            ImmutableList.of("REGENERATION;200;2", "ABSORPTION;2400;0", "SPEED;200;0")),
    MATCH_GOLDEN_HEAD_FOOD_LEVEL("match.golden-head.food-level", 6),
    // Event
    EVENT_SUMO_EVENT_ARENAS("event.sumo-event.arenas", ImmutableList.of("sumoevent")),
    EVENT_SUMO_EVENT_KIT("event.sumo-event.kit", "sumo"),
    // Chat Format
    CHAT_FORMAT_ENABLED("chat-format.enabled", true),
    CHAT_FORMAT_FORMAT("chat-format.format", "&a%1$s&f: %2$s"),
    // Profile
    PROFILE_DEFAULT_ELO("profile.default-elo", 1000),
    PROFILE_SAVE_ON_SERVER_STOP("profile.save-on-server-stop", true),
    PROFILE_DEFAULT_SETTINGS_TIME_CHANGER("profile.default-settings.time-changer", "normal"),
    PROFILE_DEFAULT_SETTINGS_ARENA_SELECTION("profile.default-settings.arena-selection", false),
    PROFILE_DEFAULT_SETTINGS_MATCH_SCOREBOARD("profile.default-settings.match-scoreboard", true),
    PROFILE_DEFAULT_SETTINGS_ALLOW_DUEL_REQUEST("profile.default-settings.allow-duel-request", true),
    PROFILE_DEFAULT_SETTINGS_ALLOW_PARTY_INVITE("profile.default-settings.allow-party-invite", true),
    PROFILE_DEFAULT_SETTINGS_SPECTATOR_VISIBILITY("profile.default-settings.spectator-visibility", true),
    PROFILE_DEFAULT_SETTINGS_SPECTATOR_JOIN_LEAVE_MESSAGE("profile.default-settings.spectator-join-leave-message",
            true),
    PROFILE_DEFAULT_SETTINGS_EVENT_ANNOUNCEMENT("profile.default-settings.event-announcement", true),
    PROFILE_DEFAULT_SETTINGS_PING_RANGE("profile.default-settings.ping-range", "infinite"),
    // Crafting Options
    CRAFTING_ENABLED("crafting.enabled", false),
    CRAFTING_WHITELISTED_ITEMS("crafting.whitelisted-items", ImmutableList.of("MUSHROOM_SOUP")),
    // Imanity Spigot Options
    IMANITY_TELEPORT_ASYNC("imanity.teleport-async", true),
    // Optimization
    OPTIMIZATION_SET_BLOCK_FAST("optimization.set-block-fast", true),
    // Experiment
    EXPERIMENT_DISABLE_ORIGINAL_ARENA("experiment.disable-original-arena", false),
    EXPERIMENT_K_FACTOR("experiment.k-factor", 32),
    ;

    @Getter
    private final String path;
    @Getter
    private final Object defaultValue;

    public String toString() {
        String str = Eden.INSTANCE.getConfigFile().getString(path);
        if (str.equals(path)) {
            return defaultValue.toString();
        }
        return str;
    }

    public List<String> toStringList() {
        List<String> str = Eden.INSTANCE.getConfigFile().getStringList(path);
        if (str.isEmpty() || str.get(0).equals(path)) {
            return (List<String>) defaultValue;
        }
        if (str.get(0).equals("null")) {
            return ImmutableList.of();
        }
        return str;
    }

    public boolean toBoolean() {
        return Boolean.parseBoolean(toString());
    }

    public int toInteger() {
        return Integer.parseInt(toString());
    }

    public double toDouble() {
        return Double.parseDouble(toString());
    }

    public static void loadDefault() {
        BasicConfigFile configFile = Eden.INSTANCE.getConfigFile();

        for (Config config : Config.values()) {
            String path = config.getPath();
            String str = configFile.getString(path);
            if (str.equals(path)) {
                Common.debug("Ê≤íÊúâÊâæÂà∞ '" + path + "'... Ê≠£Âú®Âä†ÂÖ•Âà∞ config.yml");
                configFile.getConfiguration().set(path, config.getDefaultValue());
            }
        }

        configFile.save();
        configFile.load();
    }

}


Filename: .\main\java\rip\diamond\practice\config\EdenSound.java
package rip.diamond.practice.config;

import lombok.RequiredArgsConstructor;
import org.bukkit.Sound;
import org.bukkit.entity.Player;
import rip.diamond.practice.Eden;
import rip.diamond.practice.util.Common;
import rip.diamond.practice.util.Util;

@RequiredArgsConstructor
public enum EdenSound {

    RECEIVE_DUEL_REQUEST("receive-duel-request", Sound.CHICKEN_EGG_POP, 1f, 1f),
    GOLDEN_HEAD_EAT("golden-head-eat", Sound.EAT, 1f, 1f),
    SELF_BREAK_BED("self-break-bed", Sound.ENDERDRAGON_GROWL, 1f, 1f),
    OPPONENT_BREAK_BED("opponent-break-bed", Sound.WITHER_DEATH, 1f, 1f),
    NEW_ROUND_COUNTDOWN("new-round-countdown", Sound.CLICK, 1f, 1f),
    MATCH_START("match-start", Sound.FIREWORK_BLAST, 1f, 1f),
    ;

    private final String path;
    private final Sound sound;
    private final float volume;
    private final float pitch;

    private Sound getSound() {
        String str = Eden.INSTANCE.getSoundFile().getString(path);
        if (Util.isNull(str)) {
            return sound;
        }
        return Sound.valueOf(str.split(";")[0]);
    }

    public float getVolume() {
        String str = Eden.INSTANCE.getSoundFile().getString(path);
        if (Util.isNull(str)) {
            return volume;
        }
        return Float.parseFloat(str.split(";")[1]);
    }

    public float getPitch() {
        String str = Eden.INSTANCE.getSoundFile().getString(path);
        if (Util.isNull(str)) {
            return pitch;
        }
        return Float.parseFloat(str.split(";")[2]);
    }

    public void play(Player player) {
        Common.playSound(player, getSound(), getVolume(), getPitch());
    }

}


Filename: .\main\java\rip\diamond\practice\config\Language.java
package rip.diamond.practice.config;

import lombok.AllArgsConstructor;
import lombok.Getter;
import me.clip.placeholderapi.PlaceholderAPI;
import org.bukkit.ChatColor;
import org.bukkit.command.CommandSender;
import org.bukkit.entity.Player;
import rip.diamond.practice.Eden;
import rip.diamond.practice.EdenPlaceholder;
import rip.diamond.practice.util.CC;
import rip.diamond.practice.util.Checker;
import rip.diamond.practice.util.Common;
import rip.diamond.practice.util.Util;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

@AllArgsConstructor
public enum Language {

    SCOREBOARD_TITLE("scoreboard.title"),
    SCOREBOARD_BOXING_COUNTER_NO_COMBO("scoreboard.boxing-counter.no-combo"),
    SCOREBOARD_BOXING_COUNTER_TEXT_SOLO("scoreboard.boxing-counter.text-solo"),
    SCOREBOARD_BOXING_COUNTER_TEXT_TEAM("scoreboard.boxing-counter.text-team"),
    SCOREBOARD_LOADING("scoreboard.loading"),
    SCOREBOARD_IN_LOBBY("scoreboard.in-lobby"),
    SCOREBOARD_IN_PARTY("scoreboard.in-party"),
    SCOREBOARD_IN_EDIT("scoreboard.in-edit"),
    SCOREBOARD_IN_EDIT_GUI("scoreboard.in-edit-gui"),
    SCOREBOARD_IN_QUEUE_UNRANKED("scoreboard.in-queue-unranked"),
    SCOREBOARD_IN_QUEUE_RANKED("scoreboard.in-queue-ranked"),
    SCOREBOARD_IN_MATCH_SOLO_FIGHTING("scoreboard.in-match-solo.fighting"),
    SCOREBOARD_IN_MATCH_SOLO_BOXING("scoreboard.in-match-solo.boxing"),
    SCOREBOARD_IN_MATCH_SOLO_BED("scoreboard.in-match-solo.bed"),
    SCOREBOARD_IN_MATCH_SOLO_POINT("scoreboard.in-match-solo.point"),
    SCOREBOARD_IN_MATCH_SOLO_ENDING("scoreboard.in-match-solo.ending"),
    SCOREBOARD_IN_MATCH_TEAMS_FIGHTING("scoreboard.in-match-teams.fighting"),
    SCOREBOARD_IN_MATCH_TEAMS_BOXING("scoreboard.in-match-teams.boxing"),
    SCOREBOARD_IN_MATCH_TEAMS_BED("scoreboard.in-match-teams.bed"),
    SCOREBOARD_IN_MATCH_TEAMS_POINT("scoreboard.in-match-teams.point"),
    SCOREBOARD_IN_MATCH_TEAMS_ENDING("scoreboard.in-match-teams.ending"),
    SCOREBOARD_IN_MATCH_FFA_FIGHTING("scoreboard.in-match-ffa.fighting"),
    SCOREBOARD_IN_MATCH_FFA_ENDING("scoreboard.in-match-ffa.ending"),
    SCOREBOARD_IN_SPECTATE_SOLO_FIGHTING("scoreboard.in-spectate-solo.fighting"),
    SCOREBOARD_IN_SPECTATE_SOLO_BOXING("scoreboard.in-spectate-solo.boxing"),
    SCOREBOARD_IN_SPECTATE_SOLO_BED("scoreboard.in-spectate-solo.bed"),
    SCOREBOARD_IN_SPECTATE_SOLO_POINT("scoreboard.in-spectate-solo.point"),
    SCOREBOARD_IN_SPECTATE_SOLO_ENDING("scoreboard.in-spectate-solo.ending"),
    SCOREBOARD_IN_SPECTATE_TEAMS_FIGHTING("scoreboard.in-spectate-teams.fighting"),
    SCOREBOARD_IN_SPECTATE_TEAMS_BOXING("scoreboard.in-spectate-teams.boxing"),
    SCOREBOARD_IN_SPECTATE_TEAMS_BED("scoreboard.in-spectate-teams.bed"),
    SCOREBOARD_IN_SPECTATE_TEAMS_POINT("scoreboard.in-spectate-teams.point"),
    SCOREBOARD_IN_SPECTATE_TEAMS_ENDING("scoreboard.in-spectate-teams.ending"),
    SCOREBOARD_IN_SPECTATE_FFA_FIGHTING("scoreboard.in-spectate-ffa.fighting"),
    SCOREBOARD_IN_SPECTATE_FFA_ENDING("scoreboard.in-spectate-ffa.ending"),
    JOIN_MESSAGE("join-message"),
    LOADING_PROFILE("loading-profile"),
    INVALID_SYNTAX("invalid-syntax"),
    LOCATION_NOT_FOUND("location-not-found"),
    LOCATION_CHANGED("location-changed"),
    NO_PERMISSION("no-permission"),
    ENABLED("enabled"),
    DISABLED("disabled"),
    CONFIRM_TITLE("confirm-title"),
    REACHED_BUILD_LIMIT("reached-build-limit"),
    BANNED_COMMAND("banned-command"),
    ARENA_ALREADY_EXISTS("arena.exists"),
    ARENA_NOT_EXISTS("arena.not-exists"),
    ARENA_CREATED("arena.created"),
    ARENA_SUCCESSFULLY_SET("arena.successfully-set"),
    ARENA_SAVED("arena.saved"),
    ARENA_SAVED_ALL("arena.saved-all"),
    ARENA_CANNOT_SET_BECAUSE_CLONE_FOUND("arena.cannot-set-because-clone-found"),
    ARENA_GENERATE_DISPLAY("arena.generate.display"),
    ARENA_GENERATE_HOVER("arena.generate.hover"),
    ARENA_GENERATE_COPYING("arena.generate.copying"),
    ARENA_REMOVE_SUCCESS_MAIN("arena.remove.success-main"),
    ARENA_REMOVE_SUCCESS_DUPLICATE("arena.remove.success-duplicate"),
    ARENA_MENU_TITLE("arena.menu.title"),
    ARENA_MENU_ARENA_EDIT_NAME("arena.menu.arena-edit.name"),
    ARENA_MENU_ARENA_EDIT_LORE("arena.menu.arena-edit.lore"),
    ARENA_ALLOWED_KITS_MENU_TITLE("arena.allowed-kits-menu.title"),
    ARENA_ALLOWED_KITS_MENU_LORE_CLICK_TO_SELECT("arena.allowed-kits-menu.lore.click-to-select"),
    ARENA_ALLOWED_KITS_MENU_LORE_SELECTED("arena.allowed-kits-menu.lore.selected"),
    ARENA_DETAILS_MENU_TITLE("arena.details-menu.title"),
    ARENA_DETAILS_MENU_DETAIL_NAME("arena.details-menu.detail.name"),
    ARENA_DETAILS_MENU_DETAIL_LORE("arena.details-menu.detail.lore"),
    ARENA_DETAILS_MENU_DETAIL_LORE_NOT_DUPLICATED("arena.details-menu.detail.lore-not-duplicated"),
    ARENA_DETAILS_MENU_DETAIL_LORE_CLICK_TO_DELETE("arena.details-menu.detail.click-to-delete"),
    ARENA_DETAILS_MENU_DETAIL_LORE_CLICK_TO_TELEPORT("arena.details-menu.detail.click-to-teleport"),
    ARENA_DETAILS_MENU_DETAIL_TELEPORTED("arena.details-menu.detail.teleported"),
    ARENA_DETAILS_MENU_CREATE_DUPLICATE_NAME("arena.details-menu.create-duplicate.name"),
    ARENA_DETAILS_MENU_CREATE_DUPLICATE_LORE("arena.details-menu.create-duplicate.lore"),
    ARENA_EDIT_MENU_TITLE("arena.edit-menu.title"),
    ARENA_EDIT_MENU_CLICK_TO_EDIT("arena.edit-menu.click-to-edit"),
    ARENA_EDIT_MENU_DISPLAY_NAME_NAME("arena.edit-menu.display-name.name"),
    ARENA_EDIT_MENU_DISPLAY_NAME_DESCRIPTION("arena.edit-menu.display-name.description"),
    ARENA_EDIT_MENU_DISPLAY_NAME_ACTION_DESCRIPTION("arena.edit-menu.display-name.action-description"),
    ARENA_EDIT_MENU_DISPLAY_NAME_PROCEDURE_MESSAGE("arena.edit-menu.display-name.procedure.message"),
    ARENA_EDIT_MENU_DISPLAY_NAME_PROCEDURE_SUCCESS("arena.edit-menu.display-name.procedure.success"),
    ARENA_EDIT_MENU_ALLOWED_KITS_NAME("arena.edit-menu.allowed-kits.name"),
    ARENA_EDIT_MENU_ALLOWED_KITS_DESCRIPTION("arena.edit-menu.allowed-kits.description"),
    ARENA_EDIT_MENU_A_POSITION_NAME("arena.edit-menu.a-position.name"),
    ARENA_EDIT_MENU_A_POSITION_DESCRIPTION("arena.edit-menu.a-position.description"),
    ARENA_EDIT_MENU_A_POSITION_ACTION_DESCRIPTION("arena.edit-menu.a-position.action-description"),
    ARENA_EDIT_MENU_B_POSITION_NAME("arena.edit-menu.b-position.name"),
    ARENA_EDIT_MENU_B_POSITION_DESCRIPTION("arena.edit-menu.b-position.description"),
    ARENA_EDIT_MENU_B_POSITION_ACTION_DESCRIPTION("arena.edit-menu.b-position.action-description"),
    ARENA_EDIT_MENU_SPECTATOR_POSITION_NAME("arena.edit-menu.spectator-position.name"),
    ARENA_EDIT_MENU_SPECTATOR_POSITION_DESCRIPTION("arena.edit-menu.spectator-position.description"),
    ARENA_EDIT_MENU_SPECTATOR_POSITION_ACTION_DESCRIPTION("arena.edit-menu.spectator-position.action-description"),
    ARENA_EDIT_MENU_MIN_NAME("arena.edit-menu.min.name"),
    ARENA_EDIT_MENU_MIN_DESCRIPTION("arena.edit-menu.min.description"),
    ARENA_EDIT_MENU_MIN_ACTION_DESCRIPTION("arena.edit-menu.min.action-description"),
    ARENA_EDIT_MENU_MAX_NAME("arena.edit-menu.max.name"),
    ARENA_EDIT_MENU_MAX_DESCRIPTION("arena.edit-menu.max.description"),
    ARENA_EDIT_MENU_MAX_ACTION_DESCRIPTION("arena.edit-menu.max.action-description"),
    ARENA_EDIT_MENU_Y_LIMIT_NAME("arena.edit-menu.y-limit.name"),
    ARENA_EDIT_MENU_Y_LIMIT_DESCRIPTION("arena.edit-menu.y-limit.description"),
    ARENA_EDIT_MENU_BUILD_MAX_NAME("arena.edit-menu.build-max.name"),
    ARENA_EDIT_MENU_BUILD_MAX_DESCRIPTION("arena.edit-menu.build-max.description"),
    ARENA_EDIT_MENU_PORTAL_PROTECTION_RADIUS_NAME("arena.edit-menu.portal-protection-radius.name"),
    ARENA_EDIT_MENU_PORTAL_PROTECTION_RADIUS_DESCRIPTION("arena.edit-menu.portal-protection-radius.description"),
    ARENA_EDIT_MENU_CLONE_NAME("arena.edit-menu.clone.name"),
    ARENA_EDIT_MENU_CLONE_DESCRIPTION("arena.edit-menu.clone.description"),
    ARENA_EDIT_MENU_CLONE_ACTION_DESCRIPTION("arena.edit-menu.clone.action-description"),
    ARENA_EDIT_MENU_DELETE_NAME("arena.edit-menu.delete.name"),
    ARENA_EDIT_MENU_DELETE_DESCRIPTION("arena.edit-menu.delete.description"),
    ARENA_EDIT_MENU_DELETE_ACTION_DESCRIPTION("arena.edit-menu.delete.action-description"),
    ARENA_EDIT_MENU_DELETE_ACTION_DESCRIPTION_HAS_CLONE("arena.edit-menu.delete.action-description-has-clone"),
    ARENA_EDIT_MENU_SAVE_NAME("arena.edit-menu.save.name"),
    ARENA_EDIT_MENU_SAVE_ACTION_DESCRIPTION("arena.edit-menu.toggle.action-description"),
    ARENA_EDIT_MENU_TOGGLE_NAME("arena.edit-menu.toggle.name"),
    ARENA_EDIT_MENU_TOGGLE_DESCRIPTION("arena.edit-menu.toggle.description"),
    ARENA_EDIT_MENU_TOGGLE_NEED_RESTART("arena.edit-menu.toggle.need-restart"),
    ARENA_EDIT_MENU_TOGGLE_ACTION_DESCRIPTION("arena.edit-menu.toggle.action-description"),
    ARENA_EDIT_MENU_TOGGLE_ACTION_DESCRIPTION_NOT_FINISHED_SETUP(
            "arena.edit-menu.toggle.action-description-not-finished-setup"),
    ARENA_EDIT_MENU_TOGGLE_ACTION_DESCRIPTION_NEED_RESTART("arena.edit-menu.toggle.action-description-need-restart"),
    ARENA_EDIT_MENU_ICON_NAME("arena.edit-menu.icon.name"),
    ARENA_EDIT_MENU_ICON_DESCRIPTION("arena.edit-menu.icon.description"),
    ARENA_EDIT_MENU_ICON_ACTION_DESCRIPTION("arena.edit-menu.icon.action-description"),
    ARENA_EDIT_MENU_ICON_CANNOT_BE_AIR("arena.edit-menu.icon.cannot-be-air"),
    ARENA_EDIT_MIN("arena.edit.min"),
    ARENA_EDIT_MAX("arena.edit.max"),
    ARENA_EDIT_Y_LIMIT("arena.edit.y-limit"),
    ARENA_EDIT_BUILD_MAX("arena.edit.build-max"),
    ARENA_EDIT_PORTAL_PROTECTION_RADIUS("arena.edit.portal-protection-radius"),
    ARENA_EDIT_ALLOWED_KITS("arena.edit.allowed-kits"),
    ARENA_EDIT_ALLOWED_KITS_ADDED("arena.edit.allowed-kits-added"),
    ARENA_EDIT_ALLOWED_KITS_REMOVED("arena.edit.allowed-kits-removed"),
    ARENA_EDIT_CANNOT_EDIT_NOT_FINISHED_SETUP("arena.edit.cannot-edit-not-finished-setup"),
    ARENA_EDIT_CANNOT_EDIT_NEED_RESTART("arena.edit.cannot-edit-need-restart"),
    DUEL_CANNOT_FIND_PLAYER("duel.cannot-find-player"),
    DUEL_CANNOT_DUEL_SELF("duel.cannot-duel-self"),
    DUEL_CANNOT_DUEL_NOT_IN_PARTY("duel.cannot-duel-not-in-party"),
    DUEL_HAS_PENDING_DUEL_REQUEST("duel.has-pending-duel-request"),
    DUEL_INVALID_PLAYER("duel.invalid-player"),
    DUEL_INVALID_KIT("duel.invalid-kit"),
    DUEL_INVALID_ARENA("duel.invalid-arena"),
    DUEL_INVALID_DUEL_REQUEST("duel.invalid-duel-request"),
    DUEL_HELP_MESSAGE("duel.help-message"),
    DUEL_CHOOSE_ARENA_MENU_NAME("duel.choose-arena-menu.name"),
    DUEL_CHOOSE_ARENA_MENU_BUTTON_NAME("duel.choose-arena-menu.button.name"),
    DUEL_CHOOSE_ARENA_MENU_BUTTON_RANDOM("duel.choose-arena-menu.button.random"),
    DUEL_CHOOSE_ARENA_MENU_BUTTON_LORE("duel.choose-arena-menu.button.lore"),
    DUEL_CHOOSE_KIT_MENU_NAME("duel.choose-kit-menu.name"),
    DUEL_CHOOSE_KIT_MENU_BUTTON_NAME("duel.choose-kit-menu.button.name"),
    DUEL_CHOOSE_KIT_MENU_BUTTON_LORE("duel.choose-kit-menu.button.lore"),
    DUEL_DUEL_REQUEST_CANNOT_FIND_TARGET("duel.duel-request.cannot-find-target"),
    DUEL_DUEL_REQUEST_DISPLAY_1V1("duel.duel-request.display-1v1"),
    DUEL_DUEL_REQUEST_DISPLAY_PARTY("duel.duel-request.display-party"),
    DUEL_DUEL_REQUEST_CLICK_TO_ACCEPT("duel.duel-request.click-to-accept"),
    DUEL_DUEL_REQUEST_CLICK_TO_ACCEPT_HOVER("duel.duel-request.click-to-accept-hover"),
    DUEL_DUEL_REQUEST_CLICK_TO_VIEW_PING("duel.duel-request.click-to-view-ping"),
    DUEL_DUEL_REQUEST_CLICK_TO_VIEW_PING_HOVER("duel.duel-request.click-to-view-ping-hover"),
    DUEL_DUEL_REQUEST_SUCCESS_1V1("duel.duel-request.success-1v1"),
    DUEL_DUEL_REQUEST_SUCCESS_PARTY("duel.duel-request.success-party"),
    DUEL_VERIFY_TARGET_NOT_FOUND("duel.verify.target-not-found"),
    DUEL_VERIFY_NEED_TO_BE_IN_LOBBY("duel.verify.need-to-be-in-lobby"),
    DUEL_VERIFY_TARGET_NEED_TO_BE_IN_LOBBY("duel.verify.target-need-to-be-in-lobby"),
    DUEL_VERIFY_TARGET_DUEL_REQUEST_DISABLED("duel.verify.target-duel-request-disabled"),
    DUEL_VERIFY_ARENA_DISABLED("duel.verify.arena-disabled"),
    DUEL_VERIFY_CANNOT_FIND_ARENA("duel.verify.cannot-find-arena"),
    DUEL_VERIFY_TARGET_IN_A_PARTY("duel.verify.target-in-a-party"),
    DUEL_VERIFY_TARGET_NOT_IN_A_PARTY("duel.verify.target-not-in-a-party"),
    DUEL_VERIFY_CANNOT_DUEL_SAME_PARTY("duel.verify.cannot-duel-same-party"),
    DUEL_VERIFY_PLAYER_NOT_IN_LOBBY("duel.verify.player-not-in-lobby"),
    EVENT_EVENT_IS_RUNNING("event.event-is-running"),
    EVENT_EVENT_IS_NOT_RUNNING("event.event-is-not-running"),
    EVENT_EVENT_ALREADY_STARTED("event.event-already-started"),
    EVENT_NO_AVAILABLE_STATUS("event.no-available-status"),
    EVENT_WRONG_STATE("event.wrong-state"),
    EVENT_AUTO_CREATE_PARTY_BECAUSE_NEED_A_PARTY("event.auto-create-party-because-need-a-party"),
    EVENT_PARTY_SIZE_OVER("event.party-size-over"),
    EVENT_AUTO_SET_PARTY_SIZE("event.auto-set-party-size"),
    EVENT_CANNOT_USE_THIS_COMMAND("event.cannot-use-this-command"),
    EVENT_LEAVE_EVENT_BECAUSE_PARTY_DISBAND("event.leave-event-because-party-disband"),
    EVENT_CANNOT_JOIN_PARTY_BECAUSE_IN_EVENT("event.cannot-join-party-because-in-event"),
    EVENT_LEAVE_EVENT_BECAUSE_ERROR("event.leave-event-because-error"),
    EVENT_FORCE_CANCEL_EVENT("event.force-cancel-event"),
    EVENT_NO_WINNER_BECAUSE_NO_PARTY("event.no-winner-because-no-party"),
    EVENT_WINNER_ANNOUNCE_MESSAGE("event.winner-announce.message"),
    EVENT_WINNER_ANNOUNCE_SPLIT_FORMAT("event.winner-announce.split-format"),
    EVENT_EVENT_CREATE_MENU_TITLE("event.event-create-menu.title"),
    EVENT_EVENT_CREATE_MENU_BUTTON_NAME("event.event-create-menu.button.name"),
    EVENT_EVENT_CREATE_MENU_BUTTON_LORE_CLICK_TO_CREATE_EVENT(
            "event.event-create-menu.button.lore.click-to-create-event"),
    EVENT_EVENT_CREATE_MENU_BUTTON_LORE_NO_PERMISSION("event.event-create-menu.button.lore.no-permission"),
    EVENT_EVENT_SELECT_KIT_MENU_TITLE("event.event-select-kit-menu.title"),
    EVENT_EVENT_SELECT_KIT_MENU_BUTTON_NAME("event.event-select-kit-menu.button.name"),
    EVENT_EVENT_SELECT_KIT_MENU_BUTTON_LORE("event.event-select-kit-menu.button.lore"),
    EVENT_EVENT_SETTINGS_MENU_TITLE("event.event-settings-menu.title"),
    EVENT_EVENT_SETTINGS_MENU_MAX_PLAYERS_BUTTON_NAME("event.event-settings-menu.max-players-button.name"),
    EVENT_EVENT_SETTINGS_MENU_MAX_PLAYERS_BUTTON_LORE("event.event-settings-menu.max-players-button.lore"),
    EVENT_EVENT_SETTINGS_MENU_PARTY_SIZE_BUTTON_NAME("event.event-settings-menu.party-size-button.name"),
    EVENT_EVENT_SETTINGS_MENU_PARTY_SIZE_BUTTON_LORE("event.event-settings-menu.party-size-button.lore"),
    EVENT_EVENT_SETTINGS_MENU_KIT_BUTTON_NAME("event.event-settings-menu.kit-button.name"),
    EVENT_EVENT_SETTINGS_MENU_KIT_BUTTON_LORE("event.event-settings-menu.kit-button.lore"),
    EVENT_EVENT_SETTINGS_MENU_START_BUTTON_NAME("event.event-settings-menu.start-button.name"),
    EVENT_EVENT_SETTINGS_MENU_START_BUTTON_LORE("event.event-settings-menu.start-button.lore"),
    EVENT_EVENT_CREATE_MESSAGE("event.event-create.message"),
    EVENT_EVENT_CREATE_CLICKABLE_MESSAGE("event.event-create.clickable.message"),
    EVENT_EVENT_CREATE_CLICKABLE_HOVER("event.event-create.clickable.hover"),
    EVENT_PARTY_NAME_FORMAT("event.party-name-format"),
    EVENT_EVENT_JOIN_MESSAGE("event.event-join.message"),
    EVENT_EVENT_JOIN_CLICKABLE_MESSAGE("event.event-join.clickable.message"),
    EVENT_EVENT_JOIN_CLICKABLE_HOVER("event.event-join.clickable.hover"),
    EVENT_STARTING_FULL("event.starting-full"),
    EVENT_EVENT_LEAVE_MESSAGE("event.event-leave.message"),
    EVENT_EVENT_START_COUNTDOWN_MESSAGE("event.event-start-countdown.message"),
    EVENT_EVENT_START_COUNTDOWN_CLICKABLE_MESSAGE("event.event-start-countdown.clickable.message"),
    EVENT_EVENT_START_COUNTDOWN_CLICKABLE_HOVER("event.event-start-countdown.clickable.hover"),
    EVENT_CANCEL_NOT_ENOUGH_PLAYERS("event.cancel-not-enough-players"),
    EVENT_TOURNAMENT_NAME("event.tournament.name"),
    EVENT_TOURNAMENT_MATCH_END_MESSAGE("event.tournament.match-end-message"),
    EVENT_TOURNAMENT_SCOREBOARD_STARTING_EVENT("event.tournament.scoreboard.starting-event"),
    EVENT_TOURNAMENT_SCOREBOARD_STARTING_NEW_ROUND("event.tournament.scoreboard.starting-new-round"),
    EVENT_TOURNAMENT_SCOREBOARD_FIGHTING("event.tournament.scoreboard.fighting"),
    EVENT_TOURNAMENT_STATUS_STARTING_EVENT("event.tournament.status.starting-event"),
    EVENT_TOURNAMENT_STATUS_STARTING_NEW_ROUND("event.tournament.status.starting-new-round"),
    EVENT_TOURNAMENT_STATUS_FIGHTING("event.tournament.status.fighting"),
    EVENT_TOURNAMENT_STATUS_FIGHTING_TEAM_FORMAT("event.tournament.status.fighting-team-format"),
    EVENT_TOURNAMENT_NEW_ROUND_COUNTDOWN("event.tournament.new-round.countdown"),
    EVENT_TOURNAMENT_NEW_ROUND_START("event.tournament.new-round.start"),
    EVENT_TOURNAMENT_NEW_ROUND_NO_AVAILABLE_ARENA("event.tournament.new-round.no-available-arena"),
    EVENT_TOURNAMENT_NEW_ROUND_AUTO_PROMOTION("event.tournament.new-round.auto-promotion"),
    EVENT_SUMO_EVENT_NAME("event.sumo-event.name"),
    EVENT_SUMO_EVENT_MATCH_END_MESSAGE("event.sumo-event.match-end-message"),
    EVENT_SUMO_EVENT_LOBBY_SCOREBOARD_STARTING_EVENT("event.sumo-event.lobby-scoreboard.starting-event"),
    EVENT_SUMO_EVENT_LOBBY_SCOREBOARD_FIGHTING("event.sumo-event.lobby-scoreboard.fighting"),
    EVENT_SUMO_EVENT_IN_GAME_SCOREBOARD_STARTING_MATCH("event.sumo-event.in-game-scoreboard.starting-match"),
    EVENT_SUMO_EVENT_IN_GAME_SCOREBOARD_FIGHTING("event.sumo-event.in-game-scoreboard.fighting"),
    EVENT_SUMO_EVENT_IN_GAME_SCOREBOARD_ENDING("event.sumo-event.in-game-scoreboard.ending"),
    EVENT_SUMO_EVENT_STATUS_STARTING_EVENT("event.sumo-event.status.starting-event"),
    EVENT_SUMO_EVENT_STATUS_STARTING_NEW_ROUND("event.sumo-event.status.starting-new-round"),
    EVENT_SUMO_EVENT_STATUS_FIGHTING("event.sumo-event.status.fighting"),
    EVENT_SUMO_EVENT_NEW_ROUND_COUNTDOWN("event.sumo-event.new-round.countdown"),
    EVENT_SUMO_EVENT_NEW_ROUND_STARTED("event.sumo-event.new-round.started"),
    HOOK_FOUND_CUSTOM_SPIGOT("hook.found-custom-spigot"),
    HOOK_CANNOT_FIND_CUSTOM_SPIGOT("hook.cannot-find-custom-spigot"),
    HOOK_ERROR_KNOCKBACK_NOT_FOUND("hook.error-knockback-not-found"),
    KIT_EDITOR_CANNOT_EDIT_WRONG_STATE("kit-editor.cannot-edit-wrong-state"),
    KIT_EDITOR_EXTRA_ITEM_MENU_NAME("kit-editor.extra-item-menu-name"),
    KIT_EDITOR_SAVE_MENU_NAME("kit-editor.save-menu.name"),
    KIT_EDITOR_SAVE_MENU_SAVE_LOADOUT_BUTTON_NAME("kit-editor.save-menu.save-loadout-button-name"),
    KIT_EDITOR_SAVE_MENU_LOAD_LOADOUT_BUTTON_NAME("kit-editor.save-menu.load-loadout-button-name"),
    KIT_EDITOR_SAVE_MENU_RENAME_LOADOUT_BUTTON_NAME("kit-editor.save-menu.rename-loadout-button-name"),
    KIT_EDITOR_SAVE_MENU_DELETE_LOADOUT_BUTTON_NAME("kit-editor.save-menu.delete-loadout-button-name"),
    KIT_EDITOR_SAVE_MENU_RENAME_INSTRUCTIONS("kit-editor.save-menu.rename-instructions"),
    KIT_EDITOR_SAVE_MENU_INVALID_CHARACTER("kit-editor.save-menu.invalid-character"),
    KIT_EDITOR_SELECT_KIT_MENU_NAME("kit-editor.select-kit-menu.name"),
    KIT_EDITOR_SELECT_KIT_MENU_BUTTON_NAME("kit-editor.select-kit-menu.button.name"),
    KIT_EDITOR_SELECT_KIT_MENU_BUTTON_LORE("kit-editor.select-kit-menu.button.lore"),
    KIT_EDITOR_CANNOT_USE_COMMAND_WHILE_EDITING("kit-editor.cannot-use-command-while-editing"),
    KIT_EDITOR_DISALLOW_EXTRA_ITEM("kit-editor.disallow-extra-item"),
    KIT_EDITOR_CANNOT_FIND_EDITOR_LOCATION("kit-editor.cannot-find-editor-location"),
    KIT_EDITOR_EDITING("kit-editor.editing"),
    KIT_NOT_EXISTS("kit.not-exists"),
    KIT_NO_KITS_FOUND("kit.no-kits-found"),
    KIT_SAVED("kit.saved"),
    KIT_SAVED_ALL_KITS("kit.saved-all-kits"),
    KIT_KIT_ALREADY_EXISTS("kit.kit-already-exists"),
    KIT_SUCCESSFULLY_CREATE("kit.successfully-create"),
    KIT_SUCCESSFULLY_DELETE("kit.successfully-delete"),
    KIT_SUCCESSFULLY_CLONE("kit.successfully-clone"),
    KIT_CANNOT_SAVE_EXTRA_ITEMS("kit.cannot-save-extra-items"),
    KIT_SUCCESSFULLY_UPDATED_EXTRA_ITEMS("kit.successfully-updated-extra-items"),
    KIT_BUTTON_EDIT_DAMAGE_TICKS_NAME("kit.button.edit-damage-ticks.name"),
    KIT_BUTTON_EDIT_DAMAGE_TICKS_LORE("kit.button.edit-damage-ticks.lore"),
    KIT_BUTTON_EDIT_DAMAGE_TICKS_PROCEDURE_MESSAGE("kit.button.edit-damage-ticks.procedure.message"),
    KIT_BUTTON_EDIT_DAMAGE_TICKS_PROCEDURE_SUCCESS("kit.button.edit-damage-ticks.procedure.success"),
    KIT_BUTTON_EDIT_DAMAGE_TICKS_PROCEDURE_ADDITIONAL_MESSAGE(
            "kit.button.edit-damage-ticks.procedure.additional-message"),
    KIT_BUTTON_EDIT_DESCRIPTION_NAME("kit.button.edit-description.name"),
    KIT_BUTTON_EDIT_DESCRIPTION_LORE_START("kit.button.edit-description.lore-start"),
    KIT_BUTTON_EDIT_DESCRIPTION_LORE_END("kit.button.edit-description.lore-end"),
    KIT_BUTTON_EDIT_DESCRIPTION_PROCEDURE_MESSAGE("kit.button.edit-description.procedure.message"),
    KIT_BUTTON_EDIT_DESCRIPTION_PROCEDURE_SUCCESS("kit.button.edit-description.procedure.success"),
    KIT_BUTTON_EDIT_DESCRIPTION_PROCEDURE_ADDITIONAL_MESSAGE(
            "kit.button.edit-description.procedure.additional-message"),
    KIT_BUTTON_EDIT_DISPLAY_NAME_NAME("kit.button.edit-display-name.name"),
    KIT_BUTTON_EDIT_DISPLAY_NAME_LORE("kit.button.edit-display-name.lore"),
    KIT_BUTTON_EDIT_DISPLAY_NAME_PROCEDURE_MESSAGE("kit.button.edit-display-name.procedure.message"),
    KIT_BUTTON_EDIT_DISPLAY_NAME_PROCEDURE_SUCCESS("kit.button.edit-display-name.procedure.success"),
    KIT_BUTTON_EDIT_EXTRA_ITEMS_NAME("kit.button.edit-extra-items.name"),
    KIT_BUTTON_EDIT_EXTRA_ITEMS_LORE("kit.button.edit-extra-items.lore"),
    KIT_BUTTON_EDIT_ICON_NAME("kit.button.edit-icon.name"),
    KIT_BUTTON_EDIT_ICON_LORE("kit.button.edit-icon.lore"),
    KIT_BUTTON_EDIT_ICON_PROCEDURE_AIR("kit.button.edit-icon.procedure.air"),
    KIT_BUTTON_EDIT_ICON_PROCEDURE_SUCCESS("kit.button.edit-icon.procedure.success"),
    KIT_BUTTON_EDIT_MATCH_TYPE_NAME("kit.button.edit-match-type.name"),
    KIT_BUTTON_EDIT_MATCH_TYPE_LORE_CLICK_LEFT("kit.button.edit-match-type.lore-click-left"),
    KIT_BUTTON_EDIT_MATCH_TYPE_LORE_CLICK_MIDDLE("kit.button.edit-match-type.lore-click-middle"),
    KIT_BUTTON_EDIT_MATCH_TYPE_LORE_CLICK_RIGHT("kit.button.edit-match-type.lore-click-right"),
    KIT_BUTTON_EDIT_MATCH_TYPE_LORE("kit.button.edit-match-type.lore"),
    KIT_BUTTON_EDIT_POTION_EFFECT_NAME("kit.button.edit-potion-effect.name"),
    KIT_BUTTON_EDIT_POTION_EFFECT_LORE_START("kit.button.edit-potion-effect.lore-start"),
    KIT_BUTTON_EDIT_POTION_EFFECT_LORE_END("kit.button.edit-potion-effect.lore-end"),
    KIT_BUTTON_EDIT_POTION_EFFECT_PROCEDURE_MESSAGE("kit.button.edit-potion-effect.procedure.message"),
    KIT_BUTTON_EDIT_POTION_EFFECT_PROCEDURE_ALREADY_HAVE_POTION_EFFECT(
            "kit.button.edit-potion-effect.procedure.already-have-potion-effect"),
    KIT_BUTTON_EDIT_POTION_EFFECT_PROCEDURE_SUCCESS_ADD("kit.button.edit-potion-effect.procedure.success-add"),
    KIT_BUTTON_EDIT_POTION_EFFECT_PROCEDURE_SUCCESS_REMOVE("kit.button.edit-potion-effect.procedure.success-remove"),
    KIT_BUTTON_EDIT_POTION_EFFECT_PROCEDURE_ADDITIONAL_MESSAGE(
            "kit.button.edit-potion-effect.procedure.additional-message"),
    KIT_BUTTON_EDIT_PRIORITY_NAME("kit.button.edit-priority.name"),
    KIT_BUTTON_EDIT_PRIORITY_LORE("kit.button.edit-priority.lore"),
    KIT_BUTTON_EDIT_PRIORITY_PROCEDURE_MESSAGE("kit.button.edit-priority.procedure.message"),
    KIT_BUTTON_EDIT_PRIORITY_PROCEDURE_SUCCESS("kit.button.edit-priority.procedure.success"),
    KIT_BUTTON_EDIT_PRIORITY_PROCEDURE_ADDITIONAL_MESSAGE("kit.button.edit-priority.procedure.additional-message"),
    KIT_BUTTON_PREVIEW_LORE("kit.button.preview.lore"),
    KIT_BUTTON_SAVE_NAME("kit.button.save.name"),
    KIT_BUTTON_SAVE_LORE("kit.button.save.lore"),
    KIT_BUTTON_RULES_TOGGLE_SUCCESS("kit.button.rules-toggle.success"),
    KIT_BUTTON_RULES_SET_VALUE_NAME("kit.button.rules-set-value.name"),
    KIT_BUTTON_RULES_SET_VALUE_LORE("kit.button.rules-set-value.lore"),
    KIT_BUTTON_RULES_SET_VALUE_PROCEDURE_MESSAGE("kit.button.rules-set-value.procedure.message"),
    KIT_BUTTON_RULES_SET_VALUE_PROCEDURE_SUCCESS("kit.button.rules-set-value.procedure.success"),
    KIT_BUTTON_RULES_SET_VALUE_PROCEDURE_ADDITIONAL_MESSAGE("kit.button.rules-set-value.procedure.additional-message"),
    KIT_BUTTON_SAVE_LOADOUT_NAME("kit.button.save-loadout.name"),
    KIT_BUTTON_SAVE_LOADOUT_LORE("kit.button.save-loadout.lore"),
    KIT_BUTTON_SAVE_LOADOUT_SUCCESS("kit.button.save-loadout.success"),
    KIT_BUTTON_TOGGLE_NAME("kit.button.toggle.name"),
    KIT_BUTTON_TOGGLE_LORE("kit.button.toggle.description"),
    KIT_BUTTON_TOGGLE_SUCCESS("kit.button.toggle.success"),
    KIT_BUTTON_TOGGLE_RANKED_NAME("kit.button.toggle-ranked.name"),
    KIT_BUTTON_TOGGLE_RANKED_LORE("kit.button.toggle-ranked.description"),
    KIT_BUTTON_TOGGLE_RANKED_SUCCESS("kit.button.toggle-ranked.success"),
    KIT_KIT_DETAIL_MENU_TITLE("kit.kit-detail-menu.title"),
    KIT_KIT_PREVIEW_MENU_TITLE("kit.kit-preview-menu.title"),
    KIT_KIT_MANAGEMENT_MENU_TITLE("kit.kit-management-menu.title"),
    KIT_KIT_MANAGEMENT_MENU_BUTTON_NAME("kit.kit-management-menu.button.name"),
    KIT_KIT_MANAGEMENT_MENU_BUTTON_LORE("kit.kit-management-menu.button.lore"),
    KIT_GAME_RULES_RECEIVE_KIT_LOADOUT_BOOK_RULES("kit.game-rules.receive-kit-loadout-book.rules"),
    KIT_GAME_RULES_RECEIVE_KIT_LOADOUT_BOOK_DESCRIPTION("kit.game-rules.receive-kit-loadout-book.description"),
    KIT_GAME_RULES_DEATH_ON_WATER_RULES("kit.game-rules.death-on-water.rules"),
    KIT_GAME_RULES_DEATH_ON_WATER_DESCRIPTION("kit.game-rules.death-on-water.description"),
    KIT_GAME_RULES_BOXING_RULES("kit.game-rules.boxing.rules"),
    KIT_GAME_RULES_BOXING_DESCRIPTION("kit.game-rules.boxing.description"),
    KIT_GAME_RULES_BED_RULES("kit.game-rules.bed.rules"),
    KIT_GAME_RULES_BED_DESCRIPTION("kit.game-rules.bed.description"),
    KIT_GAME_RULES_BREAK_GOAL_RULES("kit.game-rules.break-goal.rules"),
    KIT_GAME_RULES_BREAK_GOAL_DESCRIPTION("kit.game-rules.break-goal.description"),
    KIT_GAME_RULES_PORTAL_GOAL_RULES("kit.game-rules.portal-goal.rules"),
    KIT_GAME_RULES_PORTAL_GOAL_DESCRIPTION("kit.game-rules.portal-goal.description"),
    KIT_GAME_RULES_PROJECTILE_ONLY_RULES("kit.game-rules.projectile-only.rules"),
    KIT_GAME_RULES_PROJECTILE_ONLY_DESCRIPTION("kit.game-rules.projectile-only.description"),
    KIT_GAME_RULES_HYPIXELUHC_RULES("kit.game-rules.hypixelUHC.rules"),
    KIT_GAME_RULES_HYPIXELUHC_DESCRIPTION("kit.game-rules.hypixelUHC.description"),
    KIT_GAME_RULES_SPLEEF_RULES("kit.game-rules.spleef.rules"),
    KIT_GAME_RULES_SPLEEF_DESCRIPTION("kit.game-rules.spleef.description"),
    KIT_GAME_RULES_HEALTH_REGENERATION_RULES("kit.game-rules.health-regeneration.rules"),
    KIT_GAME_RULES_HEALTH_REGENERATION_DESCRIPTION("kit.game-rules.health-regeneration.description"),
    KIT_GAME_RULES_SHOW_HEALTH_RULES("kit.game-rules.show-health.rules"),
    KIT_GAME_RULES_SHOW_HEALTH_DESCRIPTION("kit.game-rules.show-health.description"),
    KIT_GAME_RULES_FOOD_LEVEL_CHANGE_RULES("kit.game-rules.food-level-change.rules"),
    KIT_GAME_RULES_FOOD_LEVEL_CHANGE_DESCRIPTION("kit.game-rules.food-level-change.description"),
    KIT_GAME_RULES_POINT_RULES("kit.game-rules.point.rules"),
    KIT_GAME_RULES_POINT_DESCRIPTION("kit.game-rules.point.description"),
    KIT_GAME_RULES_RANKED_POINT_RULES("kit.game-rules.ranked-point.rules"),
    KIT_GAME_RULES_RANKED_POINT_DESCRIPTION("kit.game-rules.ranked-point.description"),
    KIT_GAME_RULES_RESET_ARENA_WHEN_GET_POINT_RULES("kit.game-rules.reset-arena-when-get-point.rules"),
    KIT_GAME_RULES_RESET_ARENA_WHEN_GET_POINT_DESCRIPTION("kit.game-rules.reset-arena-when-get-point.description"),
    KIT_GAME_RULES_ONLY_LOSER_RESET_POSITION_WHEN_GET_POINT_RULES(
            "kit.game-rules.only-loser-reset-position-when-get-point.rules"),
    KIT_GAME_RULES_ONLY_LOSER_RESET_POSITION_WHEN_GET_POINT_DESCRIPTION(
            "kit.game-rules.only-loser-reset-position-when-get-point.description"),
    KIT_GAME_RULES_BUILD_RULES("kit.game-rules.build.rules"),
    KIT_GAME_RULES_BUILD_DESCRIPTION("kit.game-rules.build.description"),
    KIT_GAME_RULES_START_FREEZE_RULES("kit.game-rules.start-freeze.rules"),
    KIT_GAME_RULES_START_FREEZE_DESCRIPTION("kit.game-rules.start-freeze.description"),
    KIT_GAME_RULES_NO_DAMAGE_RULES("kit.game-rules.no-damage.rules"),
    KIT_GAME_RULES_NO_DAMAGE_DESCRIPTION("kit.game-rules.no-damage.description"),
    KIT_GAME_RULES_INSTANT_GAPPLE_RULES("kit.game-rules.instant-gapple.rules"),
    KIT_GAME_RULES_INSTANT_GAPPLE_DESCRIPTION("kit.game-rules.instant-gapple.description"),
    KIT_GAME_RULES_ENDER_PEARL_COOLDOWN_RULES("kit.game-rules.ender-pearl-cooldown.rules"),
    KIT_GAME_RULES_ENDER_PEARL_COOLDOWN_DESCRIPTION("kit.game-rules.ender-pearl-cooldown.description"),
    KIT_GAME_RULES_CLEAR_BLOCK_RULES("kit.game-rules.clear-block.rules"),
    KIT_GAME_RULES_CLEAR_BLOCK_DESCRIPTION("kit.game-rules.clear-block.description"),
    KIT_GAME_RULES_DROP_ITEM_WHEN_DIE_RULES("kit.game-rules.drop-item-when-die.rules"),
    KIT_GAME_RULES_DROP_ITEM_WHEN_DIE_DESCRIPTION("kit.game-rules.drop-item-when-die.description"),
    KIT_GAME_RULES_NO_FALL_DAMAGE_RULES("kit.game-rules.no-fall-damage.rules"),
    KIT_GAME_RULES_NO_FALL_DAMAGE_DESCRIPTION("kit.game-rules.no-fall-damage.description"),
    KIT_GAME_RULES_GIVE_BACK_ARROW_RULES("kit.game-rules.give-back-arrow.rules"),
    KIT_GAME_RULES_GIVE_BACK_ARROW_DESCRIPTION("kit.game-rules.give-back-arrow.description"),
    KIT_GAME_RULES_DROP_ITEMS_RULES("kit.game-rules.drop-items.rules"),
    KIT_GAME_RULES_DROP_ITEMS_DESCRIPTION("kit.game-rules.drop-items.description"),
    KIT_GAME_RULES_TEAM_PROJECTILE_RULES("kit.game-rules.team-projectile.rules"),
    KIT_GAME_RULES_TEAM_PROJECTILE_DESCRIPTION("kit.game-rules.team-projectile.description"),
    KIT_GAME_RULES_BOW_BOOSTING_RULES("kit.game-rules.bow-boosting.rules"),
    KIT_GAME_RULES_BOW_BOOSTING_DESCRIPTION("kit.game-rules.bow-boosting.description"),
    KIT_GAME_RULES_RESPAWN_TIME_RULES("kit.game-rules.respawn-time.rules"),
    KIT_GAME_RULES_RESPAWN_TIME_DESCRIPTION("kit.game-rules.respawn-time.description"),
    KIT_GAME_RULES_MAXIMUM_POINTS_RULES("kit.game-rules.maximum-points.rules"),
    KIT_GAME_RULES_MAXIMUM_POINTS_DESCRIPTION("kit.game-rules.maximum-points.description"),
    KIT_GAME_RULES_MATCH_COUNTDOWN_DURATION_RULES("kit.game-rules.match-countdown-duration.rules"),
    KIT_GAME_RULES_MATCH_COUNTDOWN_DURATION_DESCRIPTION("kit.game-rules.match-countdown-duration.description"),
    KIT_GAME_RULES_NEW_ROUND_TIME_RULES("kit.game-rules.new-round-time.rules"),
    KIT_GAME_RULES_NEW_ROUND_TIME_DESCRIPTION("kit.game-rules.new-round-time.description"),
    KIT_GAME_RULES_CLEAR_BLOCK_TIME_RULES("kit.game-rules.clear-block-time.rules"),
    KIT_GAME_RULES_CLEAR_BLOCK_TIME_DESCRIPTION("kit.game-rules.clear-block-time.description"),
    KIT_GAME_RULES_KNOCKBACK_NAME_RULES("kit.game-rules.knockback-name.rules"),
    KIT_GAME_RULES_KNOCKBACK_NAME_DESCRIPTION("kit.game-rules.knockback-name.description"),
    LEADERBOARD_RELOAD("leaderboard.reload"),
    LEADERBOARD_TOP10_DISPLAY_NAME("leaderboard.top10-display.name"),
    LEADERBOARD_TOP10_DISPLAY_LORE("leaderboard.top10-display.lore"),
    LEADERBOARD_BEST_WINSTREAK_MENU_TITLE("leaderboard.best-winstreak-menu-title"),
    LEADERBOARD_ELO_MENU_TITLE("leaderboard.elo-menu-title"),
    LEADERBOARD_WINS_MENU_TITLE("leaderboard.wins-menu-title"),
    LEADERBOARD_WINSTREAK_MENU_TITLE("leaderboard.winstreak-menu-title"),
    LEADERBOARD_KIT_STATS_MENU_TITLE("leaderboard.kit-stats-menu.title"),
    LEADERBOARD_KIT_STATS_MENU_GLOBAL_STATS_NAME("leaderboard.kit-stats-menu.global-stats.name"),
    LEADERBOARD_KIT_STATS_MENU_GLOBAL_STATS_LORE("leaderboard.kit-stats-menu.global-stats.lore"),
    LEADERBOARD_KIT_STATS_MENU_KIT_STATS_NAME("leaderboard.kit-stats-menu.kit-stats.name"),
    LEADERBOARD_KIT_STATS_MENU_KIT_STATS_LORE("leaderboard.kit-stats-menu.kit-stats.lore"),
    LEADERBOARD_ERROR_NOT_ENOUGH_SLOT("leaderboard.error-not-enough-slot"),
    LEADERBOARD_SWITCH_LEADERBOARD_BUTTON_VIEW_STATS_BUTTON_NAME(
            "leaderboard.switch-leaderboard-button.view-stats-button.name"),
    LEADERBOARD_SWITCH_LEADERBOARD_BUTTON_VIEW_STATS_BUTTON_LORE(
            "leaderboard.switch-leaderboard-button.view-stats-button.lore"),
    MATCH_SEPARATE("match.separate"),
    MATCH_START_UNRANKED("match.start-unranked"),
    MATCH_START_RANKED("match.start-ranked"),
    MATCH_JOIN_SPECTATE("match.join-spectate"),
    MATCH_LEAVE_SPECTATE("match.leave-spectate"),
    MATCH_CANNOT_DROP_WEAPON("match.cannot-drop-weapon"),
    MATCH_USE_AGAIN_GOLDEN_HEAD("match.use-again-golden-head"),
    MATCH_USE_AGAIN_ENDER_PEARL("match.use-again-ender-pearl"),
    MATCH_USE_AGAIN_FIREBALL("match.use-again-fireball"),
    MATCH_RECEIVED_KIT_LOADOUT("match.received-kit-loadout"),
    MATCH_RECEIVED_KIT_LOADOUT_BECAUSE_TIMEOUT("match.received-kit-loadout-because-timeout"),
    MATCH_AUTO_EQUIPPED_KIT("match.auto-equipped-kit"),
    MATCH_KIT_EDIT_SAVED("match.kit-edit-saved"),
    MATCH_CANNOT_BREAK_OWN_BED("match.cannot-break-own-bed"),
    MATCH_CAN_USE_ENDERPEARL("match.can-use-enderpearl"),
    MATCH_ARROW_DAMAGE("match.arrow-damage"),
    MATCH_REQUEUE_NOT_IN_MATCH("match.requeue-not-in-match"),
    MATCH_CANNOT_PREFIRE("match.cannot-prefire"),
    MATCH_BED_BREAK_TITLE("match.bed-break.title"),
    MATCH_BED_BREAK_SUBTITLE("match.bed-break.subtitle"),
    MATCH_BED_BREAK_MESSAGE("match.bed-break.message"),
    MATCH_DEATH_MESSAGE_DISCONNECT("match.death-message.disconnect"),
    MATCH_DEATH_MESSAGE_KILLED("match.death-message.killed"),
    MATCH_DEATH_MESSAGE_DEFAULT("match.death-message.default"),
    MATCH_POST_MATCH_INVENTORY_WINNER("match.post-match-inventory.winner"),
    MATCH_POST_MATCH_INVENTORY_LOSER("match.post-match-inventory.loser"),
    MATCH_POST_MATCH_INVENTORY_HOVER("match.post-match-inventory.hover"),
    MATCH_POST_MATCH_INVENTORY_MESSAGE("match.post-match-inventory.message"),
    MATCH_POST_MATCH_INVENTORY_RATING_CHANGES("match.post-match-inventory.rating-changes"),
    MATCH_FORCE_END_MESSAGE("match.force-end.message"),
    MATCH_FORCE_END_NOT_ONLINE("match.force-end.not-online"),
    MATCH_FORCE_END_PROFILE_NOT_FOUND("match.force-end.profile-not-found"),
    MATCH_FORCE_END_NOT_IN_MATCH("match.force-end.not-in-match"),
    MATCH_FORCE_END_REASON("match.force-end.reason"),
    MATCH_FORCE_END_SUCCESS("match.force-end.success"),
    MATCH_SPECTATE_WRONG_STATE("match.spectate.wrong-state"),
    MATCH_SPECTATE_HAVE_PARTY("match.spectate.have-party"),
    MATCH_SPECTATE_NOT_ONLINE("match.spectate.not-online"),
    MATCH_SPECTATE_PROFILE_NOT_FOUND("match.spectate.profile-not-found"),
    MATCH_NO_SPEED_NOT_IN_MATCH("match.no-speed.not-in-match"),
    MATCH_NO_SPEED_NOT_BOXING("match.no-speed.not-boxing"),
    MATCH_NO_SPEED_SUCCESS_REMOVED("match.no-speed.success-removed"),
    MATCH_NO_SPEED_SUCCESS_ADDED("match.no-speed.success-added"),
    MATCH_VIEW_INVENTORY_WRONG_STATE("match.view-inventory.wrong-state"),
    MATCH_VIEW_INVENTORY_USAGE("match.view-inventory.usage"),
    MATCH_VIEW_INVENTORY_INVALID_UUID("match.view-inventory.invalid-uuid"),
    MATCH_VIEW_INVENTORY_CANNOT_FIND("match.view-inventory.cannot-find"),
    MATCH_SPECTATE_MENU_TITLE("match.spectate-menu.title"),
    MATCH_SPECTATE_MENU_BUTTON_NAME_SOLO("match.spectate-menu.button.name-solo"),
    MATCH_SPECTATE_MENU_BUTTON_NAME_SPLIT("match.spectate-menu.button.name-split"),
    MATCH_SPECTATE_MENU_BUTTON_NAME_FFA("match.spectate-menu.button.name-ffa"),
    MATCH_SPECTATE_MENU_BUTTON_NAME_SUMO_EVENT("match.spectate-menu.button.name-sumo-event"),
    MATCH_SPECTATE_MENU_BUTTON_NAME_ERROR("match.spectate-menu.button.name-error"),
    MATCH_SPECTATE_MENU_BUTTON_LORE("match.spectate-menu.button.lore"),
    MATCH_SPECTATE_MENU_ERROR_BUTTON_NAME("match.spectate-menu.error-button.name"),
    MATCH_SPECTATE_MENU_ERROR_BUTTON_LORE("match.spectate-menu.error-button.lore"),
    MATCH_SPECTATE_TELEPORT_MENU_TITLE("match.spectate-teleport-menu.title"),
    MATCH_SPECTATE_TELEPORT_MENU_BUTTON_NAME("match.spectate-teleport-menu.button.name"),
    MATCH_SPECTATE_TELEPORT_MENU_BUTTON_LORE("match.spectate-teleport-menu.button.lore"),
    MATCH_SPECTATE_TELEPORT_MENU_WRONG_STATE("match.spectate-teleport-menu.wrong-state"),
    MATCH_SPECTATE_TELEPORT_MENU_ALREADY_DIED("match.spectate-teleport-menu.already-died"),
    MATCH_SPECTATE_TELEPORT_MENU_NOT_ONLINE("match.spectate-teleport-menu.not-online"),
    MATCH_SPECTATE_TELEPORT_MENU_TARGET_WRONG_STATE("match.spectate-teleport-menu.target-wrong-state"),
    MATCH_SPECTATE_TELEPORT_MENU_NOT_SAME_MATCH("match.spectate-teleport-menu.not-same-match"),
    MATCH_VIEW_INVENTORY_MENU_TITLE("match.view-inventory-menu.title"),
    MATCH_VIEW_INVENTORY_MENU_OPEN_MESSAGE("match.view-inventory-menu.open-message"),
    MATCH_VIEW_INVENTORY_MENU_SWITCH_INVENTORY_BUTTON_NAME("match.view-inventory-menu.switch-inventory-button.name"),
    MATCH_VIEW_INVENTORY_MENU_PLAYER_INFORMATION_BUTTON_NAME(
            "match.view-inventory-menu.player-information-button.name"),
    MATCH_VIEW_INVENTORY_MENU_PLAYER_INFORMATION_BUTTON_LORE(
            "match.view-inventory-menu.player-information-button.lore"),
    MATCH_VIEW_INVENTORY_MENU_EFFECTS_BUTTON_NAME("match.view-inventory-menu.effects-button.name"),
    MATCH_VIEW_INVENTORY_MENU_EFFECTS_BUTTON_NO_EFFECTS_LORE(
            "match.view-inventory-menu.effects-button.no-effects-lore"),
    MATCH_VIEW_INVENTORY_MENU_EFFECTS_BUTTON_EFFECTS_FORMAT("match.view-inventory-menu.effects-button.effects-format"),
    MATCH_VIEW_INVENTORY_MENU_HEALING_BUTTON_NAME("match.view-inventory-menu.healing-button.name"),
    MATCH_VIEW_INVENTORY_MENU_HEALING_BUTTON_NO_HEALING_LORE(
            "match.view-inventory-menu.healing-button.no-healing-lore"),
    MATCH_VIEW_INVENTORY_MENU_HEALING_BUTTON_HEALING_LORE("match.view-inventory-menu.healing-button.healing-lore"),
    MATCH_VIEW_INVENTORY_MENU_STATISTICS_BUTTON_NAME("match.view-inventory-menu.statistics-button.name"),
    MATCH_VIEW_INVENTORY_MENU_STATISTICS_BUTTON_LORE("match.view-inventory-menu.statistics-button.lore"),
    MATCH_HEALING_METHOD_POTION("match.healing-method.potion"),
    MATCH_HEALING_METHOD_SOUP("match.healing-method.soup"),
    MATCH_HEALING_METHOD_GOLDEN_APPLE("match.healing-method.golden-apple"),
    MATCH_HEALING_METHOD_GOD_APPLE("match.healing-method.god-apple"),
    MATCH_NEW_ROUND_START_COUNTDOWN("match.new-round-start.countdown"),
    MATCH_NEW_ROUND_START_TITLE("match.new-round-start.title"),
    MATCH_NEW_ROUND_START_MESSAGE("match.new-round-start.message"),
    MATCH_NEW_ROUND_START_SCORED_TITLE("match.new-round-start.scored-title"),
    MATCH_NEW_ROUND_START_SCORED_SUBTITLE("match.new-round-start.scored-subtitle"),
    MATCH_NEW_ROUND_START_SCORE("match.new-round-start.score"),
    MATCH_RESPAWN_TITLE("match.respawn.title"),
    MATCH_RESPAWN_SUBTITLE("match.respawn.subtitle"),
    MATCH_RESPAWN_COUNTDOWN("match.respawn.countdown"),
    MATCH_RESPAWN_MESSAGE("match.respawn.message"),
    MATCH_TEAM_COLOR_RED_NAME("match.team-color.red.name"),
    MATCH_TEAM_COLOR_RED_LOGO("match.team-color.red.logo"),
    MATCH_TEAM_COLOR_BLUE_NAME("match.team-color.blue.name"),
    MATCH_TEAM_COLOR_BLUE_LOGO("match.team-color.blue.logo"),
    MATCH_TEAM_COLOR_GREEN_NAME("match.team-color.green.name"),
    MATCH_TEAM_COLOR_GREEN_LOGO("match.team-color.green.logo"),
    MATCH_TEAM_COLOR_YELLOW_NAME("match.team-color.yellow.name"),
    MATCH_TEAM_COLOR_YELLOW_LOGO("match.team-color.yellow.logo"),
    MATCH_TEAM_COLOR_AQUA_NAME("match.team-color.aqua.name"),
    MATCH_TEAM_COLOR_AQUA_LOGO("match.team-color.aqua.logo"),
    MATCH_TEAM_COLOR_WHITE_NAME("match.team-color.white.name"),
    MATCH_TEAM_COLOR_WHITE_LOGO("match.team-color.white.logo"),
    MATCH_TEAM_COLOR_PINK_NAME("match.team-color.pink.name"),
    MATCH_TEAM_COLOR_PINK_LOGO("match.team-color.pink.logo"),
    MATCH_TEAM_COLOR_GRAY_NAME("match.team-color.gray.name"),
    MATCH_TEAM_COLOR_GRAY_LOGO("match.team-color.gray.logo"),
    MATCH_MATCH_TYPE_SOLO("match.match-type.solo"),
    MATCH_MATCH_TYPE_FFA("match.match-type.ffa"),
    MATCH_MATCH_TYPE_SPLIT("match.match-type.split"),
    MATCH_MATCH_TYPE_SUMO_EVENT("match.match-type.sumo-event"),
    MATCH_END_TITLE_WIN_TITLE("match.end-title.win.title"),
    MATCH_END_TITLE_WIN_SUBTITLE("match.end-title.win.subtitle"),
    MATCH_END_TITLE_LOSE_TITLE("match.end-title.lose.title"),
    MATCH_END_TITLE_LOSE_SUBTITLE("match.end-title.lose.subtitle"),
    PARTY_CREATED("party.created"),
    PARTY_SUCCESSFULLY_SET_MAX_SIZE("party.successfully-set-max-size"),
    PARTY_SUCCESSFULLY_SET_CHAT("party.successfully-set-chat"),
    PARTY_ANNOUNCE_MESSAGE("party.announce.message"),
    PARTY_ANNOUNCE_CLICKABLE("party.announce.clickable"),
    PARTY_ANNOUNCE_HOVER("party.announce.hover"),
    PARTY_PRIVACY_MESSAGE("party.privacy.message"),
    PARTY_PRIVACY_OPEN("party.privacy.open"),
    PARTY_PRIVACY_CLOSED("party.privacy.closed"),
    PARTY_BROADCAST_FORMAT("party.broadcast-format"),
    PARTY_PARTY_CHAT_FORMAT("party.party-chat-format"),
    PARTY_OWN_PROFILE_NOT_FOUND("party.own-profile-not-found"),
    PARTY_CANNOT_INTERACT_SELF("party.cannot-interact-self"),
    PARTY_JOIN_MESSAGE_NORMAL("party.join-message.normal"),
    PARTY_JOIN_MESSAGE_FORCE("party.join-message.force"),
    PARTY_LEAVE_MESSAGE_NORMAL("party.leave-message.normal"),
    PARTY_LEAVE_MESSAGE_FORCE("party.leave-message.force"),
    PARTY_DISBAND("party.disband"),
    PARTY_INVITE_TEAM_MESSAGE("party.invite.team-message"),
    PARTY_INVITE_INVITE_MESSAGE("party.invite.invite-message"),
    PARTY_INVITE_CLICKABLE("party.invite.clickable"),
    PARTY_INVITE_HOVER("party.invite.hover"),
    PARTY_INFORMATION("party.information"),
    PARTY_CHAT_OFF("party.chat-off"),
    PARTY_TOGGLE_PARTY_CHAT("party.toggle-party-chat"),
    PARTY_DISBAND_LEADER_LEFT("party.disband-leader-left"),
    PARTY_QUIT("party.quit"),
    PARTY_ONLY_LEADER("party.only-leader"),
    PARTY_IN_A_PARTY("party.in-a-party"),
    PARTY_NOT_IN_A_PARTY("party.not-in-a-party"),
    PARTY_WRONG_STATE("party.wrong-state"),
    PARTY_PARTY_NOT_OPEN("party.party-not-open"),
    PARTY_ANNOUNCE_COOLDOWN("party.announce-cooldown"),
    PARTY_PLAYER_NOT_FOUND("party.player-not-found"),
    PARTY_PARTY_NOT_FOUND("party.party-not-found"),
    PARTY_FULL("party.full"),
    PARTY_ALREADY_IN_PARTY("party.already-in-party"),
    PARTY_TARGET_ALREADY_IN_PARTY("party.target-already-in-party"),
    PARTY_NOT_INVITED("party.not-invited"),
    PARTY_DISABLED_PARTY_INVITE("party.disabled-party-invite"),
    PARTY_NOT_INTEGER("party.not-integer"),
    PARTY_SIZE_BELOW_1("party.size-below-1"),
    PARTY_ERROR_LEADER_NOT_FOUND("party.error-leader-not-found"),
    PARTY_MAX_SIZE("party.max-size"),
    PARTY_ALREADY_INVITE("party.already-invite"),
    PARTY_INVALID_MATCH_TYPE("party.invalid-match-type"),
    PARTY_INVALID_KIT("party.invalid-kit"),
    PARTY_INVALID_ARENA("party.invalid-arena"),
    PARTY_HELP_MESSAGE("party.help-message"),
    PARTY_CHOOSE_ARENA_MENU_TITLE("party.choose-arena-menu.title"),
    PARTY_CHOOSE_ARENA_MENU_BUTTON_NAME("party.choose-arena-menu.button.name"),
    PARTY_CHOOSE_ARENA_MENU_BUTTON_RANDOM("party.choose-arena-menu.button.random"),
    PARTY_CHOOSE_ARENA_MENU_BUTTON_LORE("party.choose-arena-menu.button.lore"),
    PARTY_CHOOSE_KIT_MENU_TITLE("party.choose-kit-menu.title"),
    PARTY_CHOOSE_KIT_MENU_BUTTON_NAME("party.choose-kit-menu.button.name"),
    PARTY_CHOOSE_KIT_MENU_BUTTON_LORE("party.choose-kit-menu.button.lore"),
    PARTY_CHOOSE_MATCH_TYPE_MENU_TITLE("party.choose-match-type-menu.title"),
    PARTY_CHOOSE_MATCH_TYPE_MENU_SPLIT_BUTTON_NAME("party.choose-match-type-menu.split-button.name"),
    PARTY_CHOOSE_MATCH_TYPE_MENU_SPLIT_BUTTON_LORE("party.choose-match-type-menu.split-button.lore"),
    PARTY_CHOOSE_MATCH_TYPE_MENU_FFA_BUTTON_NAME("party.choose-match-type-menu.ffa-button.name"),
    PARTY_CHOOSE_MATCH_TYPE_MENU_FFA_BUTTON_LORE("party.choose-match-type-menu.ffa-button.lore"),
    PARTY_OTHER_PARTIES_MENU_TITLE("party.other-parties-menu.title"),
    PARTY_OTHER_PARTIES_MENU_BUTTON_NAME("party.other-parties-menu.button.name"),
    PARTY_OTHER_PARTIES_MENU_BUTTON_LORE_START("party.other-parties-menu.button.lore-start"),
    PARTY_OTHER_PARTIES_MENU_BUTTON_LORE_END("party.other-parties-menu.button.lore-end"),
    PARTY_START_PARTY_FIGHT_ONLY_LEADER("party.start-party-fight.only-leader"),
    PARTY_START_PARTY_FIGHT_NEED_MORE_THAN_2("party.start-party-fight.need-more-than-2"),
    PARTY_START_PARTY_FIGHT_ARENA_DISABLED("party.start-party-fight.arena-disabled"),
    PARTY_START_PARTY_FIGHT_CANNOT_FIND_ARENA("party.start-party-fight.cannot-find-arena"),
    PARTY_START_PARTY_FIGHT_PLAYERS_NOT_IN_LOBBY("party.start-party-fight.players-not-in-lobby"),
    PROFILE_CANNOT_FIND_PLAYER("profile.cannot-find-player"),
    PROFILE_ERROR_CANNOT_LOAD_PLAYER("profile.error-cannot-load-player"),
    PROFILE_KIT_RIGHT_CLICK_TO_RECEIVE("profile.kit-right-click-to-receive"),
    PROFILE_SETTINGS_MENU_TITLE("profile.settings-menu.title"),
    PROFILE_SETTINGS_MENU_CLICK_TO_SWITCH_SETTINGS("profile.settings-menu.click-to-switch-settings"),
    PROFILE_SETTINGS_MENU_NO_PERMISSION("profile.settings-menu.no-permission"),
    PROFILE_PROCEDURE_ENTER_CANCEL_TO_CANCEL("profile.procedure.enter-cancel-to-cancel"),
    PROFILE_PROCEDURE_SUCCESS_CANCEL("profile.procedure.success-cancel"),
    PROFILE_SETTINGS_SUCCESSFULLY_CHANGED("profile.settings.successfully-changed"),
    PROFILE_SETTINGS_TIME_CHANGER_NAME("profile.settings.time-changer.name"),
    PROFILE_SETTINGS_TIME_CHANGER_LORE("profile.settings.time-changer.lore"),
    PROFILE_SETTINGS_TIME_CHANGER_NORMAL_SERVER_TIME("profile.settings.time-changer.normal-server-time"),
    PROFILE_SETTINGS_TIME_CHANGER_DAY("profile.settings.time-changer.day"),
    PROFILE_SETTINGS_TIME_CHANGER_AFTERNOON("profile.settings.time-changer.afternoon"),
    PROFILE_SETTINGS_TIME_CHANGER_NIGHT("profile.settings.time-changer.night"),
    PROFILE_SETTINGS_TIME_CHANGER_MIDNIGHT("profile.settings.time-changer.midnight"),
    PROFILE_SETTINGS_ARENA_SELECTION_NAME("profile.settings.arena-selection.name"),
    PROFILE_SETTINGS_ARENA_SELECTION_LORE("profile.settings.arena-selection.lore"),
    PROFILE_SETTINGS_MATCH_SCOREBOARD_NAME("profile.settings.match-scoreboard.name"),
    PROFILE_SETTINGS_MATCH_SCOREBOARD_LORE("profile.settings.match-scoreboard.lore"),
    PROFILE_SETTINGS_ALLOW_DUEL_REQUEST_NAME("profile.settings.allow-duel-request.name"),
    PROFILE_SETTINGS_ALLOW_DUEL_REQUEST_LORE("profile.settings.allow-duel-request.lore"),
    PROFILE_SETTINGS_ALLOW_PARTY_INVITE_NAME("profile.settings.allow-party-invite.name"),
    PROFILE_SETTINGS_ALLOW_PARTY_INVITE_LORE("profile.settings.allow-party-invite.lore"),
    PROFILE_SETTINGS_SPECTATOR_VISIBILITY_NAME("profile.settings.spectator-visibility.name"),
    PROFILE_SETTINGS_SPECTATOR_VISIBILITY_LORE("profile.settings.spectator-visibility.lore"),
    PROFILE_SETTINGS_SPECTATOR_JOIN_LEAVE_MESSAGE_NAME("profile.settings.spectator-join-leave-message.name"),
    PROFILE_SETTINGS_SPECTATOR_JOIN_LEAVE_MESSAGE_LORE("profile.settings.spectator-join-leave-message.lore"),
    PROFILE_SETTINGS_EVENT_ANNOUNCEMENT_NAME("profile.settings.event-announcement.name"),
    PROFILE_SETTINGS_EVENT_ANNOUNCEMENT_LORE("profile.settings.event-announcement.lore"),
    PROFILE_SETTINGS_PING_RANGE_NAME("profile.settings.ping-range.name"),
    PROFILE_SETTINGS_PING_RANGE_LORE("profile.settings.ping-range.lore"),
    PROFILE_SETTINGS_PING_RANGE_UNLIMITED("profile.settings.ping-range.unlimited"),
    QUEUE_USAGE("queue.usage"),
    QUEUE_CANNOT_QUIT_QUEUE("queue.cannot-quit-queue"),
    QUEUE_CANNOT_QUEUE("queue.cannot-queue"),
    QUEUE_TYPE_UNRANKED("queue.type.unranked"),
    QUEUE_TYPE_RANKED("queue.type.ranked"),
    QUEUE_MENU_TITLE("queue.menu.title"),
    QUEUE_MENU_BUTTON_LORE("queue.menu.button.lore"),
    QUEUE_ERROR_FOUND_QUEUE_PROFILE("queue.error-found-queue-profile"),
    QUEUE_ERROR_NOT_FOUND_QUEUE_PROFILE("queue.error-not-found-queue-profile"),
    QUEUE_WRONG_STATE("queue.wrong-state"),
    QUEUE_ERROR_KIT_DATA_NOT_FOUND("queue.error-kit-data-not-found"),
    QUEUE_ERROR_NOT_ENOUGH_WINS("queue.error-not-enough-wins"),
    QUEUE_SUCCESS_JOIN("queue.success-join"),
    QUEUE_SUCCESS_QUIT("queue.success-quit"),
    BUTTON_BACK_NAME("button.back.name"),
    BUTTON_BACK_LORE("button.back.lore"),
    BUTTON_CONFIRM_NAME_CONFIRM("button.confirm.name-confirm"),
    BUTTON_CONFIRM_NAME_CANCEL("button.confirm.name-cancel"),
    BUTTON_TOGGLE_NAME("button.toggle.name"),
    BUTTON_JUMP_TO_PAGE_NAME("button.jump-to-page.name"),
    BUTTON_JUMP_TO_PAGE_CURRENT_PAGE_LORE("button.jump-to-page.current-page-lore"),
    BUTTON_PAGE_NEXT_PAGE_AVAILABLE_NAME("button.page.next-page-available.name"),
    BUTTON_PAGE_NEXT_PAGE_AVAILABLE_LORE("button.page.next-page-available.lore"),
    BUTTON_PAGE_NEXT_PAGE_CURRENT_NAME("button.page.next-page-current.name"),
    BUTTON_PAGE_NEXT_PAGE_CURRENT_LORE("button.page.next-page-current.lore"),
    BUTTON_PAGE_PREVIOUS_PAGE_AVAILABLE_NAME("button.page.previous-page-available.name"),
    BUTTON_PAGE_PREVIOUS_PAGE_AVAILABLE_LORE("button.page.previous-page-available.lore"),
    BUTTON_PAGE_PREVIOUS_PAGE_CURRENT_NAME("button.page.previous-page-current.name"),
    BUTTON_PAGE_PREVIOUS_PAGE_CURRENT_LORE("button.page.previous-page-current.lore"),
    BUTTON_PAGE_FILTER_NAME("button.page-filter.name"),
    BUTTON_PAGE_FILTER_LORE("button.page-filter.lore"),
    BUTTON_PAGE_FILTER_NO_FILTERS("button.page-filter.no-filters"),
    MENU_VIEW_ALL_PAGES_TITLE("menu.view-all-pages.title"),
    TABLIST_HEADER("tablist.header"),
    TABLIST_FOOTER("tablist.footer"),
    ;

    @Getter
    private final String path;

    @Override
    public String toString() {
        return toString("");
    }

    public String toString(Object... replacements) {
        return toString(null, replacements);
    }

    public String toString(Player player, Object... replacements) {
        String str = Eden.INSTANCE.getLanguageFile().getString(path);
        if (str.equalsIgnoreCase("null")) {
            return null; // Fix for #437 - If return a "null" string, it will send an empty message
        }
        if (Util.isNull(str)) {
            return path;
        }
        str = translate(str, player);
        for (int i = 0; i < replacements.length; i++) {
            String replacement = convert(replacements[i]);
            str = str.replace("{" + i + "}", replacement);
        }
        return CC.translate(str);
    }

    public List<String> toStringList(Object... replacements) {
        return toStringList(null, replacements);
    }

    public List<String> toStringList(Player player, Object... replacements) {
        if (Util.isNull(Eden.INSTANCE.getLanguageFile().getString(path))) {
            return Collections.singletonList(path);
        }
        List<String> strings = new ArrayList<>();

        for (String str : Eden.INSTANCE.getLanguageFile().getStringList(path)) {
            str = translate(str, player);
            if (str == null) {
                continue;
            }
            for (int i = 0; i < replacements.length; i++) {
                String replacement = convert(replacements[i]);
                str = str.replace("{" + i + "}", replacement);
            }

            List<String> toBeAdded = Arrays.asList(str.split(EdenPlaceholder.NEW_LINE, -1));
            strings.addAll(toBeAdded);
        }

        return CC.translate(strings);
    }

    public void sendMessage(Player player, Object... replacements) {
        String msg = toString(player, replacements);
        if (msg == null) {
            return;
        }
        Common.sendMessage(player, msg);
    }

    public void sendListOfMessage(Player player, Object... replacements) {
        Common.sendMessage(player, toStringList(player, replacements));
    }

    private String convert(Object object) {
        if (object instanceof Integer) {
            return object + "";
        } else if (object instanceof Double) {
            return object + "";
        } else if (object instanceof Long) {
            return object + "";
        } else if (object instanceof Short) {
            return object + "";
        } else if (object instanceof ChatColor) {
            return object.toString();
        } else {
            return (String) object;
        }
    }

    public static String translate(String string, Player player) {
        String str = string;
        if (player != null) {
            str = Eden.INSTANCE.getPlaceholder().translate(player, str);
            if (str != null && Checker.isPluginEnabled("PlaceholderAPI")) {
                str = Eden.INSTANCE.getHookManager().getPlaceholderAPIHook().setPlaceholders(player, str);
            }
        }
        return str;
    }
}


Filename: .\main\java\rip\diamond\practice\config\MenusConfig.java
package rip.diamond.practice.config;

import lombok.Getter;
import rip.diamond.practice.Eden;
import rip.diamond.practice.util.BasicConfigFile;

@Getter
public class MenusConfig {

    private final BasicConfigFile configFile;

    public MenusConfig(Eden plugin) {
        this.configFile = new BasicConfigFile(plugin, "menus.yml");
    }

    public void reload() {
        this.configFile.load();
    }

    public BasicConfigFile getConfig() {
        return configFile;
    }

}


Filename: .\main\java\rip\diamond\practice\database\DatabaseHandler.java
package rip.diamond.practice.database;

import org.bson.Document;
import rip.diamond.practice.profile.PlayerProfile;

import java.util.List;
import java.util.UUID;
import java.util.function.Consumer;

public interface DatabaseHandler {
    void init();

    void shutdown();

    // Load a profile by UUID
    void loadProfile(UUID uuid, Consumer<Document> callback);

    // Find a profile by Name (for offline lookups/stats)
    void findProfileByName(String name, Consumer<Document> callback);

    // Save a profile
    void saveProfile(PlayerProfile profile);

    // Get all documents (For leaderboards/resets) - Heavy operation
    List<Document> getAllProfiles();

    // Save raw document (For migration)
    void saveDocumentRaw(Document document);
}


Filename: .\main\java\rip\diamond\practice\database\DatabaseManager.java
package rip.diamond.practice.database;

import lombok.Getter;
import rip.diamond.practice.Eden;
import rip.diamond.practice.config.Config;
import rip.diamond.practice.database.impl.FlatFileHandler;
import rip.diamond.practice.database.impl.MongoHandler;
import rip.diamond.practice.util.Common;

@Getter
public class DatabaseManager {

    private final Eden plugin;
    private DatabaseHandler handler;

    public DatabaseManager(Eden plugin) {
        this.plugin = plugin;
        this.init();
    }

    public void init() {
        String type = Config.STORAGE_TYPE.toString();

        if (type.equalsIgnoreCase("FLATFILE")) {
            this.handler = new FlatFileHandler();
            Common.log("&a[Database] Selected Storage: FlatFile (JSON)");
        } else {
            // Default to Mongo if not FlatFile, or if Mongo is enabled in old config style
            this.handler = new MongoHandler();
            Common.log("&a[Database] Selected Storage: MongoDB");
        }

        try {
            this.handler.init();
        } catch (Exception e) {
            Common.log("&c[Database] Failed to initialize database!");
            e.printStackTrace();
        }
    }

    public void shutdown() {
        if (this.handler != null) {
            this.handler.shutdown();
        }
    }
}


Filename: .\main\java\rip\diamond\practice\database\impl\FlatFileHandler.java
package rip.diamond.practice.database.impl;

import com.google.common.collect.Lists;
import org.bson.Document;
import org.bukkit.Bukkit;
import rip.diamond.practice.Eden;
import rip.diamond.practice.database.DatabaseHandler;
import rip.diamond.practice.profile.PlayerProfile;
import rip.diamond.practice.util.Common;
import rip.diamond.practice.util.Tasks;

import java.io.*;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Consumer;
import java.util.stream.Collectors;

public class FlatFileHandler implements DatabaseHandler {

    private final File folder;
    // Cache name to UUID mappings to make offline lookups fast
    private final Map<String, UUID> nameIndex = new ConcurrentHashMap<>();

    public FlatFileHandler() {
        this.folder = new File(Eden.INSTANCE.getDataFolder(), "data");
    }

    @Override
    public void init() {
        if (!folder.exists()) {
            folder.mkdirs();
        }

        // Build name index asynchronously on startup
        Tasks.runAsync(() -> {
            long start = System.currentTimeMillis();
            File[] files = folder.listFiles((dir, name) -> name.endsWith(".json"));
            if (files != null) {
                for (File file : files) {
                    try {
                        // We assume file name is UUID
                        String uuidStr = file.getName().replace(".json", "");
                        UUID uuid = UUID.fromString(uuidStr);

                        // We have to peek inside the file to get the name, or rely on file structure
                        // For performance, let's just read it.
                        Document doc = readDocument(file);
                        if (doc != null && doc.containsKey("lowerCaseUsername")) {
                            nameIndex.put(doc.getString("lowerCaseUsername"), uuid);
                        }
                    } catch (Exception ignored) {
                    }
                }
            }
            Common.log("FlatFile Index built in " + (System.currentTimeMillis() - start) + "ms");
        });
    }

    @Override
    public void shutdown() {
        // Nothing to close for flat files
    }

    @Override
    public void loadProfile(UUID uuid, Consumer<Document> callback) {
        Tasks.runAsync(() -> {
            File file = new File(folder, uuid.toString() + ".json");
            if (!file.exists()) {
                callback.accept(null);
                return;
            }
            callback.accept(readDocument(file));
        });
    }

    @Override
    public void findProfileByName(String name, Consumer<Document> callback) {
        Tasks.runAsync(() -> {
            UUID uuid = nameIndex.get(name.toLowerCase());
            if (uuid == null) {
                callback.accept(null);
                return;
            }
            File file = new File(folder, uuid.toString() + ".json");
            if (!file.exists()) {
                callback.accept(null);
                return;
            }
            callback.accept(readDocument(file));
        });
    }

    @Override
    public void saveProfile(PlayerProfile profile) {
        // We perform serialization on the main thread to ensure data consistency,
        // but write IO on async thread.
        Document document = profile.toBson();
        String json = document.toJson();

        // Update index
        nameIndex.put(profile.getUsername().toLowerCase(), profile.getUniqueId());

        Tasks.runAsync(() -> {
            File file = new File(folder, profile.getUniqueId().toString() + ".json");
            try (BufferedWriter writer = Files.newBufferedWriter(file.toPath(), StandardCharsets.UTF_8)) {
                writer.write(json);
            } catch (IOException e) {
                e.printStackTrace();
            }
        });
    }

    @Override
    public List<Document> getAllProfiles() {
        File[] files = folder.listFiles((dir, name) -> name.endsWith(".json"));
        if (files == null)
            return new ArrayList<>();

        // Parallel stream for faster reading of many files
        return Arrays.stream(files)
                .parallel()
                .map(this::readDocument)
                .filter(Objects::nonNull)
                .collect(Collectors.toList());
    }

    private Document readDocument(File file) {
        try {
            String content = new String(Files.readAllBytes(file.toPath()), StandardCharsets.UTF_8);
            return Document.parse(content);
        } catch (IOException e) {
            e.printStackTrace();
            return null;
        }
    }

    public void saveDocumentRaw(Document document) {
        String uuid = document.getString("uuid");
        String json = document.toJson();

        // Update index if username exists
        if (document.containsKey("lowerCaseUsername")) {
            nameIndex.put(document.getString("lowerCaseUsername"), UUID.fromString(uuid));
        }

        File file = new File(folder, uuid + ".json");
        try (BufferedWriter writer = Files.newBufferedWriter(file.toPath(), StandardCharsets.UTF_8)) {
            writer.write(json);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}


Filename: .\main\java\rip\diamond\practice\database\impl\MongoHandler.java
package rip.diamond.practice.database.impl;

import com.mongodb.client.MongoClient;
import com.mongodb.client.MongoClients;
import com.mongodb.client.MongoCollection;
import com.mongodb.client.MongoDatabase;
import com.mongodb.client.model.Filters;
import com.mongodb.client.model.ReplaceOptions;
import lombok.Getter;
import org.bson.Document;
import rip.diamond.practice.Eden;
import rip.diamond.practice.config.Config;
import rip.diamond.practice.database.DatabaseHandler;
import rip.diamond.practice.profile.PlayerProfile;
import rip.diamond.practice.util.Tasks;

import java.util.ArrayList;
import java.util.List;
import java.util.UUID;
import java.util.function.Consumer;

@Getter
public class MongoHandler implements DatabaseHandler {

    private MongoClient client;
    private MongoDatabase database;
    private MongoCollection<Document> profiles;

    @Override
    public void init() {
        if (Config.MONGO_URI_MODE.toBoolean()) {
            this.client = MongoClients.create(Config.MONGO_URI_CONNECTION_STRING.toString());
        } else {
            String uri = "mongodb://" + Config.MONGO_NORMAL_HOST.toString() + ":"
                    + Config.MONGO_NORMAL_PORT.toInteger();
            if (Config.MONGO_NORMAL_AUTH_ENABLED.toBoolean()) {
                String username = Config.MONGO_NORMAL_AUTH_USERNAME.toString();
                String password = Config.MONGO_NORMAL_AUTH_PASSWORD.toString()
                        .replaceAll("%(?![0-9a-fA-F]{2})", "%25")
                        .replaceAll("\\+", "%2B");
                uri = "mongodb://" + username + ":" + password + "@" + Config.MONGO_NORMAL_HOST.toString() + ":"
                        + Config.MONGO_NORMAL_PORT.toInteger();
            }
            this.client = MongoClients.create(uri);
        }
        this.database = client.getDatabase(Config.MONGO_URI_DATABASE.toString());
        this.profiles = this.database.getCollection("profiles");
    }

    @Override
    public void shutdown() {
        if (this.client != null) {
            this.client.close();
        }
    }

    @Override
    public void loadProfile(UUID uuid, Consumer<Document> callback) {
        Tasks.runAsync(() -> {
            Document document = profiles.find(Filters.eq("uuid", uuid.toString())).first();
            callback.accept(document);
        });
    }

    @Override
    public void findProfileByName(String name, Consumer<Document> callback) {
        Tasks.runAsync(() -> {
            Document document = profiles.find(Filters.eq("lowerCaseUsername", name.toLowerCase())).first();
            callback.accept(document);
        });
    }

    @Override
    public void saveProfile(PlayerProfile profile) {
        Tasks.runAsync(() -> {
            profiles.replaceOne(Filters.eq("uuid", profile.getUniqueId().toString()), profile.toBson(),
                    new ReplaceOptions().upsert(true));
        });
    }

    @Override
    public List<Document> getAllProfiles() {
        return profiles.find().into(new ArrayList<>());
    }

    public void saveDocumentRaw(Document document) {
        String uuid = document.getString("uuid");
        profiles.replaceOne(Filters.eq("uuid", uuid), document, new ReplaceOptions().upsert(true));
    }
}


Filename: .\main\java\rip\diamond\practice\debug\TestCommand.java
package rip.diamond.practice.debug;

import net.minecraft.server.v1_8_R3.*;
import org.bukkit.Bukkit;
import org.bukkit.Color;
import org.bukkit.FireworkEffect;
import org.bukkit.Material;
import org.bukkit.craftbukkit.v1_8_R3.CraftWorld;
import org.bukkit.craftbukkit.v1_8_R3.entity.CraftPlayer;
import org.bukkit.craftbukkit.v1_8_R3.inventory.CraftItemStack;
import org.bukkit.entity.Player;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.meta.FireworkMeta;
import org.bukkit.scheduler.BukkitRunnable;
import rip.diamond.practice.Eden;
import rip.diamond.practice.events.EdenEvent;
import rip.diamond.practice.profile.PlayerProfile;
import rip.diamond.practice.util.Common;
import rip.diamond.practice.util.command.Command;
import rip.diamond.practice.util.command.CommandArgs;
import rip.diamond.practice.util.command.argument.CommandArguments;

public class TestCommand extends Command {

    @CommandArgs(name = "test", permission = "eden.command.test", async = false)
    public void execute(CommandArguments command) {
        Player player = command.getPlayer();
        PlayerProfile profile = PlayerProfile.get(player);
        String[] args = command.getArgs();

        if (args[0].equalsIgnoreCase("1")) {
            Common.sendMessage(player, profile.getMatch().getArenaDetail().isUsing() + "");
            return;
        } else if (args[0].equalsIgnoreCase("2")) {
            Bukkit.getPlayer("GoodestEnglish").performCommand("party create");
            Bukkit.getPlayer("Fauzh").performCommand("party join GoodestEnglish");
            Bukkit.getPlayer("DragonL").performCommand("party join GoodestEnglish");
            return;
        }


    }
}


Filename: .\main\java\rip\diamond\practice\debug\TestListener.java
package rip.diamond.practice.debug;

import org.bukkit.Material;
import org.bukkit.World;
import org.bukkit.entity.EnderPearl;
import org.bukkit.entity.Player;
import org.bukkit.entity.Projectile;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.Listener;
import org.bukkit.event.entity.ProjectileLaunchEvent;
import org.bukkit.event.player.PlayerChangedWorldEvent;
import org.bukkit.event.player.PlayerInteractEvent;
import org.bukkit.inventory.ItemStack;
import rip.diamond.practice.util.CC;
import rip.diamond.practice.util.Common;
import rip.diamond.practice.util.command.CommandManager;

public class TestListener implements Listener {

    @EventHandler(priority = EventPriority.MONITOR)
    public void onLaunch(ProjectileLaunchEvent event) {
        Projectile projectile = event.getEntity();
        if (projectile instanceof EnderPearl) {
            Common.broadcastMessage(CC.BLUE + "ProjectileLaunchEvent: " + event.isCancelled());
        }
    }

    @EventHandler(priority = EventPriority.MONITOR)
    public void onInteract(PlayerInteractEvent event) {
        ItemStack itemStack = event.getItem();
        if (itemStack != null && itemStack.getType() == Material.ENDER_PEARL) {
            Common.broadcastMessage(CC.BLUE + "PlayerInteractEvent: " + event.useItemInHand().name());
        }
    }

    @EventHandler
    public void onSwitch(PlayerChangedWorldEvent event) {
        World from = event.getFrom();
        Player player = event.getPlayer();
        Common.broadcastMessage(CC.BLUE +  player.getName() + " - " + from.getName() + " to " + player.getWorld().getName());
    }

}


Filename: .\main\java\rip\diamond\practice\duel\DuelRequest.java
package rip.diamond.practice.duel;

import lombok.Getter;
import org.bukkit.Bukkit;
import org.bukkit.Sound;
import org.bukkit.entity.Player;
import rip.diamond.practice.config.EdenSound;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.arenas.Arena;
import rip.diamond.practice.duel.task.DuelRequestClearTask;
import rip.diamond.practice.kits.Kit;
import rip.diamond.practice.party.Party;
import rip.diamond.practice.util.Clickable;
import rip.diamond.practice.util.Common;

import java.util.HashMap;
import java.util.Map;
import java.util.UUID;
import java.util.stream.Collectors;

public class DuelRequest {

	@Getter private static final Map<UUID, DuelRequest> duelRequests = new HashMap<>();

	@Getter private final UUID senderUUID;
	@Getter private final UUID targetUUID;
	@Getter private final String targetName;
	@Getter private final boolean party;
	@Getter private final Kit kit;
	@Getter private final Arena arena;
	private final long createdAt = System.currentTimeMillis();

	public static void init() {
		new DuelRequestClearTask();
	}

	public DuelRequest(UUID senderUUID, UUID targetUUID, boolean party, Kit kit, Arena arena) {
		this.senderUUID = senderUUID;
		this.targetUUID = targetUUID;
		this.targetName = Bukkit.getPlayer(targetUUID).getName();
		this.party = party;
		this.kit = kit;
		this.arena = arena;

		duelRequests.put(senderUUID, this);
	}

	public boolean isExpired() {
		return System.currentTimeMillis() - createdAt >= 30000L;
	}

	public DuelRequest send() {
		Player sender = Bukkit.getPlayer(senderUUID);
		Player target = Bukkit.getPlayer(targetUUID);

		if (sender == null) {
			return this;
		}
		if (target == null) {
			Language.DUEL_DUEL_REQUEST_CANNOT_FIND_TARGET.sendMessage(sender);
			return this;
		}

		String ping = isParty() ? Party.getByPlayer(sender).getAllPartyMembers().stream().map(partyMember -> formatPing(partyMember.getPlayer())).collect(Collectors.joining("\n")) : formatPing(sender);

		Clickable clickable = new Clickable(party ? Language.DUEL_DUEL_REQUEST_DISPLAY_PARTY.toString(sender.getName(), kit.getDisplayName(), arena.getDisplayName(), Party.getByPlayer(sender).getAllPartyMembers().size()) : Language.DUEL_DUEL_REQUEST_DISPLAY_1V1.toString(sender.getName(), kit.getDisplayName(), arena.getDisplayName()));
		clickable.add(Language.DUEL_DUEL_REQUEST_CLICK_TO_ACCEPT.toString(), Language.DUEL_DUEL_REQUEST_CLICK_TO_ACCEPT_HOVER.toString(), "/duel accept " + senderUUID);
		clickable.add(" ");
		clickable.add(Language.DUEL_DUEL_REQUEST_CLICK_TO_VIEW_PING.toString(), ping, null);
		clickable.sendToPlayer(target);
		EdenSound.RECEIVE_DUEL_REQUEST.play(target);

		if (party) {
			Language.DUEL_DUEL_REQUEST_SUCCESS_PARTY.sendMessage(sender, kit.getDisplayName(), arena.getDisplayName(), target.getName());
		} else {
			Language.DUEL_DUEL_REQUEST_SUCCESS_1V1.sendMessage(sender, kit.getDisplayName(), arena.getDisplayName(), target.getName());
		}
		return this;
	}

	private String formatPing(Player player) {
		return Language.DUEL_DUEL_REQUEST_CLICK_TO_VIEW_PING_HOVER.toString(player.getName(), player.spigot().getPing());
	}

}


Filename: .\main\java\rip\diamond\practice\duel\DuelRequestManager.java
package rip.diamond.practice.duel;

import org.bukkit.Bukkit;
import org.bukkit.entity.Player;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.arenas.Arena;
import rip.diamond.practice.arenas.ArenaDetail;
import rip.diamond.practice.kits.Kit;
import rip.diamond.practice.match.impl.SoloMatch;
import rip.diamond.practice.match.impl.TeamMatch;
import rip.diamond.practice.match.team.Team;
import rip.diamond.practice.match.team.TeamPlayer;
import rip.diamond.practice.party.Party;
import rip.diamond.practice.profile.PlayerProfile;
import rip.diamond.practice.profile.PlayerState;
import rip.diamond.practice.profile.ProfileSettings;
import rip.diamond.practice.queue.QueueType;

import java.util.stream.Collectors;

public class DuelRequestManager {

    public void sendDuelRequest(Player sender, Player target, Kit kit, Arena arena) {
        if (!verify(sender, target, kit, arena)) {
            return;
        }
        Party party = Party.getByPlayer(sender);
        new DuelRequest(sender.getUniqueId(), target.getUniqueId(), party != null, kit, arena).send();
    }

    public void acceptDuelRequest(DuelRequest duelRequest) {
        Player sender = Bukkit.getPlayer(duelRequest.getSenderUUID());
        Player target = Bukkit.getPlayer(duelRequest.getTargetUUID());
        Kit kit = duelRequest.getKit();
        Arena arena = duelRequest.getArena();

        if (!verify(sender, target, kit, arena)) {
            return;
        }

        ArenaDetail arenaDetail = Arena.getArenaDetail(arena);

        Team team1 = new Team(new TeamPlayer(sender));
        Team team2 = new Team(new TeamPlayer(target));

        if (duelRequest.isParty()) {
            Party party1 = Party.getByPlayer(sender);
            Party party2 = Party.getByPlayer(target);

            team1.getTeamPlayers().addAll(party1.getPartyMembers().stream().map(partyMember -> new TeamPlayer(partyMember.getPlayer())).collect(Collectors.toList()));
            team2.getTeamPlayers().addAll(party2.getPartyMembers().stream().map(partyMember -> new TeamPlayer(partyMember.getPlayer())).collect(Collectors.toList()));

            TeamMatch match = new TeamMatch(arenaDetail, kit, team1, team2);
            match.start();
        } else {
            SoloMatch match = new SoloMatch(arenaDetail, kit, team1, team2, QueueType.UNRANKED, true);
            match.start();
        }
    }

    public boolean verify(Player sender, Player target, Kit kit, Arena arena) {
        if (target == null) {
            Language.DUEL_VERIFY_TARGET_NOT_FOUND.sendMessage(sender);
            return false;
        }
        if (sender == target) {
            Language.DUEL_CANNOT_DUEL_SELF.sendMessage(sender);
            return false;
        }
        PlayerProfile profile = PlayerProfile.get(sender);
        if (profile.getPlayerState() != PlayerState.IN_LOBBY) {
            Language.DUEL_VERIFY_NEED_TO_BE_IN_LOBBY.sendMessage(sender);
            return false;
        }

        PlayerProfile targetProfile = PlayerProfile.get(target);
        if (targetProfile.getPlayerState() != PlayerState.IN_LOBBY) {
            Language.DUEL_VERIFY_TARGET_NEED_TO_BE_IN_LOBBY.sendMessage(sender);
            return false;
        }
        if (!targetProfile.getSettings().get(ProfileSettings.ALLOW_DUEL_REQUEST).isEnabled()) {
            Language.DUEL_VERIFY_TARGET_DUEL_REQUEST_DISABLED.sendMessage(sender);
            return false;
        }

        if (arena.isEdited()) {
            Language.DUEL_VERIFY_ARENA_DISABLED.sendMessage(sender);
            return false;
        }

        ArenaDetail arenaDetail = Arena.getArenaDetail(arena);
        if (arenaDetail == null) {
            Language.DUEL_VERIFY_CANNOT_FIND_ARENA.sendMessage(sender);
            return false;
        }

        Party party1 = Party.getByPlayer(sender);
        Party party2 = Party.getByPlayer(target);
        if (party1 == null && party2 != null) {
            Language.DUEL_VERIFY_TARGET_IN_A_PARTY.sendMessage(sender);
            return false;
        }
        if (party1 != null && party2 == null) {
            Language.DUEL_VERIFY_TARGET_NOT_IN_A_PARTY.sendMessage(sender);
            return false;
        }

        boolean isPartyDuelRequest = party1 != null;
        if (isPartyDuelRequest) {
            if (party1 == party2) {
                Language.DUEL_VERIFY_CANNOT_DUEL_SAME_PARTY.sendMessage(sender);
                return false;
            }
            if (!party1.getLeader().getUniqueID().equals(sender.getUniqueId())) {
                Language.PARTY_ONLY_LEADER.sendMessage(sender);
                return false;
            }
            if (!party1.isAllPlayersInState(PlayerState.IN_LOBBY)) {
                Language.DUEL_VERIFY_PLAYER_NOT_IN_LOBBY.sendMessage(sender, party1.getLeader().getUsername());
                return false;
            }
            if (!party2.isAllPlayersInState(PlayerState.IN_LOBBY)) {
                Language.DUEL_VERIFY_PLAYER_NOT_IN_LOBBY.sendMessage(sender, party2.getLeader().getUsername());
                return false;
            }
        }
        return true;
    }

}


Filename: .\main\java\rip\diamond\practice\duel\command\DuelCommand.java
package rip.diamond.practice.duel.command;

import org.bukkit.Bukkit;
import org.bukkit.entity.Player;
import rip.diamond.practice.Eden;
import rip.diamond.practice.arenas.Arena;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.duel.DuelRequest;
import rip.diamond.practice.duel.menu.ChooseArenaMenu;
import rip.diamond.practice.duel.menu.ChooseKitMenu;
import rip.diamond.practice.kits.Kit;
import rip.diamond.practice.party.Party;
import rip.diamond.practice.profile.PlayerProfile;
import rip.diamond.practice.profile.PlayerState;
import rip.diamond.practice.profile.ProfileSettings;
import rip.diamond.practice.util.InsertUtil;
import rip.diamond.practice.util.command.Command;
import rip.diamond.practice.util.command.CommandArgs;
import rip.diamond.practice.util.command.argument.CommandArguments;
import rip.diamond.practice.util.exception.PracticeUnexpectedException;

import java.util.UUID;

public class DuelCommand extends Command {

    @CommandArgs(name = "duel")
    public void execute(CommandArguments command) {
        Player player = command.getPlayer();
        String[] args = command.getArgs();

        if (args.length == 0) {
            Language.DUEL_HELP_MESSAGE.sendListOfMessage(player);
            return;
        }

        if (args.length == 2) {
            if (args[0].equalsIgnoreCase("accept")) {
                InsertUtil.InsertType type = InsertUtil.check(args[1]);
                UUID uuid;
                switch (type) {
                    case UUID:
                        uuid = UUID.fromString(args[1]);
                        break;
                    case STRING:
                        Player target = Bukkit.getPlayer(args[1]);
                        if (target == null) {
                            Language.DUEL_INVALID_PLAYER.sendMessage(player, args[1]);
                            return;
                        }
                        uuid = target.getUniqueId();
                        break;
                    default:
                        throw new PracticeUnexpectedException(type.name() + " is not a valid InsertType");
                }

                DuelRequest duelRequest = DuelRequest.getDuelRequests().get(uuid);
                if (duelRequest == null) {
                    Language.DUEL_INVALID_DUEL_REQUEST.sendMessage(player);
                    return;
                }
                plugin.getDuelRequestManager().acceptDuelRequest(duelRequest);
                DuelRequest.getDuelRequests().remove(uuid);
                return;
            }
        }

        //duel [player] [kit:optional]
        Player target = Bukkit.getPlayer(args[0]);
        if (target == null) {
            Language.DUEL_CANNOT_FIND_PLAYER.sendMessage(player, args[0]);
            return;
        }
        PlayerProfile profile = PlayerProfile.get(player);
        if (profile.getPlayerState() != PlayerState.IN_LOBBY) {
            Language.DUEL_VERIFY_NEED_TO_BE_IN_LOBBY.sendMessage(player);
            return;
        }
        if (player == target) {
            Language.DUEL_CANNOT_DUEL_SELF.sendMessage(player);
            return;
        }
        Party pParty = Party.getByPlayer(player);
        Party tParty = Party.getByPlayer(target);
        if (pParty != null && tParty == null) {
            Language.DUEL_CANNOT_DUEL_NOT_IN_PARTY.sendMessage(player);
            return;
        }
        if (DuelRequest.getDuelRequests().containsKey(player.getUniqueId())) {
            Language.DUEL_HAS_PENDING_DUEL_REQUEST.sendMessage(player);
            return;
        }

        if (args.length == 1) {
            new ChooseKitMenu(target.getUniqueId(), pParty != null).openMenu(player);
            return;
        } else if (args.length == 2) {
            Kit kit = Kit.getByName(args[1]);
            if (kit == null) {
                Language.DUEL_INVALID_KIT.sendMessage(player, args[1]);
                return;
            }
            Eden.INSTANCE.getDuelRequestManager().sendDuelRequest(player, target, kit, Arena.getEnabledArena(kit));
            return;
        } else if (args.length == 3) {
            Kit kit = Kit.getByName(args[1]);
            if (kit == null) {
                Language.DUEL_INVALID_KIT.sendMessage(player, args[1]);
                return;
            }
            Arena arena = Arena.getEnabledArena(args[2], kit);
            if (arena == null) {
                Language.DUEL_INVALID_ARENA.sendMessage(player, args[2]);
                return;
            }
            Eden.INSTANCE.getDuelRequestManager().sendDuelRequest(player, target, kit, arena);
            return;
        }
    }
}


Filename: .\main\java\rip\diamond\practice\duel\menu\ChooseArenaMenu.java
package rip.diamond.practice.duel.menu;

import lombok.RequiredArgsConstructor;
import org.bukkit.Bukkit;
import org.bukkit.Material;
import org.bukkit.entity.Player;
import org.bukkit.event.inventory.ClickType;
import org.bukkit.inventory.ItemStack;
import rip.diamond.practice.Eden;
import rip.diamond.practice.arenas.Arena;
import rip.diamond.practice.arenas.ArenaDetail;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.kits.Kit;
import rip.diamond.practice.util.BasicConfigFile;
import rip.diamond.practice.util.CC;
import rip.diamond.practice.util.Common;
import rip.diamond.practice.util.ItemBuilder;
import rip.diamond.practice.util.menu.Button;
import rip.diamond.practice.util.menu.Menu;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.stream.Collectors;

@RequiredArgsConstructor
public class ChooseArenaMenu extends Menu {
    private final UUID targetUUID;
    private final Kit kit;
    private final int page;

    public ChooseArenaMenu(UUID targetUUID, Kit kit) {
        this(targetUUID, kit, 1);
    }

    @Override
    public String getTitle(Player player) {
        BasicConfigFile config = Eden.INSTANCE.getMenusConfig().getConfig();
        return CC.translate(config.getString("duel-choose-arena-menu.title"));
    }

    @Override
    public int getSize() {
        BasicConfigFile config = Eden.INSTANCE.getMenusConfig().getConfig();
        String sizeStr = config.getString("duel-choose-arena-menu.size");

        if ("dynamic".equalsIgnoreCase(sizeStr)) {
            if (page > 1) {
                return config.getInt("duel-choose-arena-menu.max-size");
            }

            int itemsPerPage = getItemsPerPage(config);
            List<Arena> arenas = getFilteredArenas();
            int itemsOnThisPage = Math.min(arenas.size() - ((page - 1) * itemsPerPage), itemsPerPage);

            boolean hasBorder = config.getBoolean("duel-choose-arena-menu.border.enabled");
            int contentSlots = itemsOnThisPage;
            int rowsNeeded = (int) Math.ceil(contentSlots / 7.0);
            int totalRows = rowsNeeded + (hasBorder ? 2 : 0);

            int maxSize = config.getInt("duel-choose-arena-menu.max-size");
            int calculatedSize = Math.max(27, Math.min(totalRows * 9, maxSize));

            return ((calculatedSize + 8) / 9) * 9;
        } else {
            return config.getInt("duel-choose-arena-menu.size");
        }
    }

    @Override
    public Map<Integer, Button> getButtons(Player player) {
        Map<Integer, Button> buttons = new HashMap<>();
        BasicConfigFile config = Eden.INSTANCE.getMenusConfig().getConfig();
        int itemsPerPage = getItemsPerPage(config);

        // Filler
        if (config.getBoolean("duel-choose-arena-menu.filler.enabled")) {
            ItemStack filler = new ItemBuilder(
                    org.bukkit.Material.valueOf(config.getString("duel-choose-arena-menu.filler.material")))
                    .durability(config.getInt("duel-choose-arena-menu.filler.data"))
                    .name(" ")
                    .build();
            for (int i = 0; i < getSize(); i++) {
                buttons.put(i, new Button() {
                    @Override
                    public ItemStack getButtonItem(Player player) {
                        return filler;
                    }
                });
            }
        }

        // Border
        if (config.getBoolean("duel-choose-arena-menu.border.enabled")) {
            ItemStack border = new ItemBuilder(
                    org.bukkit.Material.valueOf(config.getString("duel-choose-arena-menu.border.material")))
                    .durability(config.getInt("duel-choose-arena-menu.border.data"))
                    .name(" ")
                    .build();
            int size = getSize();
            for (int i = 0; i < size; i++) {
                if (i < 9 || i >= size - 9 || i % 9 == 0 || i % 9 == 8) {
                    buttons.put(i, new Button() {
                        @Override
                        public ItemStack getButtonItem(Player player) {
                            return border;
                        }
                    });
                }
            }
        }

        // Random Arena Button
        int randomSlot = config.getInt("duel-choose-arena-menu.items.random-arena-button.slot");
        buttons.put(randomSlot, new Button() {
            @Override
            public ItemStack getButtonItem(Player player) {
                return new ItemBuilder(
                        org.bukkit.Material
                                .valueOf(config.getString("duel-choose-arena-menu.items.random-arena-button.material")))
                        .name(config.getString("duel-choose-arena-menu.items.random-arena-button.name"))
                        .lore(config.getStringList("duel-choose-arena-menu.items.random-arena-button.lore"))
                        .build();
            }

            @Override
            public void clicked(Player player, ClickType clickType) {
                Arena arena = Arena.getEnabledArena(kit);
                if (arena == null) {
                    Common.log("[Eden] There's no available arenas for kit " + kit.getName()
                            + ", consider add more arenas.");
                    return;
                }
                player.closeInventory();
                Eden.INSTANCE.getDuelRequestManager().sendDuelRequest(player, Bukkit.getPlayer(targetUUID), kit, arena);
            }
        });

        // Go Back Button
        if (config.getBoolean("duel-choose-arena-menu.items.go-back.enabled")) {
            int goBackSlot = config.getInt("duel-choose-arena-menu.items.go-back.slot");
            buttons.put(goBackSlot, new Button() {
                @Override
                public ItemStack getButtonItem(Player player) {
                    return new ItemBuilder(
                            org.bukkit.Material
                                    .valueOf(config.getString("duel-choose-arena-menu.items.go-back.material")))
                            .name(config.getString("duel-choose-arena-menu.items.go-back.name"))
                            .lore(config.getStringList("duel-choose-arena-menu.items.go-back.lore"))
                            .build();
                }

                @Override
                public void clicked(Player player, ClickType clickType) {
                    new rip.diamond.practice.duel.menu.ChooseKitMenu(targetUUID, false).openMenu(player);
                }
            });
        }

        // Arenas
        List<Arena> allArenas = getFilteredArenas();
        int startIndex = (page - 1) * itemsPerPage;
        int endIndex = Math.min(startIndex + itemsPerPage, allArenas.size());

        List<Arena> arenasOnThisPage = allArenas.subList(startIndex, endIndex);

        boolean hasBorder = config.getBoolean("duel-choose-arena-menu.border.enabled");
        int arenaIndex = 0;
        for (int slot = 0; slot < getSize() && arenaIndex < arenasOnThisPage.size(); slot++) {
            // Skip border slots and the random arena button slot
            if (hasBorder && (slot < 9 || slot >= getSize() - 9 || slot % 9 == 0 || slot % 9 == 8)) {
                continue;
            }
            // Skip if this slot is the random arena button
            if (slot == randomSlot) {
                continue;
            }

            Arena arena = arenasOnThisPage.get(arenaIndex);
            buttons.put(slot, new Button() {
                @Override
                public ItemStack getButtonItem(Player player) {
                    return new ItemBuilder(arena.getIcon().clone())
                            .name(config.getString("duel-choose-arena-menu.items.arena-button.name")
                                    .replace("{arena-name}", arena.getDisplayName()))
                            .lore(config.getStringList("duel-choose-arena-menu.items.arena-button.lore"))
                            .build();
                }

                @Override
                public void clicked(Player player, ClickType clickType) {
                    player.closeInventory();
                    Eden.INSTANCE.getDuelRequestManager().sendDuelRequest(player, Bukkit.getPlayer(targetUUID), kit,
                            arena);
                }
            });
            arenaIndex++;
        }

        // Pagination
        if (page > 1) {
            int prevSlot = config.getInt("duel-choose-arena-menu.items.previous-page.slot");
            buttons.put(prevSlot, new Button() {
                @Override
                public ItemStack getButtonItem(Player player) {
                    return new ItemBuilder(
                            org.bukkit.Material
                                    .valueOf(config.getString("duel-choose-arena-menu.items.previous-page.material")))
                            .name(config.getString("duel-choose-arena-menu.items.previous-page.name"))
                            .lore(config.getStringList("duel-choose-arena-menu.items.previous-page.lore"))
                            .build();
                }

                @Override
                public void clicked(Player player, ClickType clickType) {
                    new ChooseArenaMenu(targetUUID, kit, page - 1).openMenu(player);
                }
            });
        }

        if (endIndex < allArenas.size()) {
            int nextSlot = config.getInt("duel-choose-arena-menu.items.next-page.slot");
            buttons.put(nextSlot, new Button() {
                @Override
                public ItemStack getButtonItem(Player player) {
                    return new ItemBuilder(
                            org.bukkit.Material
                                    .valueOf(config.getString("duel-choose-arena-menu.items.next-page.material")))
                            .name(config.getString("duel-choose-arena-menu.items.next-page.name"))
                            .lore(config.getStringList("duel-choose-arena-menu.items.next-page.lore"))
                            .build();
                }

                @Override
                public void clicked(Player player, ClickType clickType) {
                    new ChooseArenaMenu(targetUUID, kit, page + 1).openMenu(player);
                }
            });
        }

        return buttons;
    }

    private int getItemsPerPage(BasicConfigFile config) {
        int size;
        if (config.getString("duel-choose-arena-menu.size").equalsIgnoreCase("dynamic")) {
            size = config.getInt("duel-choose-arena-menu.max-size");
        } else {
            size = config.getInt("duel-choose-arena-menu.size");
        }

        if (config.getBoolean("duel-choose-arena-menu.border.enabled")) {
            int rows = size / 9;
            return (rows - 2) * 7;
        } else {
            return size - 9;
        }
    }

    private List<Arena> getFilteredArenas() {
        return Arena.getArenas().stream()
                .filter(arena -> {
                    return arena.isEnabled() && !arena.isLocked() && !arena.getArenaDetails().isEmpty()
                            && arena.getAllowedKits().contains(kit.getName());
                })
                .collect(Collectors.toList());
    }
}


Filename: .\main\java\rip\diamond\practice\duel\menu\ChooseKitMenu.java
package rip.diamond.practice.duel.menu;

import lombok.RequiredArgsConstructor;
import org.bukkit.Bukkit;
import org.bukkit.Material;
import org.bukkit.entity.Player;
import org.bukkit.event.inventory.ClickType;
import org.bukkit.inventory.ItemStack;
import rip.diamond.practice.Eden;
import rip.diamond.practice.arenas.Arena;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.kits.Kit;
import rip.diamond.practice.kits.KitMatchType;
import rip.diamond.practice.profile.PlayerProfile;
import rip.diamond.practice.profile.ProfileSettings;
import rip.diamond.practice.util.BasicConfigFile;
import rip.diamond.practice.util.CC;
import rip.diamond.practice.util.ItemBuilder;
import rip.diamond.practice.util.menu.Button;
import rip.diamond.practice.util.menu.Menu;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.stream.Collectors;

@RequiredArgsConstructor
public class ChooseKitMenu extends Menu {
    private final UUID targetUUID;
    private final boolean party;
    private final int page;

    public ChooseKitMenu(UUID targetUUID, boolean party) {
        this(targetUUID, party, 1);
    }

    @Override
    public String getTitle(Player player) {
        BasicConfigFile config = Eden.INSTANCE.getMenusConfig().getConfig();
        return CC.translate(config.getString("duel-choose-kit-menu.title"));
    }

    @Override
    public int getSize() {
        BasicConfigFile config = Eden.INSTANCE.getMenusConfig().getConfig();
        String sizeStr = config.getString("duel-choose-kit-menu.size");

        if ("dynamic".equalsIgnoreCase(sizeStr)) {
            if (page > 1) {
                return config.getInt("duel-choose-kit-menu.max-size");
            }

            int itemsPerPage = getItemsPerPage(config);
            List<Kit> kits = getFilteredKits();
            int kitsOnThisPage = Math.min(kits.size() - ((page - 1) * itemsPerPage), itemsPerPage);

            boolean hasBorder = config.getBoolean("duel-choose-kit-menu.border.enabled");
            int contentSlots = kitsOnThisPage;
            int rowsNeeded = (int) Math.ceil(contentSlots / 7.0);
            int totalRows = rowsNeeded + (hasBorder ? 2 : 0);

            int maxSize = config.getInt("duel-choose-kit-menu.max-size");
            int calculatedSize = Math.max(27, Math.min(totalRows * 9, maxSize));

            return ((calculatedSize + 8) / 9) * 9;
        } else {
            return config.getInt("duel-choose-kit-menu.size");
        }
    }

    @Override
    public Map<Integer, Button> getButtons(Player player) {
        Map<Integer, Button> buttons = new HashMap<>();
        BasicConfigFile config = Eden.INSTANCE.getMenusConfig().getConfig();
        int itemsPerPage = getItemsPerPage(config);

        // Filler
        if (config.getBoolean("duel-choose-kit-menu.filler.enabled")) {
            ItemStack filler = new ItemBuilder(
                    org.bukkit.Material.valueOf(config.getString("duel-choose-kit-menu.filler.material")))
                    .durability(config.getInt("duel-choose-kit-menu.filler.data"))
                    .name(" ")
                    .build();
            for (int i = 0; i < getSize(); i++) {
                buttons.put(i, new Button() {
                    @Override
                    public ItemStack getButtonItem(Player player) {
                        return filler;
                    }
                });
            }
        }

        // Border
        if (config.getBoolean("duel-choose-kit-menu.border.enabled")) {
            ItemStack border = new ItemBuilder(
                    org.bukkit.Material.valueOf(config.getString("duel-choose-kit-menu.border.material")))
                    .durability(config.getInt("duel-choose-kit-menu.border.data"))
                    .name(" ")
                    .build();
            int size = getSize();
            for (int i = 0; i < size; i++) {
                if (i < 9 || i >= size - 9 || i % 9 == 0 || i % 9 == 8) {
                    buttons.put(i, new Button() {
                        @Override
                        public ItemStack getButtonItem(Player player) {
                            return border;
                        }
                    });
                }
            }
        }

        // Kit buttons
        List<Kit> allKits = getFilteredKits();
        int startIndex = (page - 1) * itemsPerPage;
        int endIndex = Math.min(startIndex + itemsPerPage, allKits.size());

        List<Kit> kitsOnThisPage = allKits.subList(startIndex, endIndex);

        boolean hasBorder = config.getBoolean("duel-choose-kit-menu.border.enabled");
        int kitIndex = 0;
        for (int slot = 0; slot < getSize() && kitIndex < kitsOnThisPage.size(); slot++) {
            // Skip border slots
            if (hasBorder && (slot < 9 || slot >= getSize() - 9 || slot % 9 == 0 || slot % 9 == 8)) {
                continue;
            }

            Kit kit = kitsOnThisPage.get(kitIndex);
            buttons.put(slot, new Button() {
                @Override
                public ItemStack getButtonItem(Player player) {
                    String name = config.getString("duel-choose-kit-menu.items.kit-button.name");
                    if (name == null)
                        name = "&b" + kit.getDisplayName();

                    return new ItemBuilder(kit.getDisplayIcon().getType())
                            .durability(kit.getDisplayIcon().getDurability())
                            .name(name.replace("{kit-name}", kit.getDisplayName()))
                            .lore(config.getStringList("duel-choose-kit-menu.items.kit-button.lore"))
                            .build();
                }

                @Override
                public void clicked(Player player, ClickType clickType) {
                    if (party) {
                        new ChooseArenaMenu(targetUUID, kit).openMenu(player);
                    } else {
                        Player target = Bukkit.getPlayer(targetUUID);
                        if (target != null) {
                            PlayerProfile profile = PlayerProfile.get(player);
                            if (profile.getSettings().get(ProfileSettings.ARENA_SELECTION).isEnabled()) {
                                new ChooseArenaMenu(targetUUID, kit).openMenu(player);
                            } else {
                                player.closeInventory();
                                Eden.INSTANCE.getDuelRequestManager().sendDuelRequest(player, target, kit,
                                        Arena.getEnabledArena(kit));
                            }
                        }
                    }
                }
            });
            kitIndex++;
        }

        // Pagination
        if (page > 1) {
            int prevSlot = config.getInt("duel-choose-kit-menu.items.previous-page.slot");
            buttons.put(prevSlot, new Button() {
                @Override
                public ItemStack getButtonItem(Player player) {
                    return new ItemBuilder(
                            org.bukkit.Material
                                    .valueOf(config.getString("duel-choose-kit-menu.items.previous-page.material")))
                            .name(config.getString("duel-choose-kit-menu.items.previous-page.name"))
                            .lore(config.getStringList("duel-choose-kit-menu.items.previous-page.lore"))
                            .build();
                }

                @Override
                public void clicked(Player player, ClickType clickType) {
                    // The following line is from the provided diff, but 'target' and 'kitMatchType'
                    // are not defined in this class.
                    // Reverting to original logic for ChooseKitMenu constructor parameters.
                    new ChooseKitMenu(targetUUID, party, page - 1).openMenu(player);
                }
            });
        }

        if (endIndex < allKits.size()) {
            int nextSlot = config.getInt("duel-choose-kit-menu.items.next-page.slot");
            buttons.put(nextSlot, new Button() {
                @Override
                public ItemStack getButtonItem(Player player) {
                    return new ItemBuilder(
                            org.bukkit.Material
                                    .valueOf(config.getString("duel-choose-kit-menu.items.next-page.material")))
                            .name(config.getString("duel-choose-kit-menu.items.next-page.name"))
                            .lore(config.getStringList("duel-choose-kit-menu.items.next-page.lore"))
                            .build();
                }

                @Override
                public void clicked(Player player, ClickType clickType) {
                    // The following line is from the provided diff, but 'target' and 'kitMatchType'
                    // are not defined in this class.
                    // Reverting to original logic for ChooseKitMenu constructor parameters.
                    new ChooseKitMenu(targetUUID, party, page + 1).openMenu(player);
                }
            });
        }

        return buttons;
    }

    private int getItemsPerPage(BasicConfigFile config) {
        int size;
        if (config.getString("duel-choose-kit-menu.size").equalsIgnoreCase("dynamic")) {
            size = config.getInt("duel-choose-kit-menu.max-size");
        } else {
            size = config.getInt("duel-choose-kit-menu.size");
        }

        if (config.getBoolean("duel-choose-kit-menu.border.enabled")) {
            int rows = size / 9;
            return (rows - 2) * 7;
        } else {
            // If no border, assume a standard layout where the last row is for
            // pagination/close buttons
            // and the first row might also be for special buttons, leaving the middle for
            // items.
            // This calculation is a bit arbitrary without more context on the menu layout.
            // The original code used config.getInt("duel-choose-kit-menu.items-per-page")
            // directly.
            // The provided diff suggests 'size - 9' which implies one row is reserved.
            return size - 9;
        }
    }

    private List<Kit> getFilteredKits() {
        return Kit.getKits().stream()
                .filter(Kit::isEnabled)
                .filter(kit -> !party || kit.getKitMatchTypes().contains(KitMatchType.SPLIT))
                .collect(Collectors.toList());
    }
}


Filename: .\main\java\rip\diamond\practice\duel\task\DuelRequestClearTask.java
package rip.diamond.practice.duel.task;

import rip.diamond.practice.duel.DuelRequest;
import rip.diamond.practice.util.TaskTicker;

public class DuelRequestClearTask extends TaskTicker {
    public DuelRequestClearTask() {
        super(0, 20, true);
    }

    @Override
    public void onRun() {
        DuelRequest.getDuelRequests().entrySet().removeIf(entry -> entry.getValue().isExpired());
    }

    @Override
    public void preRun() {

    }

    @Override
    public TickType getTickType() {
        return TickType.NONE;
    }

    @Override
    public int getStartTick() {
        return 0;
    }
}


Filename: .\main\java\rip\diamond\practice\event\EventJoinEvent.java
package rip.diamond.practice.event;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import rip.diamond.practice.events.EdenEvent;
import rip.diamond.practice.party.Party;
import rip.diamond.practice.util.BaseEvent;

@Getter
@RequiredArgsConstructor
public class EventJoinEvent extends BaseEvent {

    private final Party party;
    private final EdenEvent event;

}


Filename: .\main\java\rip\diamond\practice\event\KitLoadoutReceivedEvent.java
package rip.diamond.practice.event;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import org.bukkit.entity.Player;
import rip.diamond.practice.kits.KitLoadout;
import rip.diamond.practice.match.Match;
import rip.diamond.practice.util.BaseEvent;

@Getter
@RequiredArgsConstructor
public class KitLoadoutReceivedEvent extends BaseEvent {

    private final Player player;
    private final Match match;
    private final KitLoadout kitLoadout;

}


Filename: .\main\java\rip\diamond\practice\event\MatchEndEvent.java
package rip.diamond.practice.event;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import rip.diamond.practice.match.Match;
import rip.diamond.practice.util.BaseEvent;

@Getter
@RequiredArgsConstructor
public class MatchEndEvent extends BaseEvent {

    private final Match match;
    private final boolean forceEnd;

}


Filename: .\main\java\rip\diamond\practice\event\MatchPlayerDeathEvent.java
package rip.diamond.practice.event;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.Setter;
import org.bukkit.entity.Player;
import rip.diamond.practice.match.Match;
import rip.diamond.practice.util.BaseEvent;

@Getter
@Setter
@RequiredArgsConstructor
public class MatchPlayerDeathEvent extends BaseEvent {

    private final Match match;
    private final Player player;
    private boolean playLightningEffect = true;
    private boolean playDeathEffect = true;

}


Filename: .\main\java\rip\diamond\practice\event\MatchResetEvent.java
package rip.diamond.practice.event;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.Setter;
import rip.diamond.practice.match.Match;
import rip.diamond.practice.util.BaseEvent;

@Getter
@Setter
@RequiredArgsConstructor
public class MatchResetEvent extends BaseEvent {

    private final Match match;
    
}


Filename: .\main\java\rip\diamond\practice\event\MatchRoundEndEvent.java
package rip.diamond.practice.event;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.Setter;
import rip.diamond.practice.match.Match;
import rip.diamond.practice.util.BaseEvent;

@Getter
@Setter
@RequiredArgsConstructor
public class MatchRoundEndEvent extends BaseEvent {

    private final Match match;
    
}


Filename: .\main\java\rip\diamond\practice\event\MatchRoundStartEvent.java
package rip.diamond.practice.event;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.Setter;
import rip.diamond.practice.match.Match;
import rip.diamond.practice.util.BaseEvent;

@Getter
@Setter
@RequiredArgsConstructor
public class MatchRoundStartEvent extends BaseEvent {

    private final Match match;
    
}


Filename: .\main\java\rip\diamond\practice\event\MatchStartEvent.java
package rip.diamond.practice.event;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import rip.diamond.practice.match.Match;
import rip.diamond.practice.util.BaseEvent;

@RequiredArgsConstructor
public class MatchStartEvent extends BaseEvent{

    @Getter private final Match match;
}


Filename: .\main\java\rip\diamond\practice\event\MatchStateChangeEvent.java
package rip.diamond.practice.event;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import rip.diamond.practice.match.Match;
import rip.diamond.practice.util.BaseEvent;

@Getter
@RequiredArgsConstructor
public class MatchStateChangeEvent extends BaseEvent {

    private final Match match;

}


Filename: .\main\java\rip\diamond\practice\event\MenuOpenEvent.java
package rip.diamond.practice.event;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import rip.diamond.practice.util.BaseEvent;
import rip.diamond.practice.util.menu.Menu;

@Getter
@RequiredArgsConstructor
public class MenuOpenEvent extends BaseEvent {

    private final Menu menu;

}


Filename: .\main\java\rip\diamond\practice\event\MenuUpdateEvent.java
package rip.diamond.practice.event;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import rip.diamond.practice.util.BaseEvent;
import rip.diamond.practice.util.menu.Menu;

@Getter
@RequiredArgsConstructor
public class MenuUpdateEvent extends BaseEvent {

    private final Menu menu;

}


Filename: .\main\java\rip\diamond\practice\event\PartyDisbandEvent.java
package rip.diamond.practice.event;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import rip.diamond.practice.party.Party;
import rip.diamond.practice.util.BaseEvent;

@Getter
@RequiredArgsConstructor
public class PartyDisbandEvent extends BaseEvent {

    private final Party party;
    private final boolean forced;

}


Filename: .\main\java\rip\diamond\practice\event\PartyJoinEvent.java
package rip.diamond.practice.event;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import org.bukkit.event.Cancellable;
import rip.diamond.practice.party.Party;
import rip.diamond.practice.util.BaseEvent;
import rip.diamond.practice.util.exception.PracticeUnexpectedException;

@Getter
@RequiredArgsConstructor
public class PartyJoinEvent extends BaseEvent implements Cancellable {

    private final Party party;
    private final boolean forced;

    private boolean cancelled;
    private String cancelReason;

    @Override
    @Deprecated
    public void setCancelled(boolean cancelled) {
        throw new PracticeUnexpectedException("Cancel party join must provide a reason.");
    }

    public void setCancelled(boolean cancelled, String reason) {
        this.cancelled = cancelled;
        this.cancelReason = reason;
    }
}


Filename: .\main\java\rip\diamond\practice\event\PlayerProfileDataLoadEvent.java
package rip.diamond.practice.event;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import org.bson.Document;
import rip.diamond.practice.profile.PlayerProfile;
import rip.diamond.practice.util.BaseEvent;

@Getter
@RequiredArgsConstructor
public class PlayerProfileDataLoadEvent extends BaseEvent {

    private final PlayerProfile profile;
    private final Document document;

}


Filename: .\main\java\rip\diamond\practice\event\PlayerProfileDataSaveEvent.java
package rip.diamond.practice.event;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import org.bson.Document;
import rip.diamond.practice.profile.PlayerProfile;
import rip.diamond.practice.util.BaseEvent;

@Getter
@RequiredArgsConstructor
public class PlayerProfileDataSaveEvent extends BaseEvent {

    private final PlayerProfile profile;
    private final Document document;

}


Filename: .\main\java\rip\diamond\practice\event\PlayerProfileLoadedEvent.java
package rip.diamond.practice.event;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import org.bukkit.entity.Player;
import rip.diamond.practice.profile.PlayerProfile;
import rip.diamond.practice.util.BaseEvent;

@Getter
@RequiredArgsConstructor
public class PlayerProfileLoadedEvent extends BaseEvent {

    private final Player player;
    private final PlayerProfile profile;

}


Filename: .\main\java\rip\diamond\practice\event\QueueMatchFoundEvent.java
package rip.diamond.practice.event;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.Setter;
import org.bukkit.entity.Player;
import org.bukkit.event.Cancellable;
import rip.diamond.practice.queue.QueueProfile;
import rip.diamond.practice.util.BaseEvent;

@Getter
@Setter
@RequiredArgsConstructor
public class QueueMatchFoundEvent extends BaseEvent implements Cancellable {

    private final Player playerA;
    private final Player playerB;
    private final QueueProfile queueProfileA;
    private final QueueProfile queueProfileB;

    private boolean cancelled = false;
}


Filename: .\main\java\rip\diamond\practice\event\ScoreboardUpdateEvent.java
package rip.diamond.practice.event;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.Setter;
import org.bukkit.entity.Player;
import rip.diamond.practice.util.BaseEvent;

import java.util.ArrayList;
import java.util.List;

@Getter
@Setter
@RequiredArgsConstructor
public class ScoreboardUpdateEvent extends BaseEvent {

    private final Player player;
    private List<String> layout = new ArrayList<>();

}


Filename: .\main\java\rip\diamond\practice\event\SettingsChangeEvent.java
package rip.diamond.practice.event;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import org.bukkit.entity.Player;
import rip.diamond.practice.profile.PlayerProfile;
import rip.diamond.practice.profile.ProfileSettings;
import rip.diamond.practice.util.BaseEvent;

@Getter
@RequiredArgsConstructor
public class SettingsChangeEvent extends BaseEvent {

    private final Player player;
    private final PlayerProfile profile;
    private final ProfileSettings settings;

}


Filename: .\main\java\rip\diamond\practice\event\SettingsMenuOpenEvent.java
package rip.diamond.practice.event;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import org.bukkit.entity.Player;
import rip.diamond.practice.util.BaseEvent;
import rip.diamond.practice.util.menu.Menu;

@Getter
@RequiredArgsConstructor
public class SettingsMenuOpenEvent extends BaseEvent {

    private final Player player;
    private final Menu menu;

}


Filename: .\main\java\rip\diamond\practice\events\EdenEvent.java
package rip.diamond.practice.events;

import lombok.Getter;
import lombok.Setter;
import org.bukkit.Bukkit;
import org.bukkit.ChatColor;
import org.bukkit.entity.Player;
import org.bukkit.event.HandlerList;
import org.bukkit.event.Listener;
import rip.diamond.practice.Eden;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.event.EventJoinEvent;
import rip.diamond.practice.match.team.Team;
import rip.diamond.practice.party.Party;
import rip.diamond.practice.party.PartyMember;
import rip.diamond.practice.profile.PlayerProfile;
import rip.diamond.practice.profile.PlayerState;
import rip.diamond.practice.profile.ProfileSettings;
import rip.diamond.practice.util.Clickable;
import rip.diamond.practice.util.Common;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

@Getter
@Setter
public abstract class EdenEvent {

    private final Eden plugin = Eden.INSTANCE;
    @Getter
    private static EdenEvent onGoingEvent = null;

    private final String hoster;
    private final EventType eventType;
    private final int minPlayers;
    private final int maxPlayers;
    private final int teamSize;
    protected final List<Party> parties = new ArrayList<>();
    protected EventState state = EventState.WAITING;

    private EventCountdown countdown;
    private Listener bukkitListener;

    public EdenEvent(String hoster, EventType eventType, int minPlayers, int maxPlayers, int teamSize) {
        this.hoster = hoster;
        this.eventType = eventType;
        this.minPlayers = minPlayers;
        this.maxPlayers = maxPlayers;
        this.teamSize = teamSize;

        bukkitListener = constructListener();
        if (bukkitListener != null)
            plugin.getServer().getPluginManager().registerEvents(bukkitListener, plugin);
    }

    public String getEventName() {
        return eventType.getName();
    }

    public String getUncoloredEventName() {
        return ChatColor.stripColor(getEventName());
    }

    public String getTeamName(Team team) {
        return team.getLeader().getUsername()
                + (team.getTeamPlayers().size() <= 1 ? "" : Language.EVENT_PARTY_NAME_FORMAT.toString());
    }

    public void broadcast(Clickable clickable) {
        Bukkit.getOnlinePlayers().forEach(player -> {
            PlayerProfile profile = PlayerProfile.get(player);
            if (profile == null) {
                return;
            }
            if (profile.getSettings().get(ProfileSettings.EVENT_ANNOUNCEMENT).isEnabled()) {
                clickable.sendToPlayer(player);
            }
        });
    }

    public void broadcast(String string) {
        Bukkit.getOnlinePlayers().forEach(player -> {
            PlayerProfile profile = PlayerProfile.get(player);
            if (profile == null) {
                return;
            }
            if (profile.getSettings().get(ProfileSettings.EVENT_ANNOUNCEMENT).isEnabled()) {
                Common.sendMessage(player, string);
            }
        });
    }

    public void broadcast(List<String> string) {
        Bukkit.getOnlinePlayers().forEach(player -> {
            PlayerProfile profile = PlayerProfile.get(player);
            if (profile == null) {
                return;
            }
            if (profile.getSettings().get(ProfileSettings.EVENT_ANNOUNCEMENT).isEnabled()) {
                Common.sendMessage(player, string);
            }
        });
    }

    public void broadcastToEventPlayers(String string) {
        parties.forEach(party -> {
            party.getAllPartyMembers().forEach(partyMember -> partyMember.sendMessage(string));
        });
    }

    public void broadcastToEventPlayers(List<String> string) {
        parties.forEach(party -> {
            party.getAllPartyMembers().forEach(partyMember -> partyMember.sendMessage(string));
        });
    }

    public void create() {
        onGoingEvent = this;

        Clickable clickable = new Clickable(Language.EVENT_EVENT_CREATE_MESSAGE.toString(hoster, getEventName()));
        clickable.add(Language.EVENT_EVENT_CREATE_CLICKABLE_MESSAGE.toString(),
                Language.EVENT_EVENT_CREATE_CLICKABLE_HOVER.toString(), "/joinevent");
        broadcast(clickable);
        countdown(60);

        PlayerProfile.getProfiles().values().stream().filter(profile -> profile.getPlayer() != null
                && !profile.isSaving() && profile.getPlayerState() == PlayerState.IN_LOBBY)
                .forEach(profile -> profile.setupItems());
    }

    public static boolean isInEvent(Player player) {
        Party party = Party.getByPlayer(player);
        return isInEvent(party);
    }

    public static boolean isInEvent(Party party) {
        return party != null && onGoingEvent != null && onGoingEvent.getParties().contains(party);
    }

    public List<Player> getTotalPlayers() {
        List<Player> players = new ArrayList<>();
        parties.forEach(party -> players
                .addAll(party.getAllPartyMembers().stream().map(PartyMember::getPlayer).collect(Collectors.toList())));
        return players;
    }

    private String getPartyName(Party party) {
        return party.getLeader().getUsername()
                + (party.getPartyMembers().isEmpty() ? "" : Language.EVENT_PARTY_NAME_FORMAT.toString());
    }

    public void join(Party party) {
        parties.add(party);

        Clickable clickable = new Clickable(Language.EVENT_EVENT_JOIN_MESSAGE.toString(getPartyName(party),
                getEventName(), getTotalPlayers().size(), maxPlayers));
        clickable.add(Language.EVENT_EVENT_JOIN_CLICKABLE_MESSAGE.toString(),
                Language.EVENT_EVENT_JOIN_CLICKABLE_HOVER.toString(), "/joinevent");
        broadcast(clickable);

        EventJoinEvent event = new EventJoinEvent(party, this);
        event.call();

        if (getTotalPlayers().size() >= maxPlayers && state == EventState.WAITING) {
            broadcast(Language.EVENT_STARTING_FULL.toString());
            countdown(10);
        }
    }

    public void leave(Party party) {
        parties.remove(party);
        broadcast(Language.EVENT_EVENT_LEAVE_MESSAGE.toString(getPartyName(party), getEventName(),
                getTotalPlayers().size(), maxPlayers));
    }

    public void countdown(int seconds) {
        setCountdown(new EventCountdown(true, seconds, 45, 30, 15, 10, 5, 4, 3, 2, 1) {
            @Override
            public void runUnexpired(int tick) {
                Clickable clickable = new Clickable(
                        Language.EVENT_EVENT_START_COUNTDOWN_MESSAGE.toString(getEventName(), tick));
                clickable.add(Language.EVENT_EVENT_START_COUNTDOWN_CLICKABLE_MESSAGE.toString(),
                        Language.EVENT_EVENT_START_COUNTDOWN_CLICKABLE_HOVER.toString(), "/joinevent");
                broadcast(clickable);
            }

            @Override
            public void run() {
                if (getMinPlayers() > parties.size()) {
                    broadcast(Language.EVENT_CANCEL_NOT_ENOUGH_PLAYERS.toString());
                    destroy();
                    return;
                }
                start();
            }
        });
    }

    public void destroy() {
        if (countdown != null) {
            countdown.cancelCountdown();
            countdown = null;
        }
        if (bukkitListener != null) {
            HandlerList.unregisterAll(bukkitListener);
        }
        onGoingEvent = null;

        PlayerProfile.getProfiles().values().stream()
                .filter(profile -> profile.getPlayer() != null && !profile.isSaving()
                        && profile.getPlayerState() == PlayerState.IN_LOBBY)
                .forEach(profile -> profile.setupItems());
    }

    public void start() {
        state = EventState.RUNNING;
    }

    public void end(boolean forced) {
        state = EventState.ENDING;
        if (countdown != null) {
            countdown.cancelCountdown();
            countdown = null;
        }
    }

    public void eliminate(Party party) {
        parties.remove(party);
    }

    public void setCountdown(EventCountdown countdown) {
        if (this.countdown != null) {
            this.countdown.cancelCountdown();
        }
        this.countdown = countdown;
    }

    public abstract Listener constructListener();

    /**
     * The Scoreboard which displays to everyone who's in the lobby (Their profile
     * state should be IN_LOBBY)
     * 
     * @param player The player who will receive the scoreboard layout
     * @return A list of string which displays in the scoreboard
     */
    public abstract List<String> getLobbyScoreboard(Player player);

    /**
     * The Scoreboard which displays to players which is in the event when the event
     * is running or ending
     * 
     * @param player The player who will receive the scoreboard layout
     * @return A list of string which displays in the scoreboard
     */
    public abstract List<String> getInGameScoreboard(Player player);

    /**
     * Display the current event status
     * 
     * @param player The player who views the event status
     * @return A list of string which displays the current event status
     */
    public abstract List<String> getStatus(Player player);
}


Filename: .\main\java\rip\diamond\practice\events\EventCountdown.java
package rip.diamond.practice.events;

import org.bukkit.scheduler.BukkitRunnable;
import org.bukkit.scheduler.BukkitTask;
import rip.diamond.practice.Eden;
import rip.diamond.practice.profile.cooldown.Cooldown;
import rip.diamond.practice.util.Tasks;
import rip.diamond.practice.util.exception.PracticeUnexpectedException;

import java.util.Arrays;

public abstract class EventCountdown extends Cooldown {

    private final BukkitTask task;

    public EventCountdown(boolean async, int seconds, int... tick) {
        super(seconds);

        BukkitRunnable runnable = new BukkitRunnable() {
            @Override
            public void run() {
                if (isExpired()) {
                    runExpired();
                    cancel();
                    return;
                }
                if (Arrays.stream(tick).anyMatch(i -> i == getSecondsLeft())) {
                    runUnexpired(getSecondsLeft());
                }
            }
        };

        if (async) {
            task = runnable.runTaskTimerAsynchronously(Eden.INSTANCE, 20L, 20L);
        } else {
            task = runnable.runTaskTimer(Eden.INSTANCE, 20L, 20L);
        }
    }

    public abstract void runUnexpired(int tick);

    @Override
    public void runUnexpired() {
        throw new PracticeUnexpectedException("Please use runUnexpired(int) instead of runUnexpired()");
    }

    @Override
    public void runExpired() {
        EdenEvent.getOnGoingEvent().setCountdown(null);
        Tasks.run(EventCountdown.this::run);
    }

    @Override
    public void cancelCountdown() {
        super.cancelCountdown();
        task.cancel();
    }
}


Filename: .\main\java\rip\diamond\practice\events\EventState.java
package rip.diamond.practice.events;

public enum EventState {

    /**
     * Ë©≤Ê¥ªÂãïÊ≠£Âú®Á≠âÂæÖÁé©ÂÆ∂ÁöÑÂä†ÂÖ•
     */
    WAITING,

    /**
     * Ë©≤Ê¥ªÂãïÊ≠£Âú®ÈÅãË°å‰∏≠
     */
    RUNNING,

    /**
     * Ë©≤Ê¥ªÂãïÊ≠£Âú®ÁµêÊùü
     */
    ENDING

}


Filename: .\main\java\rip\diamond\practice\events\EventType.java
package rip.diamond.practice.events;

import lombok.AllArgsConstructor;
import lombok.Getter;
import org.bukkit.Material;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.events.impl.SumoEvent;
import rip.diamond.practice.events.impl.Tournament;

@Getter
@AllArgsConstructor
public enum EventType {

    TOURNAMENT(Material.DIAMOND_SWORD, Language.EVENT_TOURNAMENT_NAME.toString(), 2, 64, "eden.event.tournament", true, true, Tournament.class),
    SUMO_EVENT(Material.SLIME_BALL, Language.EVENT_SUMO_EVENT_NAME.toString(), 2, 64, "eden.event.sumo-event", false, true, SumoEvent.class),
    ;

    private final Material logo;
    private final String name;
    private final int defaultMinPlayers;
    private final int defaultMaxPlayers;
    private final String permission;
    private final boolean kit;
    private final boolean allowTeams;
    private final Class<?> clazz;

}


Filename: .\main\java\rip\diamond\practice\events\command\EventCommand.java
package rip.diamond.practice.events.command;

import org.bukkit.entity.Player;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.events.EdenEvent;
import rip.diamond.practice.events.EventState;
import rip.diamond.practice.events.menu.EventCreateMenu;
import rip.diamond.practice.util.Common;
import rip.diamond.practice.util.command.Command;
import rip.diamond.practice.util.command.CommandArgs;
import rip.diamond.practice.util.command.argument.CommandArguments;

public class EventCommand extends Command {
    @CommandArgs(name = "event")
    public void execute(CommandArguments command) {
        Player player = command.getPlayer();
        String[] args = command.getArgs();

        EdenEvent event = EdenEvent.getOnGoingEvent();

        if (args.length == 1) {
            if (args[0].equalsIgnoreCase("create")) {
                if (!player.hasPermission("eden.command.event.create")) {
                    Language.NO_PERMISSION.sendMessage(player);
                    return;
                }
                if (event != null) {
                    Language.EVENT_EVENT_IS_RUNNING.sendMessage(player);
                    return;
                }
                new EventCreateMenu().openMenu(player);
                return;
            } else if (args[0].equalsIgnoreCase("forcestart")) {
                if (!player.hasPermission("eden.command.event.forcestart")) {
                    Language.NO_PERMISSION.sendMessage(player);
                    return;
                }
                if (event == null) {
                    Language.EVENT_EVENT_IS_NOT_RUNNING.sendMessage(player);
                    return;
                }
                if (event.getState() != EventState.WAITING) {
                    Language.EVENT_EVENT_ALREADY_STARTED.sendMessage(player);
                    return;
                }
                event.start();
                return;
            } else if (args[0].equalsIgnoreCase("status")) {
                if (event == null) {
                    Language.EVENT_EVENT_IS_NOT_RUNNING.sendMessage(player);
                    return;
                }
                if (event.getStatus(player) == null) {
                    Language.EVENT_NO_AVAILABLE_STATUS.sendMessage(player);
                    return;
                }

                Common.sendMessage(player, event.getStatus(player));
                return;
            } else if (args[0].equalsIgnoreCase("cancel")) {
                if (!player.hasPermission("eden.command.event.cancel")) {
                    Language.NO_PERMISSION.sendMessage(player);
                    return;
                }
                if (event == null) {
                    Language.EVENT_EVENT_IS_NOT_RUNNING.sendMessage(player);
                    return;
                }
                event.end(true);
                return;
            }
        }
    }
}


Filename: .\main\java\rip\diamond\practice\events\command\JoinEventCommand.java
package rip.diamond.practice.events.command;

import org.bukkit.entity.Player;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.events.EdenEvent;
import rip.diamond.practice.events.EventState;
import rip.diamond.practice.party.Party;
import rip.diamond.practice.profile.PlayerProfile;
import rip.diamond.practice.profile.PlayerState;
import rip.diamond.practice.util.command.Command;
import rip.diamond.practice.util.command.CommandArgs;
import rip.diamond.practice.util.command.argument.CommandArguments;

public class JoinEventCommand extends Command {
    @CommandArgs(name = "joinevent")
    public void execute(CommandArguments command) {
        Player player = command.getPlayer();

        EdenEvent event = EdenEvent.getOnGoingEvent();

        if (event == null) {
            Language.EVENT_EVENT_IS_NOT_RUNNING.sendMessage(player);
            return;
        }
        if (event.getState() != EventState.WAITING) {
            Language.EVENT_EVENT_ALREADY_STARTED.sendMessage(player);
            return;
        }

        PlayerProfile profile = PlayerProfile.get(player);
        if (profile.getPlayerState() != PlayerState.IN_LOBBY) {
            Language.EVENT_WRONG_STATE.sendMessage(player);
            return;
        }

        Party party = Party.getByPlayer(player);
        if (party == null) {
            party = new Party(player, event.getTeamSize());
            Language.EVENT_AUTO_CREATE_PARTY_BECAUSE_NEED_A_PARTY.sendMessage(player);
        } else if (party.getAllPartyMembers().size() > event.getTeamSize()) {
            Language.EVENT_PARTY_SIZE_OVER.sendMessage(player, event.getTeamSize());
            return;
        } else if (party.getMaxSize() != event.getTeamSize()) {
            party.setMaxSize(event.getTeamSize());
            Language.EVENT_AUTO_SET_PARTY_SIZE.sendMessage(player, party.getMaxSize());
        }

        event.join(party);
        return;
    }
}


Filename: .\main\java\rip\diamond\practice\events\impl\SumoEvent.java
package rip.diamond.practice.events.impl;

import com.google.common.collect.ImmutableList;
import lombok.Getter;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.Listener;
import org.bukkit.event.entity.EntityDamageEvent;
import org.bukkit.event.player.PlayerMoveEvent;
import org.bukkit.scheduler.BukkitRunnable;
import rip.diamond.practice.Eden;
import rip.diamond.practice.EdenPlaceholder;
import rip.diamond.practice.config.Config;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.arenas.Arena;
import rip.diamond.practice.arenas.ArenaDetail;
import rip.diamond.practice.event.MatchPlayerDeathEvent;
import rip.diamond.practice.event.MatchRoundStartEvent;
import rip.diamond.practice.event.PartyDisbandEvent;
import rip.diamond.practice.events.EdenEvent;
import rip.diamond.practice.events.EventCountdown;
import rip.diamond.practice.events.EventState;
import rip.diamond.practice.events.EventType;
import rip.diamond.practice.kits.Kit;
import rip.diamond.practice.match.Match;
import rip.diamond.practice.match.impl.SumoEventMatch;
import rip.diamond.practice.match.team.Team;
import rip.diamond.practice.match.team.TeamPlayer;
import rip.diamond.practice.party.Party;
import rip.diamond.practice.party.PartyMember;
import rip.diamond.practice.profile.PlayerProfile;
import rip.diamond.practice.profile.PlayerState;
import rip.diamond.practice.util.Util;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Random;
import java.util.stream.Collectors;

@Getter
public class SumoEvent extends EdenEvent {

    private SumoEventState sumoEventState = SumoEventState.NONE;
    private SumoEventMatch match;
    private int round = 0;
    private Team teamA, teamB;

    public SumoEvent(String hoster, int minPlayers, int maxPlayers, int teamSize) {
        super(hoster, EventType.SUMO_EVENT, minPlayers, maxPlayers, teamSize);
    }

    private boolean canEnd() {
        return getState() == EventState.RUNNING && getParties().size() <= 1;
    }

    public boolean isFighting(Team team) {
        return teamA == team || teamB == team;
    }

    @Override
    public Listener constructListener() {
        return new Listener() {
            //Use this event as detecting when the match start countdown is ended
            @EventHandler
            public void onStart(MatchRoundStartEvent event) {
                if (event.getMatch() == match) {
                    startNewRound();
                }
            }

            @EventHandler
            public void onMove(PlayerMoveEvent event) {
                Player player = event.getPlayer();
                PlayerProfile profile = PlayerProfile.get(player);

                if (profile.getPlayerState() == PlayerState.IN_MATCH && profile.getMatch() != null && profile.getMatch() instanceof SumoEventMatch) {
                    Match match = profile.getMatch();
                    Team team = match.getTeam(player);

                    if (isFighting(team) && sumoEventState == SumoEventState.STARTING_NEW_ROUND) {
                        Util.teleport(player, event.getFrom());
                    }
                }
            }

            @EventHandler
            public void onDamage(EntityDamageEvent event) {
                if (!(event.getEntity() instanceof Player)) {
                    return;
                }
                Player player = (Player) event.getEntity();
                PlayerProfile profile = PlayerProfile.get(player);

                if (profile.getPlayerState() == PlayerState.IN_MATCH && profile.getMatch() != null && profile.getMatch() instanceof SumoEventMatch) {
                    Match match = profile.getMatch();
                    Team team = match.getTeam(player);
                    TeamPlayer teamPlayer = match.getTeamPlayer(player);

                    if (!isFighting(team)) {
                        event.setCancelled(true);
                        return;
                    }

                    event.setDamage(0);
                }
            }

            @EventHandler
            public void onDeath(MatchPlayerDeathEvent event) {
                Player player = event.getPlayer();
                PlayerProfile profile = PlayerProfile.get(player);

                if (profile.getPlayerState() == PlayerState.IN_MATCH && profile.getMatch() != null && profile.getMatch() instanceof SumoEventMatch) {
                    Match match = profile.getMatch();
                    Team team = match.getTeam(player);
                    TeamPlayer teamPlayer = match.getTeamPlayer(player);

                    if (team.isEliminated()) {
                        broadcast(Language.EVENT_SUMO_EVENT_MATCH_END_MESSAGE.toString(match.getOpponentTeam(team).getLeader().getUsername(), team.getLeader().getUsername()));

                        Party party = Party.getByPlayer(team.getLeader().getPlayer());
                        //Â¶ÇÊûúÁé©ÂÆ∂Âú®Êà∞È¨•ÊôÇÈÄÄÂá∫‰º∫ÊúçÂô®ÁöÑË©±, Party ÂèØËÉΩÊúÉÊòØnull
                        if (party != null) {
                            eliminate(party);
                        }

                        if (canEnd()) {
                            end(false);
                            return;
                        }
                    }
                }
            }

            @EventHandler
            public void onDisband(PartyDisbandEvent event) {
                if (canEnd()) {
                    end(false);
                }
            }
        };
    }

    @Override
    public List<String> getLobbyScoreboard(Player player) {
        /*
         * Â¶ÇÊûú sumoEventState == SumoEventState.NONE, ÊÑèÊÄùÂ∞±ÊòØÁõ∏Êí≤ÊØîË≥ΩÈÇÑÊ≤íÈñãÂßã
         * ÈÄôÂÄãÊÉÖÊ≥Å‰∏ã, getState() ÊáâË©≤ÊúÉÂõûÂÇ≥ EventState.WAITING
         */
        if (sumoEventState == SumoEventState.NONE) {
            return Language.EVENT_SUMO_EVENT_LOBBY_SCOREBOARD_STARTING_EVENT.toStringList(player);
        }
        /*
         * Â¶ÇÊûú sumoEventState == SumoEventState.STARTING_NEW_ROUND ÊàñËÄÖ SumoEventState.FIGHTING, ÊÑèÊÄùÂ∞±ÊòØÁõ∏Êí≤ÊØîË≥ΩÂõûÂêàÂ∑≤Á∂ìÈñãÂßã, Ê¥ªÂãïÂÖßÁöÑÁé©ÂÆ∂Ê≠£Âú®Êà∞È¨•‰∏≠
         * ÈÄôÂÄãÊÉÖÊ≥Å‰∏ã, getState() ÊáâË©≤ÊúÉÂõûÂÇ≥ EventState.RUNNING
         */
        if (sumoEventState == SumoEventState.STARTING_NEW_ROUND || sumoEventState == SumoEventState.FIGHTING) {
            return Language.EVENT_SUMO_EVENT_LOBBY_SCOREBOARD_FIGHTING.toStringList(player, round, teamA.getLeader().getUsername(), teamB.getLeader().getUsername());
        }
        return ImmutableList.of(EdenPlaceholder.SKIP_LINE);
    }

    @Override
    public List<String> getInGameScoreboard(Player player) {
        if (state == EventState.RUNNING) {
            /*
             * Â¶ÇÊûú sumoEventState == SumoEventState.NONE, ÊÑèÊÄùÂ∞±ÊòØÁõ∏Êí≤ÊØîË≥ΩÈÇÑÊ≤íÈñãÂßã
             * ÈÄôÂÄãÊÉÖÊ≥Å‰∏ã, getState() ÊáâË©≤ÊúÉÂõûÂÇ≥ EventState.WAITING
             */
            if (sumoEventState == SumoEventState.NONE) {
                return Language.EVENT_SUMO_EVENT_IN_GAME_SCOREBOARD_STARTING_MATCH.toStringList(player);
            }
            /*
             * Â¶ÇÊûú sumoEventState == SumoEventState.STARTING_NEW_ROUND ÊàñËÄÖ SumoEventState.FIGHTING, ÊÑèÊÄùÂ∞±ÊòØÁõ∏Êí≤ÊØîË≥ΩÂõûÂêàÂ∑≤Á∂ìÈñãÂßã, Ê¥ªÂãïÂÖßÁöÑÁé©ÂÆ∂Ê≠£Âú®Êà∞È¨•‰∏≠
             * ÈÄôÂÄãÊÉÖÊ≥Å‰∏ã, getState() ÊáâË©≤ÊúÉÂõûÂÇ≥ EventState.RUNNING
             *
             * ÈÄôË£èÊØîËºÉÁâπÂà•, Âõ†ÁÇ∫ÊØèËº™Êà∞È¨•ÁµêÊùüÁöÑÊôÇÂÄô, sumoEventState ÈÉΩÊúÉÊòØ SumoEventState.ENDING, ‰∏ç‰ª£Ë°®Êï¥ÂÄãÊ¥ªÂãïÂ∑≤Á∂ìÁµêÊùü, ÊâÄ‰ª•Áï∂ sumoEventState == SumoEventState.ENDING ÊàëÂÄë‰πüÂèØ‰ª•È°ØÁ§∫Ê≠£Âú®Êà∞È¨•ÁöÑË®àÂàÜÁâà
             */
            if (sumoEventState == SumoEventState.STARTING_NEW_ROUND || sumoEventState == SumoEventState.FIGHTING || sumoEventState == SumoEventState.ENDING) {
                return Language.EVENT_SUMO_EVENT_IN_GAME_SCOREBOARD_FIGHTING.toStringList(player, getTeamName(teamA), getTeamName(teamB));
            }
        }

        //ÈÄôË£èÂ∞±ÊòØ‰ª£Ë°®Êï¥ÂÄãÊ¥ªÂãïÂ∑≤Á∂ìÁµêÊùüÁöÑÊôÇÂÄôË¶ÅÈ°ØÁ§∫ÁöÑÊù±Ë•ø
        if (state == EventState.ENDING) {
            return Language.EVENT_SUMO_EVENT_IN_GAME_SCOREBOARD_ENDING.toStringList(player);
        }
        return null;
    }

    @Override
    public List<String> getStatus(Player player) {
        /*
         * Â¶ÇÊûú tournamentState == TournamentState.NONE, ÊÑèÊÄùÂ∞±ÊòØÈå¶Ê®ôË≥ΩÈÇÑÊ≤íÈñãÂßã
         * ÈÄôÂÄãÊÉÖÊ≥Å‰∏ã, getState() ÊáâË©≤ÊúÉÂõûÂÇ≥ EventState.WAITING
         */
        if (sumoEventState == SumoEventState.NONE) {
            return Language.EVENT_TOURNAMENT_STATUS_STARTING_EVENT.toStringList(player, getUncoloredEventName());
        }
        /*
         * Â¶ÇÊûú tournamentState == TournamentState.STARTING_NEW_ROUND, ÊÑèÊÄùÂ∞±ÊòØÈå¶Ê®ôË≥ΩÊ≠£Âú®Ê∫ñÂÇôÈñãÂßãÊñ∞ÁöÑ‰∏ÄÂÄãÂõûÂêà
         * ÈÄôÂÄãÊÉÖÊ≥Å‰∏ã, getState() ÊáâË©≤ÊúÉÂõûÂÇ≥ EventState.RUNNING
         */
        else if (sumoEventState == SumoEventState.STARTING_NEW_ROUND) {
            return Language.EVENT_TOURNAMENT_STATUS_STARTING_NEW_ROUND.toStringList(player, getUncoloredEventName(), round);
        }
        /*
         * Â¶ÇÊûú tournamentState == TournamentState.FIGHTING, ÊÑèÊÄùÂ∞±ÊòØÈå¶Ê®ôË≥ΩÂõûÂêàÂ∑≤Á∂ìÈñãÂßã, Ê¥ªÂãïÂÖßÁöÑÁé©ÂÆ∂Ê≠£Âú®Êà∞È¨•‰∏≠
         * ÈÄôÂÄãÊÉÖÊ≥Å‰∏ã, getState() ÊáâË©≤ÊúÉÂõûÂÇ≥ EventState.RUNNING
         */
        else if (sumoEventState == SumoEventState.FIGHTING) {
            return Language.EVENT_TOURNAMENT_STATUS_FIGHTING.toStringList(player, getUncoloredEventName(), round, getTeamName(teamA), getTeamName(teamB));
        } else return null;
    }

    @Override
    public void start() {
        super.start();

        String kitName = Config.EVENT_SUMO_EVENT_KIT.toString();
        Kit kit = Kit.getByName(kitName);
        if (kit == null) {
            broadcastToEventPlayers("&c[Eden] Unable to find a kit named " + kitName + ", please contact an administrator.");
            end(true);
            return;
        }
        List<String> arenaNames = Config.EVENT_SUMO_EVENT_ARENAS.toStringList();
        Arena arena = Arena.getArena(arenaNames.get(new Random().nextInt(arenaNames.size())));
        ArenaDetail arenaDetail = Arena.getArenaDetail(arena);
        if (arenaDetail == null) {
            broadcastToEventPlayers("&c[Eden] Unable to find a usable arena, please contact an administrator.");
            end(true);
            return;
        }
        List<Team> teams = new ArrayList<>();
        parties.forEach(party -> party.getAllPartyMembers().forEach(partyMember -> teams.add(new Team(new TeamPlayer(partyMember.getPlayer())))));
        match = new SumoEventMatch(this, arenaDetail, kit, teams);
        match.start();

        if (canEnd()) {
            end(false);
            return;
        }
    }

    @Override
    public void end(boolean forced) {
        super.end(forced);
        sumoEventState = SumoEventState.ENDING;

        if (forced) {
            broadcast(Language.EVENT_FORCE_CANCEL_EVENT.toString(getEventType().getName()));
            //This line of code has to be run in the last. This is to unregister the events
            destroy();
            return;
        }

        if (getParties().isEmpty()) {
            broadcast(Language.EVENT_NO_WINNER_BECAUSE_NO_PARTY.toString());
            //This line of code has to be run in the last. This is to unregister the events
            destroy();
            return;
        }

        new BukkitRunnable() {
            private final String winners = getParties().get(0).getAllPartyMembers().stream().map(PartyMember::getUsername).collect(Collectors.joining(Language.EVENT_WINNER_ANNOUNCE_SPLIT_FORMAT.toString()));
            private int count = 5;
            @Override
            public void run() {
                if (count == 0) {
                    cancel();
                    //This line of code has to be run in the last. This is to unregister the events
                    destroy();
                } else {
                    broadcast(Language.EVENT_WINNER_ANNOUNCE_MESSAGE.toString(winners));
                    count--;
                }
            }
        }.runTaskTimer(Eden.INSTANCE, 0L, 20L);
    }

    private void startNewRound() {
        round++;

        List<Team> teams = match.getTeams().stream().filter(team -> !team.isEliminated()).collect(Collectors.toList());
        Collections.shuffle(teams);
        teamA = teams.get(0);
        teamB = teams.get(1);

        teamA.teleport(match.getArenaDetail().getA());
        teamB.teleport(match.getArenaDetail().getB());

        //We need to set the teamA and teamB first before setting the SumoEventState. This is to prevent scoreboard throw an NPE error.
        sumoEventState = SumoEventState.STARTING_NEW_ROUND;

        setCountdown(new EventCountdown(false,5, 5,4,3,2,1) {
            @Override
            public void runUnexpired(int tick) {
                broadcastToEventPlayers(Language.EVENT_SUMO_EVENT_NEW_ROUND_COUNTDOWN.toString(round, tick));
            }
            @Override
            public void runExpired() {
                sumoEventState = SumoEventState.FIGHTING;
                broadcastToEventPlayers(Language.EVENT_SUMO_EVENT_NEW_ROUND_STARTED.toString());
            }
        });
    }

    @Override
    public void eliminate(Party party) {
        super.eliminate(party);
        sumoEventState = SumoEventState.ENDING;

        party.teleport(match.getArenaDetail().getSpectator());

        setCountdown(new EventCountdown(true, 3) {
            @Override
            public void runUnexpired(int tick) {

            }

            @Override
            public void runExpired() {
                if (canEnd()) {
                    end(false);
                    return;
                }
                startNewRound();
            }
        });
    }

    enum SumoEventState {
        NONE,
        STARTING_NEW_ROUND,
        FIGHTING,
        ENDING
    }
}


Filename: .\main\java\rip\diamond\practice\events\impl\Tournament.java
package rip.diamond.practice.events.impl;

import com.google.common.collect.ImmutableList;
import lombok.Getter;
import org.apache.commons.lang.StringUtils;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.Listener;
import org.bukkit.scheduler.BukkitRunnable;
import rip.diamond.practice.Eden;
import rip.diamond.practice.EdenPlaceholder;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.arenas.Arena;
import rip.diamond.practice.arenas.ArenaDetail;
import rip.diamond.practice.event.MatchEndEvent;
import rip.diamond.practice.event.PartyDisbandEvent;
import rip.diamond.practice.events.EdenEvent;
import rip.diamond.practice.events.EventCountdown;
import rip.diamond.practice.events.EventState;
import rip.diamond.practice.events.EventType;
import rip.diamond.practice.kits.Kit;
import rip.diamond.practice.match.Match;
import rip.diamond.practice.match.impl.SoloMatch;
import rip.diamond.practice.match.impl.TeamMatch;
import rip.diamond.practice.match.team.Team;
import rip.diamond.practice.match.team.TeamPlayer;
import rip.diamond.practice.party.Party;
import rip.diamond.practice.party.PartyMember;
import rip.diamond.practice.queue.QueueType;
import rip.diamond.practice.util.Tasks;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;

@Getter
public class Tournament extends EdenEvent {

    private final Kit kit;
    private final List<Match> matches = new ArrayList<>();
    private TournamentState tournamentState = TournamentState.NONE;
    private int round = 0;

    public Tournament(String hoster, int minPlayers, int maxPlayers, Kit kit, int teamSize) {
        super(hoster, EventType.TOURNAMENT, minPlayers, maxPlayers, teamSize);

        this.kit = kit;
    }

    @Override
    public String getEventName() {
        return getTeamSize() + "v" + getTeamSize() + " " + getKit().getDisplayName() + " " + getEventType().getName();
    }

    private boolean canEnd() {
        return getState() == EventState.RUNNING && getParties().size() <= 1;
    }

    @Override
    public Listener constructListener() {
        return new Listener() {
            @EventHandler
            public void onMatchEnd(MatchEndEvent event) {
                Match match = event.getMatch();
                if (matches.contains(match)) {
                    matches.remove(match);

                    Team winner = match.getWinningTeam();
                    Team loser = match.getOpponentTeam(winner);

                    broadcast(Language.EVENT_TOURNAMENT_MATCH_END_MESSAGE.toString(getTeamName(winner), getTeamName(loser), matches.size()));

                    Party party = Party.getByPlayer(loser.getLeader().getPlayer());
                    //Â¶ÇÊûúÁé©ÂÆ∂Âú®Êà∞È¨•ÊôÇÈÄÄÂá∫‰º∫ÊúçÂô®ÁöÑË©±, Party ÂèØËÉΩÊúÉÊòØnull
                    if (party != null) {
                        eliminate(party);
                    }

                    if (canEnd()) {
                        end(false);
                        return;
                    }

                    if (matches.isEmpty()) {
                        startNewRound();
                    }
                }
            }

            @EventHandler
            public void onDisband(PartyDisbandEvent event) {
                if (canEnd()) {
                    end(false);
                }
            }
        };
    }

    @Override
    public List<String> getLobbyScoreboard(Player player) {
        /*
         * Â¶ÇÊûú tournamentState == TournamentState.NONE, ÊÑèÊÄùÂ∞±ÊòØÈå¶Ê®ôË≥ΩÈÇÑÊ≤íÈñãÂßã
         * ÈÄôÂÄãÊÉÖÊ≥Å‰∏ã, getState() ÊáâË©≤ÊúÉÂõûÂÇ≥ EventState.WAITING
         */
        if (tournamentState == TournamentState.NONE) {
            return Language.EVENT_TOURNAMENT_SCOREBOARD_STARTING_EVENT.toStringList(player);
        }
        /*
         * Â¶ÇÊûú tournamentState == TournamentState.STARTING_NEW_ROUND, ÊÑèÊÄùÂ∞±ÊòØÈå¶Ê®ôË≥ΩÊ≠£Âú®Ê∫ñÂÇôÈñãÂßãÊñ∞ÁöÑ‰∏ÄÂÄãÂõûÂêà
         * ÈÄôÂÄãÊÉÖÊ≥Å‰∏ã, getState() ÊáâË©≤ÊúÉÂõûÂÇ≥ EventState.RUNNING
         */
        if (tournamentState == TournamentState.STARTING_NEW_ROUND) {
            return Language.EVENT_TOURNAMENT_SCOREBOARD_STARTING_NEW_ROUND.toStringList(player, round);
        }
        /*
         * Â¶ÇÊûú tournamentState == TournamentState.FIGHTING, ÊÑèÊÄùÂ∞±ÊòØÈå¶Ê®ôË≥ΩÂõûÂêàÂ∑≤Á∂ìÈñãÂßã, Ê¥ªÂãïÂÖßÁöÑÁé©ÂÆ∂Ê≠£Âú®Êà∞È¨•‰∏≠
         * ÈÄôÂÄãÊÉÖÊ≥Å‰∏ã, getState() ÊáâË©≤ÊúÉÂõûÂÇ≥ EventState.RUNNING
         */
        if (tournamentState == TournamentState.FIGHTING) {
            return Language.EVENT_TOURNAMENT_SCOREBOARD_FIGHTING.toStringList(player, round, matches.size());
        }
        return ImmutableList.of(EdenPlaceholder.SKIP_LINE);
    }

    @Override
    public List<String> getInGameScoreboard(Player player) {
        return null;
    }

    @Override
    public List<String> getStatus(Player player) {
        /*
         * Â¶ÇÊûú tournamentState == TournamentState.NONE, ÊÑèÊÄùÂ∞±ÊòØÈå¶Ê®ôË≥ΩÈÇÑÊ≤íÈñãÂßã
         * ÈÄôÂÄãÊÉÖÊ≥Å‰∏ã, getState() ÊáâË©≤ÊúÉÂõûÂÇ≥ EventState.WAITING
         */
        if (tournamentState == TournamentState.NONE) {
            return Language.EVENT_SUMO_EVENT_STATUS_STARTING_EVENT.toStringList(player, getUncoloredEventName());
        }
        /*
         * Â¶ÇÊûú tournamentState == TournamentState.STARTING_NEW_ROUND, ÊÑèÊÄùÂ∞±ÊòØÈå¶Ê®ôË≥ΩÊ≠£Âú®Ê∫ñÂÇôÈñãÂßãÊñ∞ÁöÑ‰∏ÄÂÄãÂõûÂêà
         * ÈÄôÂÄãÊÉÖÊ≥Å‰∏ã, getState() ÊáâË©≤ÊúÉÂõûÂÇ≥ EventState.RUNNING
         */
        else if (tournamentState == TournamentState.STARTING_NEW_ROUND) {
            return Language.EVENT_SUMO_EVENT_STATUS_STARTING_NEW_ROUND.toStringList(player, getUncoloredEventName(), round);
        }
        /*
         * Â¶ÇÊûú tournamentState == TournamentState.FIGHTING, ÊÑèÊÄùÂ∞±ÊòØÈå¶Ê®ôË≥ΩÂõûÂêàÂ∑≤Á∂ìÈñãÂßã, Ê¥ªÂãïÂÖßÁöÑÁé©ÂÆ∂Ê≠£Âú®Êà∞È¨•‰∏≠
         * ÈÄôÂÄãÊÉÖÊ≥Å‰∏ã, getState() ÊáâË©≤ÊúÉÂõûÂÇ≥ EventState.RUNNING
         */
        else if (tournamentState == TournamentState.FIGHTING) {
            List<String> listOfFightingPlayers = new ArrayList<>();

            for (Match match : matches) {
                String team1 = match.getTeams().get(0).getTeamPlayers().stream().map(TeamPlayer::getUsername).collect(Collectors.joining(", "));
                String team2 = match.getTeams().get(1).getTeamPlayers().stream().map(TeamPlayer::getUsername).collect(Collectors.joining(", "));
                listOfFightingPlayers.add(Language.EVENT_TOURNAMENT_STATUS_FIGHTING_TEAM_FORMAT.toString(team1, team2));
            }

            return Language.EVENT_SUMO_EVENT_STATUS_FIGHTING.toStringList(player, getUncoloredEventName(), round, StringUtils.join(listOfFightingPlayers, EdenPlaceholder.NEW_LINE));
        } else return null;
    }

    @Override
    public void start() {
        super.start();

        if (canEnd()) {
            end(false);
            return;
        }

        startNewRound();
    }

    @Override
    public void end(boolean forced) {
        super.end(forced);
        tournamentState = TournamentState.ENDING;

        if (forced) {
            broadcast(Language.EVENT_FORCE_CANCEL_EVENT.toString(getEventType().getName()));
            //This line of code has to be run in the last. This is to unregister the events
            destroy();
            return;
        }

        if (getParties().isEmpty()) {
            broadcast(Language.EVENT_NO_WINNER_BECAUSE_NO_PARTY.toString());
            //This line of code has to be run in the last. This is to unregister the events
            destroy();
            return;
        }

        new BukkitRunnable() {
            private final String winners = getParties().get(0).getAllPartyMembers().stream().map(PartyMember::getUsername).collect(Collectors.joining(Language.EVENT_WINNER_ANNOUNCE_SPLIT_FORMAT.toString()));
            private int count = 5;
            @Override
            public void run() {
                if (count == 0) {
                    cancel();
                    //This line of code has to be run in the last. This is to unregister the events
                    destroy();
                } else {
                    broadcast(Language.EVENT_WINNER_ANNOUNCE_MESSAGE.toString(winners));
                    count--;
                }
            }
        }.runTaskTimer(Eden.INSTANCE, 0L, 20L);
    }

    private void startNewRound() {
        round++;
        tournamentState = TournamentState.STARTING_NEW_ROUND;
        setCountdown(new EventCountdown(false,30, 30,20,15,10,5,4,3,2,1) {
            @Override
            public void runUnexpired(int tick) {
                broadcast(Language.EVENT_TOURNAMENT_NEW_ROUND_COUNTDOWN.toString(round, tick));
            }

            @Override
            public void runExpired() {
                broadcast(Language.EVENT_TOURNAMENT_NEW_ROUND_START.toStringList(round));

                List<Party> matchParties = new ArrayList<>(getParties());
                Collections.shuffle(matchParties);

                while (matchParties.size() > 1) {
                    Party party1 = matchParties.remove(0);
                    Party party2 = matchParties.remove(0);

                    ArenaDetail arena = Arena.getAvailableArenaDetail(kit);
                    if (arena == null) {
                        //This should not happen if the server has enough arena. But just in case.
                        party1.broadcast(Language.EVENT_TOURNAMENT_NEW_ROUND_NO_AVAILABLE_ARENA.toString());
                        party2.broadcast(Language.EVENT_TOURNAMENT_NEW_ROUND_NO_AVAILABLE_ARENA.toString());
                        continue;
                    }

                    Team team1 = new Team(new TeamPlayer(party1.getLeader().getPlayer()));
                    Team team2 = new Team(new TeamPlayer(party2.getLeader().getPlayer()));
                    Match match;
                    if (getTeamSize() == 1) {
                        match = new SoloMatch(arena, kit, team1, team2, QueueType.UNRANKED, true);
                    } else {
                        team1.getTeamPlayers().addAll(party1.getPartyMembers().stream().map(partyMember -> new TeamPlayer(partyMember.getPlayer())).collect(Collectors.toList()));
                        team2.getTeamPlayers().addAll(party2.getPartyMembers().stream().map(partyMember -> new TeamPlayer(partyMember.getPlayer())).collect(Collectors.toList()));
                        match = new TeamMatch(arena, kit, team1, team2);
                    }
                    match.start();
                    matches.add(match);
                }

                if (matchParties.size() == 1) {
                    matchParties.get(0).broadcast(Language.EVENT_TOURNAMENT_NEW_ROUND_AUTO_PROMOTION.toString());
                }

                tournamentState = TournamentState.FIGHTING;
            }
        });
    }

    enum TournamentState {
        NONE,
        STARTING_NEW_ROUND,
        FIGHTING,
        ENDING
    }
}


Filename: .\main\java\rip\diamond\practice\events\listener\EventListener.java
package rip.diamond.practice.events.listener;

import com.google.common.collect.ImmutableList;
import lombok.RequiredArgsConstructor;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.Listener;
import org.bukkit.event.player.PlayerCommandPreprocessEvent;
import rip.diamond.practice.Eden;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.event.MatchStartEvent;
import rip.diamond.practice.event.PartyDisbandEvent;
import rip.diamond.practice.event.PartyJoinEvent;
import rip.diamond.practice.events.EdenEvent;
import rip.diamond.practice.events.EventState;
import rip.diamond.practice.match.Match;
import rip.diamond.practice.party.Party;

import java.util.List;

@RequiredArgsConstructor
public class EventListener implements Listener {

    private final Eden plugin;

    @EventHandler
    public void onCommand(PlayerCommandPreprocessEvent event) {
        Player player = event.getPlayer();
        EdenEvent edenEvent = EdenEvent.getOnGoingEvent();
        if (edenEvent == null) {
            return;
        }

        Party party = Party.getByPlayer(player);
        if (party == null) {
            return;
        }

        List<String> bypassCommand = ImmutableList.of(
                "/test",
                "/settings",
                "/editkits",
                "/party list",
                "/party disband",
                "/party leave",
                "/event",
                "/viewinventory"
        );
        for (String cmd : bypassCommand) {
            String message = event.getMessage().toLowerCase().replace("eden:", "");
            if (message.startsWith(cmd)) {
                return;
            }
        }

        if (edenEvent.getParties().contains(party)) {
            Language.EVENT_CANNOT_USE_THIS_COMMAND.sendMessage(player);
            event.setCancelled(true);
        }
    }

    @EventHandler
    public void onDisband(PartyDisbandEvent event) {
        Party party = event.getParty();
        EdenEvent edenEvent = EdenEvent.getOnGoingEvent();
        if (edenEvent == null) {
            return;
        }
        if (edenEvent.getParties().contains(party)) {
            edenEvent.getParties().remove(party);
            party.broadcast(Language.EVENT_LEAVE_EVENT_BECAUSE_PARTY_DISBAND.toString());
        }
    }

    @EventHandler
    public void onJoinParty(PartyJoinEvent event) {
        Party party = event.getParty();
        EdenEvent edenEvent = EdenEvent.getOnGoingEvent();
        if (edenEvent == null) {
            return;
        }

        if (edenEvent.getParties().contains(party)) {
            event.setCancelled(true, Language.EVENT_CANNOT_JOIN_PARTY_BECAUSE_IN_EVENT.toString());
        }
    }

    @EventHandler
    public void onMatchStart(MatchStartEvent event) {
        Match match = event.getMatch();
        EdenEvent edenEvent = EdenEvent.getOnGoingEvent();
        if (edenEvent != null && (edenEvent.getState() == EventState.WAITING)) {
            match.getMatchPlayers().forEach(player -> {
                Party party = Party.getByPlayer(player);
                boolean exists = edenEvent.getParties().removeIf(p -> p == party);
                if (exists) {
                    party.broadcast("&cÈåØË™§: ‰Ω†Â∑≤Ë¢´Êú¨Ê¥ªÂãïÁßªÈô§", "&cÈÄôÊòØ‰∏ÄÂÄãÁ≥ªÁµ±ÈåØË™§, Ë´ãÂõûÂ†±Áµ¶Á≥ªÁµ±ÁÆ°ÁêÜÂì°");
                }
            });
        }
    }

}


Filename: .\main\java\rip\diamond\practice\events\menu\EventCreateMenu.java
package rip.diamond.practice.events.menu;

import org.bukkit.Material;
import org.bukkit.entity.Player;
import org.bukkit.event.inventory.ClickType;
import org.bukkit.inventory.ItemStack;
import rip.diamond.practice.Eden;
import rip.diamond.practice.events.EventType;
import rip.diamond.practice.util.BasicConfigFile;
import rip.diamond.practice.util.CC;
import rip.diamond.practice.util.ItemBuilder;
import rip.diamond.practice.util.menu.Button;
import rip.diamond.practice.util.menu.Menu;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class EventCreateMenu extends Menu {
    @Override
    public String getTitle(Player player) {
        BasicConfigFile config = Eden.INSTANCE.getMenusConfig().getConfig();
        return CC.translate(config.getString("event-create-menu.title"));
    }

    @Override
    public int getSize() {
        BasicConfigFile config = Eden.INSTANCE.getMenusConfig().getConfig();
        return config.getInt("event-create-menu.size");
    }

    @Override
    public Map<Integer, Button> getButtons(Player player) {
        final Map<Integer, Button> buttons = new HashMap<>();
        BasicConfigFile config = Eden.INSTANCE.getMenusConfig().getConfig();

        // Filler
        if (config.getBoolean("event-create-menu.filler.enabled")) {
            ItemStack filler = new ItemBuilder(Material.valueOf(config.getString("event-create-menu.filler.material")))
                    .durability(config.getInt("event-create-menu.filler.data"))
                    .name(" ")
                    .build();
            for (int i = 0; i < getSize(); i++) {
                buttons.put(i, new Button() {
                    @Override
                    public ItemStack getButtonItem(Player player) {
                        return filler;
                    }
                });
            }
        }

        // Border
        if (config.getBoolean("event-create-menu.border.enabled")) {
            ItemStack border = new ItemBuilder(Material.valueOf(config.getString("event-create-menu.border.material")))
                    .durability(config.getInt("event-create-menu.border.data"))
                    .name(" ")
                    .build();
            int size = getSize();
            for (int i = 0; i < size; i++) {
                if (i < 9 || i >= size - 9 || i % 9 == 0 || i % 9 == 8) {
                    buttons.put(i, new Button() {
                        @Override
                        public ItemStack getButtonItem(Player player) {
                            return border;
                        }
                    });
                }
            }
        }

        // Event type buttons
        int slotIndex = 0;
        for (EventType eventType : EventType.values()) {
            // Find next available slot (skip border)
            int slot = -1;
            for (int i = 0; i < getSize(); i++) {
                if (!buttons.containsKey(i) || !(i < 9 || i >= getSize() - 9 || i % 9 == 0 || i % 9 == 8)) {
                    if (slotIndex == 0 || !buttons.containsKey(i)) {
                        slot = i;
                        slotIndex++;
                        break;
                    }
                }
            }

            if (slot == -1)
                continue; // No more space

            final int finalSlot = slot;
            buttons.put(finalSlot, new Button() {
                @Override
                public ItemStack getButtonItem(Player player) {
                    String name = config.getString("event-create-menu.items.event-button.name")
                            .replace("{event-name}", eventType.getName());

                    List<String> lore;
                    if (player.hasPermission(eventType.getPermission())) {
                        lore = config.getStringList("event-create-menu.items.event-button.lore-has-permission");
                    } else {
                        lore = config.getStringList("event-create-menu.items.event-button.lore-no-permission");
                    }

                    return new ItemBuilder(eventType.getLogo())
                            .name(name)
                            .lore(lore)
                            .build();
                }

                @Override
                public void clicked(Player player, ClickType clickType) {
                    if (!player.hasPermission(eventType.getPermission())) {
                        List<String> noPermLore = config
                                .getStringList("event-create-menu.items.event-button.lore-no-permission");
                        if (!noPermLore.isEmpty()) {
                            player.sendMessage(CC.translate(noPermLore.get(noPermLore.size() - 1)));
                        }
                        return;
                    }
                    new EventSettingsMenu(eventType).openMenu(player);
                }
            });
        }

        return buttons;
    }
}


Filename: .\main\java\rip\diamond\practice\events\menu\EventSelectKitMenu.java
package rip.diamond.practice.events.menu;

import lombok.RequiredArgsConstructor;
import org.bukkit.entity.Player;
import org.bukkit.event.inventory.ClickType;
import org.bukkit.inventory.ItemStack;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.kits.Kit;
import rip.diamond.practice.kits.KitMatchType;
import rip.diamond.practice.util.ItemBuilder;
import rip.diamond.practice.util.menu.Button;
import rip.diamond.practice.util.menu.Menu;

import java.util.HashMap;
import java.util.Map;

@RequiredArgsConstructor
public class EventSelectKitMenu extends Menu {
    private final EventSettingsMenu backMenu;

    @Override
    public String getTitle(Player player) {
        return Language.EVENT_EVENT_SELECT_KIT_MENU_TITLE.toString(player);
    }

    @Override
    public Map<Integer, Button> getButtons(Player player) {
        final Map<Integer, Button> buttons = new HashMap<>();

        Kit.getKits().stream()
                .filter(Kit::isEnabled)
                .filter(kit -> kit.getKitMatchTypes().contains(KitMatchType.SOLO) && kit.getKitMatchTypes().contains(KitMatchType.SPLIT))
                .forEach(kit -> buttons.put(buttons.size(), new Button() {
                    @Override
                    public ItemStack getButtonItem(Player player) {
                        return new ItemBuilder(kit.getDisplayIcon().clone())
                                .name(Language.EVENT_EVENT_SELECT_KIT_MENU_BUTTON_NAME.toString(player, kit.getDisplayName()))
                                .lore(Language.EVENT_EVENT_SELECT_KIT_MENU_BUTTON_LORE.toStringList(player))
                                .build();
                    }

                    @Override
                    public void clicked(Player player, ClickType clickType) {
                        player.closeInventory();
                        backMenu.setKit(kit);
                        backMenu.openMenu(player);
                    }
                }));

        return buttons;
    }
}


Filename: .\main\java\rip\diamond\practice\events\menu\EventSettingsMenu.java
package rip.diamond.practice.events.menu;

import lombok.Setter;
import org.bukkit.Material;
import org.bukkit.entity.Player;
import org.bukkit.event.inventory.ClickType;
import org.bukkit.inventory.ItemStack;
import rip.diamond.practice.Eden;
import rip.diamond.practice.events.EdenEvent;
import rip.diamond.practice.events.EventType;
import rip.diamond.practice.events.impl.SumoEvent;
import rip.diamond.practice.events.impl.Tournament;
import rip.diamond.practice.kits.Kit;
import rip.diamond.practice.util.BasicConfigFile;
import rip.diamond.practice.util.CC;
import rip.diamond.practice.util.ItemBuilder;
import rip.diamond.practice.util.exception.PracticeUnexpectedException;
import rip.diamond.practice.util.menu.Button;
import rip.diamond.practice.util.menu.Menu;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

public class EventSettingsMenu extends Menu {
    private final EventType eventType;
    private int maxPlayers;
    private int minPlayers;
    private int teamSize = 1;
    @Setter
    private Kit kit = Kit.getKits().get(0);

    public EventSettingsMenu(EventType eventType) {
        this.eventType = eventType;
        this.maxPlayers = eventType.getDefaultMaxPlayers();
        this.minPlayers = eventType.getDefaultMinPlayers();
    }

    @Override
    public String getTitle(Player player) {
        BasicConfigFile config = Eden.INSTANCE.getMenusConfig().getConfig();
        return CC.translate(config.getString("event-settings-menu.title"));
    }

    @Override
    public int getSize() {
        BasicConfigFile config = Eden.INSTANCE.getMenusConfig().getConfig();
        return config.getInt("event-settings-menu.size");
    }

    @Override
    public Map<Integer, Button> getButtons(Player player) {
        final Map<Integer, Button> buttons = new HashMap<>();
        BasicConfigFile config = Eden.INSTANCE.getMenusConfig().getConfig();

        // Filler
        if (config.getBoolean("event-settings-menu.filler.enabled")) {
            ItemStack filler = new ItemBuilder(
                    Material.valueOf(config.getString("event-settings-menu.filler.material")))
                    .durability(config.getInt("event-settings-menu.filler.data"))
                    .name(" ")
                    .build();
            for (int i = 0; i < getSize(); i++) {
                buttons.put(i, new Button() {
                    @Override
                    public ItemStack getButtonItem(Player player) {
                        return filler;
                    }
                });
            }
        }

        // Border
        if (config.getBoolean("event-settings-menu.border.enabled")) {
            ItemStack border = new ItemBuilder(
                    Material.valueOf(config.getString("event-settings-menu.border.material")))
                    .durability(config.getInt("event-settings-menu.border.data"))
                    .name(" ")
                    .build();
            int size = getSize();
            for (int i = 0; i < size; i++) {
                if (i < 9 || i >= size - 9 || i % 9 == 0 || i % 9 == 8) {
                    buttons.put(i, new Button() {
                        @Override
                        public ItemStack getButtonItem(Player player) {
                            return border;
                        }
                    });
                }
            }
        }

        // Max Players Button
        buttons.put(config.getInt("event-settings-menu.items.max-players-button.slot"), new Button() {
            @Override
            public ItemStack getButtonItem(Player player) {
                List<String> lore = config.getStringList("event-settings-menu.items.max-players-button.lore")
                        .stream()
                        .map(line -> line.replace("{max-players}", String.valueOf(maxPlayers)))
                        .collect(Collectors.toList());

                return new ItemBuilder(
                        Material.valueOf(config.getString("event-settings-menu.items.max-players-button.material")))
                        .name(config.getString("event-settings-menu.items.max-players-button.name"))
                        .lore(lore)
                        .build();
            }

            @Override
            public void clicked(Player player, ClickType clickType) {
                switch (clickType) {
                    case LEFT:
                        maxPlayers += 1;
                        break;
                    case SHIFT_LEFT:
                        maxPlayers += 10;
                        break;
                    case RIGHT:
                        maxPlayers -= 1;
                        break;
                    case SHIFT_RIGHT:
                        maxPlayers -= 10;
                        break;
                }
                if (maxPlayers < 2) {
                    maxPlayers = 2;
                }
                openMenu(player);
            }
        });

        // Party Size Button (only if event allows teams)
        if (eventType.isAllowTeams()) {
            buttons.put(config.getInt("event-settings-menu.items.party-size-button.slot"), new Button() {
                @Override
                public ItemStack getButtonItem(Player player) {
                    List<String> lore = config.getStringList("event-settings-menu.items.party-size-button.lore")
                            .stream()
                            .map(line -> line.replace("{team-size}", String.valueOf(teamSize)))
                            .collect(Collectors.toList());

                    return new ItemBuilder(
                            Material.valueOf(config.getString("event-settings-menu.items.party-size-button.material")))
                            .durability(config.getInt("event-settings-menu.items.party-size-button.data"))
                            .name(config.getString("event-settings-menu.items.party-size-button.name"))
                            .lore(lore)
                            .build();
                }

                @Override
                public void clicked(Player player, ClickType clickType) {
                    switch (clickType) {
                        case LEFT:
                            teamSize += 1;
                            break;
                        case RIGHT:
                            teamSize -= 1;
                            break;
                    }
                    if (teamSize < 1) {
                        teamSize = 1;
                    }
                    openMenu(player);
                }
            });
        }

        // Kit Button (only if event requires a kit)
        if (eventType.isKit()) {
            buttons.put(config.getInt("event-settings-menu.items.kit-button.slot"), new Button() {
                @Override
                public ItemStack getButtonItem(Player player) {
                    List<String> lore = config.getStringList("event-settings-menu.items.kit-button.lore")
                            .stream()
                            .map(line -> line.replace("{kit-name}", kit.getDisplayName()))
                            .collect(Collectors.toList());

                    return new ItemBuilder(
                            Material.valueOf(config.getString("event-settings-menu.items.kit-button.material")))
                            .name(config.getString("event-settings-menu.items.kit-button.name"))
                            .lore(lore)
                            .build();
                }

                @Override
                public void clicked(Player player, ClickType clickType) {
                    new EventSelectKitMenu(EventSettingsMenu.this).openMenu(player);
                }
            });
        }

        // Start Button
        buttons.put(config.getInt("event-settings-menu.items.start-button.slot"), new Button() {
            @Override
            public ItemStack getButtonItem(Player player) {
                List<String> lore = config.getStringList("event-settings-menu.items.start-button.lore")
                        .stream()
                        .map(line -> line.replace("{event-name}", eventType.getName()))
                        .map(line -> line.replace("{min-players}", String.valueOf(minPlayers)))
                        .map(line -> line.replace("{max-players}", String.valueOf(maxPlayers)))
                        .collect(Collectors.toList());

                return new ItemBuilder(
                        Material.valueOf(config.getString("event-settings-menu.items.start-button.material")))
                        .durability(config.getInt("event-settings-menu.items.start-button.data"))
                        .name(config.getString("event-settings-menu.items.start-button.name"))
                        .lore(lore)
                        .build();
            }

            @Override
            public void clicked(Player player, ClickType clickType) {
                player.closeInventory();

                EdenEvent event = EdenEvent.getOnGoingEvent();
                if (event != null) {
                    player.sendMessage(CC.translate("&cThere's already an active event!"));
                    return;
                }

                switch (eventType) {
                    case TOURNAMENT:
                        Tournament tournament = new Tournament(player.getName(), minPlayers, maxPlayers, kit, teamSize);
                        tournament.create();
                        return;
                    case SUMO_EVENT:
                        SumoEvent sumoEvent = new SumoEvent(player.getName(), minPlayers, maxPlayers, teamSize);
                        sumoEvent.create();
                        return;
                    default:
                        throw new PracticeUnexpectedException(
                                "Event type " + eventType.getName() + " is not initialized yet");
                }
            }
        });

        return buttons;
    }
}


Filename: .\main\java\rip\diamond\practice\hook\HookManager.java
package rip.diamond.practice.hook;

import lombok.Getter;
import lombok.Setter;
import rip.diamond.practice.Eden;
import rip.diamond.practice.hook.plugin.citizens.CitizensHook;
import rip.diamond.practice.hook.plugin.citizens.CitizensListener;
import rip.diamond.practice.hook.plugin.placeholderapi.EdenPlaceholderExpansion;
import rip.diamond.practice.hook.plugin.placeholderapi.PlaceholderAPIHook;
import rip.diamond.practice.util.Checker;

@Getter
@Setter
public class HookManager {

    private final Eden plugin;

    private CitizensHook citizensHook;
    private PlaceholderAPIHook placeholderAPIHook;

    public HookManager(Eden plugin) {
        this.plugin = plugin;



        if (Checker.isPluginEnabled("PlaceholderAPI")) {
            new EdenPlaceholderExpansion(plugin).register();
            this.placeholderAPIHook = new PlaceholderAPIHook();
        }
        if (Checker.isPluginEnabled("Citizens")) {
            this.citizensHook = new CitizensHook();
            plugin.getServer().getPluginManager().registerEvents(new CitizensListener(plugin, citizensHook), plugin);
        }
    }

}


Filename: .\main\java\rip\diamond\practice\hook\plugin\citizens\CitizensHook.java
package rip.diamond.practice.hook.plugin.citizens;

import com.google.common.collect.ImmutableList;
import lombok.Getter;
import net.citizensnpcs.api.CitizensAPI;
import net.citizensnpcs.api.event.NPCCreateEvent;
import net.citizensnpcs.api.npc.NPC;
import org.bukkit.Bukkit;
import org.bukkit.entity.Player;

import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

public class CitizensHook {

    @Getter private final List<NPC> npcs = new ArrayList<>();

    public boolean isNPC(UUID uuid) {
        return CitizensAPI.getNPCRegistry().getByUniqueId(uuid) != null;
    }

    public List<Player> getOnlinePlayers() {
        List<Player> players = new ArrayList<>(Bukkit.getOnlinePlayers());
        npcs.forEach(npc -> {
            if (npc.getEntity() instanceof Player && npc.getEntity().hasMetadata("PvP-Bot")) {
                players.add((Player) npc.getEntity());
            }
        });
        return ImmutableList.copyOf(players);
    }

    public Player getNPCPlayer(UUID uuid) {
        return (Player) CitizensAPI.getNPCRegistry().getByUniqueId(uuid).getEntity();
    }

}


Filename: .\main\java\rip\diamond\practice\hook\plugin\citizens\CitizensListener.java
package rip.diamond.practice.hook.plugin.citizens;

import lombok.RequiredArgsConstructor;
import net.citizensnpcs.api.event.NPCCreateEvent;
import net.citizensnpcs.api.event.NPCRemoveEvent;
import net.citizensnpcs.api.npc.NPC;
import org.bukkit.event.EventHandler;
import org.bukkit.event.Listener;
import rip.diamond.practice.Eden;

@RequiredArgsConstructor
public class CitizensListener implements Listener {

    private final Eden plugin;
    private final CitizensHook hook;

    @EventHandler
    public void onNPCCreate(NPCCreateEvent event) {
        NPC npc = event.getNPC();
        hook.getNpcs().add(npc);
    }

    @EventHandler
    public void onNPCRemove(NPCRemoveEvent event) {
        NPC npc = event.getNPC();
        hook.getNpcs().remove(npc);
    }

}


Filename: .\main\java\rip\diamond\practice\hook\plugin\placeholderapi\EdenPlaceholderExpansion.java
package rip.diamond.practice.hook.plugin.placeholderapi;

import lombok.RequiredArgsConstructor;
import me.clip.placeholderapi.expansion.PlaceholderExpansion;
import org.bukkit.entity.Player;
import rip.diamond.practice.Eden;
import rip.diamond.practice.config.Config;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.kits.Kit;
import rip.diamond.practice.leaderboard.Leaderboard;
import rip.diamond.practice.leaderboard.LeaderboardManager;
import rip.diamond.practice.leaderboard.LeaderboardPlayerCache;
import rip.diamond.practice.match.Match;
import rip.diamond.practice.party.Party;
import rip.diamond.practice.profile.PlayerProfile;
import rip.diamond.practice.profile.data.ProfileKitData;
import rip.diamond.practice.queue.Queue;
import rip.diamond.practice.queue.QueueType;

import java.util.LinkedHashMap;
import java.util.Map;

@RequiredArgsConstructor
public class EdenPlaceholderExpansion extends PlaceholderExpansion {

    private final Eden plugin;

    @Override
    public String getIdentifier() {
        return "eden";
    }

    @Override
    public String getAuthor() {
        return "GoodestEnglish";
    }

    @Override
    public boolean persist() {
        return true;
    }

    @Override
    public String getVersion() {
        return Eden.INSTANCE.getDescription().getVersion();
    }

    @Override
    public String onPlaceholderRequest(Player player, String param) {
        if (player == null) {
            return null;
        }
        String[] args = param.split("_");
        PlayerProfile profile = PlayerProfile.get(player);

        // Requested in #228
        if (param.startsWith("kit_status")) {
            String kitName = args[2];
            Kit kit = Kit.getByName(kitName);
            if (kit == null) {
                return "Unable to find kit " + kitName;
            }
            return kit.isEnabled() ? Language.ENABLED.toString() : Language.DISABLED.toString();
        }
        if (param.startsWith("in_party")) {
            return profile.getParty() == null ? Language.DISABLED.toString() : Language.ENABLED.toString();
        }
        if (param.startsWith("party")) {
            Party party = profile.getParty();
            if (party == null) {
                return "";
            }
            if (param.equalsIgnoreCase("party_privacy")) {
                return party.getPrivacy().getReadable();
            }
            if (param.equalsIgnoreCase("party_leader")) {
                return party.getLeader().getUsername();
            }
        }
        if (param.startsWith("queue")) {
            if (param.startsWith("queue_unranked_")) {
                String kitName = args[2];
                Kit kit = Kit.getByName(kitName);
                if (kit == null) {
                    return "Unable to find kit " + kitName;
                }
                return Queue.getPlayers().values().stream()
                        .filter(qProfile -> qProfile.getKit() == kit && qProfile.getQueueType() == QueueType.UNRANKED)
                        .count() + "";
            }
            if (param.startsWith("queue_ranked_")) {
                String kitName = args[2];
                Kit kit = Kit.getByName(kitName);
                if (kit == null) {
                    return "Unable to find kit " + kitName;
                }
                return Queue.getPlayers().values().stream()
                        .filter(qProfile -> qProfile.getKit() == kit && qProfile.getQueueType() == QueueType.RANKED)
                        .count() + "";
            }
        }
        if (param.startsWith("match_unranked_")) {
            String kitName = args[2];
            Kit kit = Kit.getByName(kitName);
            if (kit == null) {
                return "Unable to find kit " + kitName;
            }
            return Match.getMatches().values().stream()
                    .filter(m -> m.getKit() == kit && m.getQueueType() == QueueType.UNRANKED)
                    .mapToInt(m -> m.getMatchPlayers().size()).sum() + "";
        }
        if (param.startsWith("match_ranked_")) {
            String kitName = args[2];
            Kit kit = Kit.getByName(kitName);
            if (kit == null) {
                return "Unable to find kit " + kitName;
            }
            return Match.getMatches().values().stream()
                    .filter(m -> m.getKit() == kit && m.getQueueType() == QueueType.UNRANKED)
                    .mapToInt(m -> m.getMatchPlayers().size()).sum() + "";
        }

        if (param.startsWith("match")) {
            Match match = profile.getMatch();
            if (match == null) {
                return "Player isn't in a match";
            }
            // Requested in #467
            if (param.equalsIgnoreCase("match_match_type")) {
                return match.getMatchType().getReadable();
            }
            if (param.equalsIgnoreCase("match_queue_type")) {
                return match.getQueueType().getReadable();
            }
            // Requested in #445
            if (param.equalsIgnoreCase("match_player_team_color")) {
                return match.getTeam(player).getTeamColor().getColor();
            }
            if (param.equalsIgnoreCase("match_player_team_name")) {
                return match.getTeam(player).getTeamColor().getTeamName();
            }
            if (param.equalsIgnoreCase("match_player_team_logo")) {
                return match.getTeam(player).getTeamColor().getTeamLogo();
            }
            if (param.equalsIgnoreCase("match_arena_name")) {
                return match.getArenaDetail().getArena().getDisplayName();
            }
            if (param.equalsIgnoreCase("match_kit_name")) {
                return match.getKit().getDisplayName();
            }
        }
        if (args[0].equalsIgnoreCase("player")) {
            if (param.equalsIgnoreCase("player_status")) {
                return profile.getPlayerState().name();
            }

            int rankedWon = profile.getKitData().values().stream().mapToInt(ProfileKitData::getRankedWon).sum();
            int rankedLost = profile.getKitData().values().stream().mapToInt(ProfileKitData::getRankedLost).sum();
            int unrankedWon = profile.getKitData().values().stream().mapToInt(ProfileKitData::getUnrankedWon).sum();
            int unrankedLost = profile.getKitData().values().stream().mapToInt(ProfileKitData::getUnrankedLost).sum();
            int totalElo = profile.getKitData().values().stream().mapToInt(ProfileKitData::getElo).sum();

            if (param.equalsIgnoreCase("player_ranked_win")) {
                return rankedWon + "";
            }
            if (param.equalsIgnoreCase("player_ranked_loss")) {
                return rankedLost + "";
            }
            if (param.equalsIgnoreCase("player_unranked_win")) {
                return unrankedWon + "";
            }
            if (param.equalsIgnoreCase("player_unranked_loss")) {
                return unrankedLost + "";
            }
            if (param.equalsIgnoreCase("player_overall_win")) {
                return rankedWon + unrankedWon + "";
            }
            if (param.equalsIgnoreCase("player_overall_loss")) {
                return rankedLost + unrankedLost + "";
            }
            if (param.equalsIgnoreCase("player_total_elo")) {
                return totalElo + "";
            }
            if (param.equalsIgnoreCase("player_global_elo")) {
                return totalElo / Kit.getKits().stream().filter(kit -> kit.isEnabled() && kit.isRanked()).count() + "";
            }

            String kitName = args[2];
            if (param.startsWith("player_elo")) {
                return profile.getKitData().get(kitName).getElo() + "";
            }
            if (param.startsWith("player_peakElo")) {
                return profile.getKitData().get(kitName).getPeakElo() + "";
            }
            if (param.startsWith("player_unrankedWon")) {
                return profile.getKitData().get(kitName).getUnrankedWon() + "";
            }
            if (param.startsWith("player_unrankedLost")) {
                return profile.getKitData().get(kitName).getUnrankedLost() + "";
            }
            if (param.startsWith("player_rankedWon")) {
                return profile.getKitData().get(kitName).getRankedWon() + "";
            }
            if (param.startsWith("player_rankedLost")) {
                return profile.getKitData().get(kitName).getRankedLost() + "";
            }
            if (param.startsWith("player_bestWinstreak")) {
                return profile.getKitData().get(kitName).getBestWinstreak() + "";
            }
            if (param.startsWith("player_winstreak")) {
                return profile.getKitData().get(kitName).getWinstreak() + "";
            }
        }
        if (args[0].equalsIgnoreCase("leaderboard")) {
            // If database is disabled, there will be no leaderboard data. So we are going
            // to return "Database not enabled"
            if (Eden.INSTANCE.getDatabaseManager().getHandler() == null) {
                return "Database isn't enabled";
            }

            String kitName = args[3];
            Kit kit = Kit.getByName(kitName);
            int position = Integer.parseInt(args[4]);
            LeaderboardManager manager = Eden.INSTANCE.getLeaderboardManager();
            if (param.startsWith("leaderboard_bestWinstreak_player_")) {
                LinkedHashMap<Integer, LeaderboardPlayerCache> leaderboard = manager.getBestWinstreakLeaderboard()
                        .get(kit).getLeaderboard();
                if (leaderboard.size() < position) {
                    return "-";
                }
                return leaderboard.get(position).getPlayerName();
            }
            if (param.startsWith("leaderboard_bestWinstreak_winstreak_")) {
                LinkedHashMap<Integer, LeaderboardPlayerCache> leaderboard = manager.getBestWinstreakLeaderboard()
                        .get(kit).getLeaderboard();
                if (leaderboard.size() < position) {
                    return "-";
                }
                return leaderboard.get(position).getData() + "";
            }
            if (param.startsWith("leaderboard_elo_player_")) {
                LinkedHashMap<Integer, LeaderboardPlayerCache> leaderboard = manager.getEloLeaderboard().get(kit)
                        .getLeaderboard();
                if (leaderboard.size() < position) {
                    return "-";
                }
                return leaderboard.get(position).getPlayerName();
            }
            if (param.startsWith("leaderboard_elo_elo_")) {
                LinkedHashMap<Integer, LeaderboardPlayerCache> leaderboard = manager.getEloLeaderboard().get(kit)
                        .getLeaderboard();
                if (leaderboard.size() < position) {
                    return "-";
                }
                return leaderboard.get(position).getData() + "";
            }
            if (param.startsWith("leaderboard_wins_player_")) {
                LinkedHashMap<Integer, LeaderboardPlayerCache> leaderboard = manager.getWinsLeaderboard().get(kit)
                        .getLeaderboard();
                if (leaderboard.size() < position) {
                    return "-";
                }
                return leaderboard.get(position).getPlayerName();
            }
            if (param.startsWith("leaderboard_wins_win_")) {
                LinkedHashMap<Integer, LeaderboardPlayerCache> leaderboard = manager.getWinsLeaderboard().get(kit)
                        .getLeaderboard();
                if (leaderboard.size() < position) {
                    return "-";
                }
                return leaderboard.get(position).getData() + "";
            }
            if (param.startsWith("leaderboard_winstreak_player_")) {
                LinkedHashMap<Integer, LeaderboardPlayerCache> leaderboard = manager.getWinstreakLeaderboard().get(kit)
                        .getLeaderboard();
                if (leaderboard.size() < position) {
                    return "-";
                }
                return leaderboard.get(position).getPlayerName();
            }
            if (param.startsWith("leaderboard_winstreak_winstreak_")) {
                LinkedHashMap<Integer, LeaderboardPlayerCache> leaderboard = manager.getWinstreakLeaderboard().get(kit)
                        .getLeaderboard();
                if (leaderboard.size() < position) {
                    return "-";
                }
                return leaderboard.get(position).getData() + "";
            }
        }

        return null; // Placeholder is unknown by the Expansion
    }

}


Filename: .\main\java\rip\diamond\practice\hook\plugin\placeholderapi\PlaceholderAPIHook.java
package rip.diamond.practice.hook.plugin.placeholderapi;

import me.clip.placeholderapi.PlaceholderAPI;
import org.bukkit.entity.Player;

public class PlaceholderAPIHook {

    public String setPlaceholders(Player player, String string) {
        return PlaceholderAPI.setPlaceholders(player, string);
    }

}


Filename: .\main\java\rip\diamond\practice\kiteditor\KitEditorListener.java
package rip.diamond.practice.kiteditor;

import lombok.RequiredArgsConstructor;
import org.bukkit.Material;
import org.bukkit.block.Block;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.Listener;
import org.bukkit.event.block.Action;
import org.bukkit.event.inventory.InventoryClickEvent;
import org.bukkit.event.inventory.InventoryCloseEvent;
import org.bukkit.event.inventory.InventoryDragEvent;
import org.bukkit.event.inventory.InventoryType;
import org.bukkit.event.player.PlayerCommandPreprocessEvent;
import org.bukkit.event.player.PlayerInteractEvent;
import org.bukkit.event.player.PlayerQuitEvent;
import rip.diamond.practice.Eden;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.kiteditor.menu.KitEditorExtraItemsMenu;
import rip.diamond.practice.kiteditor.menu.KitEditorSaveMenu;
import rip.diamond.practice.kiteditor.menu.KitEditorSelectKitMenu;
import rip.diamond.practice.kits.Kit;
import rip.diamond.practice.profile.PlayerProfile;
import rip.diamond.practice.util.CC;
import rip.diamond.practice.util.Common;

import java.util.stream.Collectors;

@RequiredArgsConstructor
public class KitEditorListener implements Listener {

    private final Eden plugin;

    @EventHandler(priority = EventPriority.LOW)
    public void onPlayerQuitEvent(PlayerQuitEvent event) {
        Player player = event.getPlayer();
        if (plugin.getKitEditorManager().isEditing(player)) {
            plugin.getKitEditorManager().leaveKitEditor(player, true);
        }
    }

    @EventHandler(priority = EventPriority.MONITOR)
    public void onInventoryClose(InventoryCloseEvent event) {
        Player player = (Player) event.getPlayer();

        // Only handle if in GUI mode and editing
        if (!plugin.getConfigFile().getString("kit-editor-mode").equalsIgnoreCase("GUI")) {
            return;
        }

        if (!plugin.getKitEditorManager().isEditing(player)) {
            return;
        }

        // Check if inventory was closed without opening another menu (escape key)
        // We'll use a delayed check to see if they're still in editor mode without a
        // menu open
        plugin.getServer().getScheduler().runTaskLater(plugin, () -> {
            if (plugin.getKitEditorManager().isEditing(player)) {
                InventoryType type = player.getOpenInventory().getType();
                if (type == InventoryType.CRAFTING || type == InventoryType.CREATIVE) {
                    // Player pressed escape without opening another menu - exit editor mode
                    plugin.getKitEditorManager().leaveKitEditor(player, true);
                    plugin.getServer().getScheduler().runTaskLater(plugin,
                            () -> new KitEditorSelectKitMenu().openMenu(player), 3L);
                }
            }
        }, 2L);
    }

    @EventHandler
    public void onCommand(PlayerCommandPreprocessEvent event) {
        Player player = event.getPlayer();
        if (plugin.getKitEditorManager().isEditing(player)) {
            Language.KIT_EDITOR_CANNOT_USE_COMMAND_WHILE_EDITING.sendMessage(player);
            event.setCancelled(true);
        }
    }

    @EventHandler
    public void onInteract(PlayerInteractEvent event) {
        Player player = event.getPlayer();
        PlayerProfile profile = PlayerProfile.get(player);

        if (!plugin.getKitEditorManager().isEditing(player)) {
            return;
        }

        // Cancel the event to prevent player uses potion, pearl, rod, bow, etc
        event.setCancelled(true);

        Action action = event.getAction();
        Block block = event.getClickedBlock();
        if (block == null) {
            return;
        }
        if (action != Action.RIGHT_CLICK_BLOCK) {
            return;
        }
        Kit kit = plugin.getKitEditorManager().getEditingProfile(player).getKit();
        switch (block.getType()) {
            case CHEST:
                if (kit.getKitExtraItems().isEmpty()) {
                    Language.KIT_EDITOR_DISALLOW_EXTRA_ITEM.sendMessage(player);
                    break;
                }
                new KitEditorExtraItemsMenu(kit).openMenu(player);
                break;
            case ANVIL:
                new KitEditorSaveMenu(kit).openMenu(player);
                break;
            case WALL_SIGN:
            case SIGN_POST:
                plugin.getKitEditorManager().leaveKitEditor(player, true);
                break;
        }
    }

    @EventHandler
    public void onInventoryClick(InventoryClickEvent event) {
        Player player = (Player) event.getWhoClicked();
        if (!plugin.getKitEditorManager().isEditing(player)) {
            return;
        }
        if (event.getSlotType() == InventoryType.SlotType.OUTSIDE) {
            player.setItemOnCursor(null);
            return;
        }
        if (event.getSlotType() == InventoryType.SlotType.ARMOR
                || event.getSlotType() == InventoryType.SlotType.CRAFTING) {
            event.setCancelled(true);
        }
    }

    // Èò≤Ê≠¢Áé©ÂÆ∂ÊîæÁΩÆÁâ©ÂìÅÂà∞ÂÖ∂‰ªñ‰ΩçÁΩÆ
    @EventHandler
    public void onDrag(InventoryDragEvent event) {
        Player player = (Player) event.getWhoClicked();
        if (!plugin.getKitEditorManager().isEditing(player)) {
            return;
        }
        if (event.getInventorySlots().stream().anyMatch(i -> i > 36)) {
            event.setCancelled(true);
        }
    }

}


Filename: .\main\java\rip\diamond\practice\kiteditor\KitEditorManager.java
package rip.diamond.practice.kiteditor;

import lombok.Getter;
import lombok.Setter;
import org.bukkit.Location;
import org.bukkit.entity.Player;
import rip.diamond.practice.Eden;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.kits.Kit;
import rip.diamond.practice.profile.PlayerProfile;
import rip.diamond.practice.profile.PlayerState;
import rip.diamond.practice.util.Common;
import rip.diamond.practice.util.Util;
import rip.diamond.practice.util.serialization.LocationSerialization;
import org.bukkit.Color;
import org.bukkit.Material;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.meta.LeatherArmorMeta;
import rip.diamond.practice.match.team.TeamColor;

import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

@Getter
public class KitEditorManager {

    private final Eden plugin;
    private final Map<UUID, KitEditProfile> editing = new HashMap<>();
    @Setter
    private Location editorLocation = null;

    public KitEditorManager(Eden plugin) {
        this.plugin = plugin;
        try {
            this.editorLocation = LocationSerialization
                    .deserializeLocation(plugin.getLocationFile().getString("editor-location"));
        } catch (Exception e) {
            Common.log("Unable to deserialize editor-location from location file.");
        }
    }

    public boolean isEditing(Player player) {
        PlayerProfile profile = PlayerProfile.get(player);
        // Check if PracticePlayer is null, this usually be null when player quit the
        // server instantly when they join
        if (profile == null) {
            return false;
        }
        return profile.getPlayerState() == PlayerState.IN_EDIT && editing.containsKey(player.getUniqueId());
    }

    public KitEditProfile getEditingProfile(Player player) {
        return editing.get(player.getUniqueId());
    }

    public void addKitEditor(Player player, Kit kit) {
        if (Eden.INSTANCE.getConfigFile().getString("kit-editor-mode").equalsIgnoreCase("GUI")) {
            PlayerProfile profile = PlayerProfile.get(player);
            profile.setPlayerState(PlayerState.IN_EDIT);

            KitEditProfile kProfile = new KitEditProfile(player.getUniqueId(), kit);
            editing.put(player.getUniqueId(), kProfile);

            player.getInventory().clear();
            player.getInventory().setContents(kit.getKitLoadout().getContents());
            colorize(player, kit);

            new rip.diamond.practice.kiteditor.menu.KitEditorMenu(kit, 1).openMenu(player);
            return;
        }

        if (editorLocation == null) {
            Language.KIT_EDITOR_CANNOT_FIND_EDITOR_LOCATION.sendMessage(player);
            return;
        }
        PlayerProfile profile = PlayerProfile.get(player);
        profile.setPlayerState(PlayerState.IN_EDIT);

        KitEditProfile kProfile = new KitEditProfile(player.getUniqueId(), kit);
        editing.put(player.getUniqueId(), kProfile);

        Util.teleport(player, editorLocation);
        player.getInventory().clear();
        player.getInventory().setContents(kit.getKitLoadout().getContents());
        colorize(player, kit);

        Language.KIT_EDITOR_EDITING.sendListOfMessage(player, kit.getDisplayName());
    }

    public void leaveKitEditor(Player player, boolean sendToSpawnAndReset) {
        editing.remove(player.getUniqueId());
        if (sendToSpawnAndReset) {
            // In GUI mode, don't teleport to spawn - just reset player state and give lobby
            // items
            if (Eden.INSTANCE.getConfigFile().getString("kit-editor-mode").equalsIgnoreCase("GUI")) {
                plugin.getLobbyManager().reset(player);
            } else {
                // In legacy mode, teleport to spawn and reset
                plugin.getLobbyManager().sendToSpawnAndReset(player);
            }
        }
    }

    private void colorize(Player player, Kit kit) {
        if (kit.getGameRules().isTeamProjectile()) {
            TeamColor teamColor = (player.getUniqueId().hashCode() % 2 == 0) ? TeamColor.RED : TeamColor.BLUE;

            ItemStack[] contents = player.getInventory().getContents();
            boolean changed = false;

            for (ItemStack item : contents) {
                if (item != null && (item.getType() == Material.WOOL ||
                        item.getType() == Material.STAINED_GLASS_PANE ||
                        item.getType() == Material.STAINED_CLAY ||
                        item.getType() == Material.STAINED_GLASS ||
                        item.getType() == Material.CARPET)) {
                    item.setDurability((short) teamColor.getDurability());
                    changed = true;
                }
            }

            if (changed) {
                player.getInventory().setContents(contents);
            }

            ItemStack[] armor = player.getInventory().getArmorContents();
            boolean armorChanged = false;
            for (ItemStack item : armor) {
                if (item != null && item.getType().name().contains("LEATHER")) {
                    LeatherArmorMeta meta = (LeatherArmorMeta) item.getItemMeta();
                    meta.setColor(Color.fromRGB(teamColor.getRgb()));
                    item.setItemMeta(meta);
                    armorChanged = true;
                }
            }

            if (armorChanged) {
                player.getInventory().setArmorContents(armor);
            }

            player.updateInventory();
        }
    }

}


Filename: .\main\java\rip\diamond\practice\kiteditor\KitEditProfile.java
package rip.diamond.practice.kiteditor;

import lombok.AllArgsConstructor;
import lombok.Getter;
import rip.diamond.practice.kits.Kit;

import java.util.UUID;

@Getter
@AllArgsConstructor
public class KitEditProfile {

    private UUID playerUuid;
    private Kit kit;

}


Filename: .\main\java\rip\diamond\practice\kiteditor\command\EditKitsCommand.java
package rip.diamond.practice.kiteditor.command;

import org.bukkit.entity.Player;
import rip.diamond.practice.Eden;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.kiteditor.menu.KitEditorSelectKitMenu;
import rip.diamond.practice.kits.Kit;
import rip.diamond.practice.profile.PlayerProfile;
import rip.diamond.practice.profile.PlayerState;
import rip.diamond.practice.util.command.Command;
import rip.diamond.practice.util.command.CommandArgs;
import rip.diamond.practice.util.command.argument.CommandArguments;

public class EditKitsCommand extends Command {
    @CommandArgs(name = "editkits")
    public void execute(CommandArguments command) {
        String[] args = command.getArgs();
        Player player = command.getPlayer();
        PlayerProfile profile = PlayerProfile.get(player);

        if (profile.getPlayerState() != PlayerState.IN_LOBBY) {
            Language.KIT_EDITOR_CANNOT_EDIT_WRONG_STATE.sendMessage(player);
            return;
        }

        if (args.length == 0) {
            new KitEditorSelectKitMenu().openMenu(player);
        } else if (args.length == 1) {
            Kit kit = Kit.getByName(args[0]);
            if (kit == null) {
                Language.INVALID_SYNTAX.sendMessage(player);
                return;
            }
            Eden.INSTANCE.getKitEditorManager().addKitEditor(player, kit);
        }
    }
}


Filename: .\main\java\rip\diamond\practice\kiteditor\menu\KitEditorExtraItemsMenu.java
package rip.diamond.practice.kiteditor.menu;

import lombok.RequiredArgsConstructor;
import org.bukkit.Material;
import org.bukkit.entity.Player;
import org.bukkit.event.inventory.ClickType;
import org.bukkit.inventory.ItemStack;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.kits.Kit;
import rip.diamond.practice.kits.KitExtraItem;
import rip.diamond.practice.util.ItemBuilder;
import rip.diamond.practice.util.menu.Button;
import rip.diamond.practice.util.menu.Menu;
import rip.diamond.practice.util.menu.pagination.PaginatedMenu;

import java.util.HashMap;
import java.util.Map;

public class KitEditorExtraItemsMenu extends PaginatedMenu {
    private final Kit kit;
    private final Menu backMenu;

    public KitEditorExtraItemsMenu(Kit kit) {
        this(kit, null);
    }

    public KitEditorExtraItemsMenu(Kit kit, Menu backMenu) {
        this.kit = kit;
        this.backMenu = backMenu;
    }

    @Override
    public String getPrePaginatedTitle(Player player) {
        return Language.KIT_EDITOR_EXTRA_ITEM_MENU_NAME.toString();
    }

    @Override
    public Map<Integer, Button> getGlobalButtons(Player player) {
        Map<Integer, Button> buttons = new HashMap<>();

        // Add back button in center (slot 4)
        if (backMenu != null) {
            buttons.put(4, new Button() {
                @Override
                public ItemStack getButtonItem(Player player) {
                    return new ItemBuilder(Material.ARROW)
                            .name("&aGo Back")
                            .lore("&7Click to return to kit editor")
                            .build();
                }

                @Override
                public void clicked(Player player, ClickType clickType) {
                    backMenu.openMenu(player);
                }
            });
        }

        return buttons;
    }

    @Override
    public Map<Integer, Button> getAllPagesButtons(Player player) {
        Map<Integer, Button> buttons = new HashMap<>();
        for (KitExtraItem item : kit.getKitExtraItems()) {
            ItemBuilder builder = new ItemBuilder(item.getMaterial()).amount(item.getAmount())
                    .durability(item.getData()).enchantments(item.getEnchantments());
            if (item.getName() != null) {
                builder.name(item.getName());
            }
            if (item.isUnbreakable()) {
                builder.unbreakable();
            }

            buttons.put(buttons.size(), new Button() {
                @Override
                public ItemStack getButtonItem(Player player) {
                    return builder.build();
                }

                @Override
                public void clicked(Player player, ClickType clickType) {
                    // Only allow taking items to cursor
                    player.setItemOnCursor(builder.build());
                }

                @Override
                public boolean shouldCancel(Player player, ClickType clickType) {
                    // Prevent placing items in menu
                    return true;
                }
            });
        }
        return buttons;
    }

    @Override
    public void onClose(Player player) {
        if (backMenu != null) {
            // Use a delay to prevent inventory closing issues
            rip.diamond.practice.Eden.INSTANCE.getServer().getScheduler()
                    .runTaskLater(rip.diamond.practice.Eden.INSTANCE, () -> {
                        backMenu.openMenu(player);
                    }, 1L);
        }
    }
}


Filename: .\main\java\rip\diamond\practice\kiteditor\menu\KitEditorMenu.java
package rip.diamond.practice.kiteditor.menu;

import lombok.RequiredArgsConstructor;
import org.bukkit.Color;
import org.bukkit.DyeColor;
import org.bukkit.Material;
import org.bukkit.entity.Player;
import org.bukkit.event.inventory.ClickType;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.meta.ItemMeta;
import org.bukkit.inventory.meta.LeatherArmorMeta;
import rip.diamond.practice.Eden;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.kits.Kit;
import rip.diamond.practice.kits.KitLoadout;
import rip.diamond.practice.match.team.TeamColor;
import rip.diamond.practice.profile.PlayerProfile;
import rip.diamond.practice.profile.procedure.Procedure;
import rip.diamond.practice.profile.procedure.ProcedureType;
import rip.diamond.practice.util.BasicConfigFile;
import rip.diamond.practice.util.CC;
import rip.diamond.practice.util.ItemBuilder;
import rip.diamond.practice.util.menu.Button;
import rip.diamond.practice.util.menu.Menu;

import java.util.*;

@RequiredArgsConstructor
public class KitEditorMenu extends Menu {

    private final Kit kit;
    private final int page;

    @Override
    public String getTitle(Player player) {
        return CC.translate(Eden.INSTANCE.getMenusConfig().getConfig().getString("kit-editor-menu.title"));
    }

    @Override
    public int getSize() {
        return Eden.INSTANCE.getMenusConfig().getConfig().getInt("kit-editor-menu.size");
    }

    @Override
    public Map<Integer, Button> getButtons(Player player) {
        Map<Integer, Button> buttons = new HashMap<>();
        BasicConfigFile config = Eden.INSTANCE.getMenusConfig().getConfig();
        PlayerProfile profile = PlayerProfile.get(player);

        // Filler
        if (config.getBoolean("kit-editor-menu.filler.enabled")) {
            ItemStack filler = new ItemBuilder(Material.valueOf(config.getString("kit-editor-menu.filler.material")))
                    .durability(config.getInt("kit-editor-menu.filler.data"))
                    .name(" ")
                    .build();
            for (int i = 0; i < getSize(); i++) {
                buttons.put(i, new Button() {
                    @Override
                    public ItemStack getButtonItem(Player player) {
                        return filler;
                    }
                });
            }
        }

        // Border
        if (config.getBoolean("kit-editor-menu.border.enabled")) {
            ItemStack border = new ItemBuilder(Material.valueOf(config.getString("kit-editor-menu.border.material")))
                    .durability(config.getInt("kit-editor-menu.border.data"))
                    .name(" ")
                    .build();
            int size = getSize();
            for (int i = 0; i < size; i++) {
                if (i < 9 || i >= size - 9 || i % 9 == 0 || i % 9 == 8) {
                    buttons.put(i, new Button() {
                        @Override
                        public ItemStack getButtonItem(Player player) {
                            return border;
                        }
                    });
                }
            }
        }

        // Team Colorization Logic - Use consistent color per player session
        final TeamColor teamColor;
        if (kit.getGameRules().isTeamProjectile()) {
            // Use player UUID to determine consistent team color (prevents volatile color
            // changes)
            teamColor = (player.getUniqueId().hashCode() % 2 == 0) ? TeamColor.RED : TeamColor.BLUE;
        } else {
            teamColor = null;
        }

        // Armor
        ItemStack[] armor = kit.getKitLoadout().getArmor();
        if (armor != null) {
            setArmorButton(buttons, config.getInt("kit-editor-menu.items.armor.helmet"), armor[3], teamColor);
            setArmorButton(buttons, config.getInt("kit-editor-menu.items.armor.chestplate"), armor[2], teamColor);
            setArmorButton(buttons, config.getInt("kit-editor-menu.items.armor.leggings"), armor[1], teamColor);
            setArmorButton(buttons, config.getInt("kit-editor-menu.items.armor.boots"), armor[0], teamColor);
        }

        // Kit Slots
        List<Integer> slotPositions = config.getConfiguration().getIntegerList("kit-editor-menu.items.kit-slots");
        int slotsPerPage = slotPositions.size();
        int startIndex = (page - 1) * slotsPerPage;

        for (int i = 0; i < slotsPerPage; i++) {
            int kitIndex = startIndex + i;
            // Max 8 kits total as per request
            if (kitIndex >= 8)
                break;

            int slot = slotPositions.get(i);
            KitLoadout loadout = profile.getKitData().get(kit.getName()).getLoadouts()[kitIndex];
            String loadoutName = (loadout == null) ? "Kit " + (kitIndex + 1) : loadout.getCustomName();

            // Book Button (Book when empty, Book and Quill when saved)
            buttons.put(slot, new Button() {
                @Override
                public ItemStack getButtonItem(Player player) {
                    if (loadout == null) {
                        // Empty slot configuration
                        String emptyMaterial = config.getString("kit-editor-menu.items.book-button.empty.material");
                        int emptyData = config.getInt("kit-editor-menu.items.book-button.empty.data");
                        String emptyName = config.getString("kit-editor-menu.items.book-button.empty.name")
                                .replace("%slot%", String.valueOf(kitIndex + 1));
                        List<String> emptyLore = config.getStringList("kit-editor-menu.items.book-button.empty.lore");

                        return new ItemBuilder(Material.valueOf(emptyMaterial))
                                .durability(emptyData)
                                .name(emptyName)
                                .lore(emptyLore)
                                .build();
                    } else {
                        // Saved kit configuration
                        String savedMaterial = config.getString("kit-editor-menu.items.book-button.saved.material");
                        int savedData = config.getInt("kit-editor-menu.items.book-button.saved.data");
                        String savedName = config.getString("kit-editor-menu.items.book-button.saved.name")
                                .replace("%name%", loadoutName)
                                .replace("%slot%", String.valueOf(kitIndex + 1));
                        List<String> savedLore = config.getStringList("kit-editor-menu.items.book-button.saved.lore");

                        return new ItemBuilder(Material.valueOf(savedMaterial))
                                .durability(savedData)
                                .name(savedName)
                                .lore(savedLore)
                                .build();
                    }
                }

                @Override
                public void clicked(Player player, ClickType clickType) {
                    if (loadout == null) {
                        // Create new kit
                        KitLoadout newLoadout = new KitLoadout("Kit " + (kitIndex + 1), kit);
                        newLoadout.setContents(kit.getKitLoadout().getContents());
                        newLoadout.setArmor(kit.getKitLoadout().getArmor());
                        profile.getKitData().get(kit.getName()).replaceKit(kitIndex, newLoadout);
                        new KitEditorMenu(kit, page).openMenu(player);
                    } else {
                        // Load kit into inventory
                        player.closeInventory();
                        loadout.apply(kit, null, player); // Match is null, just applies to inventory
                        colorize(player, teamColor);
                        player.sendMessage(CC.translate("&aKit loaded."));
                        // Reopen menu after 1 tick delay to show updated inventory
                        Eden.INSTANCE.getServer().getScheduler().runTaskLater(Eden.INSTANCE, () -> {
                            new KitEditorMenu(kit, page).openMenu(player);
                        }, 1L);
                    }
                }
            });

            // Action Buttons (Only if loadout exists)
            if (loadout != null) {
                // Save Button (formerly Load Button)
                if (config.getBoolean("kit-editor-menu.items.dynamic-buttons.save.enabled")) {
                    int loadSlot = slot + config.getInt("kit-editor-menu.items.dynamic-buttons.save.slot-offset");
                    buttons.put(loadSlot, new Button() {
                        @Override
                        public ItemStack getButtonItem(Player player) {
                            return new ItemBuilder(
                                    Material.valueOf(
                                            config.getString("kit-editor-menu.items.dynamic-buttons.save.material")))
                                    .durability(config.getInt("kit-editor-menu.items.dynamic-buttons.save.data"))
                                    .name(config.getString("kit-editor-menu.items.dynamic-buttons.save.name"))
                                    .lore(config.getStringList("kit-editor-menu.items.dynamic-buttons.save.lore"))
                                    .build();
                        }

                        @Override
                        public void clicked(Player player, ClickType clickType) {
                            // Save current inventory to this kit
                            loadout.setContents(player.getInventory().getContents());
                            loadout.setArmor(player.getInventory().getArmorContents());
                            profile.getKitData().get(kit.getName()).replaceKit(kitIndex, loadout);
                            player.sendMessage(CC.translate("&aKit saved."));
                            new KitEditorMenu(kit, page).openMenu(player);
                        }
                    });
                }

                // Rename Button
                if (config.getBoolean("kit-editor-menu.items.dynamic-buttons.rename.enabled")) {
                    int renameSlot = slot + config.getInt("kit-editor-menu.items.dynamic-buttons.rename.slot-offset");
                    buttons.put(renameSlot, new Button() {
                        @Override
                        public ItemStack getButtonItem(Player player) {
                            return new ItemBuilder(
                                    Material.valueOf(
                                            config.getString("kit-editor-menu.items.dynamic-buttons.rename.material")))
                                    .durability(config.getInt("kit-editor-menu.items.dynamic-buttons.rename.data"))
                                    .name(config.getString("kit-editor-menu.items.dynamic-buttons.rename.name"))
                                    .lore(config.getStringList("kit-editor-menu.items.dynamic-buttons.rename.lore"))
                                    .build();
                        }

                        @Override
                        public void clicked(Player player, ClickType clickType) {
                            player.closeInventory();
                            Procedure.buildProcedure(player, "&aType the new name for this kit:", ProcedureType.CHAT,
                                    (string) -> {
                                        String message = (String) string;
                                        if (!message.matches("[a-zA-Z0-9_\\s+]*")) {
                                            player.sendMessage(CC.translate("&cInvalid characters."));
                                            return;
                                        }
                                        loadout.setCustomName(message);
                                        new KitEditorMenu(kit, page).openMenu(player);
                                    });
                        }
                    });
                }

                // Reset Button
                if (config.getBoolean("kit-editor-menu.items.dynamic-buttons.reset.enabled")) {
                    int resetSlot = slot + config.getInt("kit-editor-menu.items.dynamic-buttons.reset.slot-offset");
                    buttons.put(resetSlot, new Button() {
                        @Override
                        public ItemStack getButtonItem(Player player) {
                            return new ItemBuilder(
                                    Material.valueOf(
                                            config.getString("kit-editor-menu.items.dynamic-buttons.reset.material")))
                                    .durability(config.getInt("kit-editor-menu.items.dynamic-buttons.reset.data"))
                                    .name(config.getString("kit-editor-menu.items.dynamic-buttons.reset.name"))
                                    .lore(config.getStringList("kit-editor-menu.items.dynamic-buttons.reset.lore"))
                                    .build();
                        }

                        @Override
                        public void clicked(Player player, ClickType clickType) {
                            loadout.setContents(kit.getKitLoadout().getContents());
                            loadout.setArmor(kit.getKitLoadout().getArmor());
                            profile.getKitData().get(kit.getName()).replaceKit(kitIndex, loadout);
                            player.sendMessage(CC.translate("&aKit reset to default layout."));
                            // Close menu, apply default kit to player, then reopen
                            player.closeInventory();
                            player.getInventory().setContents(kit.getKitLoadout().getContents());
                            player.getInventory().setArmorContents(kit.getKitLoadout().getArmor());
                            colorize(player, teamColor);
                            player.updateInventory();
                            Eden.INSTANCE.getServer().getScheduler().runTaskLater(Eden.INSTANCE, () -> {
                                new KitEditorMenu(kit, page).openMenu(player);
                            }, 1L);
                        }
                    });
                }

                // Delete Button
                if (config.getBoolean("kit-editor-menu.items.dynamic-buttons.delete.enabled")) {
                    int deleteSlot = slot + config.getInt("kit-editor-menu.items.dynamic-buttons.delete.slot-offset");
                    buttons.put(deleteSlot, new Button() {
                        @Override
                        public ItemStack getButtonItem(Player player) {
                            return new ItemBuilder(
                                    Material.valueOf(
                                            config.getString("kit-editor-menu.items.dynamic-buttons.delete.material")))
                                    .durability(config.getInt("kit-editor-menu.items.dynamic-buttons.delete.data"))
                                    .name(config.getString("kit-editor-menu.items.dynamic-buttons.delete.name"))
                                    .lore(config.getStringList("kit-editor-menu.items.dynamic-buttons.delete.lore"))
                                    .build();
                        }

                        @Override
                        public void clicked(Player player, ClickType clickType) {
                            profile.getKitData().get(kit.getName()).deleteKit(kitIndex);
                            new KitEditorMenu(kit, page).openMenu(player);
                        }
                    });
                }
            }
        }

        // Extra Items
        if (!kit.getKitExtraItems().isEmpty()) {
            buttons.put(config.getInt("kit-editor-menu.items.extra-items.slot"), new Button() {
                @Override
                public ItemStack getButtonItem(Player player) {
                    return new ItemBuilder(
                            Material.valueOf(config.getString("kit-editor-menu.items.extra-items.material")))
                            .name(config.getString("kit-editor-menu.items.extra-items.name"))
                            .lore(config.getStringList("kit-editor-menu.items.extra-items.lore"))
                            .build();
                }

                @Override
                public void clicked(Player player, ClickType clickType) {
                    new KitEditorExtraItemsMenu(kit, KitEditorMenu.this).openMenu(player);
                }
            });
        }

        // Pagination
        if (page > 1) {
            buttons.put(config.getInt("kit-editor-menu.items.previous-page.slot"), new Button() {
                @Override
                public ItemStack getButtonItem(Player player) {
                    return new ItemBuilder(
                            Material.valueOf(config.getString("kit-editor-menu.items.previous-page.material")))
                            .name(config.getString("kit-editor-menu.items.previous-page.name"))
                            .build();
                }

                @Override
                public void clicked(Player player, ClickType clickType) {
                    new KitEditorMenu(kit, page - 1).openMenu(player);
                }
            });
        }

        if (startIndex + slotsPerPage < 8) { // Max 8 kits
            // Only show next page button if on page 1 and all kits 1-4 are saved
            boolean showNextPage = true;
            if (page == 1) {
                // Check if all kits 1-4 are saved
                for (int i = 0; i < 4; i++) {
                    if (profile.getKitData().get(kit.getName()).getLoadouts()[i] == null) {
                        showNextPage = false;
                        break;
                    }
                }
            }

            if (showNextPage) {
                buttons.put(config.getInt("kit-editor-menu.items.next-page.slot"), new Button() {
                    @Override
                    public ItemStack getButtonItem(Player player) {
                        return new ItemBuilder(
                                Material.valueOf(config.getString("kit-editor-menu.items.next-page.material")))
                                .name(config.getString("kit-editor-menu.items.next-page.name"))
                                .build();
                    }

                    @Override
                    public void clicked(Player player, ClickType clickType) {
                        new KitEditorMenu(kit, page + 1).openMenu(player);
                    }
                });
            }
        }

        // Back Button
        buttons.put(config.getInt("kit-editor-menu.items.back-button.slot"), new Button() {
            @Override
            public ItemStack getButtonItem(Player player) {
                return new ItemBuilder(
                        Material.valueOf(config.getString("kit-editor-menu.items.back-button.material")))
                        .name(config.getString("kit-editor-menu.items.back-button.name"))
                        .lore(config.getStringList("kit-editor-menu.items.back-button.lore"))
                        .build();
            }

            @Override
            public void clicked(Player player, ClickType clickType) {
                // Exit editing mode and restore lobby items
                Eden.INSTANCE.getKitEditorManager().leaveKitEditor(player, true);
                // Schedule opening the selector menu after lobby items are given
                Eden.INSTANCE.getServer().getScheduler().runTaskLater(Eden.INSTANCE, () -> {
                    new KitEditorSelectKitMenu().openMenu(player);
                }, 2L);
            }
        });

        return buttons;
    }

    private void colorize(Player player, TeamColor teamColor) {
        if (teamColor == null)
            return;

        ItemStack[] contents = player.getInventory().getContents();
        boolean changed = false;

        for (ItemStack item : contents) {
            if (item != null && (item.getType() == Material.WOOL ||
                    item.getType() == Material.STAINED_GLASS_PANE ||
                    item.getType() == Material.STAINED_CLAY ||
                    item.getType() == Material.STAINED_GLASS ||
                    item.getType() == Material.CARPET)) {
                item.setDurability((short) teamColor.getDurability());
                changed = true;
            }
        }

        if (changed) {
            player.getInventory().setContents(contents);
        }

        ItemStack[] armor = player.getInventory().getArmorContents();
        boolean armorChanged = false;
        for (ItemStack item : armor) {
            if (item != null && item.getType().name().contains("LEATHER")) {
                LeatherArmorMeta meta = (LeatherArmorMeta) item.getItemMeta();
                meta.setColor(Color.fromRGB(teamColor.getRgb()));
                item.setItemMeta(meta);
                armorChanged = true;
            }
        }

        if (armorChanged) {
            player.getInventory().setArmorContents(armor);
        }

        player.updateInventory();
    }

    private void setArmorButton(Map<Integer, Button> buttons, int slot, ItemStack item, TeamColor teamColor) {
        BasicConfigFile config = Eden.INSTANCE.getMenusConfig().getConfig();

        // Handle empty armor slots with placeholder
        if (item == null || item.getType() == Material.AIR) {
            String placeholderMaterial = config.getString("kit-editor-menu.items.armor.empty-placeholder.material");

            // If material is empty string or not set, don't show placeholder
            if (placeholderMaterial == null || placeholderMaterial.trim().isEmpty()) {
                return;
            }

            // Create placeholder item
            ItemStack placeholder = new ItemBuilder(Material.valueOf(placeholderMaterial))
                    .durability(config.getInt("kit-editor-menu.items.armor.empty-placeholder.data"))
                    .name(config.getString("kit-editor-menu.items.armor.empty-placeholder.name"))
                    .lore(config.getStringList("kit-editor-menu.items.armor.empty-placeholder.lore"))
                    .build();

            buttons.put(slot, new Button() {
                @Override
                public ItemStack getButtonItem(Player player) {
                    return placeholder;
                }
            });
            return;
        }

        ItemStack finalItem = item.clone();
        if (teamColor != null) {
            // Colorize leather armor
            if (finalItem.getType().name().contains("LEATHER")) {
                LeatherArmorMeta meta = (LeatherArmorMeta) finalItem.getItemMeta();
                meta.setColor(Color.fromRGB(teamColor.getRgb()));
                finalItem.setItemMeta(meta);
            }
            // Colorize blocks (wool, stained glass pane, stained clay)
            else if (finalItem.getType() == Material.WOOL ||
                    finalItem.getType() == Material.STAINED_GLASS_PANE ||
                    finalItem.getType() == Material.STAINED_CLAY) {
                finalItem.setDurability((short) teamColor.getDurability());
            }
        }

        buttons.put(slot, new Button() {
            @Override
            public ItemStack getButtonItem(Player player) {
                return finalItem;
            }
        });
    }
}


Filename: .\main\java\rip\diamond\practice\kiteditor\menu\KitEditorSaveMenu.java
package rip.diamond.practice.kiteditor.menu;

import lombok.RequiredArgsConstructor;
import org.bukkit.Material;
import org.bukkit.entity.Player;
import org.bukkit.event.inventory.ClickType;
import org.bukkit.inventory.ItemStack;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.kits.Kit;
import rip.diamond.practice.kits.KitLoadout;
import rip.diamond.practice.profile.PlayerProfile;
import rip.diamond.practice.profile.procedure.Procedure;
import rip.diamond.practice.profile.procedure.ProcedureType;
import rip.diamond.practice.util.ItemBuilder;
import rip.diamond.practice.util.menu.Button;
import rip.diamond.practice.util.menu.Menu;

import java.util.HashMap;
import java.util.Map;

@RequiredArgsConstructor
public class KitEditorSaveMenu extends Menu {
    private final Kit kit;

    @Override
    public Map<Integer, Button> getButtons(Player player) {
        PlayerProfile profile = PlayerProfile.get(player);
        Map<Integer, Button> buttons = new HashMap<>();

        for (int i = 0; i <= 3; i++) {
            int index = i;
            int id = i+1;
            int fixed = i*2 + 1;

            KitLoadout kitLoadout = profile.getKitData().get(kit.getName()).getLoadouts()[i];
            String kitLoadoutCustomName = kitLoadout == null ? kit.getDisplayName() + "#" + (id) : kitLoadout.getCustomName();
            buttons.put(fixed, new Button() {
                @Override
                public ItemStack getButtonItem(Player player) {
                    return new ItemBuilder(Material.CHEST)
                            .name(Language.KIT_EDITOR_SAVE_MENU_SAVE_LOADOUT_BUTTON_NAME.toString(kitLoadoutCustomName))
                            .build();
                }

                @Override
                public void clicked(Player player, ClickType clickType) {
                    KitLoadout loadout = new KitLoadout(kitLoadoutCustomName, kit);
                    loadout.setContents(player.getInventory().getContents());
                    profile.getKitData().get(kit.getName()).replaceKit(index, loadout);
                    openMenu(player);
                }
            });

            if (kitLoadout != null) {
                buttons.put(fixed + 9, new Button() {
                    @Override
                    public ItemStack getButtonItem(Player player) {
                        return new ItemBuilder(Material.BOOK)
                                .name(Language.KIT_EDITOR_SAVE_MENU_LOAD_LOADOUT_BUTTON_NAME.toString(kitLoadoutCustomName))
                                .build();
                    }

                    @Override
                    public void clicked(Player player, ClickType clickType) {
                        player.getInventory().setArmorContents(null);
                        player.getInventory().setContents(kitLoadout.getContents());
                        player.updateInventory();
                        openMenu(player);
                    }
                });
                buttons.put(fixed + 18, new Button() {
                    @Override
                    public ItemStack getButtonItem(Player player) {
                        return new ItemBuilder(Material.NAME_TAG)
                                .name(Language.KIT_EDITOR_SAVE_MENU_RENAME_LOADOUT_BUTTON_NAME.toString(kitLoadoutCustomName))
                                .build();
                    }

                    @Override
                    public void clicked(Player player, ClickType clickType) {
                        player.closeInventory();
                        Procedure.buildProcedure(player, Language.KIT_EDITOR_SAVE_MENU_RENAME_INSTRUCTIONS.toString(kitLoadoutCustomName), ProcedureType.CHAT, (string) -> {
                            String message = (String) string;
                            if (!message.matches("[a-zA-Z0-9_\\s+]*")) {
                                Language.KIT_EDITOR_SAVE_MENU_INVALID_CHARACTER.sendMessage(player);
                                return;
                            }
                            kitLoadout.setCustomName(message);
                            new KitEditorSaveMenu(kit).openMenu(player);
                        });
                    }
                });
                buttons.put(fixed + 27, new Button() {
                    @Override
                    public ItemStack getButtonItem(Player player) {
                        return new ItemBuilder(Material.LAVA_BUCKET)
                                .name(Language.KIT_EDITOR_SAVE_MENU_DELETE_LOADOUT_BUTTON_NAME.toString(kitLoadoutCustomName))
                                .build();
                    }

                    @Override
                    public void clicked(Player player, ClickType clickType) {
                        profile.getKitData().get(kit.getName()).deleteKit(index);
                        openMenu(player);
                    }
                });
            }
        }

        return buttons;
    }

    @Override
    public int getSize() {
        return 9*4;
    }

    @Override
    public String getTitle(Player player) {
        return Language.KIT_EDITOR_SAVE_MENU_NAME.toString();
    }
}


Filename: .\main\java\rip\diamond\practice\kiteditor\menu\KitEditorSelectKitMenu.java
package rip.diamond.practice.kiteditor.menu;

import org.bukkit.Material;
import org.bukkit.entity.Player;
import org.bukkit.event.inventory.ClickType;
import org.bukkit.inventory.ItemStack;
import rip.diamond.practice.Eden;
import rip.diamond.practice.kits.Kit;
import rip.diamond.practice.util.BasicConfigFile;
import rip.diamond.practice.util.CC;
import rip.diamond.practice.util.ItemBuilder;
import rip.diamond.practice.util.menu.Button;
import rip.diamond.practice.util.menu.Menu;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

public class KitEditorSelectKitMenu extends Menu {

	@Override
	public String getTitle(Player player) {
		BasicConfigFile config = Eden.INSTANCE.getMenusConfig().getConfig();
		return CC.translate(config.getString("kit-editor-select-kit-menu.title"));
	}

	@Override
	public int getSize() {
		BasicConfigFile config = Eden.INSTANCE.getMenusConfig().getConfig();
		String sizeStr = config.getString("kit-editor-select-kit-menu.size");

		if ("dynamic".equalsIgnoreCase(sizeStr)) {
			// Calculate dynamic size based on number of editable kits
			List<Kit> editableKits = getEditableKits();
			boolean hasBorder = config.getBoolean("kit-editor-select-kit-menu.border.enabled");

			// Calculate needed rows
			int kitsCount = editableKits.size();
			int slotsPerRow = hasBorder ? 7 : 9; // Account for border
			int rowsNeeded = (int) Math.ceil((double) kitsCount / slotsPerRow);
			int totalRows = rowsNeeded + (hasBorder ? 2 : 0); // Add top and bottom border

			// Ensure minimum of 3 rows
			int maxSize = config.getInt("kit-editor-select-kit-menu.max-size");
			int calculatedSize = Math.max(27, Math.min(totalRows * 9, maxSize));

			// Round to valid inventory size
			return ((calculatedSize + 8) / 9) * 9;
		} else {
			return config.getInt("kit-editor-select-kit-menu.size");
		}
	}

	@Override
	public Map<Integer, Button> getButtons(Player player) {
		Map<Integer, Button> buttons = new HashMap<>();
		BasicConfigFile config = Eden.INSTANCE.getMenusConfig().getConfig();

		// Filler
		if (config.getBoolean("kit-editor-select-kit-menu.filler.enabled")) {
			ItemStack filler = new ItemBuilder(
					Material.valueOf(config.getString("kit-editor-select-kit-menu.filler.material")))
					.durability(config.getInt("kit-editor-select-kit-menu.filler.data"))
					.name(" ")
					.build();
			for (int i = 0; i < getSize(); i++) {
				buttons.put(i, new Button() {
					@Override
					public ItemStack getButtonItem(Player player) {
						return filler;
					}
				});
			}
		}

		// Border
		if (config.getBoolean("kit-editor-select-kit-menu.border.enabled")) {
			ItemStack border = new ItemBuilder(
					Material.valueOf(config.getString("kit-editor-select-kit-menu.border.material")))
					.durability(config.getInt("kit-editor-select-kit-menu.border.data"))
					.name(" ")
					.build();
			int size = getSize();
			for (int i = 0; i < size; i++) {
				if (i < 9 || i >= size - 9 || i % 9 == 0 || i % 9 == 8) {
					buttons.put(i, new Button() {
						@Override
						public ItemStack getButtonItem(Player player) {
							return border;
						}
					});
				}
			}
		}

		// Kit buttons
		List<Kit> editableKits = getEditableKits();
		int kitIndex = 0;

		for (int slot = 0; slot < getSize() && kitIndex < editableKits.size(); slot++) {
			// Skip border slots
			if (buttons.containsKey(slot) && (slot < 9 || slot >= getSize() - 9 || slot % 9 == 0 || slot % 9 == 8)) {
				continue;
			}

			Kit kit = editableKits.get(kitIndex);
			buttons.put(slot, new KitButton(kit, config));
			kitIndex++;
		}

		return buttons;
	}

	private List<Kit> getEditableKits() {
		return Kit.getKits().stream()
				.filter(Kit::isEnabled)
				.filter(kit -> kit.getGameRules().isReceiveKitLoadoutBook())
				.collect(Collectors.toList());
	}

	private static class KitButton extends Button {
		private final Kit kit;
		private final BasicConfigFile config;

		public KitButton(Kit kit, BasicConfigFile config) {
			this.kit = kit;
			this.config = config;
		}

		@Override
		public ItemStack getButtonItem(Player player) {
			String name = config.getString("kit-editor-select-kit-menu.items.kit-button.name")
					.replace("{kit-name}", kit.getDisplayName());
			List<String> lore = config.getStringList("kit-editor-select-kit-menu.items.kit-button.lore");

			return new ItemBuilder(kit.getDisplayIcon().clone())
					.name(name)
					.lore(lore)
					.build();
		}

		@Override
		public void clicked(Player player, ClickType clickType) {
			player.closeInventory();
			Eden.INSTANCE.getKitEditorManager().addKitEditor(player, kit);
		}
	}
}


Filename: .\main\java\rip\diamond\practice\kits\Kit.java
package rip.diamond.practice.kits;

import lombok.Getter;
import lombok.Setter;
import org.bukkit.Material;
import org.bukkit.configuration.ConfigurationSection;
import org.bukkit.configuration.file.FileConfiguration;
import org.bukkit.inventory.ItemStack;
import org.bukkit.potion.PotionEffect;
import rip.diamond.practice.Eden;
import rip.diamond.practice.config.Config;
import rip.diamond.practice.util.Common;
import rip.diamond.practice.util.GsonType;
import rip.diamond.practice.util.serialization.BukkitSerialization;
import rip.diamond.practice.util.serialization.EffectSerialization;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Comparator;
import java.util.List;

public class Kit {

	@Getter
	private static final List<Kit> kits = new ArrayList<>();

	@Getter
	@Setter
	private String name;
	@Getter
	@Setter
	private String displayName;
	@Getter
	@Setter
	private int priority;
	@Getter
	@Setter
	private int damageTicks = 19;
	@Getter
	@Setter
	private boolean enabled;
	@Getter
	@Setter
	private boolean ranked;
	@Setter
	private ItemStack displayIcon;
	@Getter
	@Setter
	private List<String> description = new ArrayList<>();
	@Getter
	@Setter
	private Collection<PotionEffect> effects = new ArrayList<>();
	@Getter
	private final KitLoadout kitLoadout = new KitLoadout();
	@Getter
	@Setter
	private KitGameRules gameRules = new KitGameRules();
	@Getter
	@Setter
	private List<KitMatchType> kitMatchTypes = new ArrayList<>();
	@Getter
	@Setter
	private List<KitExtraItem> kitExtraItems = new ArrayList<>();

	@Getter
	@Setter
	private boolean pendingReload = false;
	@Getter
	@Setter
	private Kit nextVersion = null;

	public boolean isUsing() {
		return rip.diamond.practice.match.Match.getMatches().values().stream()
				.anyMatch(match -> match.getKit().equals(this));
	}

	public static void reload() {
		FileConfiguration fileConfig = Eden.INSTANCE.getKitFile().getConfiguration();
		ConfigurationSection kitSection = fileConfig.getConfigurationSection("kits");

		List<Kit> loadedKits = new ArrayList<>();

		if (kitSection != null) {
			kitSection.getKeys(false).forEach(id -> {
				boolean enabled = kitSection.getBoolean(id + ".enabled");
				boolean ranked = kitSection.getBoolean(id + ".ranked");
				String displayName = kitSection.getString(id + ".display-name");
				int priority = kitSection.getInt(id + ".priority");
				int damageTicks = kitSection.getInt(id + ".damage-ticks");
				ItemStack displayIcon = BukkitSerialization
						.itemStackFromBase64(kitSection.getString(id + ".display-icon"));
				List<String> description = Eden.GSON.fromJson(kitSection.getString(id + ".description"),
						GsonType.STRING_LIST);
				Collection<PotionEffect> effects = EffectSerialization
						.deserializeEffects(kitSection.getString(id + ".potion-effects"));
				ItemStack[] armor = BukkitSerialization
						.itemStackArrayFromBase64(kitSection.getString(id + ".armor-loadout"));
				ItemStack[] contents = BukkitSerialization
						.itemStackArrayFromBase64(kitSection.getString(id + ".contents-loadout"));
				KitGameRules gameRules = Eden.GSON.fromJson(kitSection.getString(id + ".game-rules"),
						GsonType.KIT_GAME_RULES);
				List<KitMatchType> kitMatchTypes = Eden.GSON.fromJson(kitSection.getString(id + ".kit-match-types"),
						GsonType.KIT_MATCH_TYPES);
				List<KitExtraItem> kitExtraItems = Eden.GSON.fromJson(kitSection.getString(id + ".kit-extra-item"),
						GsonType.KIT_EXTRA_ITEM);

				Kit kit = new Kit(id);
				kit.setEnabled(enabled);
				kit.setRanked(ranked);
				kit.setDisplayName(displayName);
				kit.setPriority(priority);
				kit.setDamageTicks(damageTicks);
				kit.setDisplayIcon(displayIcon);
				kit.setDescription(description);
				kit.setEffects(effects);
				kit.getKitLoadout().setArmor(armor);
				kit.getKitLoadout().setContents(contents);
				kit.setGameRules(gameRules);
				kit.setKitMatchTypes(kitMatchTypes);
				kit.setKitExtraItems(kitExtraItems);

				loadedKits.add(kit);
			});
		}

		// Process existing kits
		List<Kit> toRemove = new ArrayList<>();
		for (Kit currentKit : new ArrayList<>(kits)) {
			Kit newVersion = loadedKits.stream().filter(k -> k.getName().equals(currentKit.getName())).findFirst()
					.orElse(null);

			if (currentKit.isUsing()) {
				currentKit.setPendingReload(true);
				currentKit.setNextVersion(newVersion);
				Common.log("&cKit " + currentKit.getName() + " is in use. Queued for reload.");
			} else {
				toRemove.add(currentKit);
			}
		}

		kits.removeAll(toRemove);

		// Add new/updated kits
		for (Kit loadedKit : loadedKits) {
			if (kits.stream().noneMatch(k -> k.getName().equals(loadedKit.getName()))) {
				kits.add(loadedKit);
			}
		}

		sortKit();
		Common.log("&aReloaded kits. " + kits.size() + " kits loaded.");
	}

	public Kit(String name) {
		this.name = name;
		this.displayName = name;
		this.priority = 0;
		this.displayIcon = new ItemStack(Material.DIAMOND_SWORD);
	}

	public static void init() {
		FileConfiguration fileConfig = Eden.INSTANCE.getKitFile().getConfiguration();
		ConfigurationSection kitSection = fileConfig.getConfigurationSection("kits");
		if (kitSection == null) {
			return;
		}

		kitSection.getKeys(false).forEach(id -> {
			boolean enabled = kitSection.getBoolean(id + ".enabled");
			boolean ranked = kitSection.getBoolean(id + ".ranked");
			String displayName = kitSection.getString(id + ".display-name");
			int priority = kitSection.getInt(id + ".priority");
			int damageTicks = kitSection.getInt(id + ".damage-ticks");
			ItemStack displayIcon = BukkitSerialization.itemStackFromBase64(kitSection.getString(id + ".display-icon"));
			List<String> description = Eden.GSON.fromJson(kitSection.getString(id + ".description"),
					GsonType.STRING_LIST);
			Collection<PotionEffect> effects = EffectSerialization
					.deserializeEffects(kitSection.getString(id + ".potion-effects"));
			ItemStack[] armor = BukkitSerialization
					.itemStackArrayFromBase64(kitSection.getString(id + ".armor-loadout"));
			ItemStack[] contents = BukkitSerialization
					.itemStackArrayFromBase64(kitSection.getString(id + ".contents-loadout"));
			KitGameRules gameRules = Eden.GSON.fromJson(kitSection.getString(id + ".game-rules"),
					GsonType.KIT_GAME_RULES);
			List<KitMatchType> kitMatchTypes = Eden.GSON.fromJson(kitSection.getString(id + ".kit-match-types"),
					GsonType.KIT_MATCH_TYPES);
			List<KitExtraItem> kitExtraItems = Eden.GSON.fromJson(kitSection.getString(id + ".kit-extra-item"),
					GsonType.KIT_EXTRA_ITEM);

			Kit kit = new Kit(id);
			kit.setEnabled(enabled);
			kit.setRanked(ranked);
			kit.setDisplayName(displayName);
			kit.setPriority(priority);
			kit.setDamageTicks(damageTicks);
			kit.setDisplayIcon(displayIcon);
			kit.setDescription(description);
			kit.setEffects(effects);
			kit.getKitLoadout().setArmor(armor);
			kit.getKitLoadout().setContents(contents);
			kit.setGameRules(gameRules);
			kit.setKitMatchTypes(kitMatchTypes);
			kit.setKitExtraItems(kitExtraItems);

			kits.add(kit);
		});

		sortKit();
	}

	public static void sortKit() {
		kits.sort(Comparator.comparing(Kit::getPriority));
	}

	public ItemStack getDisplayIcon() {
		return displayIcon.clone();
	}

	public void delete() {
		Kit.getKits().remove(this);
	}

	public void save() {
		FileConfiguration fileConfig = Eden.INSTANCE.getKitFile().getConfiguration();
		String kitRoot = "kits." + name;
		fileConfig.set(kitRoot, null); // Remove everything related to that kit first, then add the details one by one
		fileConfig.set(kitRoot + ".enabled", enabled);
		fileConfig.set(kitRoot + ".ranked", ranked);
		fileConfig.set(kitRoot + ".display-name", displayName);
		fileConfig.set(kitRoot + ".priority", priority);
		fileConfig.set(kitRoot + ".damage-ticks", damageTicks);
		fileConfig.set(kitRoot + ".display-icon", BukkitSerialization.itemStackToBase64(displayIcon));
		fileConfig.set(kitRoot + ".description", Eden.GSON.toJson(description, GsonType.STRING_LIST));
		fileConfig.set(kitRoot + ".potion-effects", EffectSerialization.serializeEffects(effects));
		fileConfig.set(kitRoot + ".armor-loadout", BukkitSerialization.itemStackArrayToBase64(kitLoadout.getArmor()));
		fileConfig.set(kitRoot + ".contents-loadout",
				BukkitSerialization.itemStackArrayToBase64(kitLoadout.getContents()));
		fileConfig.set(kitRoot + ".game-rules", Eden.GSON.toJson(gameRules, GsonType.KIT_GAME_RULES));
		fileConfig.set(kitRoot + ".kit-match-types", Eden.GSON.toJson(kitMatchTypes, GsonType.KIT_MATCH_TYPES));
		fileConfig.set(kitRoot + ".kit-extra-item", Eden.GSON.toJson(kitExtraItems, GsonType.KIT_EXTRA_ITEM));

		Eden.INSTANCE.getKitFile().save();
	}

	public void autoSave() {
		if (Config.ARENA_KIT_AUTO_SAVE.toBoolean()) {
			save();
		}
	}

	public static Kit getByName(String name) {
		for (Kit kit : kits) {
			if (kit.getName().equalsIgnoreCase(name)) {
				return kit;
			}
		}
		return null;
	}

}


Filename: .\main\java\rip\diamond\practice\kits\KitExtraItem.java
package rip.diamond.practice.kits;

import lombok.Data;
import org.bukkit.Material;
import org.bukkit.enchantments.Enchantment;

import java.util.HashMap;
import java.util.Map;

@Data
public class KitExtraItem {

    private String name;
    private Material material;
    private int amount;
    private int data;
    private boolean unbreakable;
    private Map<String, Integer> enchantments;

    public Map<Enchantment, Integer> getEnchantments() {
        Map<Enchantment, Integer> enchantments = new HashMap<>();
        this.enchantments.forEach((string, integer) -> {
            enchantments.put(Enchantment.getByName(string), integer);
        });
        return enchantments;
    }

    public void setEnchantments(Map<Enchantment, Integer> enchantments) {
        Map<String, Integer> enchantmentsMap = new HashMap<>();
        enchantments.forEach((enchantment, integer) -> {
            enchantmentsMap.put(enchantment.getName(), integer);
        });
        this.enchantments = enchantmentsMap;
    }
}


Filename: .\main\java\rip\diamond\practice\kits\KitGameRules.java
package rip.diamond.practice.kits;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.kits.menu.button.impl.KitRulesSetIntegerButton;
import rip.diamond.practice.kits.menu.button.impl.KitRulesSetStringButton;
import rip.diamond.practice.kits.menu.button.impl.KitRulesToggleButton;
import rip.diamond.practice.match.Match;
import rip.diamond.practice.queue.QueueType;

import java.lang.reflect.Field;

// TODO: 8/7/2023 Add time limit (#420)

@Setter
public class KitGameRules implements Cloneable {

	@Getter private boolean receiveKitLoadoutBook = true;
	@Getter private boolean deathOnWater = false;
	@Getter private boolean boxing = false;
	@Getter private boolean bed = false;
	@Getter private boolean breakGoal = false;
	@Getter private boolean portalGoal = false;
	@Getter private boolean projectileOnly = false;
	@Getter private boolean hypixelUHC = false;
	@Getter private boolean spleef = false;
	@Getter private boolean healthRegeneration = true;
	@Getter private boolean showHealth = true;
	@Getter private boolean foodLevelChange = true;
	private boolean point = false;
	private boolean rankedPoint = false;
	@Getter private boolean resetArenaWhenGetPoint = false;
	@Getter private boolean onlyLoserResetPositionWhenGetPoint = false;
	@Getter private boolean build = false;
	@Getter private boolean startFreeze = false;
	@Getter private boolean noDamage = false;
	@Getter private boolean instantGapple = false;
	@Getter private boolean enderPearlCooldown = false;
	@Getter private boolean clearBlock = false;
	@Getter private boolean dropItemWhenDie = true;
	@Getter private boolean noFallDamage = false;
	@Getter private boolean giveBackArrow = false;
	@Getter private boolean dropItems = true;
	@Getter private boolean teamProjectile = true;
	@Getter private boolean bowBoosting = true;
	@Getter private int respawnTime = 5;
	@Getter private int maximumPoints = 3;
	@Getter private int matchCountdownDuration = 5;
	@Getter private int newRoundTime = 5;
	@Getter private int clearBlockTime = 10;
	@Getter private String knockbackName = "default";

	public boolean isPoint(Match match) {
		switch (match.getMatchType()) {
			case SOLO:
				return (point && match.getQueueType() != QueueType.RANKED) || (rankedPoint && match.getQueueType() == QueueType.RANKED);
			case SPLIT:
				//Need to check if the GameRule contains deathOnWater. This is to prevent if the GameRule contains point and the kit is sumo.
				//If it is sumo, then we should not display the point out because point should not be in sumo TeamMatch
				return ((point && match.getQueueType() != QueueType.RANKED) || (rankedPoint && match.getQueueType() == QueueType.RANKED)) && !match.getKit().getGameRules().isDeathOnWater();
			case FFA:
				return false;
		}
		return false;
	}

	@Override
	public KitGameRules clone() {
		KitGameRules rules = new KitGameRules();
		for (Field field : this.getClass().getDeclaredFields()) {
			field.setAccessible(true);
		}
		for (Field field : rules.getClass().getDeclaredFields()) {
			field.setAccessible(true);
			try {
				Object obj = this.getClass().getDeclaredField(field.getName()).get(this);
				field.set(rules, obj);
			} catch (IllegalAccessException | NoSuchFieldException e) {
				throw new RuntimeException(e);
			}
		}
		return rules;
	}

	@Getter
	@AllArgsConstructor
	public enum Readable {
		//boolean
		receiveKitLoadoutBook(Language.KIT_GAME_RULES_RECEIVE_KIT_LOADOUT_BOOK_RULES.toString(), Language.KIT_GAME_RULES_RECEIVE_KIT_LOADOUT_BOOK_DESCRIPTION.toString()),
		deathOnWater(Language.KIT_GAME_RULES_DEATH_ON_WATER_RULES.toString(), Language.KIT_GAME_RULES_DEATH_ON_WATER_DESCRIPTION.toString()),
		boxing(Language.KIT_GAME_RULES_BOXING_RULES.toString(), Language.KIT_GAME_RULES_BOXING_DESCRIPTION.toString()),
		bed(Language.KIT_GAME_RULES_BED_RULES.toString(), Language.KIT_GAME_RULES_BED_DESCRIPTION.toString()),
		breakGoal(Language.KIT_GAME_RULES_BREAK_GOAL_RULES.toString(), Language.KIT_GAME_RULES_BREAK_GOAL_DESCRIPTION.toString()),
		portalGoal(Language.KIT_GAME_RULES_PORTAL_GOAL_RULES.toString(), Language.KIT_GAME_RULES_PORTAL_GOAL_DESCRIPTION.toString()),
		projectileOnly(Language.KIT_GAME_RULES_PROJECTILE_ONLY_RULES.toString(), Language.KIT_GAME_RULES_PROJECTILE_ONLY_DESCRIPTION.toString()),
		hypixelUHC(Language.KIT_GAME_RULES_HYPIXELUHC_RULES.toString(), Language.KIT_GAME_RULES_HYPIXELUHC_DESCRIPTION.toString()),
		spleef(Language.KIT_GAME_RULES_SPLEEF_RULES.toString(), Language.KIT_GAME_RULES_SPLEEF_DESCRIPTION.toString()),
		healthRegeneration(Language.KIT_GAME_RULES_HEALTH_REGENERATION_RULES.toString(), Language.KIT_GAME_RULES_HEALTH_REGENERATION_DESCRIPTION.toString()),
		showHealth(Language.KIT_GAME_RULES_SHOW_HEALTH_RULES.toString(), Language.KIT_GAME_RULES_SHOW_HEALTH_DESCRIPTION.toString()),
		foodLevelChange(Language.KIT_GAME_RULES_FOOD_LEVEL_CHANGE_RULES.toString(), Language.KIT_GAME_RULES_FOOD_LEVEL_CHANGE_DESCRIPTION.toString()),
		point(Language.KIT_GAME_RULES_POINT_RULES.toString(), Language.KIT_GAME_RULES_POINT_DESCRIPTION.toString()),
		rankedPoint(Language.KIT_GAME_RULES_RANKED_POINT_RULES.toString(), Language.KIT_GAME_RULES_RANKED_POINT_DESCRIPTION.toString()),
		resetArenaWhenGetPoint(Language.KIT_GAME_RULES_RESET_ARENA_WHEN_GET_POINT_RULES.toString(), Language.KIT_GAME_RULES_RESET_ARENA_WHEN_GET_POINT_DESCRIPTION.toString()),
		onlyLoserResetPositionWhenGetPoint(Language.KIT_GAME_RULES_ONLY_LOSER_RESET_POSITION_WHEN_GET_POINT_RULES.toString(), Language.KIT_GAME_RULES_ONLY_LOSER_RESET_POSITION_WHEN_GET_POINT_DESCRIPTION.toString()),
		build(Language.KIT_GAME_RULES_BUILD_RULES.toString(), Language.KIT_GAME_RULES_BUILD_DESCRIPTION.toString()),
		startFreeze(Language.KIT_GAME_RULES_START_FREEZE_RULES.toString(), Language.KIT_GAME_RULES_START_FREEZE_DESCRIPTION.toString()),
		noDamage(Language.KIT_GAME_RULES_NO_DAMAGE_RULES.toString(), Language.KIT_GAME_RULES_NO_DAMAGE_DESCRIPTION.toString()),
		instantGapple(Language.KIT_GAME_RULES_INSTANT_GAPPLE_RULES.toString(), Language.KIT_GAME_RULES_INSTANT_GAPPLE_DESCRIPTION.toString()),
		enderPearlCooldown(Language.KIT_GAME_RULES_ENDER_PEARL_COOLDOWN_RULES.toString(), Language.KIT_GAME_RULES_ENDER_PEARL_COOLDOWN_DESCRIPTION.toString()),
		clearBlock(Language.KIT_GAME_RULES_CLEAR_BLOCK_RULES.toString(), Language.KIT_GAME_RULES_CLEAR_BLOCK_DESCRIPTION.toString()),
		dropItemWhenDie(Language.KIT_GAME_RULES_DROP_ITEM_WHEN_DIE_RULES.toString(), Language.KIT_GAME_RULES_DROP_ITEM_WHEN_DIE_DESCRIPTION.toString()),
		noFallDamage(Language.KIT_GAME_RULES_NO_FALL_DAMAGE_RULES.toString(), Language.KIT_GAME_RULES_NO_FALL_DAMAGE_DESCRIPTION.toString()),
		giveBackArrow(Language.KIT_GAME_RULES_GIVE_BACK_ARROW_RULES.toString(), Language.KIT_GAME_RULES_GIVE_BACK_ARROW_DESCRIPTION.toString()),
		dropItems(Language.KIT_GAME_RULES_DROP_ITEMS_RULES.toString(), Language.KIT_GAME_RULES_DROP_ITEMS_DESCRIPTION.toString()),
		teamProjectile(Language.KIT_GAME_RULES_TEAM_PROJECTILE_RULES.toString(), Language.KIT_GAME_RULES_TEAM_PROJECTILE_DESCRIPTION.toString()),
		bowBoosting(Language.KIT_GAME_RULES_BOW_BOOSTING_RULES.toString(), Language.KIT_GAME_RULES_BOW_BOOSTING_DESCRIPTION.toString()),
		//integer
		respawnTime(Language.KIT_GAME_RULES_RESPAWN_TIME_RULES.toString(), Language.KIT_GAME_RULES_RESPAWN_TIME_DESCRIPTION.toString()),
		maximumPoints(Language.KIT_GAME_RULES_MAXIMUM_POINTS_RULES.toString(), Language.KIT_GAME_RULES_MAXIMUM_POINTS_DESCRIPTION.toString()),
		matchCountdownDuration(Language.KIT_GAME_RULES_MATCH_COUNTDOWN_DURATION_RULES.toString(), Language.KIT_GAME_RULES_MATCH_COUNTDOWN_DURATION_DESCRIPTION.toString()),
		newRoundTime(Language.KIT_GAME_RULES_NEW_ROUND_TIME_RULES.toString(), Language.KIT_GAME_RULES_NEW_ROUND_TIME_DESCRIPTION.toString()),
		clearBlockTime(Language.KIT_GAME_RULES_CLEAR_BLOCK_TIME_RULES.toString(), Language.KIT_GAME_RULES_CLEAR_BLOCK_TIME_DESCRIPTION.toString()),
		//String
		knockbackName(Language.KIT_GAME_RULES_KNOCKBACK_NAME_RULES.toString(), Language.KIT_GAME_RULES_KNOCKBACK_NAME_DESCRIPTION.toString()),
		;

		private final String rule;
		private final String description;
	}

}


Filename: .\main\java\rip\diamond\practice\kits\KitListener.java
package rip.diamond.practice.kits;

import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.Listener;
import org.bukkit.event.inventory.InventoryCloseEvent;
import org.bukkit.inventory.Inventory;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.kits.menu.KitDetailsMenu;
import rip.diamond.practice.util.Tasks;

import java.util.Arrays;

public class KitListener implements Listener {

    @EventHandler
    public void onClose(InventoryCloseEvent event) {
        Player player = (Player) event.getPlayer();
        Inventory inventory = event.getView().getTopInventory();
        if (inventory.getTitle().endsWith("ÁöÑÈ°çÂ§ñÁâ©ÂìÅ")) {
            String kitName = inventory.getTitle().replaceAll("ÁöÑÈ°çÂ§ñÁâ©ÂìÅ", "");
            Kit kit = Kit.getByName(kitName);
            if (kit == null) {
                Language.KIT_CANNOT_SAVE_EXTRA_ITEMS.sendMessage(player, kitName);
                return;
            }
            kit.getKitExtraItems().clear();
            Arrays.stream(inventory.getContents()).forEach(item -> {
                if (item == null) {
                    return;
                }
                boolean hasMeta = item.hasItemMeta();
                KitExtraItem kitExtraItem = new KitExtraItem();
                kitExtraItem.setName(hasMeta ? item.getItemMeta().getDisplayName() : null);
                kitExtraItem.setMaterial(item.getType());
                kitExtraItem.setAmount(item.getAmount());
                kitExtraItem.setData(item.getDurability());
                kitExtraItem.setUnbreakable(hasMeta && item.getItemMeta().spigot().isUnbreakable());
                kitExtraItem.setEnchantments(item.getEnchantments());
                kit.getKitExtraItems().add(kitExtraItem);
            });
            Language.KIT_SUCCESSFULLY_UPDATED_EXTRA_ITEMS.sendMessage(player, kit.getName());
            kit.autoSave();
            Tasks.runLater(()-> new KitDetailsMenu(kit, null).openMenu(player), 1L);
        }
    }

}


Filename: .\main\java\rip\diamond\practice\kits\KitLoadout.java
package rip.diamond.practice.kits;

import lombok.Getter;
import lombok.Setter;
import org.bson.Document;
import org.bukkit.entity.Player;
import org.bukkit.inventory.ItemStack;
import rip.diamond.practice.event.KitLoadoutReceivedEvent;
import rip.diamond.practice.match.Match;
import rip.diamond.practice.util.serialization.BukkitSerialization;

public class KitLoadout {

	@Getter
	@Setter
	private String customName = "Default";
	private String armor;
	private String contents;

	public void fromBson(Document document) {
		customName = document.getString("customName");
		armor = document.getString("armor");
		contents = document.getString("contents");
	}

	public Document toBson() {
		return new Document()
				.append("customName", contents)
				.append("armor", armor)
				.append("contents", contents);
	}

	public KitLoadout() {
		this.armor = BukkitSerialization.itemStackArrayToBase64(new ItemStack[4]);
		this.contents = BukkitSerialization.itemStackArrayToBase64(new ItemStack[36]);
	}

	public KitLoadout(String customName, Kit kit) {
		this.customName = customName;
		this.armor = BukkitSerialization.itemStackArrayToBase64(kit.getKitLoadout().getArmor());
		this.contents = BukkitSerialization.itemStackArrayToBase64(new ItemStack[36]);
	}

	public KitLoadout(String customName) {
		this.customName = customName;
		this.armor = BukkitSerialization.itemStackArrayToBase64(new ItemStack[4]);
		this.contents = BukkitSerialization.itemStackArrayToBase64(new ItemStack[36]);
	}

	public KitLoadout(String customName, String armor, String contents) {
		this.customName = customName;
		this.armor = armor;
		this.contents = contents;
	}

	public ItemStack[] getArmor() {
		return BukkitSerialization.itemStackArrayFromBase64(armor);
	}

	public ItemStack[] getContents() {
		return BukkitSerialization.itemStackArrayFromBase64(contents);
	}

	public String getArmorAsBase64() {
		return armor;
	}

	public String getContentsAsBase64() {
		return contents;
	}

	public void setArmor(ItemStack[] armor) {
		this.armor = BukkitSerialization.itemStackArrayToBase64(armor);
	}

	public void setContents(ItemStack[] contents) {
		this.contents = BukkitSerialization.itemStackArrayToBase64(contents);
	}

	public void apply(Kit kit, Match match, Player player) {
		player.getInventory().setArmorContents(null);
		player.getInventory().clear();

		// Always use default kit armor (not custom loadout armor)
		// This ensures proper team colorization and consistent armor
		if (kit != null) {
			player.getInventory().setArmorContents(kit.getKitLoadout().getArmor());
		} else {
			// Fallback to custom armor if kit is null (shouldn't happen in normal gameplay)
			player.getInventory().setArmorContents(getArmor());
		}

		// Use custom loadout contents
		player.getInventory().setContents(getContents());

		// Only set kit loadout if match exists (not in editor mode)
		if (match != null) {
			match.getTeamPlayer(player).setKitLoadout(this);
		}

		KitLoadoutReceivedEvent e = new KitLoadoutReceivedEvent(player, match, this);
		e.call();
	}
}


Filename: .\main\java\rip\diamond\practice\kits\KitMatchType.java
package rip.diamond.practice.kits;

public enum KitMatchType {
    SOLO,
    FFA,
    SPLIT
}


Filename: .\main\java\rip\diamond\practice\kits\command\EnchantCommand.java
package rip.diamond.practice.kits.command;

import org.bukkit.enchantments.Enchantment;
import org.bukkit.entity.Player;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.util.CC;
import rip.diamond.practice.util.Checker;
import rip.diamond.practice.util.Common;
import rip.diamond.practice.util.command.Command;
import rip.diamond.practice.util.command.CommandArgs;
import rip.diamond.practice.util.command.argument.CommandArguments;

public class EnchantCommand extends Command {
    @CommandArgs(name = "enchant", aliases = {"forceenchant"}, permission = "eden.command.enchant")
    public void execute(CommandArguments command) {
        Player player = command.getPlayer();
        String[] args = command.getArgs();

        if (args.length != 2) {
            Language.INVALID_SYNTAX.sendMessage(player);
            return;
        }
        if (!Checker.isEnchantment(args[0]) || !Checker.isInteger(args[1])) {
            Language.INVALID_SYNTAX.sendMessage(player);
            return;
        }

        player.getItemInHand().addUnsafeEnchantment(Enchantment.getByName(args[0].toUpperCase()), Integer.parseInt(args[1]));
        Common.sendMessage(player, CC.YELLOW + "[Eden] Successfully enchanted your item.");
        return;
    }
}


Filename: .\main\java\rip\diamond\practice\kits\command\GoldenHeadCommand.java
package rip.diamond.practice.kits.command;

import org.bukkit.entity.Player;
import org.bukkit.inventory.ItemStack;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.util.CC;
import rip.diamond.practice.util.Checker;
import rip.diamond.practice.util.Common;
import rip.diamond.practice.util.command.Command;
import rip.diamond.practice.util.command.CommandArgs;
import rip.diamond.practice.util.command.argument.CommandArguments;
import rip.diamond.practice.util.exception.PracticeUnexpectedException;
import rip.diamond.practice.util.serialization.BukkitSerialization;

public class GoldenHeadCommand extends Command {
    @CommandArgs(name = "goldenhead", permission = "eden.command.goldenhead")
    public void execute(CommandArguments command) {
        Player player = command.getPlayer();
        String[] args = command.getArgs();

        ItemStack goldenHead = BukkitSerialization.itemStackFromBase64("rO0ABXNyABpvcmcuYnVra2l0LnV0aWwuaW8uV3JhcHBlcvJQR+zxEm8FAgABTAADbWFwdAAPTGphdmEvdXRpbC9NYXA7eHBzcgA1Y29tLmdvb2dsZS5jb21tb24uY29sbGVjdC5JbW11dGFibGVNYXAkU2VyaWFsaXplZEZvcm0AAAAAAAAAAAIAAlsABGtleXN0ABNbTGphdmEvbGFuZy9PYmplY3Q7WwAGdmFsdWVzcQB+AAR4cHVyABNbTGphdmEubGFuZy5PYmplY3Q7kM5YnxBzKWwCAAB4cAAAAAR0AAI9PXQABHR5cGV0AAZkYW1hZ2V0AARtZXRhdXEAfgAGAAAABHQAHm9yZy5idWtraXQuaW52ZW50b3J5Lkl0ZW1TdGFja3QAClNLVUxMX0lURU1zcgAPamF2YS5sYW5nLlNob3J0aE03EzRg2lICAAFTAAV2YWx1ZXhyABBqYXZhLmxhbmcuTnVtYmVyhqyVHQuU4IsCAAB4cAADc3EAfgAAc3EAfgADdXEAfgAGAAAABXEAfgAIdAAJbWV0YS10eXBldAAMZGlzcGxheS1uYW1ldAAIaW50ZXJuYWx0AAtza3VsbC1vd25lcnVxAH4ABgAAAAV0AAhJdGVtTWV0YXQABVNLVUxMdAAOwqc2R29sZGVuIEhlYWR0BXhINHNJQUFBQUFBQUFBSzJTeVpLalJoQ0c4WVFkN3Vud1kvalcwU0VvUUlpRER5d1NtNm9RRXZ0bGdsVXFWQWdraEJBODB6eWttWjZPc0gzM3BUSWlzeXIvTC8rc1Y0cDZwZjQ0bkh0Q2RyZW14S1I0b2I0WU9mVW56d3Badm1MNWR6R2hoWGN1VGRsM01lZVc3eHdRYzVyTE9KNEIvQ3YxT2o5cWk5c2RGOTFYNnVWZVBPLzlyZWhlS1lyNjVZWDZlc0RIUy9JajgrVzd4VzZ0cVhrVzdKTzhJZElWZXIrbUEzQzcxRm5ZRzRlYlZrelIzby9qWEJ2TzdzVUVQR1pPVEhHYWozVUZCaUJZZ3hqY1BVWlBPL1Y1WDV3bnQvYWVlbkpjSlFLMkJDdkxyTWNEYkRPZTlDM2c2NnVWbldPRjU4T205c3dIRTRUT1hVZXhXa2Rnb1NPQm13UWk2K3NOdzF3bnpvclIzZ2lRQzA3MVdlWThRRWgxQVhsSnhPd3VQd0dkMHNMWjBzWWhqUlNzR0t6STM4TzBxM2ZqeHV1bnVtdWgyREQyK3V6aTYrN3FlUFhOVy9ianhhRHhibGk4NmJmRGZtMCtIcFp6TlFBZnVBV1BHNkY5c3pIck5ERFM4aXNuaTFvcFBhL0FrNXRyRnErczNxUWRlWnFZMjU1OWl5WXZYL2FLbi9yeW14K3ZoT2FhWHNiN3llVmNmMldQUW94cFoyenk2WHdKMkhKYnlFbTJVMjBhVlVpdzQwdSsxTGlwRUUzQjNna2xIZEhsaGxZY2s2ZkJ0b3NRR0R1MmFQVG1xTmlrWThBSVdkcmNDSGEyWWs3UEJ5WVhBWWFKbUxMKzFpQlhrOG40RFcvU0lkYnFOQk5VVFZ6R0xrS3JSOW5uSzZtenBteWdWeUR6cENrNXdtWENPWm9ERnp5ekZjd3B1QjQwVnpvZ3U4VzdkYk10bXRhb2pjV3dqUGNKZDJHeTFaMHdiaWQzL0tJd2RyYVM3L3pMOE9DZmJDb3BkenlKU0ovS1l5azhIQ1lNZzRNNkRvRVRHUkNmY3Z0eHhHVzB3dU5iWHJXNitMU09HUjZlZVZnV0xkUHNXMHZwL0dNRTcyRWlSMjJwTjN3cGJvOFY1bHU1dHp5ckN0cHJ2ZGIyVFFTRm1ubE9uWGE0SnRkZ2NsSXZPSFVtZmVMalJkcnIwbDh2MUc5K1F2cmlpMXNNemRGUVREb0pHSkt4KzFNYVN0aFFteU4wSTRBcVNNTnBUZHR1UnNQRFlCbUtoRFBkZk1RMTZXS1BuQTBzTFEzRllPQ1VWN0Y2bkpCTFRsRE42S2cySmp0dzVtMDU0eHdIcEVFYXVlc1JIWXhPd2RMUnVNaGpDdUkyMVh3N21uVi85akhMQSt0anFLUFN3SjlhZ0Z6U2VrUG5vVW04Mm4vbUFSbmp3UG5neTNXVGlUK1pjczNuY3QwZjR4QisxSDdPTk9zUXREMTQzSDl6UCs2SFp2ZXAyZVQ2ZnJEeDZ2R3ZIbjBha0Q0TzBCZ0ZNYjJ0ZVpJckloMkhwdytPN2VRQlZLODVORGtBcW1zV2dzMDVyaVNBQU1Kd3JrV0JOMEpWUGtNVkRzaVZadjh5YnY3cURLeTlDYWtHRjFVT2k2WjlOWHZ5aE1HYXNWMVN3Y3JCSDc0b3NyaVZQam5QU1BiVzN2L0xEaUkrY2pPQVhNak91MkZ0OThqSDFid3p6UUN4S2cwdzhDWll5ZWNvZ0RQWHBwcm40V09YRUZSdFRuRGExRWhEQk01NVd6M1ZzSkxZdUpKUHNmb1ArNDlZT3ExSVVTL1VyeWlwQytyM2IxYWYwdDAzaXZvYlBDMWxSb1lGQUFBPXQAB19LdWIwc18=");

        if (goldenHead == null) {
            throw new PracticeUnexpectedException("Generated Golden Head should not be null");
        }

        if (args.length != 1) {
            player.getInventory().addItem(goldenHead);
        } else {
            if (!Checker.isInteger(args[0])) {
                Language.INVALID_SYNTAX.sendMessage(player);
                return;
            }
            goldenHead.setAmount(Integer.parseInt(args[0]));
            player.getInventory().addItem(goldenHead);
        }

        Common.sendMessage(player, CC.YELLOW + "[Eden] Added " + CC.GREEN + (args.length != 1 ? 1 : args[0]) + CC.GOLD + " Golden Head " + CC.YELLOW + "into your inventory.");
    }
}


Filename: .\main\java\rip\diamond\practice\kits\command\KitCommand.java
package rip.diamond.practice.kits.command;

import org.bukkit.entity.Player;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.kits.Kit;
import rip.diamond.practice.kits.KitGameRules;
import rip.diamond.practice.kits.menu.KitDetailsMenu;
import rip.diamond.practice.kits.menu.KitsManagementMenu;
import rip.diamond.practice.util.command.Command;
import rip.diamond.practice.util.command.CommandArgs;
import rip.diamond.practice.util.command.argument.CommandArguments;

import java.util.List;
import java.util.stream.Collectors;

public class KitCommand extends Command {
    @CommandArgs(name = "kit", permission = "eden.command.kit")
    public void execute(CommandArguments command) {
        Player player = command.getPlayer();
        String[] args = command.getArgs();

        if (args.length == 0) {
            if (Kit.getKits().size() == 0) {
                Language.KIT_NO_KITS_FOUND.sendMessage(player);
                return;
            }
            new KitsManagementMenu().openMenu(player);
            return;
        } else if (args.length == 1) {
            if (args[0].equalsIgnoreCase("list")) {
                new KitsManagementMenu().openMenu(player);
                return;
            } else if (args[0].equalsIgnoreCase("saveall")) {
                Kit.getKits().forEach(Kit::save);
                Language.KIT_SAVED_ALL_KITS.sendMessage(player);
                return;
            }
            Kit kit = Kit.getByName(args[0]);
            if (kit == null) {
                Language.KIT_NOT_EXISTS.sendMessage(player, args[0]);
                return;
            }
            new KitDetailsMenu(kit, null).openMenu(player);
        } else if (args.length == 2) {
            Kit kit = Kit.getByName(args[1]);
            if (args[0].equalsIgnoreCase("create")) {
                if (kit != null) {
                    Language.KIT_KIT_ALREADY_EXISTS.sendMessage(player, args[1]);
                    return;
                }
                Kit newKit = new Kit(args[1]);
                Kit.getKits().add(newKit);
                newKit.autoSave();
                Language.KIT_SUCCESSFULLY_CREATE.sendMessage(player, newKit.getName());
            } else if (args[0].equalsIgnoreCase("delete")) {
                if (kit == null) {
                    Language.KIT_NOT_EXISTS.sendMessage(player, args[1]);
                    return;
                }
                kit.delete();
                Language.KIT_SUCCESSFULLY_DELETE.sendMessage(player, kit.getName());
            } else if (args[0].equalsIgnoreCase("save")) {
                if (kit == null) {
                    Language.KIT_NOT_EXISTS.sendMessage(player, args[1]);
                    return;
                }
                kit.save();
                Language.KIT_SAVED.sendMessage(player, kit.getName());
            }
        } else if (args.length == 3) {
            Kit kit = Kit.getByName(args[1]);
            if (args[0].equalsIgnoreCase("clone")) {
                if (kit == null) {
                    Language.KIT_NOT_EXISTS.sendMessage(player, args[1]);
                    return;
                }
                Kit newKit = Kit.getByName(args[2]);
                if (newKit == null) {
                    Language.KIT_NOT_EXISTS.sendMessage(player, args[2]);
                    return;
                }
                KitGameRules rules = kit.getGameRules().clone();
                newKit.setGameRules(rules);
                newKit.autoSave();
                Language.KIT_SUCCESSFULLY_CLONE.sendMessage(player, kit.getName(), newKit.getName());
            }
        }
    }

    @Override
    public List<String> getDefaultTabComplete(CommandArguments command) {
        return Kit.getKits().stream().map(Kit::getName).collect(Collectors.toList());
    }
}


Filename: .\main\java\rip\diamond\practice\kits\menu\KitDetailsMenu.java
package rip.diamond.practice.kits.menu;

import lombok.RequiredArgsConstructor;
import org.bukkit.Material;
import org.bukkit.entity.Player;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.kits.Kit;
import rip.diamond.practice.kits.menu.button.impl.*;
import rip.diamond.practice.util.menu.Button;
import rip.diamond.practice.util.menu.Menu;
import rip.diamond.practice.util.menu.button.BackButton;
import rip.diamond.practice.util.menu.pagination.PageButton;
import rip.diamond.practice.util.menu.pagination.PaginatedMenu;

import java.lang.reflect.Field;
import java.util.HashMap;
import java.util.Map;

@RequiredArgsConstructor
public class KitDetailsMenu extends PaginatedMenu {
    private final Kit kit;
    private final Menu backMenu;

    @Override
    public String getPrePaginatedTitle(Player player) {
        return Language.KIT_KIT_DETAIL_MENU_TITLE.toString(kit.getName());
    }

    @Override
    public int getSize() {
        return 54;
    }

    @Override
    public Map<Integer, Button> getButtons(Player player) {
        final Map<Integer, Button> buttons = new HashMap<>();

        int minIndex = (int) ((double) (page - 1) * getMaxItemsPerPage(player));
        int maxIndex = (int) ((double) (page) * getMaxItemsPerPage(player));
        int topIndex = 0;

        for (Map.Entry<Integer, Button> entry : getAllPagesButtons(player).entrySet()) {
            int index = entry.getKey();

            if (index >= minIndex && index < maxIndex) {
                index -= (int) ((double) (getMaxItemsPerPage(player)) * (page - 1)) - 27;
                buttons.put(index, entry.getValue());

                if (index > topIndex) {
                    topIndex = index;
                }
            }
        }

        buttons.put(18, new PageButton(-1, this));
        buttons.put(26, new PageButton(1, this));

        Map<Integer, Button> global = getGlobalButtons(player);
        if (global != null) {
            buttons.putAll(global);
        }

        return buttons;
    }

    @Override
    public int getMaxItemsPerPage(Player player) {
        return 27;
    }

    @Override
    public Map<Integer, Button> getGlobalButtons(Player player) {
        final Map<Integer, Button> buttons = new HashMap<>();

        if (backMenu != null) {
            buttons.put(0, new BackButton(Material.STAINED_GLASS_PANE, 14, backMenu));
        }
        buttons.put(3, new KitEditMatchTypeButton(kit, this));
        buttons.put(4, new KitPreviewButton(kit, this));
        buttons.put(5, new KitToggleButton(kit, this));
        buttons.put(8, new KitSaveButton(kit, this));
        buttons.put(9, new KitEditDisplayNameButton(kit, this));
        buttons.put(10, new KitEditDescriptionButton(kit, this));
        buttons.put(11, new KitEditIconButton(kit, this));
        buttons.put(12, new KitEditPriorityButton(kit, this));
        buttons.put(13, new KitEditPotionEffectButton(kit, this));
        buttons.put(14, new KitEditDamageTicksButton(kit, this));
        buttons.put(15, new KitToggleRankedButton(kit, this));
        buttons.put(16, new KitSaveLoadoutButton(kit, this));
        buttons.put(17, new KitEditExtraItemsButton(kit));

        return buttons;
    }

    @Override
    public Map<Integer, Button> getAllPagesButtons(Player player) {
        final Map<Integer, Button> buttons = new HashMap<>();

        for (Field field : kit.getGameRules().getClass().getDeclaredFields()) {
            field.setAccessible(true);
            if (field.getType() == boolean.class) {
                buttons.put(buttons.size(), new KitRulesToggleButton(this, kit, field));
            } else if (field.getType() == int.class) {
                buttons.put(buttons.size(), new KitRulesSetIntegerButton(this, kit, field));
            } else {
                buttons.put(buttons.size(), new KitRulesSetStringButton(this, kit, field));
            }
        }

        return buttons;
    }
}


Filename: .\main\java\rip\diamond\practice\kits\menu\KitPreviewMenu.java
package rip.diamond.practice.kits.menu;

import lombok.RequiredArgsConstructor;
import org.bukkit.Material;
import org.bukkit.entity.Player;
import org.bukkit.inventory.ItemStack;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.kits.Kit;
import rip.diamond.practice.util.InventoryUtil;
import rip.diamond.practice.util.menu.Button;
import rip.diamond.practice.util.menu.Menu;
import rip.diamond.practice.util.menu.button.BackButton;
import rip.diamond.practice.util.menu.button.DisplayButton;

import java.util.HashMap;
import java.util.Map;

@RequiredArgsConstructor
public class KitPreviewMenu extends Menu {

    private final Kit kit;
    private final Menu backMenu;

    @Override
    public String getTitle(Player player) {
        return Language.KIT_KIT_PREVIEW_MENU_TITLE.toString(kit.getName());
    }

    @Override
    public int getSize() {
        return 9*6;
    }

    @Override
    public Map<Integer, Button> getButtons(Player player) {
        final Map<Integer, Button> buttons = new HashMap<>();
        if (backMenu != null) {
            buttons.put(0, new BackButton(Material.STAINED_GLASS_PANE, 14, backMenu));
        }
        for (int i = 0; i < 9; i++) {
            if (!buttons.containsKey(i)) {
                buttons.put(i, placeholderButton);
            }
        }
        int i = 9;
        for (ItemStack itemStack : InventoryUtil.fixInventoryOrder(kit.getKitLoadout().getContents())) {
            if (itemStack != null && itemStack.getType() != null && itemStack.getType() != Material.AIR) {
                buttons.put(i++, new DisplayButton(itemStack, true));
            }
        }
        int x = 0;
        for (ItemStack itemStack : kit.getKitLoadout().getArmor()) {
            if (itemStack != null && itemStack.getType() != null && itemStack.getType() != Material.AIR) {
                buttons.put(48 - x++, new DisplayButton(itemStack, true));
            }
        }
        return buttons;
    }
}


Filename: .\main\java\rip\diamond\practice\kits\menu\KitsManagementMenu.java
package rip.diamond.practice.kits.menu;

import org.bukkit.entity.Player;
import org.bukkit.event.inventory.ClickType;
import org.bukkit.inventory.ItemStack;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.kits.Kit;
import rip.diamond.practice.util.ItemBuilder;
import rip.diamond.practice.util.menu.Button;
import rip.diamond.practice.util.menu.pagination.PaginatedMenu;

import java.util.HashMap;
import java.util.Map;

public class KitsManagementMenu extends PaginatedMenu {
    @Override
    public String getPrePaginatedTitle(Player player) {
        return Language.KIT_KIT_MANAGEMENT_MENU_TITLE.toString();
    }

    @Override
    public Map<Integer, Button> getAllPagesButtons(Player player) {
        final Map<Integer, Button> buttons = new HashMap<>();

        Kit.getKits().forEach(kit -> {
            buttons.put(buttons.size(), new Button() {
                @Override
                public ItemStack getButtonItem(Player player) {
                    return new ItemBuilder(kit.getDisplayIcon().clone())
                            .name(Language.KIT_KIT_MANAGEMENT_MENU_BUTTON_NAME.toString(kit.getDisplayName(), kit.getName()))
                            .lore(Language.KIT_KIT_MANAGEMENT_MENU_BUTTON_LORE.toStringList(player))
                            .build();
                }

                @Override
                public void clicked(Player player, int slot, ClickType clickType, int hotbarSlot) {
                    new KitDetailsMenu(kit, KitsManagementMenu.this).openMenu(player);
                }
            });
        });

        return buttons;
    }
}


Filename: .\main\java\rip\diamond\practice\kits\menu\button\KitButton.java
package rip.diamond.practice.kits.menu.button;

import lombok.RequiredArgsConstructor;
import rip.diamond.practice.kits.Kit;
import rip.diamond.practice.util.menu.Button;

@RequiredArgsConstructor
public abstract class KitButton extends Button {

    public final Kit kit;

}


Filename: .\main\java\rip\diamond\practice\kits\menu\button\impl\KitEditDamageTicksButton.java
package rip.diamond.practice.kits.menu.button.impl;

import org.bukkit.Material;
import org.bukkit.entity.Player;
import org.bukkit.event.inventory.ClickType;
import org.bukkit.inventory.ItemStack;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.kits.Kit;
import rip.diamond.practice.kits.menu.button.KitButton;
import rip.diamond.practice.profile.procedure.Procedure;
import rip.diamond.practice.profile.procedure.ProcedureType;
import rip.diamond.practice.util.Checker;
import rip.diamond.practice.util.ItemBuilder;
import rip.diamond.practice.util.menu.Menu;

public class KitEditDamageTicksButton extends KitButton {

    private final Menu backMenu;

    public KitEditDamageTicksButton(Kit kit, Menu backMenu) {
        super(kit);
        this.backMenu = backMenu;
    }

    @Override
    public ItemStack getButtonItem(Player player) {
        return new ItemBuilder(Material.NETHER_STAR)
                .name(Language.KIT_BUTTON_EDIT_DAMAGE_TICKS_NAME.toString())
                .lore(Language.KIT_BUTTON_EDIT_DAMAGE_TICKS_LORE.toStringList(player, kit.getDamageTicks()))
                .build();
    }

    @Override
    public void clicked(Player player, int slot, ClickType clickType, int hotbarSlot) {
        player.closeInventory();
        Procedure.buildProcedure(player, Language.KIT_BUTTON_EDIT_DAMAGE_TICKS_PROCEDURE_MESSAGE.toString(), ProcedureType.CHAT, (s) -> {
            String message = (String) s;

            if (!Checker.isInteger(message)) {
                Language.INVALID_SYNTAX.sendMessage(player);
                return;
            }

            int damageTicks = Integer.parseInt(message);

            kit.setDamageTicks(damageTicks);
            Language.KIT_BUTTON_EDIT_DAMAGE_TICKS_PROCEDURE_SUCCESS.sendMessage(player, kit.getName(), kit.getDamageTicks());
            kit.autoSave();
            backMenu.openMenu(player);
        });

        Language.KIT_BUTTON_EDIT_DAMAGE_TICKS_PROCEDURE_ADDITIONAL_MESSAGE.sendMessage(player);
    }
}


Filename: .\main\java\rip\diamond\practice\kits\menu\button\impl\KitEditDescriptionButton.java
package rip.diamond.practice.kits.menu.button.impl;

import com.google.common.collect.Lists;
import org.apache.commons.lang3.StringUtils;
import org.bukkit.Material;
import org.bukkit.entity.Player;
import org.bukkit.event.inventory.ClickType;
import org.bukkit.inventory.ItemStack;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.kits.Kit;
import rip.diamond.practice.kits.menu.button.KitButton;
import rip.diamond.practice.profile.procedure.Procedure;
import rip.diamond.practice.profile.procedure.ProcedureType;
import rip.diamond.practice.util.ItemBuilder;
import rip.diamond.practice.util.menu.Menu;

import java.util.Arrays;

public class KitEditDescriptionButton extends KitButton {

    private final Menu backMenu;

    public KitEditDescriptionButton(Kit kit, Menu backMenu) {
        super(kit);
        this.backMenu = backMenu;
    }

    @Override
    public ItemStack getButtonItem(Player player) {
        return new ItemBuilder(Material.BOOK)
                .name(Language.KIT_BUTTON_EDIT_DESCRIPTION_NAME.toString())
                .lore(Language.KIT_BUTTON_EDIT_DESCRIPTION_LORE_START.toStringList(player))
                .lore(kit.getDescription())
                .lore(Language.KIT_BUTTON_EDIT_DESCRIPTION_LORE_END.toStringList(player))
                .build();
    }

    @Override
    public void clicked(Player player, int slot, ClickType clickType, int hotbarSlot) {
        player.closeInventory();
        if (clickType == ClickType.DROP) {
            kit.setDescription(Lists.newArrayList());
            backMenu.openMenu(player);
            return;
        }
        Procedure.buildProcedure(player, Language.KIT_BUTTON_EDIT_DESCRIPTION_PROCEDURE_MESSAGE.toString(), ProcedureType.CHAT, (s) -> {
            String message = (String) s;

            kit.setDescription(Arrays.asList(message.split(";")));
            Language.KIT_BUTTON_EDIT_DESCRIPTION_PROCEDURE_SUCCESS.sendMessage(player, kit.getName(), StringUtils.join(kit.getDescription(), ", "));
            kit.autoSave();
            backMenu.openMenu(player);
        });
        Language.KIT_BUTTON_EDIT_DESCRIPTION_PROCEDURE_ADDITIONAL_MESSAGE.sendMessage(player);
    }
}


Filename: .\main\java\rip\diamond\practice\kits\menu\button\impl\KitEditDisplayNameButton.java
package rip.diamond.practice.kits.menu.button.impl;

import org.bukkit.Material;
import org.bukkit.entity.Player;
import org.bukkit.event.inventory.ClickType;
import org.bukkit.inventory.ItemStack;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.kits.Kit;
import rip.diamond.practice.kits.menu.button.KitButton;
import rip.diamond.practice.profile.procedure.Procedure;
import rip.diamond.practice.profile.procedure.ProcedureType;
import rip.diamond.practice.util.Common;
import rip.diamond.practice.util.ItemBuilder;
import rip.diamond.practice.util.menu.Menu;

public class KitEditDisplayNameButton extends KitButton {

    private final Menu backMenu;

    public KitEditDisplayNameButton(Kit kit, Menu backMenu) {
        super(kit);
        this.backMenu = backMenu;
    }

    @Override
    public ItemStack getButtonItem(Player player) {
        return new ItemBuilder(Material.ANVIL)
                .name(Language.KIT_BUTTON_EDIT_DISPLAY_NAME_NAME.toString())
                .lore(Language.KIT_BUTTON_EDIT_DISPLAY_NAME_LORE.toStringList(player, kit.getDisplayName()))
                .build();
    }

    @Override
    public void clicked(Player player, int slot, ClickType clickType, int hotbarSlot) {
        player.closeInventory();
        Procedure.buildProcedure(player, Language.KIT_BUTTON_EDIT_DISPLAY_NAME_PROCEDURE_MESSAGE.toString(), ProcedureType.CHAT, (s) -> {
            String message = (String) s;

            kit.setDisplayName(message);
            Common.sendMessage(player, Language.KIT_BUTTON_EDIT_DISPLAY_NAME_PROCEDURE_SUCCESS.toString(kit.getName(), kit.getDisplayName()));
            kit.autoSave();
            backMenu.openMenu(player);
        });
    }
}


Filename: .\main\java\rip\diamond\practice\kits\menu\button\impl\KitEditExtraItemsButton.java
package rip.diamond.practice.kits.menu.button.impl;

import org.bukkit.Bukkit;
import org.bukkit.Material;
import org.bukkit.entity.Player;
import org.bukkit.event.inventory.ClickType;
import org.bukkit.event.inventory.InventoryType;
import org.bukkit.inventory.Inventory;
import org.bukkit.inventory.ItemStack;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.kits.Kit;
import rip.diamond.practice.kits.menu.button.KitButton;
import rip.diamond.practice.util.ItemBuilder;

public class KitEditExtraItemsButton extends KitButton {
    public KitEditExtraItemsButton(Kit kit) {
        super(kit);
    }

    @Override
    public ItemStack getButtonItem(Player player) {
        return new ItemBuilder(Material.ENDER_CHEST)
                .name(Language.KIT_BUTTON_EDIT_EXTRA_ITEMS_NAME.toString())
                .lore(Language.KIT_BUTTON_EDIT_EXTRA_ITEMS_LORE.toStringList(player))
                .build();
    }

    @Override
    public void clicked(Player player, int slot, ClickType clickType, int hotbarSlot) {
        Inventory inventory = Bukkit.createInventory(null, InventoryType.CHEST, kit.getName() + "ÁöÑÈ°çÂ§ñÁâ©ÂìÅ");
        kit.getKitExtraItems().forEach(item -> {
            ItemBuilder builder = new ItemBuilder(item.getMaterial()).amount(item.getAmount()).durability(item.getData()).enchantments(item.getEnchantments());
            if (item.getName() != null) {
                builder.name(item.getName());
            }
            if (item.isUnbreakable()) {
                builder.unbreakable();
            }
            inventory.addItem(builder.build());
        });
        player.openInventory(inventory);
    }
}


Filename: .\main\java\rip\diamond\practice\kits\menu\button\impl\KitEditIconButton.java
package rip.diamond.practice.kits.menu.button.impl;

import org.bukkit.Material;
import org.bukkit.entity.Player;
import org.bukkit.event.inventory.ClickType;
import org.bukkit.inventory.ItemStack;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.kits.Kit;
import rip.diamond.practice.kits.menu.button.KitButton;
import rip.diamond.practice.util.ItemBuilder;
import rip.diamond.practice.util.menu.Menu;

public class KitEditIconButton extends KitButton {

    private final Menu backMenu;

    public KitEditIconButton(Kit kit, Menu backMenu) {
        super(kit);
        this.backMenu = backMenu;
    }

    @Override
    public ItemStack getButtonItem(Player player) {
        return new ItemBuilder(Material.EYE_OF_ENDER)
                .name(Language.KIT_BUTTON_EDIT_ICON_NAME.toString())
                .lore(Language.KIT_BUTTON_EDIT_ICON_LORE.toStringList(player, kit.getDisplayIcon().getType().name(), kit.getDisplayIcon().getDurability()))
                .build();
    }

    @Override
    public void clicked(Player player, int slot, ClickType clickType, int hotbarSlot) {
        player.closeInventory();

        ItemStack itemStack = player.getItemInHand().clone();
        if (itemStack.getType() == Material.AIR) {
            Language.KIT_BUTTON_EDIT_ICON_PROCEDURE_AIR.sendMessage(player);
        } else {
            kit.setDisplayIcon(itemStack);
            Language.KIT_BUTTON_EDIT_ICON_PROCEDURE_SUCCESS.sendMessage(player, kit.getName(), itemStack.getType().name());
            kit.autoSave();
        }
        backMenu.openMenu(player);
    }
}


Filename: .\main\java\rip\diamond\practice\kits\menu\button\impl\KitEditMatchTypeButton.java
package rip.diamond.practice.kits.menu.button.impl;

import org.bukkit.Material;
import org.bukkit.entity.Player;
import org.bukkit.event.inventory.ClickType;
import org.bukkit.inventory.ItemStack;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.kits.Kit;
import rip.diamond.practice.kits.KitMatchType;
import rip.diamond.practice.kits.menu.button.KitButton;
import rip.diamond.practice.util.CC;
import rip.diamond.practice.util.ItemBuilder;
import rip.diamond.practice.util.menu.Menu;

public class KitEditMatchTypeButton extends KitButton {

    private final Menu menu;

    public KitEditMatchTypeButton(Kit kit, Menu menu) {
        super(kit);
        this.menu = menu;
    }

    @Override
    public ItemStack getButtonItem(Player player) {
        return new ItemBuilder(Material.FLINT)
                .name(Language.KIT_BUTTON_EDIT_MATCH_TYPE_NAME.toString())
                .lore(
                        "",
                        (kit.getKitMatchTypes().contains(KitMatchType.SOLO) ? CC.GREEN + " ¬ª " : CC.GRAY + "   ") + "Solo " + Language.KIT_BUTTON_EDIT_MATCH_TYPE_LORE_CLICK_LEFT.toString(),
                        (kit.getKitMatchTypes().contains(KitMatchType.FFA) ? CC.GREEN + " ¬ª " : CC.GRAY + "   ") + "FFA " + Language.KIT_BUTTON_EDIT_MATCH_TYPE_LORE_CLICK_MIDDLE.toString(),
                        (kit.getKitMatchTypes().contains(KitMatchType.SPLIT) ? CC.GREEN + " ¬ª " : CC.GRAY + "   ") + "Split " + Language.KIT_BUTTON_EDIT_MATCH_TYPE_LORE_CLICK_RIGHT.toString()
                )
                .lore(Language.KIT_BUTTON_EDIT_MATCH_TYPE_LORE.toStringList(player))
                .build();
    }

    @Override
    public void clicked(Player player, int slot, ClickType clickType, int hotbarSlot) {
        playNeutral(player);
        switch (clickType) {
            case LEFT:
                if (kit.getKitMatchTypes().contains(KitMatchType.SOLO)) {
                    kit.getKitMatchTypes().remove(KitMatchType.SOLO);
                } else {
                    kit.getKitMatchTypes().add(KitMatchType.SOLO);
                }
                break;
            case MIDDLE:
                if (kit.getKitMatchTypes().contains(KitMatchType.FFA)) {
                    kit.getKitMatchTypes().remove(KitMatchType.FFA);
                } else {
                    kit.getKitMatchTypes().add(KitMatchType.FFA);
                }
                break;
            case RIGHT:
                if (kit.getKitMatchTypes().contains(KitMatchType.SPLIT)) {
                    kit.getKitMatchTypes().remove(KitMatchType.SPLIT);
                } else {
                    kit.getKitMatchTypes().add(KitMatchType.SPLIT);
                }
                break;
            default:
                break;
        }
        kit.autoSave();
        menu.openMenu(player);
    }
}


Filename: .\main\java\rip\diamond\practice\kits\menu\button\impl\KitEditPotionEffectButton.java
package rip.diamond.practice.kits.menu.button.impl;

import org.bukkit.Material;
import org.bukkit.entity.Player;
import org.bukkit.event.inventory.ClickType;
import org.bukkit.inventory.ItemStack;
import org.bukkit.potion.PotionEffect;
import org.bukkit.potion.PotionEffectType;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.kits.Kit;
import rip.diamond.practice.kits.menu.button.KitButton;
import rip.diamond.practice.profile.procedure.Procedure;
import rip.diamond.practice.profile.procedure.ProcedureType;
import rip.diamond.practice.util.*;
import rip.diamond.practice.util.menu.Menu;

import java.util.stream.Collectors;

public class KitEditPotionEffectButton extends KitButton {

    private final Menu backMenu;

    public KitEditPotionEffectButton(Kit kit, Menu backMenu) {
        super(kit);
        this.backMenu = backMenu;
    }

    @Override
    public ItemStack getButtonItem(Player player) {
        return new ItemBuilder(Material.POTION)
                .durability(8193)
                .name(Language.KIT_BUTTON_EDIT_POTION_EFFECT_NAME.toString())
                .lore(Language.KIT_BUTTON_EDIT_POTION_EFFECT_LORE_START.toStringList(player, kit.getEffects().size()))
                .lore(kit.getEffects().stream().map(effect -> " " + CC.DARK_AQUA + WordUtil.formatWords(effect.getType().getName()) + " " + (effect.getAmplifier() + 1) + CC.GRAY + " - " + CC.WHITE + TimeUtil.millisToTimer(effect.getDuration() / 20 * 1000L)).collect(Collectors.toList()))
                .lore(Language.KIT_BUTTON_EDIT_POTION_EFFECT_LORE_END.toStringList(player))
                .hideItemFlags()
                .build();
    }

    @Override
    public void clicked(Player player, int slot, ClickType clickType, int hotbarSlot) {
        player.closeInventory();
        Procedure.buildProcedure(player, Language.KIT_BUTTON_EDIT_POTION_EFFECT_PROCEDURE_MESSAGE.toString(), ProcedureType.CHAT, (s) -> {
            String message = (String) s;
            String[] args = message.split(";");

            if (!Checker.isPotionEffect(args[0])) {
                Language.INVALID_SYNTAX.sendMessage(player);
                return;
            }

            PotionEffectType effect = PotionEffectType.getByName(args[0].replace("-", ""));

            if (message.startsWith("-")) {
                kit.getEffects().removeIf(potionEffect -> potionEffect.getType() == effect);
                Language.KIT_BUTTON_EDIT_POTION_EFFECT_PROCEDURE_SUCCESS_REMOVE.sendMessage(player, kit.getName(), WordUtil.toCapital(effect.getName()));
                return;
            } else {
                if (!Checker.isInteger(args[1]) || !Checker.isInteger(args[2])) {
                    Language.INVALID_SYNTAX.sendMessage(player);
                    return;
                }

                int amplifier = Integer.parseInt(args[1]);
                int duration = Integer.parseInt(args[2]);

                if (kit.getEffects().stream().anyMatch(potionEffect -> potionEffect.getType() == effect)) {
                    Language.KIT_BUTTON_EDIT_POTION_EFFECT_PROCEDURE_ALREADY_HAVE_POTION_EFFECT.sendListOfMessage(player, kit.getName(), WordUtil.toCapital(effect.getName()));
                    return;
                }

                kit.getEffects().add(new PotionEffect(effect, duration, amplifier));
                Language.KIT_BUTTON_EDIT_POTION_EFFECT_PROCEDURE_SUCCESS_ADD.sendMessage(player, kit.getName(), WordUtil.toCapital(effect.getName()) + " " + (amplifier + 1) + " (" + TimeUtil.millisToTimer(duration / 20 * 1000L) + ")");
            }
            kit.autoSave();
            backMenu.openMenu(player);
        });

        Language.KIT_BUTTON_EDIT_POTION_EFFECT_PROCEDURE_ADDITIONAL_MESSAGE.sendListOfMessage(player);
    }

}


Filename: .\main\java\rip\diamond\practice\kits\menu\button\impl\KitEditPriorityButton.java
package rip.diamond.practice.kits.menu.button.impl;

import org.bukkit.Material;
import org.bukkit.entity.Player;
import org.bukkit.event.inventory.ClickType;
import org.bukkit.inventory.ItemStack;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.kits.Kit;
import rip.diamond.practice.kits.menu.button.KitButton;
import rip.diamond.practice.profile.procedure.Procedure;
import rip.diamond.practice.profile.procedure.ProcedureType;
import rip.diamond.practice.util.Checker;
import rip.diamond.practice.util.ItemBuilder;
import rip.diamond.practice.util.menu.Menu;

public class KitEditPriorityButton extends KitButton {

    private final Menu backMenu;

    public KitEditPriorityButton(Kit kit, Menu backMenu) {
        super(kit);
        this.backMenu = backMenu;
    }

    @Override
    public ItemStack getButtonItem(Player player) {
        return new ItemBuilder(Material.GHAST_TEAR)
                .name(Language.KIT_BUTTON_EDIT_PRIORITY_NAME.toString())
                .lore(Language.KIT_BUTTON_EDIT_PRIORITY_LORE.toStringList(player, kit.getPriority()))
                .build();
    }

    @Override
    public void clicked(Player player, int slot, ClickType clickType, int hotbarSlot) {
        player.closeInventory();
        Procedure.buildProcedure(player, Language.KIT_BUTTON_EDIT_PRIORITY_PROCEDURE_MESSAGE.toString(), ProcedureType.CHAT, (s) -> {
            String message = (String) s;

            if (!Checker.isInteger(message)) {
                Language.INVALID_SYNTAX.sendMessage(player);
                return;
            }

            int priority = Integer.parseInt(message);

            kit.setPriority(priority);
            Kit.sortKit();
            Language.KIT_BUTTON_EDIT_PRIORITY_PROCEDURE_SUCCESS.sendMessage(player, kit.getName(), kit.getPriority());
            kit.autoSave();
            backMenu.openMenu(player);
        });

        Language.KIT_BUTTON_EDIT_PRIORITY_PROCEDURE_ADDITIONAL_MESSAGE.sendMessage(player);
    }
}


Filename: .\main\java\rip\diamond\practice\kits\menu\button\impl\KitPreviewButton.java
package rip.diamond.practice.kits.menu.button.impl;

import org.bukkit.entity.Player;
import org.bukkit.event.inventory.ClickType;
import org.bukkit.inventory.ItemStack;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.kits.Kit;
import rip.diamond.practice.kits.menu.KitPreviewMenu;
import rip.diamond.practice.kits.menu.button.KitButton;
import rip.diamond.practice.util.ItemBuilder;
import rip.diamond.practice.util.menu.Menu;

public class KitPreviewButton extends KitButton {

    private final Menu backMenu;

    public KitPreviewButton(Kit kit, Menu backMenu) {
        super(kit);
        this.backMenu = backMenu;
    }

    @Override
    public ItemStack getButtonItem(Player player) {
        return new ItemBuilder(kit.getDisplayIcon())
                .name(kit.getDisplayName())
                .lore(Language.KIT_BUTTON_PREVIEW_LORE.toStringList(player))
                .build();
    }

    @Override
    public void clicked(Player player, int slot, ClickType clickType, int hotbarSlot) {
        if (clickType == ClickType.LEFT) {
            new KitPreviewMenu(kit, backMenu).openMenu(player);
        } else if (clickType == ClickType.RIGHT) {
            player.getInventory().setContents(kit.getKitLoadout().getContents());
            player.getInventory().setArmorContents(kit.getKitLoadout().getArmor());
            player.updateInventory();
            player.closeInventory();
        }
    }
}


Filename: .\main\java\rip\diamond\practice\kits\menu\button\impl\KitRulesSetIntegerButton.java
package rip.diamond.practice.kits.menu.button.impl;

import lombok.RequiredArgsConstructor;
import lombok.SneakyThrows;
import org.bukkit.Material;
import org.bukkit.entity.Player;
import org.bukkit.event.inventory.ClickType;
import org.bukkit.inventory.ItemStack;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.kits.Kit;
import rip.diamond.practice.kits.KitGameRules;
import rip.diamond.practice.kits.menu.KitDetailsMenu;
import rip.diamond.practice.profile.procedure.Procedure;
import rip.diamond.practice.profile.procedure.ProcedureType;
import rip.diamond.practice.util.Checker;
import rip.diamond.practice.util.ItemBuilder;
import rip.diamond.practice.util.menu.Button;

import java.lang.reflect.Field;

@RequiredArgsConstructor
public class KitRulesSetIntegerButton extends Button {

    private final KitDetailsMenu menu;
    private final Kit kit;
    private final Field field;

    @Override
    public ItemStack getButtonItem(Player player) {
        return new ItemBuilder(Material.DOUBLE_PLANT)
                .durability(0)
                .name(Language.KIT_BUTTON_RULES_SET_VALUE_NAME.toString(getName()))
                .lore(Language.KIT_BUTTON_RULES_SET_VALUE_LORE.toStringList(player, KitGameRules.Readable.valueOf(field.getName()).getDescription(), getValue(player)))
                .build();
    }


    public String getName() {
        return KitGameRules.Readable.valueOf(field.getName()).getRule();
    }

    @SneakyThrows
    public int getValue(Player player) {
        return field.getInt(kit.getGameRules());
    }


    @Override
    public void clicked(Player player, ClickType clickType) {
        player.closeInventory();
        Procedure.buildProcedure(player, Language.KIT_BUTTON_RULES_SET_VALUE_PROCEDURE_MESSAGE.toString(getName()), ProcedureType.CHAT, (s) -> {
            String message = (String) s;
            if (!Checker.isInteger(message)) {
                Language.INVALID_SYNTAX.sendMessage(player);
                return;
            }
            int i = Integer.parseInt(message);

            try {
                field.setInt(kit.getGameRules(), i);
                Language.KIT_BUTTON_RULES_SET_VALUE_PROCEDURE_SUCCESS.sendMessage(player, getName(), i);
                kit.autoSave();
                menu.openMenu(player);
            } catch (IllegalAccessException e) {
                e.printStackTrace();
            }
        });

        Language.KIT_BUTTON_RULES_SET_VALUE_PROCEDURE_ADDITIONAL_MESSAGE.sendMessage(player);
    }
}


Filename: .\main\java\rip\diamond\practice\kits\menu\button\impl\KitRulesSetStringButton.java
package rip.diamond.practice.kits.menu.button.impl;

import lombok.RequiredArgsConstructor;
import lombok.SneakyThrows;
import org.bukkit.Material;
import org.bukkit.entity.Player;
import org.bukkit.event.inventory.ClickType;
import org.bukkit.inventory.ItemStack;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.kits.Kit;
import rip.diamond.practice.kits.KitGameRules;
import rip.diamond.practice.kits.menu.KitDetailsMenu;
import rip.diamond.practice.profile.procedure.Procedure;
import rip.diamond.practice.profile.procedure.ProcedureType;
import rip.diamond.practice.util.ItemBuilder;
import rip.diamond.practice.util.menu.Button;

import java.lang.reflect.Field;

@RequiredArgsConstructor
public class KitRulesSetStringButton extends Button {

    private final KitDetailsMenu menu;
    private final Kit kit;
    private final Field field;

    @Override
    public ItemStack getButtonItem(Player player) {
        return new ItemBuilder(Material.DOUBLE_PLANT)
                .durability(1)
                .name(Language.KIT_BUTTON_RULES_SET_VALUE_NAME.toString(getName()))
                .lore(Language.KIT_BUTTON_RULES_SET_VALUE_LORE.toStringList(player, KitGameRules.Readable.valueOf(field.getName()).getDescription(), getValue(player)))
                .build();
    }


    public String getName() {
        return KitGameRules.Readable.valueOf(field.getName()).getRule();
    }

    @SneakyThrows
    public String getValue(Player player) {
        return (String) field.get(kit.getGameRules());
    }


    @Override
    public void clicked(Player player, ClickType clickType) {
        player.closeInventory();
        Procedure.buildProcedure(player, Language.KIT_BUTTON_RULES_SET_VALUE_PROCEDURE_MESSAGE.toString(getName()), ProcedureType.CHAT, (s) -> {
            String message = (String) s;

            try {
                field.set(kit.getGameRules(), message);
                Language.KIT_BUTTON_RULES_SET_VALUE_PROCEDURE_SUCCESS.sendMessage(player, getName(), message);
                kit.autoSave();
                menu.openMenu(player);
            } catch (IllegalAccessException e) {
                e.printStackTrace();
            }
        });
    }
}


Filename: .\main\java\rip\diamond\practice\kits\menu\button\impl\KitRulesToggleButton.java
package rip.diamond.practice.kits.menu.button.impl;

import lombok.RequiredArgsConstructor;
import lombok.SneakyThrows;
import org.bukkit.entity.Player;
import org.bukkit.event.inventory.ClickType;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.kits.Kit;
import rip.diamond.practice.kits.KitGameRules;
import rip.diamond.practice.kits.menu.KitDetailsMenu;
import rip.diamond.practice.util.menu.button.ToggleButton;

import java.lang.reflect.Field;

@RequiredArgsConstructor
public class KitRulesToggleButton extends ToggleButton {

    private final KitDetailsMenu menu;
    private final Kit kit;
    private final Field field;

    @Override
    public String getOptionName() {
        return KitGameRules.Readable.valueOf(field.getName()).getRule();
    }

    @Override
    public String getDescription() {
        return KitGameRules.Readable.valueOf(field.getName()).getDescription();
    }

    @SneakyThrows
    @Override
    public boolean isEnabled(Player player) {
        return field.getBoolean(kit.getGameRules());
    }

    @SneakyThrows
    @Override
    public void onClick(Player player, int slot, ClickType clickType, int hotbarSlot) {
        field.setBoolean(kit.getGameRules(), !isEnabled(player));
        Language.KIT_BUTTON_RULES_TOGGLE_SUCCESS.sendMessage(player, kit.getName(), getOptionName(), (isEnabled(player) ? Language.ENABLED.toString() : Language.DISABLED.toString()));
        kit.autoSave();
        menu.openMenu(player);
    }
}


Filename: .\main\java\rip\diamond\practice\kits\menu\button\impl\KitSaveButton.java
package rip.diamond.practice.kits.menu.button.impl;

import org.bukkit.Material;
import org.bukkit.entity.Player;
import org.bukkit.event.inventory.ClickType;
import org.bukkit.inventory.ItemStack;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.kits.Kit;
import rip.diamond.practice.kits.menu.button.KitButton;
import rip.diamond.practice.util.ItemBuilder;
import rip.diamond.practice.util.Util;
import rip.diamond.practice.util.menu.Menu;
import rip.diamond.practice.util.menu.menus.ConfirmMenu;

public class KitSaveButton extends KitButton {

    private final Menu backMenu;

    public KitSaveButton(Kit kit, Menu backMenu) {
        super(kit);
        this.backMenu = backMenu;
    }

    @Override
    public ItemStack getButtonItem(Player player) {
        return new ItemBuilder(Material.INK_SACK)
                .durability(10)
                .name(Language.KIT_BUTTON_SAVE_NAME.toString())
                .lore(Language.KIT_BUTTON_SAVE_LORE.toStringList(player))
                .build();
    }

    @Override
    public void clicked(Player player, int slot, ClickType clickType, int hotbarSlot) {
        new ConfirmMenu((bool) -> {
            if (bool) {
                Util.performCommand(player, "kit save " + kit.getName());
            }
            backMenu.openMenu(player);
        }, false, null).openMenu(player);
    }
}


Filename: .\main\java\rip\diamond\practice\kits\menu\button\impl\KitSaveLoadoutButton.java
package rip.diamond.practice.kits.menu.button.impl;

import org.bukkit.Material;
import org.bukkit.entity.Player;
import org.bukkit.event.inventory.ClickType;
import org.bukkit.inventory.ItemStack;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.kits.Kit;
import rip.diamond.practice.kits.menu.button.KitButton;
import rip.diamond.practice.util.ItemBuilder;
import rip.diamond.practice.util.menu.Menu;
import rip.diamond.practice.util.menu.menus.ConfirmMenu;

public class KitSaveLoadoutButton extends KitButton {

    private final Menu backMenu;

    public KitSaveLoadoutButton(Kit kit, Menu backMenu) {
        super(kit);
        this.backMenu = backMenu;
    }

    @Override
    public ItemStack getButtonItem(Player player) {
        return new ItemBuilder(Material.CHEST)
                .name(Language.KIT_BUTTON_SAVE_LOADOUT_NAME.toString())
                .lore(Language.KIT_BUTTON_SAVE_LOADOUT_LORE.toStringList(player))
                .build();
    }

    @Override
    public void clicked(Player player, int slot, ClickType clickType, int hotbarSlot) {
        new ConfirmMenu((bool) -> {
            if (bool) {
                kit.getKitLoadout().setArmor(player.getInventory().getArmorContents());
                kit.getKitLoadout().setContents(player.getInventory().getContents());
                kit.save();
                Language.KIT_BUTTON_SAVE_LOADOUT_SUCCESS.sendMessage(player, kit.getName());
                kit.autoSave();
            }
            backMenu.openMenu(player);
        }, true, null).openMenu(player);
    }
}


Filename: .\main\java\rip\diamond\practice\kits\menu\button\impl\KitToggleButton.java
package rip.diamond.practice.kits.menu.button.impl;

import lombok.RequiredArgsConstructor;
import org.bukkit.entity.Player;
import org.bukkit.event.inventory.ClickType;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.kits.Kit;
import rip.diamond.practice.kits.menu.KitDetailsMenu;
import rip.diamond.practice.util.CC;
import rip.diamond.practice.util.menu.button.ToggleButton;

@RequiredArgsConstructor
public class KitToggleButton extends ToggleButton {

    private final Kit kit;
    private final KitDetailsMenu menu;

    @Override
    public String getOptionName() {
        return Language.KIT_BUTTON_TOGGLE_NAME.toString();
    }

    @Override
    public String getDescription() {
        return Language.KIT_BUTTON_TOGGLE_LORE.toString((kit.isEnabled() ? Language.ENABLED.toString() : Language.DISABLED.toString()));
    }

    @Override
    public boolean isEnabled(Player player) {
        return kit.isEnabled();
    }

    @Override
    public void onClick(Player player, int slot, ClickType clickType, int hotbarSlot) {
        kit.setEnabled(!kit.isEnabled());
        Language.KIT_BUTTON_TOGGLE_SUCCESS.sendMessage(player, kit.getName(), (isEnabled(player) ? CC.GREEN + Language.ENABLED.toString() : CC.RED + Language.DISABLED.toString()));
        kit.autoSave();
        menu.openMenu(player);
    }
}


Filename: .\main\java\rip\diamond\practice\kits\menu\button\impl\KitToggleRankedButton.java
package rip.diamond.practice.kits.menu.button.impl;

import lombok.RequiredArgsConstructor;
import org.bukkit.entity.Player;
import org.bukkit.event.inventory.ClickType;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.kits.Kit;
import rip.diamond.practice.kits.menu.KitDetailsMenu;
import rip.diamond.practice.util.CC;
import rip.diamond.practice.util.menu.button.ToggleButton;

@RequiredArgsConstructor
public class KitToggleRankedButton extends ToggleButton {

    private final Kit kit;
    private final KitDetailsMenu menu;

    @Override
    public String getOptionName() {
        return Language.KIT_BUTTON_TOGGLE_RANKED_NAME.toString();
    }

    @Override
    public String getDescription() {
        return Language.KIT_BUTTON_TOGGLE_RANKED_LORE.toString((kit.isRanked() ? Language.ENABLED.toString() : Language.DISABLED.toString()));
    }

    @Override
    public boolean isEnabled(Player player) {
        return kit.isRanked();
    }

    @Override
    public void onClick(Player player, int slot, ClickType clickType, int hotbarSlot) {
        kit.setRanked(!kit.isRanked());
        Language.KIT_BUTTON_TOGGLE_RANKED_SUCCESS.sendMessage(player, kit.getName(), (isEnabled(player) ? CC.GREEN + Language.ENABLED.toString() : CC.RED + Language.DISABLED.toString()));
        kit.autoSave();
        menu.openMenu(player);
    }
}


Filename: .\main\java\rip\diamond\practice\layout\NameTagAdapter.java
package rip.diamond.practice.layout;

import org.bukkit.entity.Player;
import rip.diamond.practice.config.Config;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.match.Match;
import rip.diamond.practice.match.team.Team;
import rip.diamond.practice.profile.PlayerProfile;
import rip.diamond.practice.profile.PlayerState;
import rip.diamond.practice.util.CC;
import rip.diamond.practice.util.Common;
import rip.diamond.practice.util.nametags.construct.NameTagInfo;
import rip.diamond.practice.util.nametags.provider.NameTagProvider;

public class NameTagAdapter extends NameTagProvider {

    public NameTagAdapter() {
        super("Eden Provider", 1);
    }

    @Override
    public NameTagInfo fetchNameTag(Player target, Player viewer) {
        String prefix = Language.translate(getPrefix(target, viewer), target);
        int length = prefix.length();
        if (length > 16) {
            Common.log(CC.RED + "[Eden] Nametag prefix should only contain 16 character. Currently prefix has " + length + " character. (" + prefix + ")");
            return createNameTag("", "");
        }
        return createNameTag(prefix, "");
    }

    private String getPrefix(Player target, Player viewer) {
        PlayerProfile profile = PlayerProfile.get(target);

        if (profile != null && (profile.getPlayerState() == PlayerState.IN_MATCH || profile.getPlayerState() == PlayerState.IN_SPECTATING) && profile.getMatch() != null) {
            Match match = profile.getMatch();
            Team team = match.getTeam(target);

            //Means it is a spectator
            if (team == null) {
                return Config.NAMETAG_PREFIX_SPECTATOR.toString();
            }

            return match.getRelationColor(viewer, target);
        }
        //Means the player is not in a match
        else {
            return Config.NAMETAG_PREFIX_LOBBY.toString();
        }
    }
}


Filename: .\main\java\rip\diamond\practice\layout\ScoreboardAdapter.java
package rip.diamond.practice.layout;

import io.github.epicgo.sconey.element.SconeyElement;
import io.github.epicgo.sconey.element.SconeyElementAdapter;
import io.github.epicgo.sconey.element.SconeyElementMode;
import org.bukkit.entity.Player;
import rip.diamond.practice.Eden;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.event.ScoreboardUpdateEvent;
import rip.diamond.practice.events.EdenEvent;
import rip.diamond.practice.match.Match;
import rip.diamond.practice.party.Party;
import rip.diamond.practice.profile.PlayerProfile;
import rip.diamond.practice.profile.PlayerState;
import rip.diamond.practice.profile.ProfileSettings;
import rip.diamond.practice.queue.Queue;
import rip.diamond.practice.queue.QueueProfile;
import rip.diamond.practice.queue.QueueType;

public class ScoreboardAdapter implements SconeyElementAdapter {

    private final Eden plugin = Eden.INSTANCE;

    /**
     * This method returns the scoreboard element used by this instance
     * 
     * @param player the player containing the provided scoreboard
     * @return the scoreboard element used by this instance
     */
    @Override
    public SconeyElement getElement(final Player player) {
        SconeyElement element = new SconeyElement();

        element.setTitle(Language.SCOREBOARD_TITLE.toString(player));
        element.setMode(SconeyElementMode.CUSTOM);

        PlayerProfile profile = PlayerProfile.get(player);

        if (profile == null) {
            return element;
        }

        // Removed GUI kit editor check - scoreboard displays normally now

        ScoreboardUpdateEvent event = new ScoreboardUpdateEvent(player);
        event.call();
        if (!event.getLayout().isEmpty()) {
            element.addAll(event.getLayout());
            return element;
        }

        Party party = Party.getByPlayer(player);
        QueueProfile qProfile = Queue.getPlayers().get(player.getUniqueId());
        Match match = profile.getMatch();
        EdenEvent edenEvent = EdenEvent.getOnGoingEvent();

        if (profile.getPlayerState() == PlayerState.LOADING) {
            element.addAll(Language.SCOREBOARD_LOADING.toStringList(player));
        } else if (profile.getPlayerState() == PlayerState.IN_LOBBY && party == null) {
            element.addAll(Language.SCOREBOARD_IN_LOBBY.toStringList(player));
        } else if (profile.getPlayerState() == PlayerState.IN_LOBBY && party != null) {
            element.addAll(Language.SCOREBOARD_IN_PARTY.toStringList(player));
        } else if (profile.getPlayerState() == PlayerState.IN_EDIT) {
            // Check kit editor mode and show appropriate scoreboard
            if (plugin.getConfigFile().getString("kit-editor-mode").equalsIgnoreCase("GUI")) {
                element.addAll(Language.SCOREBOARD_IN_EDIT_GUI.toStringList(player));
            } else {
                element.addAll(Language.SCOREBOARD_IN_EDIT.toStringList(player));
            }
        } else if (profile.getPlayerState() == PlayerState.IN_QUEUE && qProfile != null
                && qProfile.getQueueType() == QueueType.UNRANKED) {
            element.addAll(Language.SCOREBOARD_IN_QUEUE_UNRANKED.toStringList(player));
        } else if (profile.getPlayerState() == PlayerState.IN_QUEUE && qProfile != null
                && qProfile.getQueueType() == QueueType.RANKED) {
            element.addAll(Language.SCOREBOARD_IN_QUEUE_RANKED.toStringList(player));
        } else if (edenEvent != null && edenEvent.getTotalPlayers().contains(player)
                && edenEvent.getInGameScoreboard(player) != null) {
            element.addAll(edenEvent.getInGameScoreboard(player));
        } else if (profile.getPlayerState() == PlayerState.IN_MATCH && match != null) {
            if (!profile.getSettings().get(ProfileSettings.MATCH_SCOREBOARD).isEnabled()) {
                return element;
            }
            element.addAll(match.getMatchScoreboard(player));
        } else if (profile.getPlayerState() == PlayerState.IN_SPECTATING && match != null) {
            if (!profile.getSettings().get(ProfileSettings.MATCH_SCOREBOARD).isEnabled()) {
                return element;
            }
            element.addAll(match.getSpectateScoreboard(player));
        }

        return element;
    }
}

Filename: .\main\java\rip\diamond\practice\layout\TabAdapter.java
package rip.diamond.practice.layout;

import org.bukkit.Bukkit;
import org.bukkit.entity.Player;
import rip.diamond.practice.config.Config;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.util.CC;
import rip.diamond.practice.util.tablist.ImanityTabAdapter;
import rip.diamond.practice.util.tablist.util.BufferedTabObject;
import rip.diamond.practice.util.tablist.util.Skin;
import rip.diamond.practice.util.tablist.util.TabColumn;
import rip.diamond.practice.util.tablist.util.TablistUtil;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

public class TabAdapter implements ImanityTabAdapter {

    @Override
    public Set<BufferedTabObject> getSlots(Player player) {
        Set<BufferedTabObject> objects = new HashSet<>();

        int i = 0;
        int maxSlots = TablistUtil.getPossibleSlots(player);
        List<Player> playerList = new ArrayList<Player>(Bukkit.getOnlinePlayers()).subList(0, Math.min(Bukkit.getOnlinePlayers().size(), maxSlots));

        for (Player target : playerList) {
            int x = i / (maxSlots / 20) + 1; //Somehow ImanityTablist slot count starts at 1, so we have to start at 1 :shrug:
            int y = i % (maxSlots / 20);

            objects.add(new BufferedTabObject()
                    .slot(x)
                    .column(TabColumn.getFromOrdinal(y))
                    .text(CC.translate(Language.translate(Config.FANCY_TABLIST_FORMAT.toString().replace("{player-name}", target.getName()), target)))
                    .ping(target.spigot().getPing())
                    .skin(Skin.fromPlayer(target))
            );

            i++;
        }

        return objects;
    }

    @Override
    public String getHeader(Player player) {
        if (Language.TABLIST_HEADER.toString().equals(Language.TABLIST_HEADER.getPath())) {
            return null;
        }
        return Language.TABLIST_HEADER.toString(player);
    }

    @Override
    public String getFooter(Player player) {
        if (Language.TABLIST_FOOTER.toString().equals(Language.TABLIST_FOOTER.getPath())) {
            return null;
        }
        return Language.TABLIST_FOOTER.toString(player);
    }
}


Filename: .\main\java\rip\diamond\practice\leaderboard\Leaderboard.java
package rip.diamond.practice.leaderboard;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

import java.util.LinkedHashMap;

@Getter
@RequiredArgsConstructor
public abstract class Leaderboard {

    private final LeaderboardType type;
    private final LinkedHashMap<Integer, LeaderboardPlayerCache> leaderboard = new LinkedHashMap<>();

    public abstract void update();

}


Filename: .\main\java\rip\diamond\practice\leaderboard\LeaderboardManager.java
package rip.diamond.practice.leaderboard;

import lombok.Getter;
import rip.diamond.practice.Eden;
import rip.diamond.practice.kits.Kit;
import rip.diamond.practice.leaderboard.impl.KitLeaderboard;
import rip.diamond.practice.util.Common;
import rip.diamond.practice.util.Tasks;

import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

@Getter
public class LeaderboardManager {
    private final Map<Kit, KitLeaderboard> winsLeaderboard = new HashMap<>();
    private final Map<Kit, KitLeaderboard> eloLeaderboard = new HashMap<>();
    private final Map<Kit, KitLeaderboard> winstreakLeaderboard = new HashMap<>();
    private final Map<Kit, KitLeaderboard> bestWinstreakLeaderboard = new HashMap<>();
    private final Map<Kit, KitLeaderboard> dailyWinstreakLeaderboard = new HashMap<>();

    public void init() {
        if (Eden.INSTANCE.getDatabaseManager().getHandler() == null) {
            return;
        }
        for (Kit kit : Kit.getKits()) {
            winsLeaderboard.put(kit, new KitLeaderboard(LeaderboardType.WINS, kit));
            eloLeaderboard.put(kit, new KitLeaderboard(LeaderboardType.ELO, kit));
            winstreakLeaderboard.put(kit, new KitLeaderboard(LeaderboardType.WINSTREAK, kit));
            bestWinstreakLeaderboard.put(kit, new KitLeaderboard(LeaderboardType.BEST_WINSTREAK, kit));
            dailyWinstreakLeaderboard.put(kit, new KitLeaderboard(LeaderboardType.WINSTREAK_DAILY, kit));
        }

        Tasks.runAsyncTimer(this::update, 0L, 20L * 60L * 5L); // Updates every 5 minutes
    }

    public void update() {
        long previous = System.currentTimeMillis();
        Common.debug("Ê≠£Âú®Êõ¥Êñ∞ÊéíË°åÊ¶ú... ÈÄôÂèØËÉΩÈúÄË¶Å‰∏ÄÊÆµÊôÇÈñì");
        for (Map<Kit, KitLeaderboard> datas : Arrays.asList(winsLeaderboard, eloLeaderboard, winstreakLeaderboard,
                bestWinstreakLeaderboard, dailyWinstreakLeaderboard)) {
            // ÊØè‰∫îÂàÜÈêòÊõ¥Êñ∞ÊéíË°åÊ¶ú
            datas.values().forEach(Leaderboard::update);
        }
        long current = System.currentTimeMillis();
        Common.debug("ÊéíË°åÊ¶úÊõ¥Êñ∞ÂÆåÁï¢! ËÄóÊôÇ" + (current - previous) + "ms");
    }

    /**
     * Incrementally update a player's stats for a specific kit across all
     * leaderboards
     * This is called immediately after a match ends for instant updates
     */
    public void updatePlayerStats(UUID uuid, String username, Kit kit,
            rip.diamond.practice.profile.data.ProfileKitData kitData) {
        if (Eden.INSTANCE.getDatabaseManager().getHandler() == null) {
            return;
        }

        // Update all leaderboard types for this kit
        KitLeaderboard winsLb = winsLeaderboard.get(kit);
        if (winsLb != null) {
            winsLb.updatePlayer(uuid, username, kitData.getWon());
        }

        KitLeaderboard eloLb = eloLeaderboard.get(kit);
        if (eloLb != null && kit.isRanked()) {
            eloLb.updatePlayer(uuid, username, kitData.getElo());
        }

        KitLeaderboard winstreakLb = winstreakLeaderboard.get(kit);
        if (winstreakLb != null) {
            winstreakLb.updatePlayer(uuid, username, kitData.getWinstreak());
        }

        KitLeaderboard bestWinstreakLb = bestWinstreakLeaderboard.get(kit);
        if (bestWinstreakLb != null) {
            bestWinstreakLb.updatePlayer(uuid, username, kitData.getBestWinstreak());
        }

        KitLeaderboard dailyWinstreakLb = dailyWinstreakLeaderboard.get(kit);
        if (dailyWinstreakLb != null) {
            dailyWinstreakLb.updatePlayer(uuid, username, kitData.getDailyWinstreak());
        }
    }

}


Filename: .\main\java\rip\diamond\practice\leaderboard\LeaderboardPlayerCache.java
package rip.diamond.practice.leaderboard;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

import java.util.UUID;

@Getter
@Setter
@AllArgsConstructor
public class LeaderboardPlayerCache {

    private String playerName;
    private UUID playerUUID;
    private int data;

}


Filename: .\main\java\rip\diamond\practice\leaderboard\LeaderboardType.java
package rip.diamond.practice.leaderboard;

import lombok.AllArgsConstructor;
import rip.diamond.practice.kits.Kit;

@AllArgsConstructor
public enum LeaderboardType {

    // All-time leaderboards
    WINS("kitData.{kit}.won"),
    ELO("kitData.{kit}.elo"),
    WINSTREAK("kitData.{kit}.winstreak"),
    BEST_WINSTREAK("kitData.{kit}.bestWinstreak"),

    // Daily leaderboards
    WINS_DAILY("kitData.{kit}.dailyWins"),
    LOSSES_DAILY("kitData.{kit}.dailyLosses"),
    WINSTREAK_DAILY("kitData.{kit}.dailyWinstreak"),

    // Weekly leaderboards
    WINS_WEEKLY("kitData.{kit}.weeklyWins"),
    LOSSES_WEEKLY("kitData.{kit}.weeklyLosses"),
    WINSTREAK_WEEKLY("kitData.{kit}.weeklyWinstreak"),

    // Monthly leaderboards
    WINS_MONTHLY("kitData.{kit}.monthlyWins"),
    LOSSES_MONTHLY("kitData.{kit}.monthlyLosses"),
    WINSTREAK_MONTHLY("kitData.{kit}.monthlyWinstreak");

    private final String path;

    public String getPath(Kit kit) {
        return path.replace("{kit}", kit.getName());
    }

}


Filename: .\main\java\rip\diamond\practice\leaderboard\command\ReloadLeaderboardCommand.java
package rip.diamond.practice.leaderboard.command;

import org.bukkit.entity.Player;
import rip.diamond.practice.Eden;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.util.command.Command;
import rip.diamond.practice.util.command.CommandArgs;
import rip.diamond.practice.util.command.argument.CommandArguments;

public class ReloadLeaderboardCommand extends Command {
    @CommandArgs(name = "reloadleaderboard", permission = "eden.command.reloadleaderboard", aliases = {"reloadlb"}, async = true)
    public void execute(CommandArguments command) {
        Player player = command.getPlayer();
        Language.LEADERBOARD_RELOAD.sendMessage(player);
        Eden.INSTANCE.getLeaderboardManager().update();
    }
}


Filename: .\main\java\rip\diamond\practice\leaderboard\impl\KitLeaderboard.java
package rip.diamond.practice.leaderboard.impl;

import lombok.Getter;
import org.bson.Document;
import org.bukkit.inventory.ItemStack;
import rip.diamond.practice.Eden;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.kits.Kit;
import rip.diamond.practice.leaderboard.Leaderboard;
import rip.diamond.practice.leaderboard.LeaderboardPlayerCache;
import rip.diamond.practice.leaderboard.LeaderboardType;
import rip.diamond.practice.util.ItemBuilder;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.UUID;

@Getter
public class KitLeaderboard extends Leaderboard {

    private final Kit kit;

    public KitLeaderboard(LeaderboardType type, Kit kit) {
        super(type);
        this.kit = kit;
    }

    @Override
    public void update() {
        String path = getType().getPath(kit);

        // Get all documents from abstraction layer
        List<Document> documents = Eden.INSTANCE.getDatabaseManager().getHandler().getAllProfiles();

        // Sort in Java memory
        documents.sort((doc1, doc2) -> {
            Integer val1 = getStatsValue(doc1, path);
            Integer val2 = getStatsValue(doc2, path);

            // Handle time-based winstreak leaderboards
            if (getType() == LeaderboardType.WINSTREAK_DAILY) {
                long date1 = getStatsValueLong(doc1, path.replace("dailyWinstreak", "lastDailyReset"));
                long date2 = getStatsValueLong(doc2, path.replace("dailyWinstreak", "lastDailyReset"));
                if (!isSameDay(date1, System.currentTimeMillis()))
                    val1 = 0;
                if (!isSameDay(date2, System.currentTimeMillis()))
                    val2 = 0;
            } else if (getType() == LeaderboardType.WINSTREAK_WEEKLY) {
                long date1 = getStatsValueLong(doc1, path.replace("weeklyWinstreak", "lastWeeklyReset"));
                long date2 = getStatsValueLong(doc2, path.replace("weeklyWinstreak", "lastWeeklyReset"));
                if (!isSameWeek(date1, System.currentTimeMillis()))
                    val1 = 0;
                if (!isSameWeek(date2, System.currentTimeMillis()))
                    val2 = 0;
            } else if (getType() == LeaderboardType.WINSTREAK_MONTHLY) {
                long date1 = getStatsValueLong(doc1, path.replace("monthlyWinstreak", "lastMonthlyReset"));
                long date2 = getStatsValueLong(doc2, path.replace("monthlyWinstreak", "lastMonthlyReset"));
                if (!isSameMonth(date1, System.currentTimeMillis()))
                    val1 = 0;
                if (!isSameMonth(date2, System.currentTimeMillis()))
                    val2 = 0;
            }

            return val2.compareTo(val1); // Descending order
        });

        getLeaderboard().clear();

        // Take top entries, but skip those with 0 data (stale/expired entries)
        int position = 1;
        for (int i = 0; i < documents.size() && position <= 10; i++) {
            Document document = documents.get(i);
            String username = document.getString("username");
            UUID uuid = UUID.fromString(document.getString("uuid"));
            int data = getStatsValue(document, path);

            // Handle time-based winstreak leaderboards
            if (getType() == LeaderboardType.WINSTREAK_DAILY) {
                long date = getStatsValueLong(document, path.replace("dailyWinstreak", "lastDailyReset"));
                if (!isSameDay(date, System.currentTimeMillis()))
                    data = 0;
            } else if (getType() == LeaderboardType.WINSTREAK_WEEKLY) {
                long date = getStatsValueLong(document, path.replace("weeklyWinstreak", "lastWeeklyReset"));
                if (!isSameWeek(date, System.currentTimeMillis()))
                    data = 0;
            } else if (getType() == LeaderboardType.WINSTREAK_MONTHLY) {
                long date = getStatsValueLong(document, path.replace("monthlyWinstreak", "lastMonthlyReset"));
                if (!isSameMonth(date, System.currentTimeMillis()))
                    data = 0;
            }

            // Skip entries with 0 data (stale/expired from previous time periods)
            if (data == 0) {
                continue;
            }

            getLeaderboard().put(position, new LeaderboardPlayerCache(username, uuid, data));
            position++;
        }
    }

    /**
     * Incrementally update a single player's stats in the leaderboard
     * This is much more performant than doing a full update
     */
    public void updatePlayer(UUID uuid, String username, int newData) {
        // For time-based leaderboards, check if data is stale
        if (newData == 0) {
            // Remove player if they have 0 data
            getLeaderboard().entrySet().removeIf(entry -> entry.getValue().getPlayerUUID().equals(uuid));
            return;
        }

        // Check if player is already in leaderboard
        Integer existingPosition = null;
        for (Map.Entry<Integer, LeaderboardPlayerCache> entry : getLeaderboard().entrySet()) {
            if (entry.getValue().getPlayerUUID().equals(uuid)) {
                existingPosition = entry.getKey();
                break;
            }
        }

        // If player is already in leaderboard, update their data
        if (existingPosition != null) {
            getLeaderboard().get(existingPosition).setData(newData);
        } else if (getLeaderboard().size() < 10) {
            // If leaderboard has less than 10 entries, add player
            getLeaderboard().put(getLeaderboard().size() + 1, new LeaderboardPlayerCache(username, uuid, newData));
        } else {
            // Check if new data is better than the worst entry
            int worstPosition = 10;
            LeaderboardPlayerCache worstEntry = getLeaderboard().get(worstPosition);
            if (worstEntry != null && newData > worstEntry.getData()) {
                // Replace worst entry with new player
                getLeaderboard().put(worstPosition, new LeaderboardPlayerCache(username, uuid, newData));
            }
        }

        // Re-sort the leaderboard
        List<Map.Entry<Integer, LeaderboardPlayerCache>> entries = new ArrayList<>(getLeaderboard().entrySet());
        entries.sort((e1, e2) -> Integer.compare(e2.getValue().getData(), e1.getValue().getData()));

        // Rebuild with correct positions
        getLeaderboard().clear();
        for (int i = 0; i < entries.size(); i++) {
            getLeaderboard().put(i + 1, entries.get(i).getValue());
        }
    }

    private boolean isSameDay(long time1, long time2) {
        java.util.Calendar cal1 = java.util.Calendar.getInstance();
        cal1.setTimeInMillis(time1);
        java.util.Calendar cal2 = java.util.Calendar.getInstance();
        cal2.setTimeInMillis(time2);
        return cal1.get(java.util.Calendar.YEAR) == cal2.get(java.util.Calendar.YEAR) &&
                cal1.get(java.util.Calendar.DAY_OF_YEAR) == cal2.get(java.util.Calendar.DAY_OF_YEAR);
    }

    private boolean isSameWeek(long time1, long time2) {
        java.util.Calendar cal1 = java.util.Calendar.getInstance();
        cal1.setTimeInMillis(time1);
        java.util.Calendar cal2 = java.util.Calendar.getInstance();
        cal2.setTimeInMillis(time2);
        return cal1.get(java.util.Calendar.YEAR) == cal2.get(java.util.Calendar.YEAR) &&
                cal1.get(java.util.Calendar.WEEK_OF_YEAR) == cal2.get(java.util.Calendar.WEEK_OF_YEAR);
    }

    private boolean isSameMonth(long time1, long time2) {
        java.util.Calendar cal1 = java.util.Calendar.getInstance();
        cal1.setTimeInMillis(time1);
        java.util.Calendar cal2 = java.util.Calendar.getInstance();
        cal2.setTimeInMillis(time2);
        return cal1.get(java.util.Calendar.YEAR) == cal2.get(java.util.Calendar.YEAR) &&
                cal1.get(java.util.Calendar.MONTH) == cal2.get(java.util.Calendar.MONTH);
    }

    private long getStatsValueLong(Document document, String path) {
        try {
            String[] paths = path.split("\\.");
            Object current = document;

            for (int j = 0; j < paths.length; j++) {
                if (current instanceof Document) {
                    current = ((Document) current).get(paths[j]);
                } else {
                    return 0L;
                }

                if (current == null)
                    return 0L;
            }

            if (current instanceof Number) {
                return ((Number) current).longValue();
            }

        } catch (Exception e) {
        }
        return 0L;
    }

    // Helper to dig into nested BSON/JSON
    private int getStatsValue(Document document, String path) {
        try {
            String[] paths = path.split("\\.");
            Object current = document;

            for (int j = 0; j < paths.length; j++) {
                if (current instanceof Document) {
                    current = ((Document) current).get(paths[j]);
                } else {
                    return 0; // Path broken
                }

                if (current == null)
                    return 0;
            }

            // Safe Number Casting
            if (current instanceof Number) {
                return ((Number) current).intValue();
            }

        } catch (Exception e) {
            // Suppress errors for missing keys
        }
        return 0;
    }

    public ItemStack getDisplayIcon() {
        List<String> lore = new ArrayList<>();

        getLeaderboard().forEach((key, value) -> lore
                .add(Language.LEADERBOARD_TOP10_DISPLAY_LORE.toString(key, value.getPlayerName(), value.getData())));

        return new ItemBuilder(kit.getDisplayIcon())
                .name(Language.LEADERBOARD_TOP10_DISPLAY_NAME.toString(kit.getDisplayName()))
                .lore(lore)
                .build().clone();
    }

}


Filename: .\main\java\rip\diamond\practice\leaderboard\menu\LeaderboardMenu.java
package rip.diamond.practice.leaderboard.menu;

import lombok.RequiredArgsConstructor;
import org.bukkit.Material;
import org.bukkit.entity.Player;
import org.bukkit.event.inventory.ClickType;
import org.bukkit.inventory.ItemStack;
import rip.diamond.practice.Eden;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.leaderboard.menu.impl.*;
import rip.diamond.practice.profile.PlayerProfile;
import rip.diamond.practice.util.CC;
import rip.diamond.practice.util.ItemBuilder;
import rip.diamond.practice.util.menu.Button;
import rip.diamond.practice.util.menu.pagination.PageButton;
import rip.diamond.practice.util.menu.pagination.PaginatedMenu;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

public abstract class LeaderboardMenu extends PaginatedMenu {
    private final Eden plugin = Eden.INSTANCE;

    private Integer[] getAllowedSlots() {
        List<String> slotStrings = Eden.INSTANCE.getMenusConfig().getConfig()
                .getStringList("leaderboard-menu.items.allowed-slots");
        return slotStrings.stream()
                .map(Integer::parseInt)
                .toArray(Integer[]::new);
    }

    @Override
    public int getSize() {
        return Eden.INSTANCE.getMenusConfig().getConfig().getInt("leaderboard-menu.size");
    }

    @Override
    public int getMaxItemsPerPage(Player player) {
        return getAllowedSlots().length;
    }

    @Override
    public Map<Integer, Button> getButtons(Player player) {
        int minIndex = (int) ((double) (getPage() - 1) * getMaxItemsPerPage(player));
        int maxIndex = (int) ((double) (getPage()) * getMaxItemsPerPage(player));
        int topIndex = 0;
        Integer[] allowedSlots = getAllowedSlots();

        HashMap<Integer, Button> buttons = new HashMap<>();

        for (Map.Entry<Integer, Button> entry : getAllPagesButtons(player).entrySet()) {
            int index = entry.getKey();

            if (index >= minIndex && index < maxIndex) {
                index -= (int) ((double) (getMaxItemsPerPage(player)) * (getPage() - 1));
                buttons.put(allowedSlots[index], entry.getValue());
                if (index > topIndex) {
                    topIndex = index;
                }
            }
        }

        buttons.put(0, new PageButton(-1, this));
        buttons.put(8, new PageButton(1, this));

        for (int i = 1; i < 8; i++) {
            buttons.put(i, getPlaceholderButton());
        }

        Map<Integer, Button> global = getGlobalButtons(player);

        if (global != null) {
            buttons.putAll(global);
        }

        // Áµ¶‰∫à‰∏ÄÂÄãÁî®ÁéªÁíÉÂúçÁπûËëóÁöÑËÉåÊôØ
        for (int j = 0; j < getSize(); j++) {
            if (!buttons.containsKey(j)) {
                buttons.put(j, placeholderButton);
            }
        }

        return buttons;
    }

    @Override
    public Map<Integer, Button> getGlobalButtons(Player player) {
        Map<Integer, Button> buttons = new HashMap<>();

        buttons.put(getSize() - 9 + 1, new SwitchLeaderboardButton(Material.CARPET, 1,
                Language.LEADERBOARD_WINS_MENU_TITLE.toString(), WinsLeaderboardMenu.class));
        buttons.put(getSize() - 9 + 2, new SwitchLeaderboardButton(Material.CARPET, 2,
                Language.LEADERBOARD_ELO_MENU_TITLE.toString(), EloLeaderboardMenu.class));
        buttons.put(getSize() - 9 + 4, new SwitchLeaderboardButton(Material.DIAMOND, 0,
                Language.LEADERBOARD_SWITCH_LEADERBOARD_BUTTON_VIEW_STATS_BUTTON_NAME.toString(), KitStatsMenu.class));
        buttons.put(getSize() - 9 + 6, new SwitchLeaderboardButton(Material.CARPET, 3,
                Language.LEADERBOARD_WINSTREAK_MENU_TITLE.toString(), WinstreakLeaderboardMenu.class));
        buttons.put(getSize() - 9 + 7, new SwitchLeaderboardButton(Material.CARPET, 4,
                Language.LEADERBOARD_BEST_WINSTREAK_MENU_TITLE.toString(), BestWinstreakLeaderboardMenu.class));

        return buttons;
    }

    @RequiredArgsConstructor
    private class SwitchLeaderboardButton extends Button {
        private final Material material;
        private final int durability;
        private final String name;
        private final Class<?> clazz;

        @Override
        public ItemStack getButtonItem(Player player) {
            ItemBuilder builder = new ItemBuilder(material)
                    .durability(durability)
                    .name(CC.AQUA + name)
                    .lore(Language.LEADERBOARD_SWITCH_LEADERBOARD_BUTTON_VIEW_STATS_BUTTON_LORE.toStringList(player));
            if (clazz.getName().equals(LeaderboardMenu.this.getClass().getName())) {
                builder.glow();
            }
            return builder.build();
        }

        @Override
        public void clicked(Player player, ClickType clickType) {
            if (clazz.equals(KitStatsMenu.class)) {
                new KitStatsMenu(PlayerProfile.get(player)).openMenu(player);
                return;
            }
            try {
                LeaderboardMenu menu = (LeaderboardMenu) clazz.newInstance();
                menu.openMenu(player);
            } catch (InstantiationException | IllegalAccessException e) {
                e.printStackTrace();
            }
        }
    }

}


Filename: .\main\java\rip\diamond\practice\leaderboard\menu\impl\BestWinstreakLeaderboardMenu.java
package rip.diamond.practice.leaderboard.menu.impl;

import org.bukkit.entity.Player;
import org.bukkit.inventory.ItemStack;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.leaderboard.menu.LeaderboardMenu;
import rip.diamond.practice.util.menu.Button;

import java.util.*;

public class BestWinstreakLeaderboardMenu extends LeaderboardMenu {

    @Override
    public String getPrePaginatedTitle(Player player) {
        return Language.LEADERBOARD_BEST_WINSTREAK_MENU_TITLE.toString();
    }

    @Override
    public Map<Integer, Button> getAllPagesButtons(Player player) {
        final Map<Integer, Button> buttons = new HashMap<>();

        getPlugin().getLeaderboardManager().getBestWinstreakLeaderboard().values().stream().sorted(Comparator.comparing(leaderboard -> leaderboard.getKit().getPriority())).forEach(leaderboard -> buttons.put(buttons.size(), new Button() {
            @Override
            public ItemStack getButtonItem(Player player) {
                return leaderboard.getDisplayIcon();
            }
        }));

        return buttons;
    }
}


Filename: .\main\java\rip\diamond\practice\leaderboard\menu\impl\EloLeaderboardMenu.java
package rip.diamond.practice.leaderboard.menu.impl;

import org.bukkit.entity.Player;
import org.bukkit.inventory.ItemStack;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.leaderboard.menu.LeaderboardMenu;
import rip.diamond.practice.util.menu.Button;

import java.util.*;

public class EloLeaderboardMenu extends LeaderboardMenu {

    @Override
    public String getPrePaginatedTitle(Player player) {
        return Language.LEADERBOARD_ELO_MENU_TITLE.toString();
    }

    @Override
    public Map<Integer, Button> getAllPagesButtons(Player player) {
        final Map<Integer, Button> buttons = new HashMap<>();

        getPlugin().getLeaderboardManager().getEloLeaderboard().values().stream().filter(leaderboard -> leaderboard.getKit().isRanked()).sorted(Comparator.comparing(leaderboard -> leaderboard.getKit().getPriority())).forEach(leaderboard -> buttons.put(buttons.size(), new Button() {
            @Override
            public ItemStack getButtonItem(Player player) {
                return leaderboard.getDisplayIcon();
            }
        }));

        return buttons;
    }
}


Filename: .\main\java\rip\diamond\practice\leaderboard\menu\impl\KitStatsMenu.java
package rip.diamond.practice.leaderboard.menu.impl;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import org.bukkit.Material;
import org.bukkit.entity.Player;
import org.bukkit.inventory.ItemStack;
import rip.diamond.practice.Eden;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.kits.Kit;
import rip.diamond.practice.leaderboard.menu.LeaderboardMenu;
import rip.diamond.practice.profile.PlayerProfile;
import rip.diamond.practice.profile.data.ProfileKitData;
import rip.diamond.practice.util.ItemBuilder;
import rip.diamond.practice.util.menu.Button;

import java.util.*;

@RequiredArgsConstructor
public class KitStatsMenu extends LeaderboardMenu {

    private final PlayerProfile profile;

    @Override
    public String getPrePaginatedTitle(Player player) {
        return Language.LEADERBOARD_KIT_STATS_MENU_TITLE.toString(profile.getUsername());
    }

    @Override
    public Map<Integer, Button> getGlobalButtons(Player player) {
        final Map<Integer, Button> buttons = super.getGlobalButtons(player);
        buttons.put(4, new GlobalStatsButton());
        return buttons;
    }

    @Override
    public Map<Integer, Button> getAllPagesButtons(Player player) {
        final Map<Integer, Button> buttons = new HashMap<>();

        profile.getKitData().keySet().stream()
                .map(Kit::getByName)
                .filter(Objects::nonNull)
                .sorted(Comparator.comparing(Kit::getPriority))
                .forEach(kit -> buttons.put(buttons.size(), new KitStatsButton(kit.getName())));

        return buttons;
    }

    private class GlobalStatsButton extends Button {
        @Override
        public ItemStack getButtonItem(Player player) {

            int rankedWon = profile.getKitData().values().stream().mapToInt(ProfileKitData::getRankedWon).sum();
            int rankedLost = profile.getKitData().values().stream().mapToInt(ProfileKitData::getRankedLost).sum();
            int unrankedWon = profile.getKitData().values().stream().mapToInt(ProfileKitData::getUnrankedWon).sum();
            int unrankedLost = profile.getKitData().values().stream().mapToInt(ProfileKitData::getUnrankedLost).sum();

            return new ItemBuilder(Material.NETHER_STAR)
                    .name(Language.LEADERBOARD_KIT_STATS_MENU_GLOBAL_STATS_NAME.toString())
                    .lore(Language.LEADERBOARD_KIT_STATS_MENU_GLOBAL_STATS_LORE.toStringList(player,
                            unrankedWon,
                            unrankedLost,
                            Eden.DECIMAL.format((double) unrankedWon / (double) (unrankedLost == 0 ? 1 : unrankedLost)),
                            (profile.getKitData().values().stream().mapToInt(ProfileKitData::getElo).sum() / (profile.getKitData().size() == 0 ? 1 : profile.getKitData().size())),
                            rankedWon,
                            rankedLost,
                            Eden.DECIMAL.format((double) rankedWon / (double) (rankedLost == 0 ? 1 : rankedLost))
                    ))
                    .build();
        }
    }

    @Getter
    @RequiredArgsConstructor
    private class KitStatsButton extends Button {
        private final String kitName;
        @Override
        public ItemStack getButtonItem(Player player) {
            Kit kit = Kit.getByName(kitName);
            if (kit == null) {
                return new ItemStack(Material.AIR);
            }
            int rankedWon = profile.getKitData().get(kitName).getRankedWon();
            int rankedLost = profile.getKitData().get(kitName).getRankedLost();
            int unrankedWon = profile.getKitData().get(kitName).getUnrankedWon();
            int unrankedLost = profile.getKitData().get(kitName).getUnrankedLost();
            int winstreak = profile.getKitData().get(kitName).getWinstreak();
            int bestWinstreak = profile.getKitData().get(kitName).getBestWinstreak();
            return new ItemBuilder(kit.getDisplayIcon().clone())
                    .name(Language.LEADERBOARD_KIT_STATS_MENU_KIT_STATS_NAME.toString(kit.getDisplayName()))
                    .lore(Language.LEADERBOARD_KIT_STATS_MENU_KIT_STATS_LORE.toStringList(player,
                            unrankedWon,
                            unrankedLost,
                            winstreak,
                            bestWinstreak,
                            Eden.DECIMAL.format((double) unrankedWon / (double) (unrankedLost == 0 ? 1 : unrankedLost)),
                            profile.getKitData().get(kitName).getElo(),
                            profile.getKitData().get(kitName).getPeakElo(),
                            rankedWon,
                            rankedLost,
                            Eden.DECIMAL.format((double) rankedWon / (double) (rankedLost == 0 ? 1 : rankedLost))
                    ))
                    .build();
        }
    }
}


Filename: .\main\java\rip\diamond\practice\leaderboard\menu\impl\WinsLeaderboardMenu.java
package rip.diamond.practice.leaderboard.menu.impl;

import org.bukkit.entity.Player;
import org.bukkit.inventory.ItemStack;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.leaderboard.menu.LeaderboardMenu;
import rip.diamond.practice.util.menu.Button;

import java.util.*;

public class WinsLeaderboardMenu extends LeaderboardMenu {

    @Override
    public String getPrePaginatedTitle(Player player) {
        return Language.LEADERBOARD_WINS_MENU_TITLE.toString();
    }

    @Override
    public Map<Integer, Button> getAllPagesButtons(Player player) {
        final Map<Integer, Button> buttons = new HashMap<>();

        getPlugin().getLeaderboardManager().getWinsLeaderboard().values().stream().sorted(Comparator.comparing(leaderboard -> leaderboard.getKit().getPriority())).forEach(leaderboard -> buttons.put(buttons.size(), new Button() {
            @Override
            public ItemStack getButtonItem(Player player) {
                return leaderboard.getDisplayIcon();
            }
        }));

        return buttons;
    }
}


Filename: .\main\java\rip\diamond\practice\leaderboard\menu\impl\WinstreakLeaderboardMenu.java
package rip.diamond.practice.leaderboard.menu.impl;

import org.bukkit.entity.Player;
import org.bukkit.inventory.ItemStack;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.leaderboard.menu.LeaderboardMenu;
import rip.diamond.practice.util.menu.Button;

import java.util.*;

public class WinstreakLeaderboardMenu extends LeaderboardMenu {

    @Override
    public String getPrePaginatedTitle(Player player) {
        return Language.LEADERBOARD_WINSTREAK_MENU_TITLE.toString();
    }

    @Override
    public Map<Integer, Button> getAllPagesButtons(Player player) {
        final Map<Integer, Button> buttons = new HashMap<>();

        getPlugin().getLeaderboardManager().getWinstreakLeaderboard().values().stream().sorted(Comparator.comparing(leaderboard -> leaderboard.getKit().getPriority())).forEach(leaderboard -> buttons.put(buttons.size(), new Button() {
            @Override
            public ItemStack getButtonItem(Player player) {
                return leaderboard.getDisplayIcon();
            }
        }));

        return buttons;
    }
}


Filename: .\main\java\rip\diamond\practice\lobby\LobbyManager.java
package rip.diamond.practice.lobby;

import lombok.Getter;
import lombok.Setter;
import org.bukkit.Location;
import org.bukkit.entity.Player;
import rip.diamond.practice.Eden;
import rip.diamond.practice.profile.PlayerProfile;
import rip.diamond.practice.profile.PlayerState;
import rip.diamond.practice.util.*;
import rip.diamond.practice.util.serialization.LocationSerialization;

@Getter
public class LobbyManager {

    private final Eden plugin;

    @Setter private Location spawnLocation = null;

    public LobbyManager(Eden plugin) {
        this.plugin = plugin;
        try {
            this.spawnLocation = LocationSerialization.deserializeLocation(plugin.getLocationFile().getString("spawn-location"));
        } catch (Exception e) {
            Common.log("Unable to deserialize spawn-location from location file.");
        }
    }

    public void teleport(Player player) {
        if (spawnLocation == null) {
            Common.sendMessage(player, CC.RED + "Unable to teleport you to a certain location. Please check if spawn location and editor location is setup correctly.");
            Common.log(CC.RED + "Unable to teleport " + player.getName() + " to a certain location. Please check if spawn location and editor location is setup correctly.");
            return;
        }
        Util.teleport(player, spawnLocation);
    }

    public void reset(Player player) {
        PlayerProfile profile = PlayerProfile.get(player);

        if (profile == null) {
            return;
        }

        PlayerUtil.reset(player);

        profile.setMatch(null);
        profile.setPlayerState(PlayerState.IN_LOBBY);
        profile.setupItems();
        profile.getCooldowns().forEach((name, cooldown) -> cooldown.cancelCountdown());
    }

    public void sendToSpawnAndReset(Player player) {
        Tasks.run(()-> {
            reset(player);
            teleport(player);
        });
    }

}

Filename: .\main\java\rip\diamond\practice\lobby\LobbyMovementHandler.java
package rip.diamond.practice.lobby;

import rip.diamond.practice.Eden;
import rip.diamond.practice.profile.PlayerProfile;
import rip.diamond.practice.profile.PlayerState;

public class LobbyMovementHandler {

    public LobbyMovementHandler(Eden plugin) {
        Eden.INSTANCE.getSpigotAPI().getMovementHandler().injectLocationUpdate((player, from, to) -> {
            PlayerProfile profile = PlayerProfile.get(player);

            if (profile != null && (profile.getPlayerState() == PlayerState.IN_LOBBY || profile.getPlayerState() == PlayerState.IN_QUEUE) && player.getLocation().getY() < 0) {
                plugin.getLobbyManager().teleport(player);
            }
        });
    }

}


Filename: .\main\java\rip\diamond\practice\match\Match.java
package rip.diamond.practice.match;

import lombok.Getter;
import lombok.Setter;
import net.minecraft.server.v1_8_R3.EntityLightning;
import net.minecraft.server.v1_8_R3.PacketPlayOutSpawnEntityWeather;
import net.minecraft.server.v1_8_R3.PacketPlayOutTitle;
import org.bukkit.Bukkit;
import org.bukkit.Location;
import org.bukkit.Material;
import org.bukkit.Sound;
import org.bukkit.block.Block;
import org.bukkit.craftbukkit.v1_8_R3.entity.CraftPlayer;
import org.bukkit.entity.Item;
import org.bukkit.entity.Player;
import org.bukkit.inventory.ItemStack;
import rip.diamond.practice.Eden;
import rip.diamond.practice.arenas.ArenaDetail;
import rip.diamond.practice.config.Config;
import rip.diamond.practice.config.EdenSound;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.event.MatchEndEvent;
import rip.diamond.practice.event.MatchPlayerDeathEvent;
import rip.diamond.practice.event.MatchStartEvent;
import rip.diamond.practice.event.MatchStateChangeEvent;
import rip.diamond.practice.kits.Kit;
import rip.diamond.practice.kits.KitLoadout;
import rip.diamond.practice.match.task.*;
import rip.diamond.practice.match.team.Team;
import rip.diamond.practice.match.team.TeamColor;
import rip.diamond.practice.match.team.TeamPlayer;
import rip.diamond.practice.profile.PlayerProfile;
import rip.diamond.practice.profile.PlayerState;
import rip.diamond.practice.profile.ProfileSettings;
import rip.diamond.practice.profile.cooldown.Cooldown;
import rip.diamond.practice.profile.cooldown.CooldownType;
import rip.diamond.practice.profile.task.ProfileCooldownTask;
import rip.diamond.practice.profile.data.ProfileKitData;
import rip.diamond.practice.queue.QueueType;
import rip.diamond.practice.util.*;
import rip.diamond.practice.util.exception.PracticeUnexpectedException;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.Collectors;

@Getter
public abstract class Match {

    protected final Eden plugin = Eden.INSTANCE;

    @Getter
    private static final Map<UUID, Match> matches = new ConcurrentHashMap<>();
    @Getter
    private static final Map<UUID, PostMatchInventory> postMatchInventories = new HashMap<>();

    private final UUID uuid = UUID.randomUUID();
    @Setter
    private boolean duel = true;
    @Setter
    private QueueType queueType = QueueType.UNRANKED;
    protected final ArenaDetail arenaDetail;
    private final Kit kit;
    private final List<Team> teams;
    private MatchState state = MatchState.STARTING;
    private final List<UUID> spectators = new ArrayList<>();
    private final List<MatchEntity> entities = new ArrayList<>();
    private final List<Location> placedBlocks = new ArrayList<>();
    private final List<TaskTicker> tasks = new ArrayList<>();

    private final long startTimestamp = System.currentTimeMillis();

    public static void init() {
        new MatchClearItemTask();
        new MatchPostMatchInventoriesClearTask();
        new ProfileCooldownTask();
    }

    public Match(ArenaDetail arenaDetail, Kit kit, List<Team> teams) {
        this.arenaDetail = arenaDetail;
        this.kit = kit;
        this.teams = teams;

        matches.put(uuid, this);
    }

    /**
     * Start the match
     */
    public void start() {
        setupTeamSpawnLocation();

        // Arena setup logic

        // Check if the kit allows block building and breaking. If yes, we set the
        // ArenaDetail to using to prevent player using the same arena
        if (kit.getGameRules().isBuild() || kit.getGameRules().isSpleef()) {
            if (Match.getMatches().values().stream().filter(match -> match != this).anyMatch(
                    match -> (match.getKit().getGameRules().isBuild() || match.getKit().getGameRules().isSpleef())
                            && match.getArenaDetail() == arenaDetail)) {
                end(true, "ÂÖ∂‰ªñÊà∞È¨•Ê≠£Âú®‰ΩøÁî®ÈÄôÂÄãÂ†¥Âú∞, ‰∏¶‰∏îË©≤Êà∞È¨•ÁöÑËÅ∑Ê•≠ÈúÄË¶Å‰ΩøÁî®ÊñπÂ°ä");
                return;
            }
            arenaDetail.setUsing(true);
        }

        // Setup player logic
        for (Player player : getMatchPlayers()) {
            PlayerProfile profile = PlayerProfile.get(player);
            profile.setMatch(this);
            profile.setPlayerState(PlayerState.IN_MATCH);

            PlayerUtil.reset(player);

            player.setSaturation(Config.MATCH_START_SATURATION.toInteger());
            player.addPotionEffects(kit.getEffects());
            player.setMaximumNoDamageTicks(kit.getDamageTicks());

            if (kit.getGameRules().isReceiveKitLoadoutBook()) {
                ProfileKitData kitData = profile.getKitData().get(kit.getName());
                int savedKitsCount = 0;
                KitLoadout firstSavedKit = null;

                if (kitData != null && kitData.getLoadouts() != null) {
                    for (KitLoadout loadout : kitData.getLoadouts()) {
                        if (loadout != null) {
                            savedKitsCount++;
                            if (firstSavedKit == null) {
                                firstSavedKit = loadout;
                            }
                        }
                    }
                }

                if (savedKitsCount >= 2) {
                    for (ItemStack itemStack : kitData.getKitItems(kit)) {
                        if (itemStack.getType().equals(Material.BOOK)) {
                            player.getInventory().setItem(8, itemStack);
                        } else {
                            player.getInventory().addItem(itemStack);
                        }
                    }
                } else if (savedKitsCount == 1) {
                    firstSavedKit.apply(kit, this, player);
                    Language.MATCH_AUTO_EQUIPPED_KIT.sendMessage(player, firstSavedKit.getCustomName());
                    rip.diamond.practice.match.kit.DynamicKitManager.getInstance().addSession(player, this, kit,
                            firstSavedKit);
                } else {
                    kit.getKitLoadout().apply(kit, this, player);
                    Language.MATCH_AUTO_EQUIPPED_KIT.sendMessage(player, kit.getKitLoadout().getCustomName());
                    rip.diamond.practice.match.kit.DynamicKitManager.getInstance().addSession(player, this, kit,
                            kit.getKitLoadout());
                }
            } else {
                kit.getKitLoadout().apply(kit, this, player);
            }
            player.updateInventory();

            // Create the health display under NameTag, if needed
            if (kit.getGameRules().isShowHealth()) {
                plugin.getScoreboardHandler().getScoreboard(player).registerHealthObjective();
                player.setHealth(player.getMaxHealth() - 0.001); // Fix for health display as 0 - #379
            }

            // Set up the knockback
            plugin.getSpigotAPI().getKnockback().applyKnockback(player, kit.getGameRules().getKnockbackName());
        }

        // Teleport players into their team spawn
        teams.forEach(team -> team.teleport(team.getSpawnLocation()));

        // Set team's color
        if (getMatchType() != MatchType.FFA) {
            for (int i = 0; i < teams.size(); i++) {
                Team team = teams.get(i);
                team.setTeamColor(TeamColor.values()[i]);
                team.getTeamPlayers().forEach(team::dye);
            }
        }

        MatchStartEvent event = new MatchStartEvent(this);
        event.call();

        new MatchNewRoundTask(this, null, false);
    }

    /**
     * @param profile A random profile from match players which is alive. This is
     *                used to create a score cooldown
     * @param scorer  The TeamPlayer who scored the point
     */
    public void score(PlayerProfile profile, TeamPlayer entity, TeamPlayer scorer) {
        getMatchPlayers().stream().map(PlayerProfile::get)
                .filter(p -> !p.getCooldowns().get(CooldownType.SCORE).isExpired()).findFirst()
                .ifPresent(lastScorerProfile -> Common.log("[Eden] " + scorer.getUsername() + " tries to score when "
                        + lastScorerProfile.getUsername() + " scored in last 3 seconds (UUID: " + uuid + ")"));

        profile.getCooldowns().put(CooldownType.SCORE, new Cooldown(3));

        Team team = getTeam(scorer);
        team.handlePoint();
        if (state == MatchState.FIGHTING && team.getPoints() < kit.getGameRules().getMaximumPoints()) {
            if (kit.getGameRules().isOnlyLoserResetPositionWhenGetPoint()) {
                new MatchRespawnTask(this, entity);
                return;
            }
            new MatchFireworkTask(team.getTeamColor().getDyeColor().getColor(), this);
            new MatchNewRoundTask(this, scorer, true);
            return;
        }

        getOpponentTeam(team).getAliveTeamPlayers().forEach(teamTarget -> die(teamTarget.getPlayer(), false));
    }

    public void die(Player deadPlayer, boolean disconnected) {
        TeamPlayer teamPlayer = getTeamPlayer(deadPlayer);
        PlayerProfile profile = PlayerProfile.get(deadPlayer);
        Team team = getTeam(deadPlayer);

        teamPlayer.setDisconnected(disconnected); // Set the disconnect state here, so player who already die, do
                                                  // /giveup, and do /spec to join back the match will not have
                                                  // duplicate messages

        if (!teamPlayer.isAlive()) {
            return;
        }

        teamPlayer.setAlive(false);
        getMatchPlayers().forEach(VisibilityController::updateVisibility);

        // Setup Post-Match Inventory
        PostMatchInventory postMatchInventory = new PostMatchInventory(teamPlayer);
        postMatchInventories.put(teamPlayer.getUuid(), postMatchInventory);

        displayDeathMessage(teamPlayer, deadPlayer);

        // Play lightning effect and death animation
        MatchPlayerDeathEvent event = new MatchPlayerDeathEvent(this, deadPlayer);
        event.call();
        if (event.isPlayLightningEffect() && Config.MATCH_DEATH_LIGHTNING.toBoolean()) {
            EntityLightning lightning = new EntityLightning(((CraftPlayer) deadPlayer).getHandle().getWorld(),
                    deadPlayer.getLocation().getX(), deadPlayer.getLocation().getY(), deadPlayer.getLocation().getZ(),
                    true, false);
            for (Player player : getPlayersAndSpectators()) {
                ((CraftPlayer) player).getHandle().playerConnection
                        .sendPacket(new PacketPlayOutSpawnEntityWeather(lightning));
                player.playSound(deadPlayer.getLocation(), Sound.AMBIENCE_THUNDER, 1.0F, 1.0F);
            }
        }
        if (event.isPlayDeathEffect() && Config.MATCH_DEATH_ANIMATION.toBoolean()) {
            Util.playDeathAnimation(deadPlayer, getPlayersAndSpectators().stream()
                    .filter(player -> player != deadPlayer).collect(Collectors.toList()));
        }

        // Check if there's only one team survives. If yes, end the match
        if (canEnd()) {
            end();
        } else if (!disconnected) {
            PlayerUtil.spectator(deadPlayer);
            Tasks.runLater(profile::setupItems, 1L);
        }
    }

    public void respawn(TeamPlayer teamPlayer) {
        Player player = teamPlayer.getPlayer();
        Team team = getTeam(player);
        team.getSpawnLocation().clone().add(0, 0, 0).getBlock().setType(Material.AIR);
        team.getSpawnLocation().clone().add(0, 1, 0).getBlock().setType(Material.AIR);
        Util.teleport(player, team.getSpawnLocation());
        player.setAllowFlight(false);
        player.setFlying(false);
        teamPlayer.setRespawning(false);
        getMatchPlayers().forEach(VisibilityController::updateVisibility);

        PlayerProfile profile = PlayerProfile.get(player);
        // So arrow will not be duplicated if GiveBackArrow is on
        profile.getCooldowns().get(CooldownType.ARROW).cancelCountdown();

        player.setExp(0);
        player.setLevel(0);

        teamPlayer.setProtectionUntil(System.currentTimeMillis() + (3 * 1000));
        teamPlayer.respawn(this);
        Language.MATCH_RESPAWN_MESSAGE.sendMessage(player);
    }

    public void displayDeathMessage(TeamPlayer teamPlayer, Player deadPlayer) {
        if (teamPlayer.isDisconnected()) {
            getPlayersAndSpectators().forEach(player -> Language.MATCH_DEATH_MESSAGE_DISCONNECT.sendMessage(player,
                    getRelationColor(player, deadPlayer),
                    teamPlayer.getUsername(),
                    getTeam(teamPlayer).getTeamColor().getColor()));
        } else if (teamPlayer.getLastHitDamager() != null && teamPlayer.getLastHitDamager().getPlayer() != null) {
            getPlayersAndSpectators().forEach(player -> Language.MATCH_DEATH_MESSAGE_KILLED.sendMessage(player,
                    getRelationColor(player, deadPlayer),
                    teamPlayer.getUsername(),
                    getRelationColor(player, teamPlayer.getLastHitDamager().getPlayer()),
                    teamPlayer.getLastHitDamager().getUsername(),
                    getTeam(teamPlayer).getTeamColor().getColor(),
                    getTeam(teamPlayer.getLastHitDamager()).getTeamColor().getColor()));
        } else {
            getPlayersAndSpectators().forEach(player -> Language.MATCH_DEATH_MESSAGE_DEFAULT.sendMessage(player,
                    getRelationColor(player, deadPlayer),
                    teamPlayer.getUsername(),
                    getTeam(teamPlayer).getTeamColor().getColor()));
        }
    }

    public void end() {
        end(false, null);
    }

    public void end(boolean forced, String reason) {
        if (state == MatchState.ENDING) {
            return;
        }

        Common.debug("Ê≠£Âú®ÁµêÊùü " + getClass().getSimpleName() + " Êà∞È¨• ("
                + teams.stream().map(team -> team.getLeader().getUsername()).collect(Collectors.joining(" vs "))
                + ") (ËÅ∑Ê•≠: " + kit.getName() + ") (Âú∞Âúñ: " + arenaDetail.getArena().getName() + ") (UUID: " + uuid + ")");
        state = MatchState.ENDING;

        MatchEndEvent event = new MatchEndEvent(this, forced);
        event.call();

        if (forced) {
            broadcastMessage(Language.MATCH_FORCE_END_MESSAGE.toString(reason));
        } else {
            // Setup Post-Match Inventories
            for (TeamPlayer teamPlayer : getWinningPlayers()) {
                PostMatchInventory postMatchInventory = new PostMatchInventory(teamPlayer);
                postMatchInventories.put(teamPlayer.getUuid(), postMatchInventory);
            }

            for (Player player : getMatchPlayers()) {
                plugin.getScoreboardHandler().getScoreboard(player).unregisterHealthObjective();
            }

            if (Config.MATCH_TITLE_END.toBoolean()) {
                displayMatchEndTitle();
            }
            displayMatchEndMessages();
            calculateMatchStats();
        }

        // #442 - Teleport back to spawn location to prevent stuck in the portal
        if (kit.getGameRules().isPortalGoal()) {
            getTeams().forEach(t -> t.teleport(t.getSpawnLocation()));
        }

        new MatchResetTask(this);
    }

    public void joinSpectate(Player player, Player target) {
        PlayerProfile profile = PlayerProfile.get(player);

        spectators.add(player.getUniqueId());

        getPlayersAndSpectators().forEach(other -> {
            // We do not want to send useless stuff to NPC. 'other' might be null because
            // the NPC might be already destroyed because it is dead
            if (other != null && !Util.isNPC(other)) {
                PlayerProfile otherProfile = PlayerProfile.get(other);
                if (otherProfile.getSettings().get(ProfileSettings.SPECTATOR_JOIN_LEAVE_MESSAGE).isEnabled()) {
                    Common.sendMessage(other, Language.MATCH_JOIN_SPECTATE.toString(player.getName()));
                }
            }
        });

        profile.setMatch(this);
        profile.setPlayerState(PlayerState.IN_SPECTATING);
        PlayerUtil.spectator(player);
        profile.setupItems();

        Util.teleport(player, getArenaDetail().getSpectator());

        // Create the health display under NameTag, if needed
        if (kit.getGameRules().isShowHealth()) {
            plugin.getScoreboardHandler().getScoreboard(player).registerHealthObjective();
        }
    }

    public void leaveSpectate(Player player) {
        spectators.remove(player.getUniqueId());

        getPlayersAndSpectators().forEach(other -> {
            // We do not want to send useless stuff to NPC. 'other' might be null because
            // the NPC might be already destroyed because it is dead
            if (other != null && !Util.isNPC(other)) {
                PlayerProfile otherProfile = PlayerProfile.get(other);
                if (otherProfile.getSettings().get(ProfileSettings.SPECTATOR_JOIN_LEAVE_MESSAGE).isEnabled()) {
                    Common.sendMessage(other, Language.MATCH_LEAVE_SPECTATE.toString(player.getName()));
                }
            }
        });

        plugin.getScoreboardHandler().getScoreboard(player).unregisterHealthObjective();
        plugin.getLobbyManager().sendToSpawnAndReset(player);
    }

    public void addDroppedItem(Item item, String whoDropped) {
        if (whoDropped != null) {
            plugin.getEntityHider().setPlayerWhoDropped(item, whoDropped);
        }
        getEntities().add(new MatchEntity(this, item));
    }

    public void clearEntities(boolean forced) {
        Iterator<MatchEntity> iterator = entities.iterator();
        while (iterator.hasNext()) {
            MatchEntity matchEntity = iterator.next();
            if (forced || System.currentTimeMillis() - matchEntity.getTimestamp() >= 10000) {
                matchEntity.getEntity().remove();
                iterator.remove();
            }
        }
    }

    public void setState(MatchState state) {
        this.state = state;

        getPlayersAndSpectators().forEach(VisibilityController::updateVisibility);

        MatchStateChangeEvent event = new MatchStateChangeEvent(this);
        Bukkit.getPluginManager().callEvent(event);
    }

    public boolean canEnd() {
        return teams.stream().filter(team -> !team.isEliminated()).count() <= 1;
    }

    public boolean isProtected(Location location, boolean isPlacing) {
        return isProtected(location, isPlacing, null);
    }

    public boolean isProtected(Location location, boolean isPlacing, Block block) {
        if (block != null && block.getType() == Material.TNT && Config.MATCH_TNT_ENABLED.toBoolean()) { // Allow TNT
                                                                                                        // placing above
                                                                                                        // build limit
            return false;
        }
        if (location.getBlockY() >= arenaDetail.getArena().getBuildMax()
                || location.getBlockY() <= arenaDetail.getArena().getYLimit()) {
            return true;
        }
        if (!arenaDetail.getCuboid().contains(location)) {
            return true;
        }
        if (kit.getGameRules().isSpleef()) {
            return location.getBlock().getType() != Material.SNOW_BLOCK
                    && location.getBlock().getType() != Material.SAND;
        }
        if (kit.getGameRules().isBed()) {
            switch (location.getBlock().getType()) {
                case BED_BLOCK:
                case WOOD:
                case ENDER_STONE:
                    return false;
            }
        }
        if (kit.getGameRules().isBreakGoal() && location.getBlock().getType() == Material.BED_BLOCK) {
            return false;
        }
        if (kit.getGameRules().isPortalGoal()) {
            long count = Util.getBlocksAroundCenter(location, arenaDetail.getArena().getPortalProtectionRadius())
                    .stream().filter(b -> b.getType() == Material.ENDER_PORTAL).count();
            if (count > 0) {
                return true;
            }
            if (location.getBlock().getType() == Material.STAINED_CLAY && (location.getBlock().getData() == 0
                    || location.getBlock().getData() == 11 || location.getBlock().getData() == 14)) {
                return false;
            }
        }
        if (Config.MATCH_ALLOW_BREAKING_BLOCKS.toStringList().contains(location.getBlock().getType().name())) {
            return false;
        }
        if (!isPlacing) {
            return !getPlacedBlocks().contains(location);
        }
        return false;
    }

    public String getRelationColor(Player viewer, Player target) {
        if (viewer.equals(target)) {
            return CC.GREEN;
        }

        Team team = getTeam(target);
        Team viewerTeam = getTeam(viewer);

        if (team == null || viewerTeam == null) {
            return Config.NAMETAG_PREFIX_OTHER.toString();
        }

        if (team.equals(viewerTeam)) {
            return Config.NAMETAG_PREFIX_TEAMMATE.toString();
        } else {
            return Config.NAMETAG_PREFIX_OPPONENT.toString();
        }
    }

    /**
     * @return A list of players who are in the match, without spectators and
     *         disconnected players
     */
    public List<Player> getMatchPlayers() {
        List<Player> players = new ArrayList<>();
        teams.forEach(team -> players.addAll(team.getTeamPlayers().stream()
                // Filter all players who are already disconnected
                .filter(tP -> !tP.isDisconnected())
                // Convert all TeamPlayer to Player
                .map(TeamPlayer::getPlayer)
                // TeamPlayer#isDisconnected will be false if the player is already dead, and
                // disconnected afterwards. This is why we have to filter nonNull objects
                .filter(Objects::nonNull)
                .collect(Collectors.toList())));
        return players;
    }

    public List<Player> getSpectators() {
        List<Player> players = new ArrayList<>();
        spectators.forEach(spectatorUUID -> players.add(Bukkit.getPlayer(spectatorUUID)));
        return players;
    }

    public List<Player> getPlayersAndSpectators() {
        List<Player> players = new ArrayList<>(getMatchPlayers());
        players.addAll(getSpectators());
        return players;
    }

    public Team getTeam(TeamPlayer player) {
        for (Team team : teams) {
            if (team.getTeamPlayers().stream().filter(Objects::nonNull).collect(Collectors.toList()).contains(player)) {
                return team;
            }
        }
        return null;
    }

    public Team getTeam(Player player) {
        for (Team team : teams) {
            if (team.getTeamPlayers().stream().map(TeamPlayer::getPlayer).filter(Objects::nonNull)
                    .collect(Collectors.toList()).contains(player)) {
                return team;
            }
        }
        return null;
    }

    public TeamPlayer getTeamPlayer(Player player) {
        return getTeamPlayer(player.getUniqueId());
    }

    public TeamPlayer getTeamPlayer(UUID uuid) {
        for (Team team : teams) {
            for (TeamPlayer teamPlayer : team.getTeamPlayers()) {
                if (teamPlayer.getUuid().equals(uuid)) {
                    return teamPlayer;
                }
            }
        }
        return null;
    }

    public List<TeamPlayer> getTeamPlayers() {
        List<TeamPlayer> players = new ArrayList<>();
        teams.stream().map(Team::getTeamPlayers).forEach(players::addAll);
        return players.stream().filter(teamPlayer -> !teamPlayer.isDisconnected()).collect(Collectors.toList());
    }

    public int getMaximumBoxingHits() {
        if (!kit.getGameRules().isBoxing()) {
            throw new PracticeUnexpectedException("Kit type is not boxing");
        }
        Team team = getTeams().stream().max(Comparator.comparing(t -> t.getTeamPlayers().size())).orElse(null);
        if (team == null) {
            throw new PracticeUnexpectedException(
                    "Cannot find a suitable team to calculate the maximum allowed hits in boxing");
        }
        return team.getTeamPlayers().size() * 100;
    }

    public long getElapsedDuration() {
        return System.currentTimeMillis() - startTimestamp;
    }

    public void broadcastMessage(String... message) {
        getPlayersAndSpectators().forEach(player -> Common.sendMessage(player, message));
    }

    public void broadcastMessage(List<String> messages) {
        getPlayersAndSpectators().forEach(player -> Common.sendMessage(player, messages));
    }

    public void broadcastTitle(String title, String subtitle, int fadeIn, int stay, int fadeOut) {
        getPlayersAndSpectators().forEach(player -> {
            TitleSender.sendTitle(player, title, PacketPlayOutTitle.EnumTitleAction.TITLE, fadeIn, stay, fadeOut);
            TitleSender.sendTitle(player, subtitle, PacketPlayOutTitle.EnumTitleAction.SUBTITLE, fadeIn, stay, fadeOut);
        });
    }

    public void broadcastTitle(String message) {
        getPlayersAndSpectators().forEach(
                player -> TitleSender.sendTitle(player, message, PacketPlayOutTitle.EnumTitleAction.TITLE, 0, 21, 5));
    }

    public void broadcastSubTitle(String message) {
        getPlayersAndSpectators().forEach(player -> TitleSender.sendTitle(player, message,
                PacketPlayOutTitle.EnumTitleAction.SUBTITLE, 0, 21, 5));
    }

    public void broadcastTitle(Team team, String message) {
        for (TeamPlayer teamPlayer : team.getTeamPlayers())
            if (teamPlayer.getPlayer() != null)
                TitleSender.sendTitle(teamPlayer.getPlayer(), message, PacketPlayOutTitle.EnumTitleAction.TITLE, 0, 21,
                        5);
    }

    public void broadcastSubTitle(Team team, String message) {
        for (TeamPlayer teamPlayer : team.getTeamPlayers())
            if (teamPlayer.getPlayer() != null)
                TitleSender.sendTitle(teamPlayer.getPlayer(), message, PacketPlayOutTitle.EnumTitleAction.SUBTITLE, 0,
                        21, 5);
    }

    public void broadcastSound(Sound sound) {
        getPlayersAndSpectators().forEach(player -> player.playSound(player.getLocation(), sound, 10, 1));
    }

    public void broadcastSound(EdenSound sound) {
        getPlayersAndSpectators().forEach(sound::play);
    }

    public void broadcastSound(Team team, Sound sound) {
        team.getTeamPlayers().stream().map(TeamPlayer::getPlayer).filter(Objects::nonNull)
                .forEach(player -> player.playSound(player.getLocation(), sound, 10, 1));
    }

    public void broadcastSound(Team team, EdenSound sound) {
        team.getTeamPlayers().stream().map(TeamPlayer::getPlayer).filter(Objects::nonNull).forEach(sound::play);
    }

    public void broadcastSpectatorsSound(Sound sound) {
        getSpectators().forEach(player -> player.playSound(player.getLocation(), sound, 10, 1));
    }

    public void broadcastSpectatorsSound(EdenSound sound) {
        getSpectators().forEach(sound::play);
    }

    public abstract void setupTeamSpawnLocation();

    public abstract void displayMatchEndMessages();

    public abstract void displayMatchEndTitle();

    public abstract void calculateMatchStats();

    public abstract MatchType getMatchType();

    public abstract Team getOpponentTeam(Team team);

    public abstract TeamPlayer getOpponent(TeamPlayer teamPlayer);

    public abstract List<TeamPlayer> getWinningPlayers();

    public abstract Team getWinningTeam();

    public abstract List<String> getMatchScoreboard(Player player);

    public abstract List<String> getSpectateScoreboard(Player player);
}


Filename: .\main\java\rip\diamond\practice\match\MatchEntity.java
package rip.diamond.practice.match;

import lombok.Getter;
import org.bukkit.entity.Entity;
import rip.diamond.practice.util.Common;

@Getter
public class MatchEntity {

    private final long timestamp;
    private final Match match;
    private final Entity entity;

    public MatchEntity(Match match, Entity entity) {
        this.timestamp = System.currentTimeMillis();
        this.match = match;
        this.entity = entity;
    }

}


Filename: .\main\java\rip\diamond\practice\match\MatchMovementHandler.java
package rip.diamond.practice.match;

import org.bukkit.Location;
import org.bukkit.Material;
import org.bukkit.block.Block;
import rip.diamond.practice.Eden;
import rip.diamond.practice.arenas.Arena;
import rip.diamond.practice.arenas.ArenaDetail;
import rip.diamond.practice.config.Config;
import rip.diamond.practice.kits.Kit;
import rip.diamond.practice.kits.KitGameRules;
import rip.diamond.practice.match.team.Team;
import rip.diamond.practice.match.team.TeamPlayer;
import rip.diamond.practice.profile.PlayerProfile;
import rip.diamond.practice.profile.PlayerState;
import rip.diamond.practice.profile.cooldown.CooldownType;
import rip.diamond.practice.util.Common;
import rip.diamond.practice.util.Util;
import rip.diamond.practice.util.cuboid.CuboidDirection;

import java.util.Comparator;

public class MatchMovementHandler {

    public MatchMovementHandler() {
        Eden.INSTANCE.getSpigotAPI().getMovementHandler().injectLocationUpdate((player, from, to) -> {
            PlayerProfile profile = PlayerProfile.get(player);

            Block block = to.getBlock();
            Block underBlock = to.clone().add(0, -1, 0).getBlock();

            if (profile.getPlayerState() == PlayerState.IN_MATCH && profile.getMatch() != null) {
                Match match = profile.getMatch();
                ArenaDetail arenaDetail = match.getArenaDetail();
                Arena arena = arenaDetail.getArena();
                Kit kit = match.getKit();
                KitGameRules gameRules = kit.getGameRules();

                if (gameRules.isStartFreeze() && match.getState() == MatchState.STARTING
                        && (from.getX() != to.getX() || from.getZ() != to.getZ())) {
                    Location location = match.getTeam(player).getSpawnLocation();
                    // https://github.com/diamond-rip/Eden/issues/389#issuecomment-1630048579 -
                    // Smoother looking by only changing the player's x and z location
                    location.setY(from.getY());
                    location.setPitch(from.getPitch());
                    location.setYaw(from.getYaw());
                    Util.teleport(player, location);
                    return;
                }

                if ((!arenaDetail.getCuboid().clone().outset(CuboidDirection.HORIZONTAL, 10).contains(player)
                        && Config.MATCH_OUTSIDE_CUBOID_INSTANT_DEATH.toBoolean())
                        || arena.getYLimit() > player.getLocation().getY()) {
                    TeamPlayer teamPlayer = match.getTeamPlayer(player);
                    // Only damage alive players who are not respawning
                    if (teamPlayer.isAlive() && !teamPlayer.isRespawning()) {
                        Util.damage(player, 99999);
                    }
                    return;
                }

                // Prevent any duplicate scoring
                // If two people go into the portal at the same time in bridge, it will count as
                // +2 points
                // If player go into the water and PlayerMoveEvent is too slow to perform
                // teleportation, it will run MatchNewRoundTask multiple times
                if (match.getMatchPlayers().stream().allMatch(p -> PlayerProfile
                        .get(p)
                        .getCooldowns()
                        .get(CooldownType.SCORE)
                        .isExpired())) {
                    TeamPlayer teamPlayer = match.getTeamPlayer(player);
                    if (match.getState() == MatchState.FIGHTING && !teamPlayer.isRespawning()) {
                        // Ê™¢Êü• KitGameRules Ê∞¥‰∏äÂç≥Ê≠ª
                        if (gameRules.isDeathOnWater() && (block.getType() == Material.WATER
                                || block.getType() == Material.STATIONARY_WATER)) {
                            if (gameRules.isPoint(match)) {
                                TeamPlayer lastHitDamager = teamPlayer.getLastHitDamager();
                                // Áé©ÂÆ∂ÊúâÊ©üÊúÉÂú®‰∏çË¢´ÊïµÊñπÊîªÊìäÁöÑÊÉÖÊ≥Å‰∏ãÊ≠ª‰∫°, ‰æãÂ¶ÇÂ≤©Êºø, Â¶ÇÊûúÊòØÈÄôÊ®£, Â∞±Âú®ÊïµÊñπÈöä‰ºçÈö®‰æøÊäΩ‰∏ÄÂÄãÁé©ÂÆ∂Âá∫‰æÜ
                                if (lastHitDamager == null) {
                                    lastHitDamager = match.getOpponentTeam(match.getTeam(player)).getAliveTeamPlayers()
                                            .get(0);
                                }
                                match.score(profile, teamPlayer, lastHitDamager);
                            } else {
                                Util.damage(player, 99999);
                            }
                            return;
                        }

                        // Ê™¢Êü• KitGameRules ÈÄ≤ÂÖ•ÁõÆÊ®ô
                        if (gameRules.isPortalGoal() && block.getType() == Material.ENDER_PORTAL) {
                            Team playerTeam = match.getTeam(player);
                            Team portalBelongsTo = match.getTeams().stream()
                                    .min(Comparator.comparing(team -> team.getSpawnLocation().distance(to)))
                                    .orElse(null);
                            if (portalBelongsTo == null) {
                                Common.log(
                                        "An error occurred while finding portalBelongsTo, please contact GoodestEnglish to fix");
                                return;
                            }
                            if (portalBelongsTo != playerTeam) {
                                match.score(profile, null, match.getTeamPlayer(player));
                            } else {
                                // Prevent player scoring their own goal
                                Util.damage(player, 99999);
                            }
                            return;
                        }
                    }
                }
            } else if (profile.getPlayerState() == PlayerState.IN_SPECTATING && profile.getMatch() != null) {
                Match match = profile.getMatch();
                ArenaDetail arenaDetail = match.getArenaDetail();

                if (!arenaDetail.getCuboid().clone()
                        .outset(CuboidDirection.HORIZONTAL, Config.MATCH_SPECTATE_EXPEND_CUBOID.toInteger())
                        .contains(player)) {
                    player.teleport(arenaDetail.getSpectator());
                    return;
                }
            }
        });
    }
}


Filename: .\main\java\rip\diamond\practice\match\MatchState.java
package rip.diamond.practice.match;

public enum MatchState {
	STARTING,
	FIGHTING,
	ENDING
}


Filename: .\main\java\rip\diamond\practice\match\MatchTaskTicker.java
package rip.diamond.practice.match;

import rip.diamond.practice.util.TaskTicker;

public abstract class MatchTaskTicker extends TaskTicker {

    private final Match match;

    public MatchTaskTicker(int delay, int period, boolean async, Match match) {
        super(delay, period, async);

        this.match = match;

        match.getTasks().add(this);
    }

    @Override
    public abstract void onRun();

    @Override
    public abstract void preRun();

    @Override
    public abstract TickType getTickType();

    @Override
    public abstract int getStartTick();

    @Override
    public synchronized void cancel() throws IllegalStateException {
        super.cancel();
        if (match.getState() == MatchState.FIGHTING) {
            match.getTasks().remove(this);
        }
    }
}


Filename: .\main\java\rip\diamond\practice\match\MatchType.java
package rip.diamond.practice.match;

import lombok.AllArgsConstructor;
import lombok.Getter;
import rip.diamond.practice.config.Language;

@Getter
@AllArgsConstructor
public enum MatchType {
    SOLO(Language.MATCH_MATCH_TYPE_SOLO.toString()),
    FFA(Language.MATCH_MATCH_TYPE_FFA.toString()),
    SPLIT(Language.MATCH_MATCH_TYPE_SPLIT.toString()),
    SUMO_EVENT(Language.MATCH_MATCH_TYPE_SUMO_EVENT.toString()),
    ;

    private final String readable;
}


Filename: .\main\java\rip\diamond\practice\match\PostMatchInventory.java
package rip.diamond.practice.match;

import lombok.Getter;
import org.bukkit.entity.Player;
import org.bukkit.inventory.ItemStack;
import org.bukkit.potion.PotionEffect;
import rip.diamond.practice.match.team.TeamPlayer;
import rip.diamond.practice.util.HeadUtil;
import rip.diamond.practice.util.HealingMethod;

import java.util.Arrays;
import java.util.Collection;
import java.util.UUID;

@Getter
public class PostMatchInventory {

    private final String owner;
    private final UUID ownerUUID;
    private final String ownerHeadValue;
    private String switchTo;
    private UUID switchToUUID;
    private final int health;
    private final int maxHealth;
    private final int hunger;
    private final ItemStack[] armor;
    private final ItemStack[] contents;
    private final Collection<PotionEffect> effects;
    private final int hits;
    private final int blockedHits;
    private final int longestCombo;
    private final HealingMethod healingMethod;
    private final int potionsThrown;
    private final int potionsMissed;

    private final long created = System.currentTimeMillis();

    public PostMatchInventory(TeamPlayer teamPlayer) {
        Player player = teamPlayer.getPlayer();

        this.owner = teamPlayer.getUsername();
        this.ownerUUID = teamPlayer.getUuid();
        this.ownerHeadValue = HeadUtil.getValue(player);
        this.health = player.getHealth() == 0 ? 0 : (int) Math.round(player.getHealth());
        this.maxHealth = (int) Math.round(player.getMaxHealth());
        this.hunger = player.getFoodLevel();
        this.armor = Arrays.stream(player.getInventory().getArmorContents()).map(itemStack -> itemStack == null ? null : itemStack.clone()).toArray(ItemStack[]::new);
        this.contents = Arrays.stream(player.getInventory().getContents()).map(itemStack -> itemStack == null ? null : itemStack.clone()).toArray(ItemStack[]::new);
        this.effects = player.getActivePotionEffects();
        this.hits = teamPlayer.getHits();
        this.blockedHits = teamPlayer.getBlockedHits();
        this.longestCombo = teamPlayer.getLongestCombo();
        this.healingMethod = HealingMethod.getHealingMethod(contents);
        this.potionsThrown = teamPlayer.getPotionsThrown();
        this.potionsMissed = teamPlayer.getPotionsMissed();
    }


    public double getPotionAccuracy() {
        if (potionsMissed == 0) {
            return 100.0;
        } else if (potionsThrown == potionsMissed) {
            return 50.0;
        }

        return Math.round(100.0D - (((double) potionsMissed / (double) potionsThrown) * 100.0D));
    }

    public void setSwitchTo(String name, UUID uuid) {
        this.switchTo = name;
        this.switchToUUID = uuid;
    }

}


Filename: .\main\java\rip\diamond\practice\match\command\ForceEndCommand.java
package rip.diamond.practice.match.command;

import org.bukkit.Bukkit;
import org.bukkit.entity.Player;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.match.Match;
import rip.diamond.practice.profile.PlayerProfile;
import rip.diamond.practice.util.CC;
import rip.diamond.practice.util.Common;
import rip.diamond.practice.util.command.Command;
import rip.diamond.practice.util.command.CommandArgs;
import rip.diamond.practice.util.command.argument.CommandArguments;

public class ForceEndCommand extends Command {
    @CommandArgs(name = "forceend", permission = "eden.command.forceend")
    public void execute(CommandArguments command) {
        Player player = command.getPlayer();
        String[] args = command.getArgs();

        if (args.length == 1) {
            Player target = Bukkit.getPlayer(args[0]);
            if (target == null) {
                Language.MATCH_FORCE_END_NOT_ONLINE.sendMessage(player);
                return;
            }
            PlayerProfile targetProfile = PlayerProfile.get(target);
            if (targetProfile == null) {
                Language.MATCH_FORCE_END_PROFILE_NOT_FOUND.sendMessage(player);
                return;
            }
            Match match = targetProfile.getMatch();
            if (match == null) {
                Language.MATCH_FORCE_END_NOT_IN_MATCH.sendMessage(player);
                return;
            }
            match.end(true, Language.MATCH_FORCE_END_REASON.toString());
            Language.MATCH_FORCE_END_SUCCESS.sendMessage(player, target.getName());
            return;
        }

        Common.sendMessage(player, CC.RED + "/forceend <player>");
    }
}


Filename: .\main\java\rip\diamond\practice\match\command\GiveUpCommand.java
package rip.diamond.practice.match.command;

import org.bukkit.entity.Player;
import rip.diamond.practice.match.Match;
import rip.diamond.practice.profile.PlayerProfile;
import rip.diamond.practice.profile.PlayerState;
import rip.diamond.practice.util.command.Command;
import rip.diamond.practice.util.command.CommandArgs;
import rip.diamond.practice.util.command.argument.CommandArguments;

public class GiveUpCommand extends Command {
    @CommandArgs(name = "giveup", aliases = {"leave", "l"})
    public void execute(CommandArguments command) {
        Player player = command.getPlayer();
        PlayerProfile profile = PlayerProfile.get(player);
        Match match = profile.getMatch();

        if (profile.getPlayerState() == PlayerState.IN_MATCH && match != null && match.getTeamPlayer(player) != null) {
            match.die(player, true);
            plugin.getScoreboardHandler().getScoreboard(player).unregisterHealthObjective();
            plugin.getLobbyManager().sendToSpawnAndReset(player);
        }
    }
}


Filename: .\main\java\rip\diamond\practice\match\command\LeaveSpectateCommand.java
package rip.diamond.practice.match.command;

import org.bukkit.entity.Player;
import rip.diamond.practice.match.Match;
import rip.diamond.practice.profile.PlayerProfile;
import rip.diamond.practice.profile.PlayerState;
import rip.diamond.practice.util.command.Command;
import rip.diamond.practice.util.command.CommandArgs;
import rip.diamond.practice.util.command.argument.CommandArguments;

public class LeaveSpectateCommand extends Command {
    @CommandArgs(name = "leavespectate")
    public void execute(CommandArguments command) {
        Player player = command.getPlayer();
        PlayerProfile profile = PlayerProfile.get(player);

        if (profile.getPlayerState() == PlayerState.IN_SPECTATING && profile.getMatch() != null) {
            Match match = profile.getMatch();
            match.leaveSpectate(player);
        }
    }
}


Filename: .\main\java\rip\diamond\practice\match\command\NoSpeedCommand.java
package rip.diamond.practice.match.command;

import org.bukkit.entity.Player;
import org.bukkit.potion.PotionEffectType;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.match.Match;
import rip.diamond.practice.profile.PlayerProfile;
import rip.diamond.practice.util.command.Command;
import rip.diamond.practice.util.command.CommandArgs;
import rip.diamond.practice.util.command.argument.CommandArguments;

public class NoSpeedCommand extends Command {
    @CommandArgs(name = "nospeed")
    public void execute(CommandArguments command) {
        Player player = command.getPlayer();
        PlayerProfile profile = PlayerProfile.get(player);

        Match match = profile.getMatch();
        if (match == null) {
            Language.MATCH_NO_SPEED_NOT_IN_MATCH.sendMessage(player);
            return;
        }
        if (!match.getKit().getGameRules().isBoxing()) {
            Language.MATCH_NO_SPEED_NOT_BOXING.sendMessage(player);
            return;
        }
        if (player.hasPotionEffect(PotionEffectType.SPEED)) {
            player.removePotionEffect(PotionEffectType.SPEED);
            Language.MATCH_NO_SPEED_SUCCESS_REMOVED.sendMessage(player);
        } else {
            match.getKit().getEffects().forEach(player::addPotionEffect);
            Language.MATCH_NO_SPEED_SUCCESS_ADDED.sendMessage(player);
        }
    }
}


Filename: .\main\java\rip\diamond\practice\match\command\RequeueCommand.java
package rip.diamond.practice.match.command;

import org.bukkit.entity.Player;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.match.Match;
import rip.diamond.practice.match.MatchState;
import rip.diamond.practice.profile.PlayerProfile;
import rip.diamond.practice.queue.Queue;
import rip.diamond.practice.util.Tasks;
import rip.diamond.practice.util.command.Command;
import rip.diamond.practice.util.command.CommandArgs;
import rip.diamond.practice.util.command.argument.CommandArguments;

public class RequeueCommand extends Command {
    @CommandArgs(name = "requeue")
    public void execute(CommandArguments command) {
        Player player = command.getPlayer();
        PlayerProfile profile = PlayerProfile.get(player);

        Match match = profile.getMatch();
        if (match == null) {
            Language.MATCH_REQUEUE_NOT_IN_MATCH.sendMessage(player);
            return;
        }
        if (match.getState() != MatchState.ENDING) {
            return;
        }
        plugin.getLobbyManager().sendToSpawnAndReset(player);
        Tasks.runLater(() -> Queue.joinQueue(player, match.getKit(), match.getQueueType()), 1L);
    }
}


Filename: .\main\java\rip\diamond\practice\match\command\SpectateCommand.java
package rip.diamond.practice.match.command;

import org.bukkit.Bukkit;
import org.bukkit.entity.Player;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.match.menu.SpectateMenu;
import rip.diamond.practice.party.Party;
import rip.diamond.practice.profile.PlayerProfile;
import rip.diamond.practice.profile.PlayerState;
import rip.diamond.practice.util.command.Command;
import rip.diamond.practice.util.command.CommandArgs;
import rip.diamond.practice.util.command.argument.CommandArguments;

public class SpectateCommand extends Command {
    @CommandArgs(name = "spectate", aliases = {"spec"})
    public void execute(CommandArguments command) {
        Player player = command.getPlayer();
        PlayerProfile profile = PlayerProfile.get(player);
        String[] args = command.getArgs();

        if (profile.getPlayerState() != PlayerState.IN_LOBBY) {
            Language.MATCH_SPECTATE_WRONG_STATE.sendMessage(player);
            return;
        }

        if (Party.getByPlayer(player) != null) {
            Language.MATCH_SPECTATE_HAVE_PARTY.sendMessage(player);
            return;
        }

        if (args.length == 0) {
            new SpectateMenu().openMenu(player);
            return;
        } else {
            String name = args[0];
            Player target = Bukkit.getPlayer(name);
            if (target == null || !target.isOnline()) {
                Language.MATCH_SPECTATE_NOT_ONLINE.sendMessage(player);
                return;
            }
            PlayerProfile tProfile = PlayerProfile.get(target);
            if (tProfile == null || tProfile.getMatch() == null) {
                Language.MATCH_SPECTATE_PROFILE_NOT_FOUND.sendMessage(player);
                return;
            }

            tProfile.getMatch().joinSpectate(player, target);
        }
    }
}


Filename: .\main\java\rip\diamond\practice\match\command\TeleporterCommand.java
package rip.diamond.practice.match.command;

import org.bukkit.entity.Player;
import rip.diamond.practice.match.Match;
import rip.diamond.practice.match.menu.SpectateTeleportMenu;
import rip.diamond.practice.profile.PlayerProfile;
import rip.diamond.practice.util.command.Command;
import rip.diamond.practice.util.command.CommandArgs;
import rip.diamond.practice.util.command.argument.CommandArguments;

public class TeleporterCommand extends Command {
    @CommandArgs(name = "teleporter")
    public void execute(CommandArguments command) {
        Player player = command.getPlayer();
        PlayerProfile profile = PlayerProfile.get(player);
        Match match = profile.getMatch();

        if (match == null) {
            return;
        }

        new SpectateTeleportMenu(match).openMenu(player);
    }
}


Filename: .\main\java\rip\diamond\practice\match\command\ViewInventoryCommand.java
package rip.diamond.practice.match.command;

import org.bukkit.entity.Player;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.match.Match;
import rip.diamond.practice.match.menu.ViewInventoryMenu;
import rip.diamond.practice.profile.PlayerProfile;
import rip.diamond.practice.profile.PlayerState;
import rip.diamond.practice.util.Checker;
import rip.diamond.practice.util.command.Command;
import rip.diamond.practice.util.command.CommandArgs;
import rip.diamond.practice.util.command.argument.CommandArguments;

import java.util.UUID;

public class ViewInventoryCommand extends Command {
    @CommandArgs(name = "viewinventory", aliases = {"viewinv"})
    public void execute(CommandArguments command) {
        Player player = command.getPlayer();
        PlayerProfile profile = PlayerProfile.get(player);
        String[] args = command.getArgs();

        //Fix for #344 - Allow player to view post match inventory while in match
        /*if (profile.getPlayerState() != PlayerState.IN_LOBBY) {
            Language.MATCH_VIEW_INVENTORY_WRONG_STATE.sendMessage(player);
            return;
        }*/

        if (args.length != 1) {
            Language.MATCH_VIEW_INVENTORY_USAGE.sendMessage(player);
            return;
        }

        if (!Checker.isUUID(args[0])) {
            Language.MATCH_VIEW_INVENTORY_INVALID_UUID.sendMessage(player);
            return;
        }

        UUID uuid = UUID.fromString(args[0]);

        if (!Match.getPostMatchInventories().containsKey(uuid)) {
            Language.MATCH_VIEW_INVENTORY_CANNOT_FIND.sendMessage(player);
            return;
        }

        new ViewInventoryMenu(Match.getPostMatchInventories().get(uuid)).openMenu(player);
    }
}


Filename: .\main\java\rip\diamond\practice\match\impl\FFAMatch.java
package rip.diamond.practice.match.impl;

import org.bukkit.Location;
import org.bukkit.entity.Player;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.arenas.ArenaDetail;
import rip.diamond.practice.kits.Kit;
import rip.diamond.practice.match.Match;
import rip.diamond.practice.match.MatchState;
import rip.diamond.practice.match.MatchType;
import rip.diamond.practice.match.team.Team;
import rip.diamond.practice.match.team.TeamPlayer;
import rip.diamond.practice.util.Clickable;
import rip.diamond.practice.util.Common;
import rip.diamond.practice.util.exception.PracticeUnexpectedException;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.stream.Collectors;

public class FFAMatch extends Match {
    public FFAMatch(ArenaDetail arena, Kit kit, List<Team> teams) {
        super(arena, kit, teams);

        setDuel(true);

        Common.debug("Ê≠£Âú®ÈñãÂßã‰∏ÄÂ†¥ FFAMatch Êà∞È¨• (" + teams.stream().map(team -> team.getLeader().getUsername()).collect(Collectors.joining(" vs ")) + ") (ËÅ∑Ê•≠: " + kit.getName() + ") (Âú∞Âúñ: " + arena.getArena().getName() + ") (UUID: " + getUuid() + ")");
    }

    @Override
    public MatchType getMatchType() {
        return MatchType.FFA;
    }

    @Override
    public Team getOpponentTeam(Team team) {
        throw new PracticeUnexpectedException("Unsupported (" + getClass().getSimpleName() + ", getOpponentTeam(Team))");
    }

    @Override
    public TeamPlayer getOpponent(TeamPlayer teamPlayer) {
        throw new PracticeUnexpectedException("Unsupported (" + getClass().getSimpleName() + ", getOpponent(TeamPlayer))");
    }

    @Override
    public void setupTeamSpawnLocation() {
        Location location = getArenaDetail().getA();
        for (Team team : getTeams()) {
            team.setSpawnLocation(location);
        }
    }

    @Override
    public void displayMatchEndMessages() {
        Team winnerTeam = getWinningTeam();
        List<Team> loserTeams = new ArrayList<>(getTeams());
        loserTeams.removeIf(team -> team == winnerTeam);

        Clickable clickable1 = new Clickable(Language.MATCH_POST_MATCH_INVENTORY_WINNER.toString());
        Iterator<TeamPlayer> iterator1 = winnerTeam.getTeamPlayers().iterator();
        while (iterator1.hasNext()) {
            TeamPlayer teamPlayer = iterator1.next();
            clickable1.add(teamPlayer.getUsername(), Language.MATCH_POST_MATCH_INVENTORY_HOVER.toString(teamPlayer.getUsername()), "/viewinv " + teamPlayer.getUuid());
            if (iterator1.hasNext()) {
                clickable1.add(Language.MATCH_SEPARATE.toString());
            }
        }
        Clickable clickable2 = new Clickable(Language.MATCH_POST_MATCH_INVENTORY_LOSER.toString());
        List<TeamPlayer> loserTeamPlayers = new ArrayList<>();
        loserTeams.forEach(team -> loserTeamPlayers.addAll(team.getTeamPlayers()));
        Iterator<TeamPlayer> iterator2 = loserTeamPlayers.iterator();
        while (iterator2.hasNext()) {
            TeamPlayer teamPlayer = iterator2.next();
            clickable2.add(teamPlayer.getUsername(), Language.MATCH_POST_MATCH_INVENTORY_HOVER.toString(teamPlayer.getUsername()), "/viewinv " + teamPlayer.getUuid());
            if (iterator2.hasNext()) {
                clickable2.add(Language.MATCH_SEPARATE.toString());
            }
        }

        Language.MATCH_POST_MATCH_INVENTORY_MESSAGE.toStringList().forEach(s -> {
            if (s.contains("{post-match-inventories}")) {
                getPlayersAndSpectators().forEach(p -> {
                    clickable1.sendToPlayer(p);
                    clickable2.sendToPlayer(p);
                });
            } else {
                getPlayersAndSpectators().forEach(p -> Common.sendMessage(p, s));
            }
        });
    }

    @Override
    public void displayMatchEndTitle() {
        Team winnerTeam = getWinningTeam();
        List<Team> loserTeams = new ArrayList<>(getTeams());
        loserTeams.removeIf(team -> team == winnerTeam);

        String winnerTeamPlayers = winnerTeam.getTeamPlayers().stream().map(TeamPlayer::getUsername).collect(Collectors.joining(", "));

        winnerTeam.broadcastTitle(Language.MATCH_END_TITLE_WIN_TITLE.toString(), Language.MATCH_END_TITLE_WIN_SUBTITLE.toString(winnerTeamPlayers));
        loserTeams.forEach(team -> team.broadcastTitle(Language.MATCH_END_TITLE_LOSE_TITLE.toString(), Language.MATCH_END_TITLE_LOSE_SUBTITLE.toString(winnerTeamPlayers)));
    }

    @Override
    public void calculateMatchStats() {

    }

    @Override
    public List<TeamPlayer> getWinningPlayers() {
        if (getState() != MatchState.ENDING) {
            throw new PracticeUnexpectedException("Cannot get Winning Players when match isn't ending");
        }
        return getWinningTeam().getTeamPlayers();
    }

    @Override
    public Team getWinningTeam() {
        List<Team> all = new ArrayList<>(getTeams());
        all.removeIf(Team::isEliminated);
        if (all.isEmpty()) {
            return null;
        }
        return all.get(0);
    }

    @Override
    public List<String> getMatchScoreboard(Player player) {
        List<String> elements = new ArrayList<>();

        if (getState() == MatchState.ENDING) {
            elements.addAll(Language.SCOREBOARD_IN_MATCH_FFA_ENDING.toStringList(player));
        } else {
            elements.addAll(Language.SCOREBOARD_IN_MATCH_FFA_FIGHTING.toStringList(player));
        }
        return elements;
    }

    @Override
    public List<String> getSpectateScoreboard(Player player) {
        List<String> elements = new ArrayList<>();

        if (getState() == MatchState.ENDING) {
            elements.addAll(Language.SCOREBOARD_IN_SPECTATE_FFA_ENDING.toStringList(player));
        } else {
            elements.addAll(Language.SCOREBOARD_IN_SPECTATE_FFA_FIGHTING.toStringList(player));
        }
        return elements;
    }
}


Filename: .\main\java\rip\diamond\practice\match\impl\SoloMatch.java
package rip.diamond.practice.match.impl;

import lombok.Getter;
import org.bukkit.Bukkit;
import org.bukkit.entity.Player;
import rip.diamond.practice.config.Config;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.arenas.ArenaDetail;
import rip.diamond.practice.kits.Kit;
import rip.diamond.practice.match.Match;
import rip.diamond.practice.match.MatchState;
import rip.diamond.practice.match.MatchType;
import rip.diamond.practice.match.team.Team;
import rip.diamond.practice.match.team.TeamPlayer;
import rip.diamond.practice.profile.PlayerProfile;
import rip.diamond.practice.profile.data.ProfileKitData;
import rip.diamond.practice.queue.QueueType;
import rip.diamond.practice.util.CC;
import rip.diamond.practice.util.Clickable;
import rip.diamond.practice.util.Common;
import rip.diamond.practice.util.Util;
import rip.diamond.practice.util.exception.PracticeUnexpectedException;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

public class SoloMatch extends Match {

    @Getter
    private final Team teamA;
    @Getter
    private final Team teamB;

    @Getter
    private final TeamPlayer playerA;
    @Getter
    private final TeamPlayer playerB;

    public SoloMatch(ArenaDetail arenaDetail, Kit kit, Team teamA, Team teamB, QueueType queueType, boolean duel) {
        super(arenaDetail, kit, Arrays.asList(teamA, teamB));

        this.teamA = teamA;
        this.teamB = teamB;

        this.playerA = teamA.getLeader();
        this.playerB = teamB.getLeader();

        setQueueType(queueType);
        setDuel(duel);

        Common.debug("Ê≠£Âú®ÈñãÂßã‰∏ÄÂ†¥ SoloMatch Êà∞È¨• (" + playerA.getUsername() + " vs " + playerB.getUsername() + ") (ËÅ∑Ê•≠: "
                + kit.getName() + ") (Âú∞Âúñ: " + arenaDetail.getArena().getName() + ") (UUID: " + getUuid() + ") (Duel: "
                + duel + ")");
    }

    @Override
    public void setupTeamSpawnLocation() {
        teamA.setSpawnLocation(getArenaDetail().getA());
        teamB.setSpawnLocation(getArenaDetail().getB());
    }

    @Override
    public void displayMatchEndMessages() {
        TeamPlayer tWinner = getWinningPlayers().get(0);
        TeamPlayer tLoser = getOpponent(getWinningPlayers().get(0));

        Clickable clickable = new Clickable(
                Language.MATCH_POST_MATCH_INVENTORY_WINNER.toString() + tWinner.getUsername(),
                Language.MATCH_POST_MATCH_INVENTORY_HOVER.toString(tWinner.getUsername()),
                "/viewinv " + tWinner.getUuid());
        clickable.add(CC.GRAY + " - ");
        clickable.add(Language.MATCH_POST_MATCH_INVENTORY_LOSER.toString() + tLoser.getUsername(),
                Language.MATCH_POST_MATCH_INVENTORY_HOVER.toString(tLoser.getUsername()),
                "/viewinv " + tLoser.getUuid());

        Language.MATCH_POST_MATCH_INVENTORY_MESSAGE.toStringList().forEach(s -> {
            if (s.contains("{post-match-inventories}")) {
                getPlayersAndSpectators().forEach(clickable::sendToPlayer);
            } else {
                getPlayersAndSpectators().forEach(p -> Common.sendMessage(p, s));
            }
        });
    }

    @Override
    public void displayMatchEndTitle() {
        TeamPlayer tWinner = getWinningPlayers().get(0);
        TeamPlayer tLoser = getOpponent(getWinningPlayers().get(0));

        tWinner.broadcastTitle(Language.MATCH_END_TITLE_WIN_TITLE.toString(),
                Language.MATCH_END_TITLE_WIN_SUBTITLE.toString(tWinner.getUsername()));
        tLoser.broadcastTitle(Language.MATCH_END_TITLE_LOSE_TITLE.toString(),
                Language.MATCH_END_TITLE_LOSE_SUBTITLE.toString(tWinner.getUsername()));
    }

    @Override
    public void calculateMatchStats() {
        TeamPlayer tWinner = getWinningPlayers().get(0);
        TeamPlayer tLoser = getOpponent(getWinningPlayers().get(0));

        // Set Post-Match Inventories swtichTo
        getPostMatchInventories().get(tWinner.getUuid()).setSwitchTo(tLoser.getUsername(), tLoser.getUuid());
        getPostMatchInventories().get(tLoser.getUuid()).setSwitchTo(tWinner.getUsername(), tWinner.getUuid());

        // Because this is a duel match, we don't increase win/lose in player statistics
        // and don't calculate the elo afterwards
        if (isDuel()) {
            return;
        }

        PlayerProfile pWinner = PlayerProfile.get(tWinner.getUuid());
        PlayerProfile pLoser = PlayerProfile.get(tLoser.getUuid());

        ProfileKitData kWinner = pWinner.getKitData().get(getKit().getName());
        ProfileKitData kLoser = pLoser.getKitData().get(getKit().getName());

        if (getQueueType() == QueueType.RANKED) {
            int oldWinnerElo = kWinner.getElo();
            int oldLoserElo = kLoser.getElo();

            int newWinnerElo = Util.getNewRating(oldWinnerElo, oldLoserElo, 1);
            int newLoserElo = Util.getNewRating(oldLoserElo, oldWinnerElo, 0);

            kWinner.setElo(newWinnerElo);
            kLoser.setElo(newLoserElo);

            int winnerEloChange = newWinnerElo - oldWinnerElo;
            int loserEloChange = oldLoserElo - newLoserElo;

            broadcastMessage(Language.MATCH_POST_MATCH_INVENTORY_RATING_CHANGES.toString(pWinner.getUsername(),
                    winnerEloChange, newWinnerElo, pLoser.getUsername(), loserEloChange, newLoserElo));
        }

        kWinner.incrementWon(getQueueType() == QueueType.RANKED);
        kLoser.incrementLost(getQueueType() == QueueType.RANKED);

        kWinner.calculateWinstreak(true);
        kLoser.calculateWinstreak(false);

        List<String> winCommands = Config.MATCH_WIN_COMMANDS.toStringList();
        List<String> loseCommands = Config.MATCH_LOSE_COMMANDS.toStringList();
        if (!winCommands.isEmpty()) {
            for (String cmd : winCommands) {
                String c = cmd.replace("{player}", tWinner.getUsername());
                Common.debug("Ê≠£Âú®Âü∑Ë°åÂæåÂè∞Êåá‰ª§ " + c);
                Bukkit.dispatchCommand(Bukkit.getConsoleSender(), c);
            }
        }
        if (!loseCommands.isEmpty()) {
            for (String cmd1 : loseCommands) {
                String d = cmd1.replace("{loser-player}", tLoser.getUsername());
                Common.debug("Ê≠£Âú®Âü∑Ë°åÂæåÂè∞Êåá‰ª§ " + d);
                Bukkit.dispatchCommand(Bukkit.getConsoleSender(), d);
            }
        }

        // Instantly update leaderboards for both players
        rip.diamond.practice.Eden.INSTANCE.getLeaderboardManager().updatePlayerStats(
                pWinner.getUniqueId(), pWinner.getUsername(), getKit(), kWinner);
        rip.diamond.practice.Eden.INSTANCE.getLeaderboardManager().updatePlayerStats(
                pLoser.getUniqueId(), pLoser.getUsername(), getKit(), kLoser);
    }

    @Override
    public MatchType getMatchType() {
        return MatchType.SOLO;
    }

    @Override
    public List<TeamPlayer> getWinningPlayers() {
        if (getState() != MatchState.ENDING) {
            throw new PracticeUnexpectedException("Cannot get Winning Players when match isn't ending");
        }
        if (playerA.isDisconnected() || !playerA.isAlive()) {
            return Collections.singletonList(playerB);
        } else {
            return Collections.singletonList(playerA);
        }
    }

    @Override
    public Team getWinningTeam() {
        if (teamA.isEliminated()) {
            return teamB;
        } else if (teamB.isEliminated()) {
            return teamA;
        } else {
            return null;
        }
    }

    @Override
    public List<String> getMatchScoreboard(Player player) {
        List<String> elements = new ArrayList<>();

        if (getState() == MatchState.ENDING) {
            elements.addAll(Language.SCOREBOARD_IN_MATCH_SOLO_ENDING.toStringList(player));
        } else {
            if (getKit().getGameRules().isBoxing()) {
                elements.addAll(Language.SCOREBOARD_IN_MATCH_SOLO_BOXING.toStringList(player));
            } else if (getKit().getGameRules().isBed()) {
                elements.addAll(Language.SCOREBOARD_IN_MATCH_SOLO_BED.toStringList(player));
            } else if (getKit().getGameRules().isPoint(this)) {
                elements.addAll(Language.SCOREBOARD_IN_MATCH_SOLO_POINT.toStringList(player));
            } else {
                elements.addAll(Language.SCOREBOARD_IN_MATCH_SOLO_FIGHTING.toStringList(player));
            }
        }
        return elements;
    }

    @Override
    public List<String> getSpectateScoreboard(Player player) {
        List<String> elements = new ArrayList<>();
        TeamPlayer playerA = getPlayerA();
        TeamPlayer playerB = getPlayerB();

        if (getState() == MatchState.ENDING) {
            elements.addAll(Language.SCOREBOARD_IN_SPECTATE_SOLO_ENDING.toStringList(player));
        } else {
            if (getKit().getGameRules().isBoxing()) {
                elements.addAll(Language.SCOREBOARD_IN_SPECTATE_SOLO_BOXING.toStringList(player));
            } else if (getKit().getGameRules().isBed()) {
                elements.addAll(Language.SCOREBOARD_IN_SPECTATE_SOLO_BED.toStringList(player));
            } else if (getKit().getGameRules().isPoint(this)) {
                elements.addAll(Language.SCOREBOARD_IN_SPECTATE_SOLO_POINT.toStringList(player));
            } else {
                elements.addAll(Language.SCOREBOARD_IN_SPECTATE_SOLO_FIGHTING.toStringList(player));
            }
        }

        return elements;
    }

    @Override
    public Team getOpponentTeam(Team team) {
        if (teamA.equals(team)) {
            return teamB;
        } else if (teamB.equals(team)) {
            return teamA;
        } else {
            return null;
        }
    }

    @Override
    public TeamPlayer getOpponent(TeamPlayer teamPlayer) {
        if (teamPlayer == null) {
            return null;
        }

        if (playerA == teamPlayer) {
            return playerB;
        } else if (playerB == teamPlayer) {
            return playerA;
        } else {
            throw new PracticeUnexpectedException("Cannot get opponent player from a solo match.");
        }
    }
}


Filename: .\main\java\rip\diamond\practice\match\impl\SumoEventMatch.java
package rip.diamond.practice.match.impl;

import org.bukkit.Location;
import org.bukkit.entity.Player;
import rip.diamond.practice.arenas.ArenaDetail;
import rip.diamond.practice.events.impl.SumoEvent;
import rip.diamond.practice.kits.Kit;
import rip.diamond.practice.match.Match;
import rip.diamond.practice.match.MatchState;
import rip.diamond.practice.match.MatchType;
import rip.diamond.practice.match.team.Team;
import rip.diamond.practice.match.team.TeamPlayer;
import rip.diamond.practice.util.Common;
import rip.diamond.practice.util.exception.PracticeUnexpectedException;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

public class SumoEventMatch extends Match {

    private final SumoEvent event;

    public SumoEventMatch(SumoEvent event, ArenaDetail arena, Kit kit, List<Team> teams) {
        super(arena, kit, teams);
        this.event = event;

        setDuel(true);

        Common.debug("Ê≠£Âú®ÈñãÂßã‰∏ÄÂ†¥ SumoEventMatch Êà∞È¨• (" + teams.stream().map(team -> team.getLeader().getUsername()).collect(Collectors.joining(" vs ")) + ") (ËÅ∑Ê•≠: " + kit.getName() + ") (Âú∞Âúñ: " + arena.getArena().getName() + ") (UUID: " + getUuid() + ")");
    }

    @Override
    public void setupTeamSpawnLocation() {
        Location location = arenaDetail.getSpectator();
        for (Team team : getTeams()) {
            team.setSpawnLocation(location);
        }
    }

    @Override
    public void displayMatchEndMessages() {

    }

    @Override
    public void displayMatchEndTitle() {

    }

    @Override
    public void calculateMatchStats() {

    }

    @Override
    public MatchType getMatchType() {
        return MatchType.SUMO_EVENT;
    }

    @Override
    public Team getOpponentTeam(Team team) {
        if (event.isFighting(team)) {
            return team == event.getTeamA() ? event.getTeamB() : event.getTeamA();
        }
        throw new PracticeUnexpectedException("Unsupported (" + getClass().getSimpleName() + ", getOpponentTeam(Team))");
    }

    @Override
    public TeamPlayer getOpponent(TeamPlayer teamPlayer) {
        throw new PracticeUnexpectedException("Unsupported (" + getClass().getSimpleName() + ", getOpponent(TeamPlayer))");
    }

    @Override
    public List<TeamPlayer> getWinningPlayers() {
        if (getState() != MatchState.ENDING) {
            throw new PracticeUnexpectedException("Cannot get Winning Players when match isn't ending");
        }
        return getWinningTeam().getTeamPlayers();
    }

    @Override
    public Team getWinningTeam() {
        List<Team> all = new ArrayList<>(getTeams());
        all.removeIf(Team::isEliminated);
        return all.get(0);
    }

    @Override
    public List<String> getMatchScoreboard(Player player) {
        return event.getInGameScoreboard(player);
    }

    @Override
    public List<String> getSpectateScoreboard(Player player) {
        return null;
    }
}


Filename: .\main\java\rip\diamond\practice\match\impl\TeamMatch.java
package rip.diamond.practice.match.impl;

import lombok.Getter;
import org.bukkit.Location;
import org.bukkit.entity.Player;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.arenas.ArenaDetail;
import rip.diamond.practice.kits.Kit;
import rip.diamond.practice.match.Match;
import rip.diamond.practice.match.MatchState;
import rip.diamond.practice.match.MatchType;
import rip.diamond.practice.match.team.Team;
import rip.diamond.practice.match.team.TeamPlayer;
import rip.diamond.practice.util.Clickable;
import rip.diamond.practice.util.Common;
import rip.diamond.practice.util.exception.PracticeUnexpectedException;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Iterator;
import java.util.List;
import java.util.stream.Collectors;

public class TeamMatch extends Match {
    @Getter private final Team teamA;
    @Getter private final Team teamB;

    public TeamMatch(ArenaDetail arena, Kit kit, Team teamA, Team teamB) {
        super(arena, kit, Arrays.asList(teamA, teamB));
        this.teamA = teamA;
        this.teamB = teamB;

        setDuel(true);

        Common.debug("Ê≠£Âú®ÈñãÂßã‰∏ÄÂ†¥ TeamMatch Êà∞È¨• (" + teamA.getLeader().getUsername() + " vs " + teamB.getLeader().getUsername() + ") (ËÅ∑Ê•≠: " + kit.getName() + ") (Âú∞Âúñ: " + arena.getArena().getName() + ") (UUID: " + getUuid() + ")");
    }

    @Override
    public MatchType getMatchType() {
        return MatchType.SPLIT;
    }

    @Override
    public void setupTeamSpawnLocation() {
        Location teamALocation = getArenaDetail().getA();
        Location teamBLocation = getArenaDetail().getB();

        teamA.setSpawnLocation(teamALocation);
        teamB.setSpawnLocation(teamBLocation);
    }

    @Override
    public void displayMatchEndMessages() {
        Team winnerTeam = getWinningTeam();
        Team loserTeam = getOpponentTeam(getWinningTeam());

        Clickable clickable1 = new Clickable(Language.MATCH_POST_MATCH_INVENTORY_WINNER.toString());
        Iterator<TeamPlayer> iterator1 = winnerTeam.getTeamPlayers().iterator();
        while (iterator1.hasNext()) {
            TeamPlayer teamPlayer = iterator1.next();
            clickable1.add(teamPlayer.getUsername(), Language.MATCH_POST_MATCH_INVENTORY_HOVER.toString(teamPlayer.getUsername()), "/viewinv " + teamPlayer.getUuid());
            if (iterator1.hasNext()) {
                clickable1.add(Language.MATCH_SEPARATE.toString());
            }
        }
        Clickable clickable2 = new Clickable(Language.MATCH_POST_MATCH_INVENTORY_LOSER.toString());
        Iterator<TeamPlayer> iterator2 = loserTeam.getTeamPlayers().iterator();
        while (iterator2.hasNext()) {
            TeamPlayer teamPlayer = iterator2.next();
            clickable2.add(teamPlayer.getUsername(), Language.MATCH_POST_MATCH_INVENTORY_HOVER.toString(teamPlayer.getUsername()), "/viewinv " + teamPlayer.getUuid());
            if (iterator2.hasNext()) {
                clickable2.add(Language.MATCH_SEPARATE.toString());
            }
        }

        Language.MATCH_POST_MATCH_INVENTORY_MESSAGE.toStringList().forEach(s -> {
            if (s.contains("{post-match-inventories}")) {
                getPlayersAndSpectators().forEach(p -> {
                    clickable1.sendToPlayer(p);
                    clickable2.sendToPlayer(p);
                });
            } else {
                getPlayersAndSpectators().forEach(p -> Common.sendMessage(p, s));
            }
        });
    }

    @Override
    public void displayMatchEndTitle() {
        Team winnerTeam = getWinningTeam();
        Team loserTeam = getOpponentTeam(getWinningTeam());

        String winnerTeamPlayers = winnerTeam.getTeamPlayers().stream().map(TeamPlayer::getUsername).collect(Collectors.joining(", "));

        winnerTeam.broadcastTitle(Language.MATCH_END_TITLE_WIN_TITLE.toString(), Language.MATCH_END_TITLE_WIN_SUBTITLE.toString(winnerTeamPlayers));
        loserTeam.broadcastTitle(Language.MATCH_END_TITLE_LOSE_TITLE.toString(), Language.MATCH_END_TITLE_LOSE_SUBTITLE.toString(winnerTeamPlayers));
    }

    @Override
    public void calculateMatchStats() {

    }

    @Override
    public List<TeamPlayer> getWinningPlayers() {
        if (getState() != MatchState.ENDING) {
            throw new PracticeUnexpectedException("Cannot get Winning Players when match isn't ending");
        }
        return getWinningTeam().getTeamPlayers().stream().filter(TeamPlayer::isAlive).collect(Collectors.toList());
    }

    @Override
    public Team getWinningTeam() {
        if (teamA.isEliminated()) {
            return teamB;
        } else if (teamB.isEliminated()) {
            return teamA;
        } else {
            return null;
        }
    }

    @Override
    public List<String> getMatchScoreboard(Player player) {
        List<String> elements = new ArrayList<>();

        if (getState() == MatchState.ENDING) {
            elements.addAll(Language.SCOREBOARD_IN_MATCH_TEAMS_ENDING.toStringList(player));
        } else {
            if (getKit().getGameRules().isBoxing()) {
                elements.addAll(Language.SCOREBOARD_IN_MATCH_TEAMS_BOXING.toStringList(player));
            } else if (getKit().getGameRules().isBed()) {
                elements.addAll(Language.SCOREBOARD_IN_MATCH_TEAMS_BED.toStringList(player));
            } else if (getKit().getGameRules().isPoint(this)) {
                elements.addAll(Language.SCOREBOARD_IN_MATCH_TEAMS_POINT.toStringList(player));
            } else {
                elements.addAll(Language.SCOREBOARD_IN_MATCH_TEAMS_FIGHTING.toStringList(player));
            }
        }
        return elements;
    }

    @Override
    public List<String> getSpectateScoreboard(Player player) {
        List<String> elements = new ArrayList<>();

        if (getState() == MatchState.ENDING) {
            elements.addAll(Language.SCOREBOARD_IN_SPECTATE_TEAMS_ENDING.toStringList(player));
        } else {
            if (getKit().getGameRules().isBoxing()) {
                elements.addAll(Language.SCOREBOARD_IN_SPECTATE_TEAMS_BOXING.toStringList(player));
            } else if (getKit().getGameRules().isBed()) {
                elements.addAll(Language.SCOREBOARD_IN_SPECTATE_TEAMS_BED.toStringList(player));
            } else if (getKit().getGameRules().isPoint(this)) {
                elements.addAll(Language.SCOREBOARD_IN_SPECTATE_TEAMS_POINT.toStringList(player));
            } else {
                elements.addAll(Language.SCOREBOARD_IN_SPECTATE_TEAMS_FIGHTING.toStringList(player));
            }
        }
        return elements;
    }

    public Team getOpponentTeam(Team team) {
        if (teamA.equals(team)) {
            return teamB;
        } else if (teamB.equals(team)) {
            return teamA;
        } else {
            return null;
        }
    }

    @Override
    public TeamPlayer getOpponent(TeamPlayer teamPlayer) {
        throw new PracticeUnexpectedException("Unsupported (TeamMatch, getOpponent(TeamPlayer))");
    }

    public Team getOpponentTeam(Player player) {
        if (teamA.containsPlayer(player)) {
            return teamB;
        } else if (teamB.containsPlayer(player)) {
            return teamA;
        } else {
            return null;
        }
    }
}


Filename: .\main\java\rip\diamond\practice\match\kit\DynamicKitManager.java
package rip.diamond.practice.match.kit;

import lombok.Getter;
import org.bukkit.Bukkit;
import org.bukkit.Material;
import org.bukkit.entity.Player;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.PlayerInventory;
import rip.diamond.practice.Eden;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.kits.Kit;
import rip.diamond.practice.kits.KitLoadout;
import rip.diamond.practice.match.Match;
import rip.diamond.practice.profile.PlayerProfile;
import rip.diamond.practice.profile.data.ProfileKitData;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

public class DynamicKitManager {

    @Getter
    private static final DynamicKitManager instance = new DynamicKitManager();

    private final Map<UUID, KitSession> activeSessions = new ConcurrentHashMap<>();

    public void addSession(Player player, Match match, Kit kit, KitLoadout appliedLoadout) {
        UUID uuid = player.getUniqueId();
        activeSessions.put(uuid, new KitSession(match, kit, appliedLoadout));

        // Schedule removal after 20 seconds
        Bukkit.getScheduler().runTaskLater(Eden.INSTANCE, () -> {
            activeSessions.remove(uuid);
        }, 20 * 20L);
    }

    public void handleInventoryClose(Player player) {
        KitSession session = activeSessions.get(player.getUniqueId());
        if (session == null) {
            return;
        }

        // Check if inventory was changed
        if (validateInventory(player.getInventory(), session.kit)) {
            if (isExactMatch(player.getInventory(), session.appliedLoadout)) {
                // No changes made - keep session active for remaining time
                return;
            }
            // Changes detected - save and remove session
            activeSessions.remove(player.getUniqueId());
            saveKit(player, session.kit);
        } else {
            // Invalid inventory - remove session to prevent exploits
            activeSessions.remove(player.getUniqueId());
        }
    }

    private boolean isExactMatch(PlayerInventory inventory, KitLoadout loadout) {
        if (!isContentEqual(inventory.getArmorContents(), loadout.getArmor()))
            return false;
        return isContentEqual(inventory.getContents(), loadout.getContents());
    }

    private boolean isContentEqual(ItemStack[] a, ItemStack[] b) {
        if (a.length != b.length)
            return false;
        for (int i = 0; i < a.length; i++) {
            ItemStack i1 = a[i];
            ItemStack i2 = b[i];
            boolean empty1 = (i1 == null || i1.getType() == Material.AIR);
            boolean empty2 = (i2 == null || i2.getType() == Material.AIR);

            if (empty1 && empty2)
                continue;
            if (empty1 || empty2)
                return false;
            if (!i1.equals(i2))
                return false;
        }
        return true;
    }

    private boolean validateInventory(PlayerInventory inventory, Kit kit) {
        // 1. Validate Armor (Strict Type Check, Ignore Data/Color)
        ItemStack[] playerArmor = inventory.getArmorContents();
        ItemStack[] kitArmor = kit.getKitLoadout().getArmor();

        if (playerArmor.length != kitArmor.length)
            return false;

        for (int i = 0; i < playerArmor.length; i++) {
            ItemStack pItem = playerArmor[i];
            ItemStack kItem = kitArmor[i];

            if (pItem == null && kItem == null)
                continue;
            if (pItem == null || kItem == null)
                return false;
            if (pItem.getType() != kItem.getType())
                return false;
        }

        // 2. Validate Contents (Fuzzy Count Check)
        Map<Material, Integer> playerCounts = countItems(inventory.getContents());
        Map<Material, Integer> kitCounts = countItems(kit.getKitLoadout().getContents());

        if (playerCounts.size() != kitCounts.size())
            return false;

        for (Map.Entry<Material, Integer> entry : kitCounts.entrySet()) {
            if (!playerCounts.containsKey(entry.getKey()))
                return false;
            if (!playerCounts.get(entry.getKey()).equals(entry.getValue()))
                return false;
        }

        return true;
    }

    private Map<Material, Integer> countItems(ItemStack[] items) {
        Map<Material, Integer> counts = new HashMap<>();
        for (ItemStack item : items) {
            if (item == null || item.getType() == Material.AIR)
                continue;
            counts.put(item.getType(), counts.getOrDefault(item.getType(), 0) + item.getAmount());
        }
        return counts;
    }

    private void saveKit(Player player, Kit kit) {
        PlayerProfile profile = PlayerProfile.get(player);
        if (profile == null)
            return;

        ProfileKitData kitData = profile.getKitData().get(kit.getName());
        if (kitData == null)
            return;

        // Always save to slot 0 (Kit 1)
        KitLoadout loadout = kitData.getLoadout(0);
        if (loadout == null) {
            loadout = new KitLoadout("Kit 1");
            kitData.replaceKit(0, loadout);
        }

        // Update loadout with current inventory
        loadout.setArmor(player.getInventory().getArmorContents());
        loadout.setContents(player.getInventory().getContents());

        // Save profile asynchronously
        profile.save(true, (success) -> {
        });

        Language.MATCH_KIT_EDIT_SAVED.sendMessage(player, loadout.getCustomName());
    }

    private static class KitSession {
        final Match match;
        final Kit kit;
        final KitLoadout appliedLoadout;

        KitSession(Match match, Kit kit, KitLoadout appliedLoadout) {
            this.match = match;
            this.kit = kit;
            this.appliedLoadout = appliedLoadout;
        }
    }
}


Filename: .\main\java\rip\diamond\practice\match\listener\DynamicKitEditListener.java
package rip.diamond.practice.match.listener;

import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.Listener;
import org.bukkit.event.inventory.InventoryCloseEvent;
import rip.diamond.practice.match.kit.DynamicKitManager;

public class DynamicKitEditListener implements Listener {

    @EventHandler
    public void onInventoryClose(InventoryCloseEvent event) {
        if (event.getPlayer() instanceof Player) {
            DynamicKitManager.getInstance().handleInventoryClose((Player) event.getPlayer());
        }
    }
}


Filename: .\main\java\rip\diamond\practice\match\listener\MatchListener.java
package rip.diamond.practice.match.listener;

import lombok.RequiredArgsConstructor;
import net.minecraft.server.v1_8_R3.NBTTagCompound;
import org.bukkit.ChatColor;
import org.bukkit.Location;
import org.bukkit.Material;
import org.bukkit.Sound;
import org.bukkit.block.Block;
import org.bukkit.craftbukkit.v1_8_R3.entity.CraftPlayer;
import org.bukkit.craftbukkit.v1_8_R3.inventory.CraftItemStack;
import org.bukkit.enchantments.Enchantment;
import org.bukkit.entity.*;
import org.bukkit.event.Event;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.Listener;
import org.bukkit.event.block.Action;
import org.bukkit.event.block.BlockBreakEvent;
import org.bukkit.event.block.BlockFromToEvent;
import org.bukkit.event.block.BlockPlaceEvent;
import org.bukkit.event.entity.*;
import org.bukkit.event.inventory.InventoryClickEvent;
import org.bukkit.event.inventory.InventoryType;
import org.bukkit.event.player.*;
import org.bukkit.inventory.ItemStack;
import org.bukkit.potion.PotionEffect;
import org.bukkit.potion.PotionEffectType;
import org.bukkit.scheduler.BukkitRunnable;
import org.bukkit.util.Vector;
import rip.diamond.practice.Eden;
import rip.diamond.practice.arenas.Arena;
import rip.diamond.practice.arenas.ArenaDetail;
import rip.diamond.practice.config.Config;
import rip.diamond.practice.config.EdenSound;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.event.KitLoadoutReceivedEvent;
import rip.diamond.practice.event.MatchStartEvent;
import rip.diamond.practice.event.MatchStateChangeEvent;
import rip.diamond.practice.kits.Kit;
import rip.diamond.practice.kits.KitGameRules;
import rip.diamond.practice.kits.KitLoadout;
import rip.diamond.practice.match.Match;
import rip.diamond.practice.match.MatchEntity;
import rip.diamond.practice.match.MatchState;
import rip.diamond.practice.match.MatchType;
import rip.diamond.practice.match.impl.TeamMatch;
import rip.diamond.practice.match.task.MatchClearBlockTask;
import rip.diamond.practice.match.task.MatchRespawnTask;
import rip.diamond.practice.match.team.Team;
import rip.diamond.practice.match.team.TeamPlayer;
import rip.diamond.practice.profile.PlayerProfile;
import rip.diamond.practice.profile.PlayerState;
import rip.diamond.practice.profile.cooldown.Cooldown;
import rip.diamond.practice.profile.cooldown.CooldownType;
import rip.diamond.practice.queue.QueueType;
import rip.diamond.practice.util.*;
import rip.diamond.practice.util.cuboid.Cuboid;
import rip.diamond.practice.util.exception.PracticeUnexpectedException;
import rip.diamond.practice.util.serialization.LocationSerialization;

import java.util.Comparator;
import java.util.List;
import java.util.Optional;
import java.util.concurrent.ThreadLocalRandom;
import java.util.stream.Collectors;

@RequiredArgsConstructor
public class MatchListener implements Listener {

    private final Eden plugin;

    @EventHandler
    public void onStart(MatchStartEvent event) {
        Match match = event.getMatch();
        Kit kit = match.getKit();

        match.getMatchPlayers().forEach(p -> {
            if (plugin.getKitEditorManager().isEditing(p)) {
                plugin.getKitEditorManager().leaveKitEditor(p, false);
            }

            PlayerProfile.get(p).getCooldowns().forEach((s, cooldown) -> cooldown.cancelCountdown());

            String opponents;
            switch (match.getMatchType()) {
                case SOLO:
                    opponents = match.getOpponent(match.getTeamPlayer(p)).getUsername();
                    break;
                case SPLIT:
                    opponents = ((TeamMatch) match).getOpponentTeam(p).getTeamPlayers().stream()
                            .map(TeamPlayer::getUsername)
                            .collect(Collectors.joining(Language.MATCH_SEPARATE.toString()));
                    break;
                case FFA:
                case SUMO_EVENT:
                    opponents = match.getTeams().stream().map(team -> team.getLeader().getUsername())
                            .collect(Collectors.joining(Language.MATCH_SEPARATE.toString()));
                    break;
                default:
                    opponents = CC.RED + "ERROR";
                    break;
            }

            if (match.getQueueType() == QueueType.UNRANKED) {
                Language.MATCH_START_UNRANKED.toStringList(match.getMatchType().getReadable(), kit.getDisplayName(),
                        match.getArenaDetail().getArena().getDisplayName(), opponents).forEach(s -> {
                            Common.sendMessage(p, s);
                        });
            } else if (match.getQueueType() == QueueType.RANKED && match.getMatchType() == MatchType.SOLO) {
                int elo = PlayerProfile.get(match.getOpponent(match.getTeamPlayer(p)).getUuid()).getKitData()
                        .get(kit.getName()).getElo();
                Language.MATCH_START_RANKED.toStringList(match.getMatchType().getReadable(), kit.getDisplayName(),
                        match.getArenaDetail().getArena().getDisplayName(), opponents, elo).forEach(s -> {
                            Common.sendMessage(p, s);
                        });
            }
        });
    }

    @EventHandler
    public void onQuit(PlayerQuitEvent event) {
        Player player = event.getPlayer();
        PlayerProfile profile = PlayerProfile.get(player);

        // Profile will be null if the profile is not loaded in PlayerJoinEvent
        if (profile == null) {
            return;
        }

        if (profile.getPlayerState() == PlayerState.IN_MATCH && profile.getMatch() != null) {
            Match match = profile.getMatch();
            match.die(player, true);
        }
    }

    @EventHandler
    public void onInventoryClick(InventoryClickEvent event) {
        ItemStack current = event.getCurrentItem();
        ItemStack cursor = event.getCursor();

        if (current != null && (current.getType() == Material.BOOK || current.getType() == Material.ENCHANTED_BOOK)) {
            net.minecraft.server.v1_8_R3.ItemStack nmsItem = CraftItemStack.asNMSCopy(current);
            if (nmsItem.hasTag()) {
                NBTTagCompound compound = nmsItem.getTag();
                if (compound.hasKey("name") && compound.hasKey("armor") && compound.hasKey("contents")) {
                    event.setCancelled(true);
                }
            }
        } else if (cursor != null
                && (cursor.getType() == Material.BOOK || cursor.getType() == Material.ENCHANTED_BOOK)) {
            net.minecraft.server.v1_8_R3.ItemStack nmsItem = CraftItemStack.asNMSCopy(cursor);
            if (nmsItem.hasTag()) {
                NBTTagCompound compound = nmsItem.getTag();
                if (compound.hasKey("name") && compound.hasKey("armor") && compound.hasKey("contents")) {
                    event.setCancelled(true);
                }
            }
        }
    }

    @EventHandler(priority = EventPriority.LOW)
    public void onDeath(PlayerDeathEvent event) {
        event.setDeathMessage(null);

        Player player = event.getEntity();
        PlayerProfile profile = PlayerProfile.get(player);

        if (profile.getPlayerState() == PlayerState.IN_MATCH && profile.getMatch() != null) {
            Match match = profile.getMatch();
            TeamPlayer teamPlayer = match.getTeamPlayer(player);
            KitGameRules gameRules = match.getKit().getGameRules();

            if ((gameRules.isBed() && !match.getTeam(player).isBedDestroyed()) || gameRules.isBreakGoal()
                    || gameRules.isPortalGoal()) {
                new MatchRespawnTask(match, teamPlayer);
            } else if (gameRules.isPoint(match)) {
                TeamPlayer lastHitDamager = teamPlayer.getLastHitDamager();
                // Áé©ÂÆ∂ÊúâÊ©üÊúÉÂú®‰∏çË¢´ÊïµÊñπÊîªÊìäÁöÑÊÉÖÊ≥Å‰∏ãÊ≠ª‰∫°, ‰æãÂ¶ÇÂ≤©Êºø, Â¶ÇÊûúÊòØÈÄôÊ®£, Â∞±Âú®ÊïµÊñπÈöä‰ºçÈö®‰æøÊäΩ‰∏ÄÂÄãÁé©ÂÆ∂Âá∫‰æÜ
                if (lastHitDamager == null) {
                    lastHitDamager = match.getOpponentTeam(match.getTeam(player)).getAliveTeamPlayers().get(0);
                }
                match.score(profile, teamPlayer, lastHitDamager);
            } else {
                match.die(player, false);
            }

            if (gameRules.isDropItemWhenDie()) {
                // This drops List will filter useless and banned items, and pots/bowls if the
                // match is ending
                List<ItemStack> drops = event.getDrops();
                drops.removeIf(i -> i == null || i.getType() == Material.AIR || i.getType() == Material.BOOK
                        || i.getType() == Material.ENCHANTED_BOOK);
                if (match.canEnd()) {
                    drops.removeIf(i -> i.getType() == Material.POTION || i.getType() == Material.GLASS_BOTTLE
                            || i.getType() == Material.MUSHROOM_SOUP || i.getType() == Material.BOWL);
                }

                for (ItemStack itemStack : drops) {
                    Item item = Util.dropItemNaturally(player.getLocation(), itemStack, player);
                    match.addDroppedItem(item, null); // Already modified the f value of EntityItem, therefore no need
                                                      // to put anything in 2nd variables
                }
            }

            if (gameRules.isClearBlock()) {
                match.getTasks().stream()
                        .filter(task -> task instanceof MatchClearBlockTask)
                        .map(task -> (MatchClearBlockTask) task)
                        .filter(task -> task.getBlockPlacer() == teamPlayer)
                        .forEach(task -> task.setActivateCallback(false));
            }
        }

        player.setHealth(20);
        player.setVelocity(new Vector());

        event.setDroppedExp(0);
        event.getDrops().clear();

        // Teleport 2 blocks up when die (only for match players, must be after
        // setHealth)
        if (profile.getPlayerState() == PlayerState.IN_MATCH && profile.getMatch() != null
                && Config.MATCH_TP_2_BLOCKS_UP_WHEN_DIE.toBoolean()) {
            Util.teleport(player, player.getLocation().clone().add(0, 2, 0));
        }
    }

    @EventHandler(priority = EventPriority.HIGH, ignoreCancelled = true) // A fix for #307 point 1 - try to cancel the
                                                                         // hits which anticheat cancelled
    public void onDamage(EntityDamageEvent event) {
        if (!(event.getEntity() instanceof Player)) {
            return;
        }

        Player player = (Player) event.getEntity();
        PlayerProfile profile = PlayerProfile.get(player);

        // profile will be null when damaged player is a citizens player NPC, but is not
        // a pvp bot
        if (profile == null) {
            return;
        }

        if (profile.getPlayerState() == PlayerState.IN_MATCH && profile.getMatch() != null) {
            Match match = profile.getMatch();
            TeamPlayer teamPlayer = match.getTeamPlayer(player);
            KitGameRules rules = match.getKit().getGameRules();

            if (teamPlayer.getProtectionUntil() > System.currentTimeMillis()) {
                event.setCancelled(true);
                return;
            }
            if (teamPlayer.isRespawning()) {
                event.setCancelled(true);
                return;
            }
            if (!teamPlayer.isAlive()) {
                event.setCancelled(true);
                return;
            }
            if (rules.isNoFallDamage() && event.getCause() == EntityDamageEvent.DamageCause.FALL) {
                event.setCancelled(true);
                return;
            }
            if (rules.isNoDamage() && !rules.isBoxing()) { // We handle boxing damages in MatchListener.onDamageEntity
                event.setDamage(0);
                return;
            }
            if (event.getCause() == EntityDamageEvent.DamageCause.VOID) {
                Util.damage(player, 99999);
                event.setCancelled(true);
                return;
            }
        }
    }

    @EventHandler(priority = EventPriority.HIGHEST) // Allow the above EntityDamageEvent run first
    public void onDamageEntity(EntityDamageByEntityEvent event) {
        if (event.getEntity() instanceof Player && (event.getDamager() instanceof Player
                || event.getDamager() instanceof FishHook || event.getDamager() instanceof Snowball
                || event.getDamager() instanceof Egg || event.getDamager() instanceof Arrow)) {
            Player entity = (Player) event.getEntity();
            Player damager = event.getDamager() instanceof Projectile
                    ? (Player) ((Projectile) event.getDamager()).getShooter()
                    : (Player) event.getDamager();

            // Damager might be null because there might be a chance when arrow hit the
            // entity, the damager isn't online
            if (damager == null) {
                event.setCancelled(true);
                return;
            }

            PlayerProfile entityProfile = PlayerProfile.get(entity);
            PlayerProfile damagerProfile = PlayerProfile.get(damager);

            // profile will be null when damaged player is a citizens player NPC, but is not
            // a pvp bot
            if (entityProfile == null) {
                return;
            }

            if (entityProfile.getPlayerState() == PlayerState.IN_MATCH
                    && damagerProfile.getPlayerState() == PlayerState.IN_MATCH) {
                Match match = entityProfile.getMatch();
                Kit kit = match.getKit();

                if (damagerProfile.getMatch() != entityProfile.getMatch()) {
                    throw new PracticeUnexpectedException("Damager's match does not match with entity's match");
                }

                // It is cancelled in EntityDamageEvent. Check this again to prevent Boxing
                // hits.
                if (match.getState() != MatchState.FIGHTING) {
                    event.setCancelled(true);
                    return;
                }

                Team teamEntity = match.getTeam(entity);
                Team teamDamager = match.getTeam(damager);

                // Ê™¢Êü•ÊîªÊìäÊñπÂíåË¢´ÊîªÊìäÊñπÊòØ‰∏çÊòØÂêåÈöä
                if (teamEntity == teamDamager) {
                    // Ê™¢Êü•ÊîªÊìäÊñπÂíåË¢´ÊîªÊìäÊñπÊòØ‰∏çÊòØÂêå‰∏ÄÂÄã‰∫∫
                    if (entity != damager) {
                        if (!kit.getGameRules().isTeamProjectile() && event.getDamager() instanceof Projectile) {
                            event.setCancelled(true);
                            return;
                        } else if (event.getDamager() instanceof Player) {
                            event.setCancelled(true);
                            return;
                        }
                    } else {
                        if (!kit.getGameRules().isBowBoosting() && event.getDamager() instanceof Arrow) {
                            event.setCancelled(true);
                            return;
                        }
                    }
                }

                // Ê™¢Êü•ËÅ∑Ê•≠ÊòØÂê¶Âè™ÂÖÅË®±ÈÅ†Á®ãÊîªÊìäÂÇ∑ÂÆ≥
                if (kit.getGameRules().isProjectileOnly() && event.getDamager() instanceof Player) {
                    event.setCancelled(true);
                    return;
                }

                TeamPlayer teamPlayerEntity = match.getTeamPlayer(entity);
                TeamPlayer teamPlayerDamager = match.getTeamPlayer(damager);
                double damage = event.getDamage();

                if (!teamPlayerEntity.isAlive() || !teamPlayerDamager.isAlive() || teamPlayerEntity.isRespawning()
                        || teamPlayerDamager.isRespawning()) {
                    event.setCancelled(true);
                    return;
                }

                if (kit.getGameRules().isBoxing() || kit.getGameRules().isNoDamage()) {
                    event.setDamage(0);
                    entity.setHealth(20.0);
                }

                if (kit.getGameRules().isBoxing()) {
                    // Check if the damage is critical damage
                    // The way bukkit handles critical damage is strange, because sometimes it might
                    // fire the same event two times with different damage
                    double predictDamage = 1 + DamageCalculator.getEnchantedDamage(damager.getItemInHand());
                    if (predictDamage > damage) {
                        return;
                    }
                }

                teamPlayerDamager.setProtectionUntil(0); // Fix for #307 point 2

                teamPlayerDamager.handleHit(event.getFinalDamage());
                teamPlayerEntity.handleGotHit(match.getTeamPlayer(damager), entity.isBlocking());

                // È°ØÁ§∫ÈÄ†ÊàêÁöÑÂÇ∑ÂÆ≥
                if (event.getDamager() instanceof Arrow && entity != damager) {
                    Util.sendArrowHitMessage(event);
                }

                // Ê™¢Êü•ËÅ∑Ê•≠ÊòØÂê¶ÁÇ∫Boxing, ÂíåÊ™¢Êü•ÊòØÂê¶ÈÅîÂà∞ÊúÄÂ§ßBoxingÊîªÊìäÊï∏, Â¶ÇÊûúÊòØÁöÑË©±Â∞±Ê≠ª‰∫°
                if (kit.getGameRules().isBoxing()
                        && match.getTeam(entity).getGotHits() >= match.getMaximumBoxingHits()) {
                    match.getTeam(entity).getAliveTeamPlayers().forEach(teamPlayer -> {
                        teamPlayer.setProtectionUntil(0); // Allow our system to damage the player
                        Util.damage(teamPlayer.getPlayer(), 99999);
                    });
                }
            }
        } else if (event.getEntity() instanceof Player && event.getDamager() instanceof Fireball
                && Config.MATCH_FIREBALL_ENABLED.toBoolean()) {
            Player player = (Player) event.getEntity();

            if (Config.MATCH_FIREBALL_KNOCKBACK_ENABLED.toBoolean()) {
                event.setCancelled(true);
                player.damage(event.getDamage() / Config.MATCH_FIREBALL_DIVIDE_DAMAGE.toDouble());
                Util.pushAway(player, event.getDamager().getLocation(),
                        Config.MATCH_FIREBALL_KNOCKBACK_VERTICAL.toDouble(),
                        Config.MATCH_FIREBALL_KNOCKBACK_HORIZONTAL.toDouble());
            } else {
                event.setDamage(event.getDamage() / Config.MATCH_FIREBALL_DIVIDE_DAMAGE.toDouble());
            }
        } else if (event.getEntity() instanceof Player && event.getDamager() instanceof TNTPrimed
                && Config.MATCH_TNT_ENABLED.toBoolean()) {
            Player player = (Player) event.getEntity();

            if (Config.MATCH_TNT_ENABLED.toBoolean()) {
                event.setCancelled(true);
                player.damage(event.getDamage() / Config.MATCH_TNT_DIVIDE_DAMAGE.toDouble());
                Util.pushAway(player, event.getDamager().getLocation(), Config.MATCH_TNT_KNOCKBACK_VERTICAL.toDouble(),
                        Config.MATCH_TNT_KNOCKBACK_HORIZONTAL.toDouble());
            } else {
                event.setDamage(event.getDamage() / Config.MATCH_TNT_DIVIDE_DAMAGE.toDouble());
            }
        }
    }

    @EventHandler
    public void onSpawn(ItemSpawnEvent event) {
        Item item = event.getEntity();
        if (item == null) {
            return;
        }

        if (item.getItemStack().getType() == Material.BED) {
            event.setCancelled(true);
        }
    }

    @EventHandler
    public void onDrop(PlayerDropItemEvent event) {
        Player player = event.getPlayer();
        PlayerProfile profile = PlayerProfile.get(player);
        Item item = event.getItemDrop();

        if (Checker.canDamage(player)) {
            Match match = profile.getMatch();

            if (!match.getKit().getGameRules().isDropItems()) {
                event.setCancelled(true);
                return;
            }

            if (item.getItemStack().getType().name().contains("_SWORD")
                    && player.getInventory().getHeldItemSlot() == 0) {
                Language.MATCH_CANNOT_DROP_WEAPON.sendMessage(player);
                event.setCancelled(true);
                return;
            }

            if (item.getItemStack().getType() == Material.GLASS_BOTTLE) {
                item.remove();
                return;
            }

            match.addDroppedItem(item, player.getName());
        }
    }

    @EventHandler
    public void onPickup(PlayerPickupItemEvent event) {
        Player player = event.getPlayer();
        PlayerProfile profile = PlayerProfile.get(player);
        Item item = event.getItem();

        if (Checker.canDamage(player)) {
            if (item.getItemStack().getType().name().contains("BOOK")) {
                event.setCancelled(true);
                return;
            }

            Match match = profile.getMatch();
            MatchEntity entity = match.getEntities().stream()
                    .filter(matchEntity -> matchEntity.getEntity().getEntityId() == item.getEntityId()).findFirst()
                    .orElse(null);
            if (entity != null) {
                match.getEntities().remove(entity);
            } else {
                event.setCancelled(true);
            }
        }
    }

    @EventHandler
    public void onConsume(PlayerItemConsumeEvent event) {
        Player player = event.getPlayer();
        PlayerProfile profile = PlayerProfile.get(player);

        if (profile.getPlayerState() == PlayerState.IN_MATCH && profile.getMatch() != null) {
            Match match = profile.getMatch();

            if (event.getItem().getType() == Material.GOLDEN_APPLE) {
                if (match.getKit().getGameRules().isHypixelUHC()) {
                    player.removePotionEffect(PotionEffectType.REGENERATION);
                    player.removePotionEffect(PotionEffectType.ABSORPTION);
                    player.addPotionEffect(new PotionEffect(PotionEffectType.REGENERATION, 100, 2));
                    player.addPotionEffect(new PotionEffect(PotionEffectType.ABSORPTION, 2400, 0));
                    player.setFoodLevel(Math.min(player.getFoodLevel() + 6, 20));
                    return;
                } else if (match.getKit().getGameRules().isInstantGapple()) {
                    event.setCancelled(true);
                    player.setItemInHand(new ItemBuilder(player.getItemInHand())
                            .amount(player.getItemInHand().getAmount() - 1).build());
                    player.setHealth(20);
                    player.setFoodLevel(Math.min(player.getFoodLevel() + 6, 20));
                    if (Config.MATCH_GOLDEN_APPLE_INSTANT_GAPPLE_EFFECTS.toBoolean()) {
                        player.addPotionEffect(new PotionEffect(PotionEffectType.ABSORPTION, 2400, 0));
                        if (Config.MATCH_GOLDEN_APPLE_GIVE_ABSORPTION_HEARTS_EVERYTIME.toBoolean()) {
                            ((CraftPlayer) player).getHandle().setAbsorptionHearts(4);
                        }
                    } else {
                        ((CraftPlayer) player).getHandle().setAbsorptionHearts(0);
                    }
                    return;
                } else if (event.getItem().hasItemMeta()
                        && ChatColor.stripColor(event.getItem().getItemMeta().getDisplayName()).toLowerCase()
                                .contains("golden head")) {
                    player.removePotionEffect(PotionEffectType.REGENERATION);
                    player.removePotionEffect(PotionEffectType.ABSORPTION);
                    player.addPotionEffect(new PotionEffect(PotionEffectType.REGENERATION, 200, 1));
                    player.addPotionEffect(new PotionEffect(PotionEffectType.ABSORPTION, 2400, 0));
                    player.setFoodLevel(Math.min(player.getFoodLevel() + 6, 20));
                    return;
                }
            }
        }
    }

    @EventHandler
    public void onInteract(PlayerInteractEvent event) {
        Player player = event.getPlayer();
        PlayerProfile profile = PlayerProfile.get(player);
        Action action = event.getAction();

        if (profile.getPlayerState() == PlayerState.IN_MATCH && profile.getMatch() != null) {
            Match match = profile.getMatch();

            ItemStack itemStack = event.getItem();
            if (itemStack != null) {
                // Golden Head
                if (itemStack.getType() == Material.SKULL_ITEM && match.getKit().getGameRules().isHypixelUHC()
                        && itemStack.hasItemMeta() && ChatColor.stripColor(itemStack.getItemMeta().getDisplayName())
                                .toLowerCase().contains("golden head")) {
                    if (!profile.getCooldowns().get(CooldownType.GOLDEN_HEAD).isExpired()) {
                        String time = TimeUtil
                                .millisToSeconds(profile.getCooldowns().get(CooldownType.GOLDEN_HEAD).getRemaining());
                        Language.MATCH_USE_AGAIN_GOLDEN_HEAD.sendMessage(player, time);
                    } else {
                        profile.getCooldowns().put(CooldownType.GOLDEN_HEAD, new Cooldown(1));

                        EdenSound.GOLDEN_HEAD_EAT.play(player);
                        for (String s : Config.MATCH_GOLDEN_HEAD_EFFECTS.toStringList()) {
                            String[] effect = s.split(";");
                            PotionEffectType type = PotionEffectType.getByName(effect[0]);
                            int duration = Integer.parseInt(effect[1]);
                            int amplifier = Integer.parseInt(effect[2]);

                            player.removePotionEffect(type);
                            player.addPotionEffect(new PotionEffect(type, duration, amplifier));
                        }
                        player.setFoodLevel(
                                Math.min(player.getFoodLevel() + Config.MATCH_GOLDEN_HEAD_FOOD_LEVEL.toInteger(), 20));
                        player.setItemInHand(new ItemBuilder(player.getItemInHand())
                                .amount(player.getItemInHand().getAmount() - 1).build());
                        player.updateInventory();
                    }
                    // ÁÑ°Ë´ñÈáëÈ†≠È°±È£üÁî®ÁµêÊûúÂ¶Ç‰Ωï, ÈÉΩÂøÖÈ†àË¶Å cancel event, ‰∏çÁÑ∂Áé©ÂÆ∂Â∞±ÂèØ‰ª•ÊîæÁΩÆÈáëÈ†≠È°±Âú®Âú∞‰∏ä
                    event.setCancelled(true);
                    return;
                }
                // Ender Pearl
                else if (itemStack.getType() == Material.ENDER_PEARL && action.name().startsWith("RIGHT_")) {
                    Kit kit = match.getKit();
                    if (match.getState() == MatchState.STARTING && kit.getGameRules().isStartFreeze()) {
                        event.setCancelled(true);
                        return;
                    }
                    if (kit.getGameRules().isEnderPearlCooldown()) {
                        if (!profile.getCooldowns().get(CooldownType.ENDER_PEARL).isExpired()) {
                            String time = TimeUtil.millisToSeconds(
                                    profile.getCooldowns().get(CooldownType.ENDER_PEARL).getRemaining());
                            Language.MATCH_USE_AGAIN_ENDER_PEARL.sendMessage(player, time);
                            event.setCancelled(true);
                            return;
                        } else {
                            Util.throwEnderPearl(event); // Try to fix #514
                            profile.getCooldowns().put(CooldownType.ENDER_PEARL, new Cooldown(16) {
                                @Override
                                public void cancelCountdown() {
                                    super.cancelCountdown();

                                    player.setLevel(0);
                                    player.setExp(0);
                                }

                                @Override
                                public void runUnexpired() {
                                    int seconds = Math.round(
                                            profile.getCooldowns().get(CooldownType.ENDER_PEARL).getRemaining()) / 1000;

                                    player.setLevel(seconds);
                                    player.setExp(profile.getCooldowns().get(CooldownType.ENDER_PEARL).getRemaining()
                                            / 16000F);
                                }

                                @Override
                                public void runExpired() {
                                    Language.MATCH_CAN_USE_ENDERPEARL.sendMessage(player);
                                    if (player.getLevel() > 0)
                                        player.setLevel(0);
                                    if (player.getExp() > 0.0F)
                                        player.setExp(0.0F);
                                }
                            });
                            return;
                        }
                    }
                    return;
                }
                // Fireball
                else if (itemStack.getType() == Material.FIREBALL && action.name().startsWith("RIGHT_")
                        && Config.MATCH_FIREBALL_ENABLED.toBoolean()) {
                    Kit kit = match.getKit();
                    if (match.getState() == MatchState.STARTING && kit.getGameRules().isStartFreeze()) {
                        event.setCancelled(true);
                        return;
                    }
                    if (!profile.getCooldowns().get(CooldownType.FIREBALL).isExpired()) {
                        String time = TimeUtil
                                .millisToSeconds(profile.getCooldowns().get(CooldownType.FIREBALL).getRemaining());
                        Language.MATCH_USE_AGAIN_FIREBALL.sendMessage(player, time);
                    } else {
                        profile.getCooldowns().put(CooldownType.FIREBALL, new Cooldown(300L));

                        final Vector direction = player.getEyeLocation().getDirection();
                        final Fireball f = player.launchProjectile(Fireball.class);
                        FireballUtil.setDirection(f, direction);
                        f.setYield((float) Config.MATCH_FIREBALL_YIELD.toDouble());
                        f.setIsIncendiary(false);

                        itemStack.setAmount(itemStack.getAmount() - 1);
                        player.setItemInHand(itemStack);
                    }
                    event.setCancelled(true);
                    return;
                }
                // Soup
                else if (itemStack.getType() == Material.MUSHROOM_SOUP && player.getHealth() < 19.0) {
                    final double newHealth = Math.min(player.getHealth() + 7.0, 20.0);
                    player.setHealth(newHealth);
                    player.setFoodLevel(20);
                    player.getItemInHand().setType(Material.BOWL);
                    player.updateInventory();

                    event.setCancelled(true);
                    return;
                }
                // Kit Loadout Book
                else if (itemStack.getType() == Material.BOOK || itemStack.getType() == Material.ENCHANTED_BOOK) {
                    net.minecraft.server.v1_8_R3.ItemStack nmsItem = CraftItemStack.asNMSCopy(itemStack);
                    if (nmsItem.hasTag()) {
                        NBTTagCompound compound = nmsItem.getTag();
                        if (compound.hasKey("name") && compound.hasKey("armor") && compound.hasKey("contents")) {
                            String name = compound.getString("name");
                            String armor = compound.getString("armor");
                            String contents = compound.getString("contents");
                            KitLoadout kitLoadout = new KitLoadout(name, armor, contents);

                            kitLoadout.apply(match.getKit(), match, player);
                            Language.MATCH_RECEIVED_KIT_LOADOUT.sendMessage(player, name);
                        }
                    }
                    return;
                }
            }
        }
    }

    @EventHandler
    public void onRegain(EntityRegainHealthEvent event) {
        if (event.getEntity() instanceof Player) {
            if (event.getRegainReason() == EntityRegainHealthEvent.RegainReason.SATIATED) {
                Player player = (Player) event.getEntity();
                PlayerProfile profile = PlayerProfile.get(player);

                if (profile.getPlayerState() == PlayerState.IN_MATCH && profile.getMatch() != null) {
                    Match match = profile.getMatch();
                    if (!match.getTeamPlayer(player).isAlive() || match.getTeamPlayer(player).isRespawning()) {
                        return;
                    }
                    if (!match.getKit().getGameRules().isHealthRegeneration()) {
                        event.setCancelled(true);
                    }
                }
            }
        }
    }

    @EventHandler
    public void onFoodLevelChange(FoodLevelChangeEvent event) {
        if (event.getEntity() instanceof Player) {
            Player player = (Player) event.getEntity();
            PlayerProfile profile = PlayerProfile.get(player);

            if (profile.getPlayerState() == PlayerState.IN_MATCH && profile.getMatch() != null) {
                Match match = profile.getMatch();
                if (match.getState() != MatchState.FIGHTING) {
                    event.setCancelled(true);
                    return;
                }
                if (!match.getTeamPlayer(player).isAlive() || match.getTeamPlayer(player).isRespawning()) {
                    event.setCancelled(true);
                    return;
                }
                if (!match.getKit().getGameRules().isFoodLevelChange()) {
                    event.setFoodLevel(20);
                }
            }
        }
    }

    @EventHandler
    public void onBucketEmpty(PlayerBucketEmptyEvent event) {
        Player player = event.getPlayer();
        PlayerProfile profile = PlayerProfile.get(player);
        Block block = event.getBlockClicked().getRelative(event.getBlockFace());

        if (profile.getPlayerState() == PlayerState.IN_MATCH && profile.getMatch() != null) {
            Match match = profile.getMatch();
            if (match.getState() == MatchState.ENDING) {
                event.setCancelled(true);
                return;
            }
            if (!match.getTeamPlayer(player).isAlive() || match.getTeamPlayer(player).isRespawning()) {
                event.setCancelled(true);
                return;
            }
            if (!match.getKit().getGameRules().isBuild()) {
                event.setCancelled(true);
                return;
            }
            if (match.isProtected(block.getLocation(), true)) {
                event.setCancelled(true);
                return;
            }

            match.getPlacedBlocks().add(block.getLocation());
        }
    }

    @EventHandler
    public void onBucketFill(PlayerBucketFillEvent event) {
        Player player = event.getPlayer();
        PlayerProfile profile = PlayerProfile.get(player);
        Block block = event.getBlockClicked().getRelative(event.getBlockFace());

        if (profile.getPlayerState() == PlayerState.IN_MATCH && profile.getMatch() != null) {
            Match match = profile.getMatch();
            if (match.getState() == MatchState.ENDING) {
                event.setCancelled(true);
                return;
            }
            if (!match.getTeamPlayer(player).isAlive() || match.getTeamPlayer(player).isRespawning()) {
                event.setCancelled(true);
                return;
            }
            if (!match.getKit().getGameRules().isBuild()) {
                event.setCancelled(true);
                return;
            }
            if (match.isProtected(block.getLocation(), true)) {
                event.setCancelled(true);
                return;
            }

            match.getPlacedBlocks().remove(block.getLocation());
        }
    }

    @EventHandler
    public void onBlockFromTo(BlockFromToEvent event) {
        Block block = event.getToBlock();
        if (block == null) {
            return;
        }

        for (Match match : Match.getMatches().values()) {
            ArenaDetail arenaDetail = match.getArenaDetail();
            if (arenaDetail == null) {
                return;
            }

            Cuboid cuboid = arenaDetail.getCuboid();
            Location blockLocation = block.getLocation();

            if (cuboid.contains(blockLocation)) {
                match.getPlacedBlocks().add(blockLocation);
            }
        }
    }

    @EventHandler
    public void onPlace(BlockPlaceEvent event) {
        Player player = event.getPlayer();
        PlayerProfile profile = PlayerProfile.get(player);
        Block block = event.getBlockPlaced();

        if (profile.getPlayerState() == PlayerState.IN_MATCH && profile.getMatch() != null) {
            Match match = profile.getMatch();
            if (match.getState() == MatchState.STARTING && match.getKit().getGameRules().isStartFreeze()) {
                if (!(match.getKit().getGameRules().isBed() && block.getType() == Material.TNT)) {
                    event.setCancelled(true);
                    return;
                }
            }
            if (match.getState() == MatchState.ENDING) {
                event.setCancelled(true);
                return;
            }
            if (!match.getTeamPlayer(player).isAlive() || match.getTeamPlayer(player).isRespawning()) {
                event.setCancelled(true);
                return;
            }
            if (!match.getKit().getGameRules().isBuild()) {
                event.setCancelled(true);
                return;
            }
            if (match.isProtected(block.getLocation(), true, block)) {
                event.setCancelled(true);
                return;
            }

            if (block.getType() == Material.TNT && Config.MATCH_TNT_ENABLED.toBoolean()) {
                ItemStack itemStack = player.getItemInHand();
                itemStack.setAmount(itemStack.getAmount() - 1);
                player.setItemInHand(itemStack);

                final TNTPrimed tntPrimed = event.getBlock().getLocation().getWorld()
                        .spawn(event.getBlock().getLocation().clone().add(0.5, 0.0, 0.5), TNTPrimed.class);
                tntPrimed.setYield((float) Config.MATCH_TNT_YIELD.toDouble());
                tntPrimed.setFuseTicks(Config.MATCH_TNT_FUSE_TICKS.toInteger());
                Util.setSource(tntPrimed, player);

                event.setCancelled(true);
                return;
            }

            match.getPlacedBlocks().add(block.getLocation());

            if (match.getKit().getGameRules().isClearBlock()) {
                TeamPlayer teamPlayer = match.getTeamPlayer(player);

                new MatchClearBlockTask(match, match.getKit().getGameRules().getClearBlockTime(), block.getWorld(),
                        block.getLocation(), teamPlayer, (itemStacks) -> {
                            if (player.isOnline() && match == profile.getMatch() && !teamPlayer.isRespawning()
                                    && teamPlayer.isAlive()) {
                                itemStacks.forEach(i -> player.getInventory().addItem(i));
                            }
                        });
            }
        }
    }

    @EventHandler
    public void onBreak(BlockBreakEvent event) {
        Player player = event.getPlayer();
        PlayerProfile profile = PlayerProfile.get(player);
        Block block = event.getBlock();

        if (profile.getPlayerState() == PlayerState.IN_MATCH && profile.getMatch() != null) {
            Match match = profile.getMatch();
            if (match.getState() != MatchState.FIGHTING) {
                event.setCancelled(true);
                return;
            }
            if (!match.getTeamPlayer(player).isAlive() || match.getTeamPlayer(player).isRespawning()) {
                event.setCancelled(true);
                return;
            }
            if (!match.getKit().getGameRules().isBuild()) {
                event.setCancelled(true);
                return;
            }
            if (match.isProtected(block.getLocation(), false)) {
                event.setCancelled(true);
                return;
            }

            match.getPlacedBlocks().remove(block.getLocation());

            Kit kit = match.getKit();
            if (block.getType() == Material.BED_BLOCK) {
                // Now get the bed location
                Location bedLocation1 = new Location(block.getLocation().getWorld(), block.getLocation().getBlockX(),
                        block.getLocation().getBlockY(), block.getLocation().getBlockZ());
                Location bedLocation2 = Util.getBedBlockNearBy(bedLocation1).clone(); // Âõ†ÁÇ∫‰∏ÄÂºµÂ∫äÁ≠âÊñºÂÖ©ÂÄãÊñπÂ°ä, ÊâÄ‰ª•ÈúÄË¶ÅÂ∫äÁöÑÂè¶‰∏ÄÈÇä‰ΩçÁΩÆ

                Team team = match.getTeam(player);
                Team opponentTeam = match.getTeams().stream()
                        .min(Comparator.comparing(t -> t.getSpawnLocation().distance(bedLocation1))).orElse(null);
                if (opponentTeam == null) {
                    throw new PracticeUnexpectedException(
                            "Cannot find the opponent team when player is destroying a bed (Match UUID: "
                                    + match.getUuid() + ")");
                }

                event.setCancelled(true);

                if (team == opponentTeam) {
                    Language.MATCH_CANNOT_BREAK_OWN_BED.sendMessage(player);
                    return;
                }

                if (kit.getGameRules().isBed()) {
                    match.broadcastSound(team, EdenSound.SELF_BREAK_BED);
                    match.broadcastSound(opponentTeam, EdenSound.OPPONENT_BREAK_BED);
                    match.broadcastSpectatorsSound(EdenSound.SELF_BREAK_BED);
                    match.broadcastTitle(opponentTeam, Language.MATCH_BED_BREAK_TITLE.toString());
                    match.broadcastSubTitle(opponentTeam, Language.MATCH_BED_BREAK_SUBTITLE.toString());
                    match.broadcastMessage(
                            Language.MATCH_BED_BREAK_MESSAGE.toStringList(opponentTeam.getTeamColor().getTeamName(),
                                    team.getTeamColor().getColor(), player.getName()));
                    opponentTeam.setBedDestroyed(true);

                    bedLocation1.getBlock().setType(Material.AIR);
                    bedLocation2.getBlock().setType(Material.AIR);
                    return;
                } else if (kit.getGameRules().isBreakGoal()) {
                    match.score(profile, null, match.getTeamPlayer(player));
                    return;
                }
            }
            if (kit.getGameRules().isSpleef()) {
                if (block.getType() == Material.SNOW_BLOCK && player.getInventory().firstEmpty() != -1
                        && Config.MATCH_SNOW_SNOWBALL_DROP_CHANCE.toInteger() > ThreadLocalRandom.current().nextInt(0,
                                100)) {
                    player.getInventory().addItem(
                            new ItemStack(Material.SNOW_BALL, Config.MATCH_SNOW_SNOWBALL_DROP_AMOUNT.toInteger()));
                }
            } else {
                block.getDrops().forEach(itemStack -> {
                    Item item = block.getLocation().getWorld()
                            .dropItemNaturally(block.getLocation().clone().add(0.5, 0.5, 0.5), itemStack);
                    match.addDroppedItem(item, player.getName());
                });
            }
            block.setType(Material.AIR);
            event.setCancelled(true);
        }
    }

    @EventHandler
    public void onPotionSplashEvent(PotionSplashEvent event) {
        if (event.getPotion().getShooter() instanceof Player) {
            Player player = (Player) event.getEntity().getShooter();
            PlayerProfile profile = PlayerProfile.get(player);
            // PracticePlayer may be null because player left the server but the potion
            // still in there
            if (profile == null) {
                return;
            }
            if (profile.getPlayerState() == PlayerState.IN_MATCH && profile.getMatch() != null) {
                Match match = profile.getMatch();
                if (match.getState() != MatchState.FIGHTING) {
                    return;
                }
                if (!match.getTeamPlayer(player).isAlive() || match.getTeamPlayer(player).isRespawning()) {
                    return;
                }
                if (event.getIntensity(player) <= 0.5D) {
                    match.getTeamPlayer(player).addPotionsMissed();
                }
            }
        }
    }

    @EventHandler
    public void onProjectileLaunch(ProjectileLaunchEvent event) {
        Projectile projectile = event.getEntity();
        if (projectile.getShooter() instanceof Player) {
            Player player = (Player) projectile.getShooter();
            PlayerProfile profile = PlayerProfile.get(player);

            if (profile.getPlayerState() == PlayerState.IN_MATCH && profile.getMatch() != null) {
                Match match = profile.getMatch();
                if (match.getState() == MatchState.STARTING && !Config.MATCH_ALLOW_PREFIRE.toBoolean()
                        && projectile instanceof Arrow) {
                    event.setCancelled(true);
                    Language.MATCH_CANNOT_PREFIRE.sendMessage(player);
                    Tasks.runLater(() -> Util.giveBackArrow(match, player), 1L);
                    return;
                }
                if (match.getState() == MatchState.ENDING) {
                    event.setCancelled(true);
                    return;
                }
                if (!match.getTeamPlayer(player).isAlive() || match.getTeamPlayer(player).isRespawning()) {
                    event.setCancelled(true);
                    return;
                }
                match.getEntities().add(new MatchEntity(match, projectile));
                if (projectile instanceof ThrownPotion) {
                    match.getTeamPlayer(player).addPotionsThrown();
                } else if (projectile instanceof Arrow && match.getKit().getGameRules().isGiveBackArrow()) {
                    profile.getCooldowns().put(CooldownType.ARROW, new Cooldown(3500L) {
                        @Override
                        public void runUnexpired() {
                            int seconds = Math.round(profile.getCooldowns().get(CooldownType.ARROW).getRemaining())
                                    / 1000;

                            player.setLevel(seconds);
                            player.setExp(profile.getCooldowns().get(CooldownType.ARROW).getRemaining() / 3500F);
                        }

                        @Override
                        public void runExpired() {
                            if (!player.getInventory().contains(Material.ARROW)) {
                                Util.giveBackArrow(match, player);
                            }
                            if (player.getLevel() > 0)
                                player.setLevel(0);
                            if (player.getExp() > 0.0F)
                                player.setExp(0.0F);
                        }
                    });
                }
            }
        }
    }

    @EventHandler
    public void onProjectileHit(ProjectileHitEvent event) {
        Projectile projectile = event.getEntity();
        if (event.getEntityType() == EntityType.ARROW) {
            projectile.remove();
        }
        if (projectile.getShooter() instanceof Player) {
            Player player = (Player) projectile.getShooter();
            PlayerProfile profile = PlayerProfile.get(player);
            if (profile == null) {
                return;
            }
            if (profile.getPlayerState() == PlayerState.IN_MATCH && profile.getMatch() != null) {
                Match match = profile.getMatch();
                if (match.getState() != MatchState.FIGHTING) {
                    return;
                }
                if (!match.getTeamPlayer(player).isAlive() || match.getTeamPlayer(player).isRespawning()) {
                    return;
                }

                if (event.getEntityType() == EntityType.SNOWBALL) {
                    Location location = event.getEntity().getLocation().clone().add(0, -1, 0);
                    if (location.getBlock().getType() == Material.SNOW_BLOCK
                            && match.getKit().getGameRules().isSpleef()) {
                        location.getBlock().setType(Material.AIR);
                    }
                }
                match.getEntities()
                        .removeIf(matchEntity -> matchEntity.getEntity().getEntityId() == projectile.getEntityId());
            }
        }
    }

    @EventHandler
    public void onItemDamage(PlayerItemDamageEvent event) {
        Player player = event.getPlayer();
        PlayerProfile profile = PlayerProfile.get(player);

        if (profile.getPlayerState() == PlayerState.IN_MATCH && profile.getMatch() != null) {
            if (!Enchantment.PROTECTION_ENVIRONMENTAL.canEnchantItem(event.getItem())) {
                return;
            }

            if (player.getLastDamageCause() != null
                    && player.getLastDamageCause() instanceof EntityDamageByEntityEvent) {
                if (((EntityDamageByEntityEvent) player.getLastDamageCause()).getDamager() instanceof FishHook) {
                    event.setCancelled(true);
                }
            }
        }
    }

    @EventHandler
    public void onExplode(EntityExplodeEvent event) {
        EntityType type = event.getEntityType();
        Location location = event.getLocation();
        Match match = Match.getMatches().values().stream()
                .filter(m -> m.getArenaDetail().getCuboid().contains(location)).findFirst().orElse(null);
        if (match == null) {
            Common.log(CC.RED + "ERROR: Cannot find match when explosion happens ("
                    + LocationSerialization.toReadable(location) + CC.RED + ") (" + type.name() + ")");
            return;
        }

        if (type == EntityType.FIREBALL && Config.MATCH_FIREBALL_ENABLED.toBoolean()) {
            event.blockList()
                    .removeIf(block -> !Config.MATCH_FIREBALL_ALLOWED_BREAKING_BLOCKS.toStringList()
                            .contains(block.getType().name()) || match.isProtected(block.getLocation(), false)
                            || block.getType() == Material.BED_BLOCK);
        } else if (type == EntityType.PRIMED_TNT && Config.MATCH_TNT_ENABLED.toBoolean()) {
            event.blockList().removeIf(
                    block -> !Config.MATCH_TNT_ALLOWED_BREAKING_BLOCKS.toStringList().contains(block.getType().name())
                            || match.isProtected(block.getLocation(), false) || block.getType() == Material.BED_BLOCK);
        }
    }

    @EventHandler
    public void onMatchStateChange(MatchStateChangeEvent event) {
        Match match = event.getMatch();
        Kit kit = match.getKit();

        if (match.getState() == MatchState.FIGHTING) {
            for (TeamPlayer teamPlayer : match.getTeamPlayers()) {
                Player player = teamPlayer.getPlayer();
                if (player != null && teamPlayer.getKitLoadout() == null) {
                    player.setItemOnCursor(null); // Fix for #308 point 1 - Prevent book duplicate
                    kit.getKitLoadout().apply(kit, match, player);
                    Language.MATCH_RECEIVED_KIT_LOADOUT_BECAUSE_TIMEOUT.sendMessage(player);
                }
            }
        }
    }

    @EventHandler
    public void onKitLoadoutReceived(KitLoadoutReceivedEvent event) {
        Player player = event.getPlayer();
        Match match = event.getMatch();

        // Match can be null when loading kit in editor mode
        if (match == null) {
            player.updateInventory();
            return;
        }

        TeamPlayer teamPlayer = match.getTeamPlayer(player);
        Kit kit = match.getKit();

        if (kit.getGameRules().isBed() || kit.getGameRules().isPoint(match)) {
            match.getTeam(player).dye(teamPlayer);
        }
        player.updateInventory();
    }

}


Filename: .\main\java\rip\diamond\practice\match\listener\SpectateListener.java
package rip.diamond.practice.match.listener;

import org.bukkit.entity.LivingEntity;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.Listener;
import org.bukkit.event.block.BlockBreakEvent;
import org.bukkit.event.block.BlockPlaceEvent;
import org.bukkit.event.entity.*;
import org.bukkit.event.player.*;
import rip.diamond.practice.match.Match;
import rip.diamond.practice.profile.PlayerProfile;
import rip.diamond.practice.profile.PlayerState;
import rip.diamond.practice.util.Common;
import rip.diamond.practice.util.Tasks;
import rip.diamond.practice.util.Util;

public class SpectateListener implements Listener {

    @EventHandler
    public void onQuit(PlayerQuitEvent event) {
        Player player = event.getPlayer();
        PlayerProfile profile = PlayerProfile.get(player);

        if (profile == null) {
            return;
        }

        if (profile.getPlayerState() == PlayerState.IN_SPECTATING && profile.getMatch() != null) {
            Match match = profile.getMatch();

            match.leaveSpectate(player);
        }
    }

    @EventHandler
    public void onPlace(BlockPlaceEvent event) {
        Player player = event.getPlayer();
        PlayerProfile profile = PlayerProfile.get(player);

        if (profile.getPlayerState() == PlayerState.IN_SPECTATING) {
            event.setCancelled(true);
        }
    }

    @EventHandler
    public void onBreak(BlockBreakEvent event) {
        Player player = event.getPlayer();
        PlayerProfile profile = PlayerProfile.get(player);

        if (profile.getPlayerState() == PlayerState.IN_SPECTATING) {
            event.setCancelled(true);
        }
    }

    @EventHandler
    public void onPlayerPickupItemEvent(PlayerPickupItemEvent event) {
        Player player = event.getPlayer();
        PlayerProfile profile = PlayerProfile.get(player);
        if (profile.getPlayerState() == PlayerState.IN_SPECTATING) {
            event.setCancelled(true);
        }
    }

    @EventHandler
    public void onPlayerDropItemEvent(PlayerDropItemEvent event) {
        Player player = event.getPlayer();
        PlayerProfile profile = PlayerProfile.get(player);
        if (profile.getPlayerState() == PlayerState.IN_SPECTATING) {
            event.setCancelled(true);
        }
    }

    @EventHandler
    public void onEntityDamage(EntityDamageEvent event) {
        if (event.getEntity() instanceof Player) {
            Player player = (Player) event.getEntity();
            PlayerProfile profile = PlayerProfile.get(player);

            if (Util.isNPC(player)) {
                return;
            }

            if (profile.getPlayerState() == PlayerState.IN_SPECTATING) {
                event.setCancelled(true);
            }
        }
    }

    @EventHandler(priority = EventPriority.LOW)
    public void onEntityDamageByEntity(EntityDamageByEntityEvent event) {
        if (event.getDamager() instanceof Player) {
            Player attacker = (Player) event.getDamager();
            PlayerProfile attackProfile = PlayerProfile.get(attacker);

            if (Util.isNPC(attacker)) {
                return;
            }

            if (attackProfile.getPlayerState() == PlayerState.IN_SPECTATING) {
                event.setCancelled(true);
            }
        }
    }

    @EventHandler
    public void onPlayerItemConsumeEvent(PlayerItemConsumeEvent event) {
        Player player = event.getPlayer();
        PlayerProfile profile = PlayerProfile.get(player);

        if (profile.getPlayerState() == PlayerState.IN_SPECTATING) {
            event.setCancelled(true);
        }
    }

    @EventHandler
    public void onFoodLevelChange(FoodLevelChangeEvent event) {
        if (event.getEntity() instanceof Player) {
            Player player = (Player) event.getEntity();
            PlayerProfile profile = PlayerProfile.get(player);

            if (profile.getPlayerState() == PlayerState.IN_SPECTATING) {
                event.setFoodLevel(20);
            }
        }
    }

    @EventHandler
    public void onInteract(PlayerInteractEvent event) {
        Player player = event.getPlayer();
        PlayerProfile profile = PlayerProfile.get(player);
        if (profile.getPlayerState() == PlayerState.IN_SPECTATING) {
            event.setCancelled(true);
        }
    }

    @EventHandler
    public void onPlayerInteractEntityEvent(PlayerInteractEntityEvent event) {
        Player player = event.getPlayer();
        PlayerProfile profile = PlayerProfile.get(player);
        if (profile.getPlayerState() == PlayerState.IN_SPECTATING) {
            event.setCancelled(true);
        }
    }

    @EventHandler
    public void onTarget(EntityTargetEvent event) {
        if (event.getTarget() instanceof Player) {
            Player player = (Player) event.getTarget();
            PlayerProfile profile = PlayerProfile.get(player);
            if (profile.getPlayerState() == PlayerState.IN_SPECTATING) {
                event.setCancelled(true);
            }
        }
    }

    /**
     * Try to fix player fly state when player changes world
     * A fix for <a href="https://github.com/diamond-rip/Eden/issues/374">#374</a>
     */
    @EventHandler
    public void onChangedWorld(PlayerChangedWorldEvent event) {
        Player player = event.getPlayer();
        PlayerProfile profile = PlayerProfile.get(player);

        if (profile.getPlayerState() == PlayerState.IN_SPECTATING) {
            Tasks.runLater(() -> {
                player.setAllowFlight(true);
                player.setFlying(true);

                player.setAllowFlight(true);
                player.setFlying(true);
            }, 2L);
        }
    }

    /**
     * Don't let spectators be affected by potions dropped near them
     */
    @EventHandler
    public void onPotionSplash(PotionSplashEvent event) {
        for (LivingEntity entity : event.getAffectedEntities()) {
            if (entity instanceof Player) {
                Player player = (Player) entity;
                PlayerProfile profile = PlayerProfile.get(player);
                if (profile.getPlayerState() == PlayerState.IN_SPECTATING) {
                    event.setIntensity(entity, 0F);
                }
            }
        }
    }

}


Filename: .\main\java\rip\diamond\practice\match\menu\SpectateMenu.java
package rip.diamond.practice.match.menu;

import org.bukkit.Material;
import org.bukkit.entity.Player;
import org.bukkit.event.inventory.ClickType;
import org.bukkit.inventory.ItemStack;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.events.EdenEvent;
import rip.diamond.practice.match.Match;
import rip.diamond.practice.match.MatchType;
import rip.diamond.practice.match.impl.SoloMatch;
import rip.diamond.practice.match.impl.TeamMatch;
import rip.diamond.practice.match.team.TeamPlayer;
import rip.diamond.practice.util.CC;
import rip.diamond.practice.util.ItemBuilder;
import rip.diamond.practice.util.TimeUtil;
import rip.diamond.practice.util.menu.Button;
import rip.diamond.practice.util.menu.pagination.PaginatedMenu;

import java.util.HashMap;
import java.util.Map;
import java.util.stream.Collectors;

public class SpectateMenu extends PaginatedMenu {

    @Override
    public String getPrePaginatedTitle(Player player) {
        return Language.MATCH_SPECTATE_MENU_TITLE.toString();
    }

    @Override
    public Map<Integer, Button> getAllPagesButtons(Player player) {
        final Map<Integer, Button> buttons = new HashMap<>();
        for (Match match : Match.getMatches().values()) {
            try {
                String title;
                if (match.getMatchType() == MatchType.SOLO) {
                    title = Language.MATCH_SPECTATE_MENU_BUTTON_NAME_SOLO.toString(((SoloMatch) match).getPlayerA().getUsername(), ((SoloMatch) match).getPlayerB().getUsername());
                } else if (match.getMatchType() == MatchType.SPLIT) {
                    title = Language.MATCH_SPECTATE_MENU_BUTTON_NAME_SPLIT.toString(((TeamMatch) match).getTeamA().getLeader().getUsername(), ((TeamMatch) match).getTeamB().getLeader().getUsername());
                } else if (match.getMatchType() == MatchType.FFA) {
                    title = Language.MATCH_SPECTATE_MENU_BUTTON_NAME_FFA.toString(match.getTeamPlayers().size());
                } else if (match.getMatchType() == MatchType.SUMO_EVENT && EdenEvent.getOnGoingEvent() != null) {
                    title = Language.MATCH_SPECTATE_MENU_BUTTON_NAME_SUMO_EVENT.toString();
                } else {
                    title = Language.MATCH_SPECTATE_MENU_BUTTON_NAME_ERROR.toString();
                }

                buttons.put(buttons.size(), new Button() {
                    @Override
                    public ItemStack getButtonItem(Player player) {
                        return new ItemBuilder(match.getKit().getDisplayIcon().clone())
                                .name(CC.AQUA + title)
                                .lore(Language.MATCH_SPECTATE_MENU_BUTTON_LORE.toStringList(player,
                                        TimeUtil.millisToTimer(match.getElapsedDuration()),
                                        match.getKit().getDisplayName(),
                                        match.getArenaDetail().getArena().getDisplayName(),
                                        match.getQueueType().getReadable(),
                                        match.getTeamPlayers().stream().map(TeamPlayer::getUsername).collect(Collectors.joining(CC.GRAY + ", " + CC.AQUA)),
                                        match.getSpectators().size()
                                ))
                                .build();
                    }

                    @Override
                    public void clicked(Player player, ClickType clickType) {
                        player.closeInventory();
                        match.joinSpectate(player, match.getMatchPlayers().get(0));
                    }
                });
            } catch (Exception e) {
                e.printStackTrace();
                buttons.put(buttons.size(), new Button() {
                    @Override
                    public ItemStack getButtonItem(Player player) {
                        return new ItemBuilder(Material.BEDROCK)
                                .name(Language.MATCH_SPECTATE_MENU_ERROR_BUTTON_NAME.toString())
                                .lore(Language.MATCH_SPECTATE_MENU_ERROR_BUTTON_LORE.toStringList(player, match.getUuid().toString()))
                                .build();
                    }
                });
            }
        }
        return buttons;
    }
}


Filename: .\main\java\rip\diamond\practice\match\menu\SpectateTeleportMenu.java
package rip.diamond.practice.match.menu;

import lombok.RequiredArgsConstructor;
import org.bukkit.Material;
import org.bukkit.entity.Player;
import org.bukkit.event.inventory.ClickType;
import org.bukkit.inventory.ItemStack;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.match.Match;
import rip.diamond.practice.match.team.TeamPlayer;
import rip.diamond.practice.profile.PlayerProfile;
import rip.diamond.practice.profile.PlayerState;
import rip.diamond.practice.util.HeadUtil;
import rip.diamond.practice.util.ItemBuilder;
import rip.diamond.practice.util.Util;
import rip.diamond.practice.util.menu.Button;
import rip.diamond.practice.util.menu.pagination.PaginatedMenu;

import java.util.HashMap;
import java.util.Map;

@RequiredArgsConstructor
public class SpectateTeleportMenu extends PaginatedMenu {

    private final Match match;

    @Override
    public String getPrePaginatedTitle(Player player) {
        return Language.MATCH_SPECTATE_TELEPORT_MENU_TITLE.toString();
    }

    @Override
    public Map<Integer, Button> getAllPagesButtons(Player player) {
        final Map<Integer, Button> buttons = new HashMap<>();

        match.getTeamPlayers().stream().filter(TeamPlayer::isAlive).forEach(teamPlayer -> {
            buttons.put(buttons.size(), new Button() {
                @Override
                public ItemStack getButtonItem(Player player) {
                    return new ItemBuilder(Material.SKULL_ITEM)
                            .durability(3)
                            .headTexture(HeadUtil.getValue(teamPlayer.getPlayer()))
                            .name(Language.MATCH_SPECTATE_TELEPORT_MENU_BUTTON_NAME.toString(teamPlayer.getUsername()))
                            .lore(Language.MATCH_SPECTATE_TELEPORT_MENU_BUTTON_LORE.toStringList(player))
                            .build();
                }

                @Override
                public void clicked(Player player, ClickType clickType) {
                    PlayerProfile profile = PlayerProfile.get(player);
                    if ((profile.getPlayerState() != PlayerState.IN_MATCH && profile.getPlayerState() != PlayerState.IN_SPECTATING) || profile.getMatch() == null) {
                        Language.MATCH_SPECTATE_TELEPORT_MENU_WRONG_STATE.sendMessage(player);
                        return;
                    }
                    if (!teamPlayer.isAlive()) {
                        Language.MATCH_SPECTATE_TELEPORT_MENU_ALREADY_DIED.sendMessage(player);
                        return;
                    }
                    Player tPlayer = teamPlayer.getPlayer();
                    if (tPlayer == null) {
                        Language.MATCH_SPECTATE_TELEPORT_MENU_NOT_ONLINE.sendMessage(player);
                        return;
                    }
                    PlayerProfile tProfile = PlayerProfile.get(tPlayer);
                    if (tProfile.getPlayerState() != PlayerState.IN_MATCH || tProfile.getMatch() == null) {
                        Language.MATCH_SPECTATE_TELEPORT_MENU_TARGET_WRONG_STATE.sendMessage(player);
                        return;
                    }
                    if (tProfile.getMatch() != profile.getMatch()) {
                        Language.MATCH_SPECTATE_TELEPORT_MENU_NOT_SAME_MATCH.sendMessage(player);
                        return;
                    }
                    Util.teleport(player, teamPlayer.getPlayer().getLocation());
                }
            });
        });

        return buttons;
    }
}


Filename: .\main\java\rip\diamond\practice\match\menu\ViewInventoryMenu.java
package rip.diamond.practice.match.menu;

import lombok.AllArgsConstructor;
import org.bukkit.Material;
import org.bukkit.entity.Player;
import org.bukkit.event.inventory.ClickType;
import org.bukkit.inventory.ItemStack;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.match.PostMatchInventory;
import rip.diamond.practice.util.*;
import rip.diamond.practice.util.menu.Button;
import rip.diamond.practice.util.menu.Menu;

import java.util.*;

@AllArgsConstructor
public class ViewInventoryMenu extends Menu {

	private PostMatchInventory info;

	@Override
	public String getTitle(Player player) {
		return Language.MATCH_VIEW_INVENTORY_MENU_TITLE.toString(info.getOwner());
	}

	@Override
	public Map<Integer, Button> getButtons(Player player) {
		Map<Integer, Button> buttons = new HashMap<>();

		for (int i = 0; i < info.getContents().length; i++) {
			ItemStack itemStack = InventoryUtil.fixInventoryOrder(info.getContents())[i];

			if (itemStack != null && itemStack.getType() != Material.AIR) {
				buttons.put(i, new Button() {
					@Override
					public ItemStack getButtonItem(Player player) {
						return itemStack;
					}
				});
			}
		}

		for (int i = 36; i < 45; i++) {
			buttons.put(i, placeholderButton);
		}

		for (int i = 0; i < info.getArmor().length; i++) {
			ItemStack itemStack = info.getArmor()[i];
			if (itemStack != null && itemStack.getType() != Material.AIR) {
				buttons.put(48-i, new Button() {
					@Override
					public ItemStack getButtonItem(Player player) {
						return itemStack;
					}
				});
			}
		}

		buttons.put(49, new PlayerInformationButton());
		buttons.put(50, new EffectsButton());
		buttons.put(51, new HealingButton());
		buttons.put(52, new StatisticsButton());
		if (info.getSwitchToUUID() != null) {
			buttons.put(53, new SwitchInventoryButton());
		}

		return buttons;
	}

	@Override
	public void onOpen(Player player) {
		Language.MATCH_VIEW_INVENTORY_MENU_OPEN_MESSAGE.sendMessage(player, info.getOwner());
	}

	private class SwitchInventoryButton extends Button {
		@Override
		public ItemStack getButtonItem(Player player) {
			return new ItemBuilder(Material.LEVER)
					.name(Language.MATCH_VIEW_INVENTORY_MENU_SWITCH_INVENTORY_BUTTON_NAME.toString(info.getSwitchTo()))
					.build();
		}

		@Override
		public void clicked(Player player, ClickType clickType) {
			Util.performCommand(player, "viewinv " + info.getSwitchToUUID().toString());
		}
	}

	private class PlayerInformationButton extends Button {
		@Override
		public ItemStack getButtonItem(Player player) {
			return new ItemBuilder(Material.SKULL_ITEM)
					.durability(3)
					.headTexture(info.getOwnerHeadValue())
					.name(Language.MATCH_VIEW_INVENTORY_MENU_PLAYER_INFORMATION_BUTTON_NAME.toString())
					.lore(Language.MATCH_VIEW_INVENTORY_MENU_PLAYER_INFORMATION_BUTTON_LORE.toStringList(player, info.getHealth(), info.getMaxHealth(), info.getHunger()))
					.build();
		}
	}

	@AllArgsConstructor
	private class EffectsButton extends Button {
		@Override
		public ItemStack getButtonItem(Player player) {
			ItemBuilder builder = new ItemBuilder(Material.POTION).name(Language.MATCH_VIEW_INVENTORY_MENU_EFFECTS_BUTTON_NAME.toString());

			if (info.getEffects().isEmpty()) {
				builder.lore(Language.MATCH_VIEW_INVENTORY_MENU_EFFECTS_BUTTON_NO_EFFECTS_LORE.toStringList(player));
			} else {
				List<String> lore = new ArrayList<>();
				info.getEffects().forEach(effect -> {
					String name = WordUtil.formatWords(effect.getType().getName()) + " " + (effect.getAmplifier() + 1);
					String duration = TimeUtil.millisToTimer((effect.getDuration() / 20) * 1000L);
					lore.add(Language.MATCH_VIEW_INVENTORY_MENU_EFFECTS_BUTTON_EFFECTS_FORMAT.toString(name, duration));
				});
				lore.add(0, "");
				lore.add("");
				builder.lore(lore);
			}
			return builder.build();
		}
	}

	@AllArgsConstructor
	private class HealingButton extends Button {
		@Override
		public ItemStack getButtonItem(Player player) {
			return new ItemBuilder(info.getHealingMethod() == null ? new ItemBuilder(Material.STAINED_GLASS_PANE).durability(14).build() : info.getHealingMethod().getItem().clone())
					.name(Language.MATCH_VIEW_INVENTORY_MENU_HEALING_BUTTON_NAME.toString())
					.lore(info.getHealingMethod() == null ? Language.MATCH_VIEW_INVENTORY_MENU_HEALING_BUTTON_NO_HEALING_LORE.toStringList(player) : Language.MATCH_VIEW_INVENTORY_MENU_HEALING_BUTTON_HEALING_LORE.toStringList(info.getOwner(), HealingMethod.getHealingLeft(info.getHealingMethod(), info.getContents()), info.getHealingMethod().getName()))
					.build();
		}
	}

	private class StatisticsButton extends Button {
		@Override
		public ItemStack getButtonItem(Player player) {
			return new ItemBuilder(Material.PAPER)
					.name(Language.MATCH_VIEW_INVENTORY_MENU_STATISTICS_BUTTON_NAME.toString())
					.lore(Language.MATCH_VIEW_INVENTORY_MENU_STATISTICS_BUTTON_LORE.toStringList(player, info.getHits(), info.getBlockedHits(), info.getLongestCombo(), info.getPotionsThrown(), info.getPotionsMissed(), info.getPotionAccuracy()))
					.build();
		}
	}

}

Filename: .\main\java\rip\diamond\practice\match\task\MatchClearBlockTask.java
package rip.diamond.practice.match.task;

import lombok.Getter;
import lombok.Setter;
import org.bukkit.Location;
import org.bukkit.Material;
import org.bukkit.World;
import org.bukkit.inventory.ItemStack;
import rip.diamond.practice.config.Config;
import rip.diamond.practice.match.Match;
import rip.diamond.practice.match.MatchTaskTicker;
import rip.diamond.practice.match.team.TeamPlayer;
import rip.diamond.practice.util.Util;

import java.util.Collection;
import java.util.function.Consumer;

@Getter
public class MatchClearBlockTask extends MatchTaskTicker {

    private final Match match;
    private final int seconds;
    private final Location location;
    private final World world;
    private final TeamPlayer blockPlacer;
    private final Consumer<Collection<ItemStack>> callback;

    @Setter private boolean activateCallback = true;

    public MatchClearBlockTask(Match match, int seconds, World world, Location location, TeamPlayer blockPlacer, Consumer<Collection<ItemStack>> callback) {
        super(seconds * 20, 1, false, match);
        this.match = match;
        this.seconds = seconds;
        this.world = world;
        this.location = location;
        this.blockPlacer = blockPlacer;
        this.callback = callback;
    }

    @Override
    public void onRun() {
        if (getTicks() <= 0) {
            cancel();

            try {
                Collection<ItemStack> itemStacks = location.clone().getBlock().getDrops();

                if (Config.OPTIMIZATION_SET_BLOCK_FAST.toBoolean()) {
                    Util.setBlockFast(location, Material.AIR, false);
                } else {
                    location.getBlock().setType(Material.AIR);
                }
                match.getPlacedBlocks().remove(location);

                if (activateCallback) {
                    callback.accept(itemStacks);
                }
            } catch (Exception ex) {
                ex.printStackTrace();
            }
        }
    }

    @Override
    public void preRun() {

    }

    @Override
    public TickType getTickType() {
        return TickType.NONE;
    }

    @Override
    public int getStartTick() {
        return 0;
    }
}


Filename: .\main\java\rip\diamond\practice\match\task\MatchClearItemTask.java
package rip.diamond.practice.match.task;

import rip.diamond.practice.match.Match;
import rip.diamond.practice.util.TaskTicker;

public class MatchClearItemTask extends TaskTicker {
    public MatchClearItemTask() {
        super(0, 20, false);
    }

    @Override
    public void onRun() {
        for (Match match : Match.getMatches().values()) {
            match.clearEntities(false);
        }
    }

    @Override
    public void preRun() {

    }

    @Override
    public TickType getTickType() {
        return TickType.NONE;
    }

    @Override
    public int getStartTick() {
        return 0;
    }
}


Filename: .\main\java\rip\diamond\practice\match\task\MatchFireworkTask.java
package rip.diamond.practice.match.task;

import net.minecraft.server.v1_8_R3.*;
import org.bukkit.Bukkit;
import org.bukkit.Color;
import org.bukkit.FireworkEffect;
import org.bukkit.Material;
import org.bukkit.craftbukkit.v1_8_R3.CraftWorld;
import org.bukkit.craftbukkit.v1_8_R3.entity.CraftPlayer;
import org.bukkit.craftbukkit.v1_8_R3.inventory.CraftItemStack;
import org.bukkit.entity.Player;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.meta.FireworkMeta;
import rip.diamond.practice.Eden;
import rip.diamond.practice.match.Match;
import rip.diamond.practice.match.MatchTaskTicker;
import rip.diamond.practice.util.Common;

import java.util.Random;

public class MatchFireworkTask extends MatchTaskTicker {
    private final Color color;
    private final Match match;

    public MatchFireworkTask(Color color, Match match) {
        super(0, 20, true, match);
        this.color = color;
        this.match = match;
    }

    @Override
    public void onRun() {
        if (getTicks() <= 0) {
            cancel();
            return;
        }
        ItemStack stackFirework = new ItemStack(Material.FIREWORK);
        FireworkMeta fireworkMeta = (FireworkMeta) stackFirework.getItemMeta();
        fireworkMeta.addEffect(FireworkEffect.builder().flicker(true).trail(true).withColor(color).withFade(Color.WHITE).build());
        fireworkMeta.setPower(2);
        stackFirework.setItemMeta(fireworkMeta);

        int randomX = new Random().nextInt(40) - 20;
        int randomZ = new Random().nextInt(40) - 20;

        EntityFireworks firework = new EntityFireworks(((CraftWorld) match.getArenaDetail().getCuboid().getWorld()).getHandle(), match.getArenaDetail().getCuboid().getCenter().getX() + randomX, match.getArenaDetail().getCuboid().getCenter().getY(), match.getArenaDetail().getCuboid().getCenter().getZ() + randomZ, CraftItemStack.asNMSCopy(stackFirework));
        for (Player player : match.getPlayersAndSpectators()) {
            ((CraftPlayer)player).getHandle().playerConnection.sendPacket(new PacketPlayOutSpawnEntity(firework, 76));
        }

        Bukkit.getScheduler().runTaskLaterAsynchronously(Eden.INSTANCE, () -> {
            firework.expectedLifespan = 0;
            for (Player player : match.getPlayersAndSpectators()) {
                ((CraftPlayer)player).getHandle().playerConnection.sendPacket(new PacketPlayOutEntityMetadata(firework.getId(), firework.getDataWatcher(), true));
                ((CraftPlayer)player).getHandle().playerConnection.sendPacket(new PacketPlayOutEntityStatus(firework, (byte) 17));
                ((CraftPlayer)player).getHandle().playerConnection.sendPacket(new PacketPlayOutEntityDestroy(firework.getId()));
            }
        }, 2L);
    }

    @Override
    public void preRun() {

    }

    @Override
    public TickType getTickType() {
        return TickType.COUNT_DOWN;
    }

    @Override
    public int getStartTick() {
        return match.getKit().getGameRules().getNewRoundTime();
    }
}


Filename: .\main\java\rip\diamond\practice\match\task\MatchNewRoundTask.java
package rip.diamond.practice.match.task;

import org.bukkit.Sound;
import org.bukkit.craftbukkit.v1_8_R3.entity.CraftPlayer;
import org.bukkit.entity.Player;
import org.bukkit.scheduler.BukkitRunnable;
import rip.diamond.practice.Eden;
import rip.diamond.practice.config.Config;
import rip.diamond.practice.config.EdenSound;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.event.MatchRoundEndEvent;
import rip.diamond.practice.event.MatchRoundStartEvent;
import rip.diamond.practice.match.Match;
import rip.diamond.practice.match.MatchState;
import rip.diamond.practice.match.MatchTaskTicker;
import rip.diamond.practice.match.team.Team;
import rip.diamond.practice.match.team.TeamPlayer;
import rip.diamond.practice.util.CenteredMessageSender;

import java.util.stream.Collectors;

public class MatchNewRoundTask extends MatchTaskTicker {

    private final Match match;
    private final TeamPlayer scoredPlayer;
    private final boolean newRound;

    public MatchNewRoundTask(Match match, TeamPlayer scoredPlayer, boolean newRound) {
        super(0, 20, false, match);
        this.match = match;
        this.scoredPlayer = scoredPlayer;
        this.newRound = newRound;
    }

    @Override
    public void onRun() {
        if (match.getState() == MatchState.ENDING) {
            cancel();
            return;
        }

        if (getTicks() == 0) {
            match.broadcastMessage(Language.MATCH_NEW_ROUND_START_MESSAGE.toString());
            match.broadcastTitle("");
            match.setState(MatchState.FIGHTING);
            match.broadcastSound(EdenSound.MATCH_START);

            MatchRoundStartEvent event = new MatchRoundStartEvent(match);
            event.call();

            cancel();
            return;
        }

        match.broadcastMessage(Language.MATCH_NEW_ROUND_START_COUNTDOWN.toString(getTicks()));
        match.broadcastTitle(Language.MATCH_NEW_ROUND_START_TITLE.toString(getTicks()));
        match.broadcastSound(EdenSound.NEW_ROUND_COUNTDOWN);
    }

    @Override
    public void preRun() {
        match.clearEntities(true); // Patch for #226 - Clear all entities when new round is happening, so things
                                   // like arrow and pearl from last round will not be activated

        // To prevent any duplicate MatchNewRoundTask happens
        // This will occur when the match is sumo, and player walked into the water
        // without taking any hits from opponent
        if (match.getTasks().stream().filter(taskTicker -> taskTicker != this)
                .anyMatch(taskTicker -> taskTicker instanceof MatchNewRoundTask)) {
            cancel();
            return;
        }

        // Meaning the game is started and someone scored
        if (scoredPlayer != null && match.getState() != MatchState.STARTING
                && match.getKit().getGameRules().isPoint(match)) {
            Team team = match.getTeam(scoredPlayer);
            Player player = scoredPlayer.getPlayer();

            // Display scored message
            match.broadcastMessage(Language.MATCH_NEW_ROUND_START_SCORE.toStringList(player,
                    team.getTeamColor().getColor(),
                    scoredPlayer.getUsername(),
                    Eden.DECIMAL
                            .format((player.getHealth() + ((CraftPlayer) player).getHandle().getAbsorptionHearts())),
                    team.getPoints(),
                    match.getOpponentTeam(team).getTeamColor().getColor(),
                    match.getOpponentTeam(team).getPoints()).stream().map(CenteredMessageSender::getCenteredMessage)
                    .collect(Collectors.toList()));

            // Display scored title
            if (Config.MATCH_TITLE_SCORE.toBoolean()) {
                String scoredTeamColor = team.getTeamColor().getColor();
                String opponentTeamColor = match.getOpponentTeam(team).getTeamColor().getColor();

                match.broadcastTitle(
                        Language.MATCH_NEW_ROUND_START_SCORED_TITLE.toString(scoredTeamColor,
                                scoredPlayer.getUsername()),
                        Language.MATCH_NEW_ROUND_START_SCORED_SUBTITLE.toString(scoredTeamColor, team.getPoints(),
                                opponentTeamColor, match.getOpponentTeam(team).getPoints()),
                        20, 60, 20);
            }
        }

        if (newRound) {
            match.setState(MatchState.STARTING);

            // Teleport players into their team spawn
            match.getTeams().forEach(t -> t.teleport(t.getSpawnLocation()));
            match.getTeamPlayers().forEach(teamPlayer -> {
                if (teamPlayer.isRespawning()) {
                    // To prevent MatchRespawnTask gets cancelled because of a new round, we need to
                    // fully respawn the player instead of just giving the kit loadout. A fix for
                    // https://github.com/RealGoodestEnglish/Eden/issues/4
                    match.respawn(teamPlayer);
                } else {
                    teamPlayer.respawn(match);
                }
            });

            if (match.getKit().getGameRules().isResetArenaWhenGetPoint()) {
                match.getArenaDetail().restoreChunk(true, false);

                // Cancel any runnable which affects the gameplay
                match.getTasks().stream().filter(taskTicker -> taskTicker instanceof MatchClearBlockTask)
                        .forEach(BukkitRunnable::cancel);
            }

            MatchRoundEndEvent event = new MatchRoundEndEvent(match);
            event.call();
        }
    }

    @Override
    public TickType getTickType() {
        return TickType.COUNT_DOWN;
    }

    @Override
    public int getStartTick() {
        if (!newRound) {
            return match.getKit().getGameRules().getMatchCountdownDuration();
        }
        return match.getKit().getGameRules().getNewRoundTime();
    }
}


Filename: .\main\java\rip\diamond\practice\match\task\MatchPostMatchInventoriesClearTask.java
package rip.diamond.practice.match.task;

import rip.diamond.practice.match.Match;
import rip.diamond.practice.util.TaskTicker;

public class MatchPostMatchInventoriesClearTask extends TaskTicker{

    public MatchPostMatchInventoriesClearTask() {
        super(0, 20, true);
    }

    @Override
    public void onRun() {
        Match.getPostMatchInventories().entrySet().removeIf(next -> System.currentTimeMillis() - next.getValue().getCreated() >= 60000L);
    }

    @Override
    public void preRun() {

    }

    @Override
    public TaskTicker.TickType getTickType() {
        return TaskTicker.TickType.NONE;
    }

    @Override
    public int getStartTick() {
        return 0;
    }

}


Filename: .\main\java\rip\diamond\practice\match\task\MatchResetTask.java
package rip.diamond.practice.match.task;

import org.bukkit.scheduler.BukkitRunnable;
import rip.diamond.practice.Eden;
import rip.diamond.practice.EdenItems;
import rip.diamond.practice.config.Config;
import rip.diamond.practice.event.MatchResetEvent;
import rip.diamond.practice.events.EdenEvent;
import rip.diamond.practice.match.Match;
import rip.diamond.practice.match.MatchTaskTicker;
import rip.diamond.practice.match.MatchType;
import rip.diamond.practice.match.impl.SoloMatch;
import rip.diamond.practice.party.Party;
import rip.diamond.practice.profile.PlayerProfile;
import rip.diamond.practice.util.TaskTicker;
import rip.diamond.practice.util.Util;

import java.util.Objects;

public class MatchResetTask extends MatchTaskTicker {
    private final Eden plugin = Eden.INSTANCE;
    private final Match match;

    public MatchResetTask(Match match) {
        super(1, Config.MATCH_END_DURATION.toInteger(), false, match);
        this.match = match;
    }

    @Override
    public void onRun() {
        if (getTicks() <= 0) {
            cancel();

            MatchResetEvent event = new MatchResetEvent(match);
            event.call();

            match.clearEntities(true);
            match.getMatchPlayers().stream().filter(player -> Objects.nonNull(player) && player.isOnline())
                    .filter(player -> PlayerProfile.get(player).getMatch() == match) // This is to prevent player is in
                                                                                     // another match because of the
                                                                                     // requeue item
                    .forEach(player -> plugin.getLobbyManager().sendToSpawnAndReset(player));
            match.getSpectators().forEach(match::leaveSpectate);
            match.getTasks().forEach(BukkitRunnable::cancel);
            match.getArenaDetail().restoreChunk(true, true);
            Match.getMatches().remove(match.getUuid());
        }
    }

    @Override
    public void preRun() {
        // Cancel MatchClearBlockTask first, to save performance
        match.getTasks().stream().filter(taskTicker -> taskTicker instanceof MatchClearBlockTask)
                .forEach(BukkitRunnable::cancel);

        // Give 'Play Again' item like Minemen Club
        if (Config.MATCH_ALLOW_REQUEUE.toBoolean() && match instanceof SoloMatch) {
            new BukkitRunnable() {
                @Override
                public void run() {
                    match.getMatchPlayers().stream()
                            .filter(Objects::nonNull) // If match players contains citizens NPC, because of it is
                                                      // already destroyed, it will be null
                            .filter(player -> !EdenEvent.isInEvent(player)) // Do not give player 'Play Again' item if
                                                                            // they are in an event
                            .forEach(player -> {
                                PlayerProfile profile = PlayerProfile.get(player);
                                if (profile.getMatch() == match) {
                                    EdenItems.giveItem(player, EdenItems.MATCH_REQUEUE);
                                }
                            });
                }
            }.runTaskLater(plugin, 20L);
        }
    }

    @Override
    public TickType getTickType() {
        return TickType.COUNT_DOWN;
    }

    @Override
    public int getStartTick() {
        return 1;
    }
}


Filename: .\main\java\rip\diamond\practice\match\task\MatchRespawnTask.java
package rip.diamond.practice.match.task;

import net.minecraft.server.v1_8_R3.PacketPlayOutTitle;
import org.bukkit.entity.Player;
import rip.diamond.practice.config.Config;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.match.Match;
import rip.diamond.practice.match.MatchState;
import rip.diamond.practice.match.MatchTaskTicker;
import rip.diamond.practice.match.team.TeamPlayer;
import rip.diamond.practice.util.Common;
import rip.diamond.practice.util.TitleSender;
import rip.diamond.practice.util.Util;
import rip.diamond.practice.util.VisibilityController;

public class MatchRespawnTask extends MatchTaskTicker {
    private final Match match;
    private final TeamPlayer teamPlayer;

    public MatchRespawnTask(Match match, TeamPlayer teamPlayer) {
        super(0, 20, false, match);
        this.match = match;
        this.teamPlayer = teamPlayer;
    }

    @Override
    public void onRun() {
        if (teamPlayer == null || !teamPlayer.isRespawning() || teamPlayer.isDisconnected()
                || teamPlayer.getPlayer() == null || match.getState() == MatchState.STARTING
                || match.getState() == MatchState.ENDING) {
            cancel();
            return;
        }
        Player player = teamPlayer.getPlayer();

        if (getTicks() <= 0) {
            cancel();
            match.respawn(teamPlayer);
            return;
        }
        Common.sendMessage(player, Language.MATCH_RESPAWN_COUNTDOWN.toString(getTicks()));
        TitleSender.sendTitle(player, Language.MATCH_RESPAWN_TITLE.toString(), PacketPlayOutTitle.EnumTitleAction.TITLE,
                0, 21, 0);
        TitleSender.sendTitle(player, Language.MATCH_RESPAWN_SUBTITLE.toString(getTicks()),
                PacketPlayOutTitle.EnumTitleAction.SUBTITLE, 0, 21, 0);
    }

    @Override
    public void preRun() {
        Player player = teamPlayer.getPlayer();

        match.displayDeathMessage(teamPlayer, teamPlayer.getPlayer());
        teamPlayer.setRespawning(true);
        match.getMatchPlayers().forEach(VisibilityController::updateVisibility);
        player.getActivePotionEffects().forEach(effect -> player.removePotionEffect(effect.getType()));
        player.setAllowFlight(true);
        player.setFlying(true);
        if (getStartTick() > 0 && Config.MATCH_RESPAWN_TELEPORT_TO_SPAWN_WHEN_DIE.toBoolean()) {
            Util.teleport(player, match.getTeam(player).getSpawnLocation());
        }

        // Êàë‰πü‰∏çÁü•ÈÅìÁÇ∫‰ªÄÈ∫º, ÈÄôÂÖ©È†ÖÊù±Ë•øÈúÄË¶ÅÈáçÊñ∞Áî®‰∏ÄÊ¨°ÊâçËÉΩÊ≠£Â∏∏ÈÅã‰Ωú
        player.setAllowFlight(true);
        player.setFlying(true);

        player.getInventory().clear();
    }

    @Override
    public TickType getTickType() {
        return TickType.COUNT_DOWN;
    }

    @Override
    public int getStartTick() {
        return match.getKit().getGameRules().getRespawnTime();
    }

    public void instantRespawn() {
        setTicks(0);
        onRun();
    }
}


Filename: .\main\java\rip\diamond\practice\match\team\Team.java
package rip.diamond.practice.match.team;

import lombok.Getter;
import lombok.Setter;
import net.md_5.bungee.api.chat.BaseComponent;
import net.minecraft.server.v1_8_R3.PacketPlayOutTitle;
import org.bukkit.Color;
import org.bukkit.Location;
import org.bukkit.Material;
import org.bukkit.entity.Player;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.meta.LeatherArmorMeta;
import org.github.paperspigot.Title;
import rip.diamond.practice.util.CC;
import rip.diamond.practice.util.Common;
import rip.diamond.practice.util.TitleSender;
import rip.diamond.practice.util.serialization.LocationSerialization;

import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

@Getter
public class Team {

	@Setter
	private TeamPlayer leader;
	@Getter
	@Setter
	private TeamColor teamColor;
	private final List<TeamPlayer> teamPlayers;
	@Setter
	private Location spawnLocation;
	@Getter
	@Setter
	private Location bedLocation;
	@Getter
	@Setter
	private boolean bedDestroyed = false;
	@Getter
	private int points = 0;

	public Team(TeamPlayer leader) {
		this.leader = leader;
		this.teamColor = TeamColor.WHITE;
		this.teamPlayers = new ArrayList<>();
		this.teamPlayers.add(this.leader);
	}

	public boolean isLeader(UUID uuid) {
		return this.leader.getUuid().equals(uuid);
	}

	public boolean containsPlayer(Player player) {
		for (TeamPlayer playerInfo : this.teamPlayers) {
			if (playerInfo.getUuid().equals(player.getUniqueId())) {
				return true;
			}
		}

		return false;
	}

	public List<UUID> getPlayersUUID() {
		List<UUID> players = new ArrayList<>();
		this.teamPlayers.forEach(matchPlayer -> players.add(matchPlayer.getUuid()));
		return players;
	}

	public List<Player> getPlayers() {
		List<Player> players = new ArrayList<>();

		this.teamPlayers.forEach(matchPlayer -> {
			Player player = matchPlayer.getPlayer();
			if (player != null) {
				players.add(player);
			}
		});

		return players;
	}

	/**
	 * Returns a list of objects that extend {@link TeamPlayer} whose
	 * {@link TeamPlayer#isAlive()} returns true.
	 *
	 * @return A list of team players that are alive.
	 */
	public List<TeamPlayer> getAliveTeamPlayers() {
		List<TeamPlayer> alive = new ArrayList<>();

		this.teamPlayers.forEach(teamPlayer -> {
			if (teamPlayer.isAlive()) {
				alive.add(teamPlayer);
			}
		});

		return alive;
	}

	/**
	 * Returns an integer that is incremented for each {@link TeamPlayer} element in
	 * the {@code teamPlayers} list whose
	 * {@link TeamPlayer#isAlive()} returns true.
	 * <p>
	 * Use this method rather than calling {@link List#size()} on the result of
	 * {@code getAliveTeamPlayers}.
	 *
	 * @return The count of team players that are alive.
	 */
	public int getAliveCount() {
		if (this.teamPlayers.size() == 1) {
			return this.leader.isAlive() ? 1 : 0;
		} else {
			int alive = 0;

			for (TeamPlayer teamPlayer : this.teamPlayers) {
				if (teamPlayer.isAlive()) {
					alive++;
				}
			}

			return alive;
		}
	}

	public int getDisconnectedCount() {
		int disconnected = 0;

		for (TeamPlayer teamPlayer : getTeamPlayers()) {
			if (teamPlayer.isDisconnected()) {
				disconnected++;
			}
		}

		return disconnected;
	}

	public int getHits() {
		return teamPlayers.stream().mapToInt(TeamPlayer::getHits).sum();
	}

	public int getGotHits() {
		return teamPlayers.stream().mapToInt(TeamPlayer::getGotHits).sum();
	}

	public int getCombo() {
		return teamPlayers.stream().mapToInt(TeamPlayer::getActiveCombo).sum();
	}

	/**
	 * Returns a list of objects that extend {@link TeamPlayer} whose
	 * {@link TeamPlayer#isAlive()} returns false.
	 *
	 * @return A list of team players that are dead.
	 */
	public List<TeamPlayer> getDeadTeamPlayers() {
		List<TeamPlayer> dead = new ArrayList<>();

		this.teamPlayers.forEach(teamPlayer -> {
			if (!teamPlayer.isAlive()) {
				dead.add(teamPlayer);
			}
		});

		return dead;
	}

	/**
	 * Subtracts the result of {@code getAliveCount} from the size of the
	 * {@code teamPlayers} list.
	 *
	 * @return The count of team players that are dead.
	 */
	public int getDeadCount() {
		return this.teamPlayers.size() - this.getAliveCount();
	}

	public boolean isEliminated() {
		return teamPlayers.stream().noneMatch(TeamPlayer::isAlive);
	}

	public Location getSpawnLocation() {
		return spawnLocation.clone().add(0, 1, 0);
	}

	public void broadcast(String messages) {
		this.getPlayers().forEach(player -> player.sendMessage(messages));
	}

	public void broadcastTitle(String title, String subtitle) {
		broadcastTitle(title, subtitle, 5, 60, 5);
	}

	public void broadcastTitle(String title, String subtitle, int fadeIn, int stay, int fadeOut) {
		this.getPlayers().forEach(player -> {
			TitleSender.sendTitle(player, title, PacketPlayOutTitle.EnumTitleAction.TITLE, fadeIn, stay, fadeOut);
			TitleSender.sendTitle(player, subtitle, PacketPlayOutTitle.EnumTitleAction.SUBTITLE, fadeIn, stay, fadeOut);
		});
	}

	public void broadcast(List<String> messages) {
		this.getPlayers().forEach(player -> messages.forEach(player::sendMessage));
	}

	public void broadcastComponents(List<BaseComponent[]> components) {
		this.getPlayers().forEach(player -> components.forEach(array -> player.spigot().sendMessage(array)));
	}

	public void teleport(Location location) {
		if (!location.getChunk().isLoaded()) {
			Common.debug(LocationSerialization.toReadable(location) + CC.RED
					+ " ÁöÑÂçÄÂ°äÈÇÑÊ≤íÂä†Ëºâ, ÂèØÊòØÁ≥ªÁµ±Ê≠£Âú®ÂÇ≥ÈÄÅÁé©ÂÆ∂Âà∞Ë©≤‰ΩçÁΩÆ, ÈÄôÂèØËÉΩÊúÉÈÄ†Êàê‰º∫ÊúçÂô®Âç°È†ì, Ë´ãÁõ°Âø´‰øÆÂæ©");
		}
		for (TeamPlayer teamPlayer : getTeamPlayers()) {
			if (teamPlayer.getPlayer() == null || teamPlayer.isDisconnected()) {
				continue;
			}
			teamPlayer.teleport(location);
		}
	}

	public void handlePoint() {
		points++;
	}

	public void dye(TeamPlayer teamPlayer) {
		Player player = teamPlayer.getPlayer();
		if (player == null) {
			return;
		}
		for (ItemStack armorContent : player.getInventory().getArmorContents()) {
			if (armorContent == null || armorContent.getType() == Material.AIR) {
				continue;
			}
			if (armorContent.getType().name().contains("LEATHER")) {
				LeatherArmorMeta meta = (LeatherArmorMeta) armorContent.getItemMeta();
				meta.setColor(Color.fromRGB(getTeamColor().getRgb()));
				armorContent.setItemMeta(meta);
			}
		}
		for (ItemStack content : player.getInventory().getContents()) {
			if (content == null || content.getType() == Material.AIR) {
				continue;
			}
			if (content.getType() == Material.WOOL || content.getType() == Material.STAINED_CLAY) {
				content.setDurability((short) getTeamColor().getDyeColor().ordinal());
			}
		}
	}

}


Filename: .\main\java\rip\diamond\practice\match\team\TeamColor.java
package rip.diamond.practice.match.team;

import lombok.AllArgsConstructor;
import lombok.Getter;
import org.bukkit.DyeColor;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.util.CC;

@Getter
@AllArgsConstructor
public enum TeamColor {

    RED(CC.RED, 16711680, DyeColor.RED, Language.MATCH_TEAM_COLOR_RED_NAME.toString(), Language.MATCH_TEAM_COLOR_RED_LOGO.toString(), DyeColor.RED.ordinal()),
    BLUE(CC.BLUE, 255, DyeColor.BLUE, Language.MATCH_TEAM_COLOR_BLUE_NAME.toString(), Language.MATCH_TEAM_COLOR_BLUE_LOGO.toString(), DyeColor.BLUE.ordinal()),
    GREEN(CC.GREEN, 32768, DyeColor.GREEN, Language.MATCH_TEAM_COLOR_GREEN_NAME.toString(), Language.MATCH_TEAM_COLOR_GREEN_LOGO.toString(), DyeColor.GREEN.ordinal()),
    YELLOW(CC.YELLOW, 16776960, DyeColor.YELLOW, Language.MATCH_TEAM_COLOR_YELLOW_NAME.toString(), Language.MATCH_TEAM_COLOR_YELLOW_LOGO.toString(), DyeColor.YELLOW.ordinal()),
    AQUA(CC.AQUA, 65535, DyeColor.CYAN, Language.MATCH_TEAM_COLOR_AQUA_NAME.toString(), Language.MATCH_TEAM_COLOR_AQUA_LOGO.toString(), DyeColor.CYAN.ordinal()),
    WHITE(CC.WHITE, 16777215, DyeColor.WHITE, Language.MATCH_TEAM_COLOR_WHITE_NAME.toString(), Language.MATCH_TEAM_COLOR_WHITE_LOGO.toString(), DyeColor.WHITE.ordinal()),
    PINK(CC.PINK, 8388736, DyeColor.PINK, Language.MATCH_TEAM_COLOR_PINK_NAME.toString(), Language.MATCH_TEAM_COLOR_PINK_LOGO.toString(), DyeColor.PINK.ordinal()),
    GRAY(CC.DARK_GRAY, 8421504, DyeColor.GRAY, Language.MATCH_TEAM_COLOR_GRAY_NAME.toString(), Language.MATCH_TEAM_COLOR_GRAY_LOGO.toString(), DyeColor.GRAY.ordinal());

    private final String color;
    private final int rgb;
    private final DyeColor dyeColor;
    private final String teamName;
    private final String teamLogo;
    private final int durability;
}


Filename: .\main\java\rip\diamond\practice\match\team\TeamPlayer.java
package rip.diamond.practice.match.team;

import lombok.Getter;
import lombok.Setter;
import net.minecraft.server.v1_8_R3.PacketPlayOutTitle;
import org.bukkit.Bukkit;
import org.bukkit.Location;
import org.bukkit.craftbukkit.v1_8_R3.entity.CraftPlayer;
import org.bukkit.entity.Player;
import org.github.paperspigot.Title;
import rip.diamond.practice.Eden;
import rip.diamond.practice.config.Config;
import rip.diamond.practice.kits.KitLoadout;
import rip.diamond.practice.match.Match;
import rip.diamond.practice.profile.PlayerProfile;
import rip.diamond.practice.util.Tasks;
import rip.diamond.practice.util.TitleSender;
import rip.diamond.practice.util.Util;

import java.util.UUID;

public class TeamPlayer {

	@Getter
	private final UUID uuid;
	@Getter
	private final String username;
	@Getter
	@Setter
	private boolean alive = true;
	@Getter
	@Setter
	private boolean respawning = false;
	@Getter
	@Setter
	private boolean disconnected = false;
	@Getter
	@Setter
	private int potionsThrown;
	@Getter
	@Setter
	private int potionsMissed;
	@Getter
	@Setter
	private int hits;
	@Getter
	@Setter
	private int blockedHits;
	@Getter
	@Setter
	private int gotHits;
	@Getter
	@Setter
	private TeamPlayer lastHitDamager;
	@Getter
	@Setter
	private int combo;
	@Getter
	@Setter
	private int longestCombo;
	@Getter
	@Setter
	private long lastHitTime;
	@Getter
	@Setter
	private double damageDealt;
	@Getter
	@Setter
	private KitLoadout kitLoadout;
	@Getter
	@Setter
	private long protectionUntil = -1;

	public TeamPlayer(Player player) {
		this.uuid = player.getUniqueId();
		this.username = player.getName();
	}

	public TeamPlayer(UUID uuid, String username) {
		this.uuid = uuid;
		this.username = username;
	}

	public Player getPlayer() {
		if (Util.isNPC(uuid)) {
			return Eden.INSTANCE.getHookManager().getCitizensHook().getNPCPlayer(uuid);
		}
		return Bukkit.getPlayer(uuid);
	}

	public PlayerProfile getPlayerProfile() {
		return PlayerProfile.get(uuid);
	}

	public int getPing() {
		Player player = getPlayer();
		return player == null ? 0 : player.spigot().getPing();
	}

	public void broadcastTitle(String title, String subtitle) {
		TitleSender.sendTitle(getPlayer(), title, PacketPlayOutTitle.EnumTitleAction.TITLE, 0,
				Config.MATCH_END_DURATION.toInteger(), 5);
		TitleSender.sendTitle(getPlayer(), subtitle, PacketPlayOutTitle.EnumTitleAction.SUBTITLE, 0,
				Config.MATCH_END_DURATION.toInteger(), 5);
	}

	public void teleport(Location location) {
		if (getPlayer() == null) {
			return;
		}
		Tasks.run(() -> Util.teleport(getPlayer(), location));
	}

	public void addPotionsThrown() {
		potionsThrown++;
	}

	public void addPotionsMissed() {
		potionsMissed++;
	}

	public void handleHit(double damage) {
		hits++;
		combo++;
		lastHitTime = System.currentTimeMillis();
		damageDealt = damageDealt + damage;
		if (combo > longestCombo) {
			longestCombo = combo;
		}
		protectionUntil = -1;
	}

	public void handleGotHit(TeamPlayer damager, boolean blockedHit) {
		gotHits++;
		combo = 0;
		lastHitTime = 0;
		lastHitDamager = damager;
		if (blockedHit) {
			blockedHits++;
		}
	}

	/**
	 * Checks if the combo has expired (more than 10 seconds since last hit)
	 * 
	 * @return true if combo expired, false otherwise
	 */
	public boolean isComboExpired() {
		if (lastHitTime == 0) {
			return true;
		}
		long timeSinceLastHit = System.currentTimeMillis() - lastHitTime;
		return timeSinceLastHit > 10000; // 10 seconds in milliseconds
	}

	/**
	 * Gets the active combo count, which is only valid if:
	 * - Combo is greater than 1 (not 0 or 1)
	 * - Combo hasn't expired (within 10 seconds of last hit)
	 * 
	 * @return active combo count, or 0 if conditions not met
	 */
	public int getActiveCombo() {
		if (combo <= 1 || isComboExpired()) {
			return 0;
		}
		return combo;
	}

	public void respawn(Match match) {
		if (getPlayer() == null) {
			return;
		}
		kitLoadout.apply(match.getKit(), match, getPlayer());
		((CraftPlayer) getPlayer()).getHandle().setAbsorptionHearts(0);
		getPlayer().setHealth(getPlayer().getMaxHealth()); // A fix for #11 - Restore health each time when respawn
		getPlayer().getActivePotionEffects().clear(); // A fix for #389 - Remove effects like absorption when score
		lastHitDamager = null; // A fix for #11 - Prevent kill spam
								// (https://www.youtube.com/watch?v=oD6k0rrNVTk)
	}

}


Filename: .\main\java\rip\diamond\practice\misc\commands\DatabaseConvertCommand.java
package rip.diamond.practice.misc.commands;

import org.bson.Document;
import org.bukkit.command.CommandSender;
import rip.diamond.practice.Eden;
import rip.diamond.practice.config.Config;
import rip.diamond.practice.database.DatabaseHandler;
import rip.diamond.practice.database.impl.FlatFileHandler;
import rip.diamond.practice.database.impl.MongoHandler;
import rip.diamond.practice.util.CC;
import rip.diamond.practice.util.Common;
import rip.diamond.practice.util.Tasks;
import rip.diamond.practice.util.command.Command;
import rip.diamond.practice.util.command.CommandArgs;
import rip.diamond.practice.util.command.argument.CommandArguments;

import java.util.List;

public class DatabaseConvertCommand extends Command {

    @CommandArgs(name = "databaseconvert", permission = "eden.command.databaseconvert", inGameOnly = false)
    public void execute(CommandArguments command) {
        CommandSender sender = command.getSender();
        String[] args = command.getArgs();

        if (args.length == 0) {
            Common.sendMessage(sender, CC.RED + "Usage: /databaseconvert <mongo2flatfile|flatfile2mongo>");
            return;
        }

        String type = args[0];
        if (type.equalsIgnoreCase("mongo2flatfile")) {
            Common.sendMessage(sender, CC.YELLOW + "Starting conversion from MongoDB to FlatFile...");
            Tasks.runAsync(() -> {
                try {
                    // Source: Mongo
                    MongoHandler mongoHandler = new MongoHandler();
                    // We don't init mongoHandler here because we assume it might be active or we
                    // just want to read
                    // But strictly speaking, if we are in FlatFile mode, Mongo might not be
                    // initialized.
                    // So we should probably init it temporarily or assume the user has configured
                    // it.
                    // For safety, let's just use the raw connection logic or instantiate it.
                    // However, MongoHandler.init() connects to the database.

                    // If we are currently in FlatFile mode, we need to connect to Mongo to read.
                    // If we are in Mongo mode, we are already connected.

                    // Let's assume we can just create a new instance and init it for the purpose of
                    // this command.
                    // But we need to be careful not to conflict with existing connections if any.
                    // Actually, the safest way is to just create a new handler, init it, read, and
                    // close it.

                    mongoHandler.init();
                    List<Document> mongoDocs = mongoHandler.getAllProfiles();

                    // Target: FlatFile
                    // If we are in Mongo mode, FlatFile might not be active.
                    FlatFileHandler flatFileHandler = new FlatFileHandler();
                    flatFileHandler.init(); // Ensures folder exists

                    int count = 0;
                    for (Document doc : mongoDocs) {
                        flatFileHandler.saveDocumentRaw(doc);
                        count++;
                    }

                    // We don't necessarily need to shutdown flatfile handler as it just writes
                    // files.
                    // But we should shutdown mongo if we opened it just for this.
                    if (!Config.STORAGE_TYPE.toString().equalsIgnoreCase("MONGODB")) {
                        mongoHandler.shutdown();
                    }

                    Common.sendMessage(sender,
                            CC.GREEN + "Successfully converted " + count + " profiles from MongoDB to FlatFile.");

                } catch (Exception e) {
                    e.printStackTrace();
                    Common.sendMessage(sender,
                            CC.RED + "An error occurred during conversion. Check console for details.");
                }
            });

        } else if (type.equalsIgnoreCase("flatfile2mongo")) {
            Common.sendMessage(sender, CC.YELLOW + "Starting conversion from FlatFile to MongoDB...");
            Tasks.runAsync(() -> {
                try {
                    // Source: FlatFile
                    FlatFileHandler flatFileHandler = new FlatFileHandler();
                    flatFileHandler.init();
                    List<Document> flatFileDocs = flatFileHandler.getAllProfiles();

                    // Target: Mongo
                    MongoHandler mongoHandler = new MongoHandler();
                    // Only init if not already the active handler (though init is usually
                    // idempotent-ish or we should check)
                    // If we are in FlatFile mode, we MUST init Mongo.
                    if (!Config.STORAGE_TYPE.toString().equalsIgnoreCase("MONGODB")) {
                        mongoHandler.init();
                    } else {
                        // If we are in Mongo mode, we can potentially use the existing one,
                        // but creating a new one is safer to avoid state issues,
                        // provided the driver handles connection pooling correctly (which it does).
                        // However, to be safe and simple:
                        mongoHandler.init();
                    }

                    int count = 0;
                    for (Document doc : flatFileDocs) {
                        mongoHandler.saveDocumentRaw(doc);
                        count++;
                    }

                    if (!Config.STORAGE_TYPE.toString().equalsIgnoreCase("MONGODB")) {
                        mongoHandler.shutdown();
                    }

                    Common.sendMessage(sender,
                            CC.GREEN + "Successfully converted " + count + " profiles from FlatFile to MongoDB.");

                } catch (Exception e) {
                    e.printStackTrace();
                    Common.sendMessage(sender,
                            CC.RED + "An error occurred during conversion. Check console for details.");
                }
            });
        } else {
            Common.sendMessage(sender, CC.RED + "Usage: /databaseconvert <mongo2flatfile|flatfile2mongo>");
        }
    }
}


Filename: .\main\java\rip\diamond\practice\misc\commands\EdenCommand.java
package rip.diamond.practice.misc.commands;

import org.apache.commons.lang3.StringUtils;
import org.bukkit.command.CommandSender;
import org.bukkit.entity.Player;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.util.CC;
import rip.diamond.practice.util.Common;
import rip.diamond.practice.util.command.Command;
import rip.diamond.practice.util.command.CommandArgs;
import rip.diamond.practice.util.command.argument.CommandArguments;
import rip.diamond.practice.spigot.spigotapi.SpigotAPI;

import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

public class EdenCommand extends Command {

    @CommandArgs(name = "eden", inGameOnly = false)
    public void execute(CommandArguments command) {
        CommandSender sender = command.getSender();
        String[] args = command.getArgs();

        if (args.length == 0) {
            Common.sendMessage(sender,
                    CC.CHAT_BAR,
                    CC.AQUA + plugin.getDescription().getName() + CC.GRAY + " - " + CC.DARK_AQUA + "v"
                            + plugin.getDescription().getVersion(),
                    CC.WHITE + "Author: " + CC.AQUA
                            + StringUtils.join(plugin.getDescription().getAuthors(), CC.GRAY + ", " + CC.AQUA),
                    CC.WHITE + "Description: " + CC.AQUA + plugin.getDescription().getDescription(),
                    CC.WHITE + "Website: " + CC.AQUA + CC.UNDER_LINE + plugin.getDescription().getWebsite(),
                    CC.CHAT_BAR);
            return;
        }

        if (sender instanceof Player && !sender.hasPermission("eden.command.eden")) {
            Language.NO_PERMISSION.sendMessage((Player) sender);
            return;
        }

        Action action;
        try {
            action = Action.valueOf(args[0].toUpperCase());
        } catch (Exception e) {
            Common.sendMessage(sender, CC.RED + "Invalid action! Available action: "
                    + Arrays.stream(Action.values()).map(Action::name).collect(Collectors.joining(", ")));
            return;
        }

        switch (action) {
            case RELOAD:
                // Use centralized reload method to ensure all configs including menus.yml are
                // reloaded
                plugin.reload();
                Common.sendMessage(sender, CC.GREEN + "Files reloaded!", CC.YELLOW
                        + "Remember: some part of the files might require restart the server to work. And we strongly recommend");
                return;
            case DEBUG:
                plugin.getConfigFile().getConfiguration().set("debug", !plugin.getConfigFile().getBoolean("debug"));
                plugin.getConfigFile().save();
                plugin.getConfigFile().load();
                Common.sendMessage(sender,
                        CC.GREEN + "Debug is now: "
                                + (plugin.getConfigFile().getBoolean("debug") ? CC.GREEN + Language.ENABLED.toString()
                                        : CC.RED + Language.DISABLED.toString()));
                return;
            case SPIGOT:
                Common.sendMessage(sender, CC.YELLOW + "Eden is currently hooked to " + CC.AQUA
                        + SpigotAPI.INSTANCE.getSpigotType().name());
                return;
        }
    }

    @Override
    public List<String> getDefaultTabComplete(CommandArguments command) {
        return Arrays.stream(Action.values()).map(Action::name).collect(Collectors.toList());
    }

    enum Action {
        RELOAD, DEBUG, SPIGOT
    }
}


Filename: .\main\java\rip\diamond\practice\misc\commands\EloResetCommand.java
package rip.diamond.practice.misc.commands;

import rip.diamond.practice.util.Tasks;
import org.bson.Document;
import org.bukkit.Bukkit;
import org.bukkit.command.CommandSender;
import rip.diamond.practice.Eden;
import rip.diamond.practice.config.Config;
import rip.diamond.practice.misc.task.EloResetTask;
import rip.diamond.practice.profile.PlayerProfile;
import rip.diamond.practice.util.CC;
import rip.diamond.practice.util.Common;
import rip.diamond.practice.util.command.Command;
import rip.diamond.practice.util.command.CommandArgs;
import rip.diamond.practice.util.command.argument.CommandArguments;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.UUID;

public class EloResetCommand extends Command {

    @CommandArgs(name = "eloreset", permission = "eden.command.eloreset", inGameOnly = false)
    public void execute(CommandArguments command) {
        CommandSender sender = command.getSender();

        if (Bukkit.getOnlinePlayers().size() != 0) {
            Common.sendMessage(sender, CC.RED + "You cannot use this command when there is online players.");
            return;
        }

        if (PlayerProfile.getProfiles().size() != 0) {
            Common.sendMessage(sender, CC.RED + "You cannot use this command when player profile is not equal to 0");
            return;
        }

        String[] args = command.getArgs();

        if (args.length == 0) {
            // Use DatabaseManager
            Tasks.runAsync(() -> {
                List<Document> documents = Eden.INSTANCE.getDatabaseManager().getHandler().getAllProfiles();
                Tasks.run(() -> new EloResetTask(documents));
            });
            Common.sendMessage(sender, CC.YELLOW + "Starting Elo Reset calculation...");
        } else if (args.length == 1) {
            UUID uuid;
            try {
                uuid = UUID.fromString(args[0]);
            } catch (Exception e) {
                Common.sendMessage(sender, CC.RED + "Invalid UUID.");
                return;
            }

            Eden.INSTANCE.getDatabaseManager().getHandler().loadProfile(uuid, (document) -> {
                if (document == null) {
                    Common.sendMessage(sender, CC.RED + "Cannot find a document with uuid '" + uuid.toString() + "'");
                    return;
                }
                // Task must run on main thread as it extends TaskTicker
                Tasks.run(() -> new EloResetTask(Collections.singletonList(document)));
            });
        }
    }
}


Filename: .\main\java\rip\diamond\practice\misc\commands\LocationCommand.java
package rip.diamond.practice.misc.commands;

import org.bukkit.Location;
import org.bukkit.entity.Player;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.util.CC;
import rip.diamond.practice.util.Common;
import rip.diamond.practice.util.command.Command;
import rip.diamond.practice.util.command.CommandArgs;
import rip.diamond.practice.util.command.argument.CommandArguments;
import rip.diamond.practice.util.serialization.LocationSerialization;

import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

public class LocationCommand extends Command {
    @CommandArgs(name = "location", permission = "eden.command.location")
    public void execute(CommandArguments command) {
        Player player = command.getPlayer();
        String[] args = command.getArgs();

        if (args.length == 0) {
            Common.sendMessage(player, CC.RED + "Usage: /" + command.getLabel() + " <type>");
            return;
        } else if (args.length == 1) {
            LocationType type;
            try {
                type = LocationType.valueOf(args[0].toUpperCase());
            } catch (Exception e) {
                Common.sendMessage(player, CC.RED + "Invalid location type! Available type: " + Arrays.stream(LocationType.values()).map(LocationType::name).collect(Collectors.joining(", ")));
                return;
            }

            Location location = player.getLocation();
            switch (type) {
                case SPAWN:
                    plugin.getLobbyManager().setSpawnLocation(location);
                    plugin.getLocationFile().getConfiguration().set("spawn-location", LocationSerialization.serializeLocation(location));
                    plugin.getLocationFile().save();
                    break;
                case EDITOR:
                    plugin.getKitEditorManager().setEditorLocation(location);
                    plugin.getLocationFile().getConfiguration().set("editor-location", LocationSerialization.serializeLocation(location));
                    plugin.getLocationFile().save();
                    break;
                case SUMO_EVENT_A:
                    plugin.getLocationFile().getConfiguration().set("sumo-event.a", LocationSerialization.serializeLocation(location));
                    plugin.getLocationFile().save();
                    break;
                case SUMO_EVENT_B:
                    plugin.getLocationFile().getConfiguration().set("sumo-event.b", LocationSerialization.serializeLocation(location));
                    plugin.getLocationFile().save();
                    break;
                case SUMO_EVENT_SPECTATOR:
                    plugin.getLocationFile().getConfiguration().set("sumo-event.spectator", LocationSerialization.serializeLocation(location));
                    plugin.getLocationFile().save();
                    break;
                default:
                    return;
            }
            Language.LOCATION_CHANGED.sendMessage(player, type.name());
        }
    }

    @Override
    public List<String> getDefaultTabComplete(CommandArguments command) {
        return Arrays.stream(LocationType.values()).map(LocationType::name).collect(Collectors.toList());
    }

    enum LocationType {
        SPAWN,
        EDITOR,
        SUMO_EVENT_A,
        SUMO_EVENT_B,
        SUMO_EVENT_SPECTATOR
    }
}


Filename: .\main\java\rip\diamond\practice\misc\commands\ToggleItemFlagCommand.java
package rip.diamond.practice.misc.commands;

import org.bukkit.entity.Player;
import org.bukkit.inventory.ItemFlag;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.meta.ItemMeta;
import rip.diamond.practice.util.Checker;
import rip.diamond.practice.util.Common;
import rip.diamond.practice.util.command.Command;
import rip.diamond.practice.util.command.CommandArgs;
import rip.diamond.practice.util.command.argument.CommandArguments;

import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

public class ToggleItemFlagCommand extends Command {
    @CommandArgs(name = "toggleitemflag", permission = "eden.command.toggleitemflag")
    public void execute(CommandArguments command) {
        Player player = command.getPlayer();
        String[] args = command.getArgs();
        ItemStack itemStack = player.getItemInHand();

        if (itemStack == null) {
            Common.sendMessage(player, "&cYou must hold an item first!");
            return;
        }
        if (!Checker.isItemFlag(args[0])) {
            Common.sendMessage(player, "&c'" + args[0] + "' is not a valid ItemFlag!");
            return;
        }
        ItemFlag flag = ItemFlag.valueOf(args[0]);
        ItemMeta meta = itemStack.getItemMeta();
        if (meta.hasItemFlag(flag)) {
            meta.removeItemFlags(flag);
        } else {
            meta.addItemFlags(flag);
        }
        itemStack.setItemMeta(meta);
        Common.sendMessage(player, "&aToggled " + flag.name());
    }

    @Override
    public List<String> getDefaultTabComplete(CommandArguments command) {
        return Arrays.stream(ItemFlag.values()).map(ItemFlag::name).collect(Collectors.toList());
    }
}


Filename: .\main\java\rip\diamond\practice\misc\listeners\ChatListener.java
package rip.diamond.practice.misc.listeners;

import lombok.RequiredArgsConstructor;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.Listener;
import org.bukkit.event.player.AsyncPlayerChatEvent;
import rip.diamond.practice.Eden;
import rip.diamond.practice.config.Config;
import rip.diamond.practice.util.Checker;

@RequiredArgsConstructor
public class ChatListener implements Listener {

    private final Eden plugin;

    @EventHandler(priority = EventPriority.HIGH)
    public void onChat(AsyncPlayerChatEvent event) {
        Player player = event.getPlayer();

        if (Config.CHAT_FORMAT_ENABLED.toBoolean()) {
            String format = Config.CHAT_FORMAT_FORMAT.toString();
            if (Checker.isPluginEnabled("PlaceholderAPI")) {
                format = plugin.getHookManager().getPlaceholderAPIHook().setPlaceholders(player, format);
            }
            event.setFormat(format);
        }
    }

}


Filename: .\main\java\rip\diamond\practice\misc\listeners\GeneralListener.java
package rip.diamond.practice.misc.listeners;

import com.google.common.collect.ImmutableList;
import lombok.RequiredArgsConstructor;
import org.bukkit.Bukkit;
import org.bukkit.Difficulty;
import org.bukkit.Material;
import org.bukkit.entity.Entity;
import org.bukkit.entity.EntityType;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.Listener;
import org.bukkit.event.block.*;
import org.bukkit.event.entity.CreatureSpawnEvent;
import org.bukkit.event.hanging.HangingBreakEvent;
import org.bukkit.event.player.PlayerCommandPreprocessEvent;
import org.bukkit.event.player.PlayerInteractEvent;
import org.bukkit.event.player.PlayerLoginEvent;
import org.bukkit.event.player.PlayerPortalEvent;
import org.bukkit.event.weather.WeatherChangeEvent;
import org.bukkit.event.world.ChunkLoadEvent;
import org.bukkit.event.world.ChunkUnloadEvent;
import org.bukkit.event.world.PortalCreateEvent;
import org.bukkit.event.world.WorldLoadEvent;
import rip.diamond.practice.Eden;
import rip.diamond.practice.config.Config;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.events.EdenEvent;
import rip.diamond.practice.misc.task.EloResetTask;
import rip.diamond.practice.party.Party;
import rip.diamond.practice.profile.PlayerProfile;
import rip.diamond.practice.util.CC;
import rip.diamond.practice.util.Common;
import rip.diamond.practice.util.TaskTicker;

import java.util.List;

@RequiredArgsConstructor
public class GeneralListener implements Listener {

    private final Eden plugin;

    @EventHandler
    public void onLogin(PlayerLoginEvent event) {
        if (TaskTicker.getTickers().stream().anyMatch(taskTicker -> taskTicker instanceof EloResetTask)) {
            event.disallow(PlayerLoginEvent.Result.KICK_OTHER, CC.RED + "ELO is resetting...");
        }
    }

    @EventHandler
    public void onLoad(ChunkLoadEvent event) {
        for (Entity entity : event.getChunk().getEntities()) {
            entity.remove();
        }
    }

    /*@EventHandler
    public void onUnload(ChunkUnloadEvent event) {
        event.setCancelled(true);
    }*/

    @EventHandler
    public void onWorldLoad(WorldLoadEvent event) {
        event.getWorld().setDifficulty(Difficulty.HARD);
    }

    @EventHandler
    public void onWeatherChange(WeatherChangeEvent event) {
        event.setCancelled(true);
    }

    @EventHandler
    public void onCreatureSpawn(CreatureSpawnEvent event) {
        event.setCancelled(true);
    }

    @EventHandler
    public void onLeavesDecay(LeavesDecayEvent event) {
        event.setCancelled(true);
    }

    @EventHandler
    public void onHangingBreak(HangingBreakEvent event) {
        event.setCancelled(true);
    }

    @EventHandler
    public void onBlockBurn(BlockBurnEvent event) {
        event.setCancelled(true);
    }

    @EventHandler
    public void onBlockSpread(BlockSpreadEvent event) {
        event.setCancelled(true);
    }

    @EventHandler
    public void onPhysics(BlockPhysicsEvent event) {
        Material type = event.getBlock().getType();
        if (!Config.MATCH_REMOVE_CACTUS_SUGAR_CANE_PHYSICS.toBoolean()) {
            return;
        }
        if(type == Material.SUGAR_CANE_BLOCK || type == Material.CACTUS) {
            event.setCancelled(true);
        }
    }

    @EventHandler
    public void onBlockIgnite(BlockIgniteEvent event) {
        if (event.getCause() == BlockIgniteEvent.IgniteCause.LIGHTNING) {
            event.setCancelled(true);
        }
    }

    //Èò≤Ê≠¢Ë∏êË∏èËæ≤‰ΩúÁâ©
    @EventHandler
    public void onCropsTrampling(PlayerInteractEvent event) {
        if (event.getAction() == Action.PHYSICAL && event.getClickedBlock().getType() == Material.SOIL) {
            event.setCancelled(true);
        }
    }

    @EventHandler
    public void onCreatePortal(PortalCreateEvent event) {
        event.setCancelled(true);
    }

    @EventHandler
    public void onEnterPortal(PlayerPortalEvent event) {
        event.setCancelled(true);
    }

    @EventHandler
    public void onGrowth(BlockGrowEvent event) {
        event.setCancelled(true);
    }

}


Filename: .\main\java\rip\diamond\practice\misc\task\EloResetTask.java
package rip.diamond.practice.misc.task;

import org.bson.Document;
import rip.diamond.practice.config.Config;
import rip.diamond.practice.profile.PlayerProfile;
import rip.diamond.practice.profile.PlayerState;
import rip.diamond.practice.util.CC;
import rip.diamond.practice.util.Common;
import rip.diamond.practice.util.TaskTicker;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.stream.Collectors;

public class EloResetTask extends TaskTicker {

    private final List<Document> documents;
    private final Map<UUID, String> successUsers = new HashMap<>();
    private final Map<UUID, String> failUsers = new HashMap<>();
    private int i = 0;
    private boolean canProcessNext = true;

    public EloResetTask(List<Document> documents) {
        super(0, 20, true);
        this.documents = documents;
    }

    @Override
    public void onRun() {
        if (!canProcessNext) {
            return;
        }
        if (i >= documents.size()) {
            Common.broadcastMessage(
                    "",
                    CC.YELLOW + "Finished elo reset task.",
                    CC.YELLOW + "A total of " + CC.GREEN + successUsers.size() + " users " + CC.YELLOW + "has been reset",
                    CC.YELLOW + "A total of " + CC.RED + failUsers.size() + " users " + CC.YELLOW + "failed to reset"
            );
            if (failUsers.size() != 0) {
                Common.broadcastMessage(CC.YELLOW + "Failed users contain: ");
                Common.broadcastMessage(failUsers.entrySet().stream().map(entry -> " - " + CC.YELLOW + entry.getKey().toString() + CC.GRAY + " (" + entry.getValue() + ")").collect(Collectors.toList()));
            }
            Common.broadcastMessage("");
            cancel();
            return;
        }
        Document document = documents.get(i);
        resetElo(document);
        i++;
    }

    @Override
    public TickType getTickType() {
        return TickType.NONE;
    }

    @Override
    public int getStartTick() {
        return 0;
    }

    private void resetElo(Document document) {
        canProcessNext = false;

        UUID uuid = UUID.fromString(document.getString("uuid"));
        String username = document.getString("username");
        PlayerProfile profile = PlayerProfile.createPlayerProfile(uuid, username);

        Common.broadcastMessage(CC.YELLOW + "Processing to clear " + username + "'s elo... (" + i + "/" + documents.size() + ")");

        profile.setTemporary(true);
        profile.load(document, (success) -> {
            if (success) {
                profile.setPlayerState(PlayerState.IN_LOBBY); //Have to set the player state in here, otherwise PlayerProfile.save will not actually save because data won't be saved when player state is LOADING.
                profile.getKitData().forEach((s, kitData) -> {
                    kitData.setElo(Config.PROFILE_DEFAULT_ELO.toInteger());
                    kitData.setPeakElo(Config.PROFILE_DEFAULT_ELO.toInteger());
                });
                profile.save(false, (bool)-> {
                    canProcessNext = true;
                    PlayerProfile.getProfiles().remove(uuid);
                });
                Common.broadcastMessage(CC.GREEN + "Successfully wiped '" + username + "' elo.");
                successUsers.put(uuid, username);
            } else {
                Common.broadcastMessage(CC.RED + "Unable to load user '" + username + "' profile.");
                failUsers.put(uuid, username);
            }
        });
    }
}


Filename: .\main\java\rip\diamond\practice\party\Party.java
package rip.diamond.practice.party;

import lombok.Getter;
import lombok.Setter;
import org.bukkit.Bukkit;
import org.bukkit.Location;
import org.bukkit.entity.Player;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.event.PartyDisbandEvent;
import rip.diamond.practice.event.PartyJoinEvent;
import rip.diamond.practice.profile.PlayerProfile;
import rip.diamond.practice.profile.PlayerState;
import rip.diamond.practice.util.Clickable;
import rip.diamond.practice.util.Common;
import rip.diamond.practice.util.Util;
import rip.diamond.practice.util.VisibilityController;

import java.util.*;
import java.util.stream.Collectors;

@Getter
public class Party {

    @Getter private static final Map<UUID, Party> parties = new HashMap<>();

    private final UUID uniqueID = UUID.randomUUID();
    private final long createdAt = System.currentTimeMillis();
    @Setter private PartyMember leader;
    private final List<PartyMember> partyMembers = new ArrayList<>();
    private final Map<UUID, PartyInvite> invites = new HashMap<>();
    private int maxSize;
    private boolean muted = false;
    private PartyPrivacy privacy = PartyPrivacy.CLOSED;

    @Setter private long lastAnnounced = 0;

    public static Party getByPlayer(Player player) {
        return PlayerProfile.get(player).getParty();
    }

    public Party(Player player, int size) {
        this.leader = new PartyMember(player);
        this.maxSize = size;
        parties.put(uniqueID, this);

        PlayerProfile profile = PlayerProfile.get(player);
        profile.setParty(this);
        profile.setupItems();

        Language.PARTY_CREATED.sendMessage(player);
    }

    public void setMaxSize(int size) {
        if (leader == null) {
            broadcast(Language.PARTY_ERROR_LEADER_NOT_FOUND.toString());
            return;
        }

        maxSize = size;
        broadcast(Language.PARTY_SUCCESSFULLY_SET_MAX_SIZE.toString(size));
    }

    public void toggleChatRoom() {
        if (leader == null) {
            broadcast(Language.PARTY_ERROR_LEADER_NOT_FOUND.toString());
            return;
        }
        muted = !muted;

        broadcast(Language.PARTY_SUCCESSFULLY_SET_CHAT.toString(muted ? Language.DISABLED.toString() : Language.ENABLED.toString()));
    }

    public void announce() {
        if (leader == null) {
            broadcast(Language.PARTY_ERROR_LEADER_NOT_FOUND.toString());
            return;
        }

        Clickable clickable = new Clickable(Language.PARTY_ANNOUNCE_MESSAGE.toString(leader.getUsername()));
        clickable.add(Language.PARTY_ANNOUNCE_CLICKABLE.toString(), Language.PARTY_ANNOUNCE_HOVER.toString(), "/party join " + leader.getUsername());

        Bukkit.getOnlinePlayers().forEach(clickable::sendToPlayer);

        lastAnnounced = System.currentTimeMillis();
    }

    public void setPrivacy(PartyPrivacy privacy) {
        this.privacy = privacy;

        broadcast(Language.PARTY_PRIVACY_MESSAGE.toString(privacy.getReadable()));
    }

    public void broadcast(String... message) {
        getAllPartyMembers().forEach(partyMember -> {
            if (partyMember == null) {
                return;
            }
            Arrays.stream(message).forEach(msg -> partyMember.sendMessage(Language.PARTY_BROADCAST_FORMAT.toString(msg)));
        });
    }

    public void teleport(Location location) {
        getAllPartyMembers().forEach(partyMember -> {
            if (partyMember == null) {
                return;
            }
            Util.teleport(partyMember.getPlayer(), location);
        });
    }

    public void join(Player player, boolean force) {
        PlayerProfile profile = PlayerProfile.get(player);
        if (profile == null) {
            Language.PARTY_OWN_PROFILE_NOT_FOUND.sendMessage(player);
            return;
        }

        PartyJoinEvent event = new PartyJoinEvent(this, force);
        event.call();

        if (event.isCancelled()) {
            Common.sendMessage(player, event.getCancelReason());
            return;
        }

        invites.remove(player.getUniqueId());
        partyMembers.add(new PartyMember(player));
        profile.setParty(this);
        profile.setupItems();

        broadcast(force ? Language.PARTY_JOIN_MESSAGE_FORCE.toString(player.getName()) : Language.PARTY_JOIN_MESSAGE_NORMAL.toString(player.getName()));

        getAllPartyMembers().forEach(partyMember -> VisibilityController.updateVisibility(partyMember.getPlayer()));
    }

    public void leave(UUID targetUUID, boolean kick) {
        PartyMember member = getPartyMembers().stream().filter(partyMember -> partyMember.getUniqueID().equals(targetUUID)).findFirst().orElse(null);
        Player target = Bukkit.getPlayer(targetUUID);

        if (member == null) {
            if (target != null) {
                Language.PARTY_OWN_PROFILE_NOT_FOUND.sendMessage(target);
            }
            return;
        }

        PlayerProfile profile = PlayerProfile.get(target);
        if (profile == null) {
            Language.PARTY_OWN_PROFILE_NOT_FOUND.sendMessage(target);
            return;
        }

        partyMembers.removeIf(pm -> pm.getUniqueID().equals(member.getUniqueID()));
        profile.setParty(null);
        profile.setupItems();

        broadcast(kick ? Language.PARTY_LEAVE_MESSAGE_FORCE.toString(member.getUsername()) : Language.PARTY_LEAVE_MESSAGE_NORMAL.toString(member.getUsername()));

        VisibilityController.updateVisibility(target);
        getAllPartyMembers().forEach(partyMember -> VisibilityController.updateVisibility(partyMember.getPlayer()));
    }

    public void disband(boolean forced) {
        Party party = parties.remove(uniqueID);
        broadcast(Language.PARTY_DISBAND.toString());
        getAllPartyMembers().stream().map(partyMember -> PlayerProfile.get(partyMember.getUniqueID())).forEach(profile -> {
            profile.setParty(null);
            //Check if the player is in a match. This is to prevent player's inventory get reset when they are in match
            if (profile.getPlayerState() != PlayerState.IN_MATCH && profile.getMatch() == null) {
                profile.setupItems();
            }
        });
        getAllPartyMembers().forEach(partyMember -> VisibilityController.updateVisibility(partyMember.getPlayer()));

        PartyDisbandEvent event = new PartyDisbandEvent(party, forced);
        event.call();
    }

    public void invite(Player player) {
        PartyInvite invite = new PartyInvite(player);
        invites.put(player.getUniqueId(), invite);

        broadcast(Language.PARTY_INVITE_TEAM_MESSAGE.toString(leader.getUsername(), invite.getUsername()));

        Clickable clickable = new Clickable(Language.PARTY_INVITE_INVITE_MESSAGE.toString(leader.getUsername()));
        clickable.add(Language.PARTY_INVITE_CLICKABLE.toString(), Language.PARTY_INVITE_HOVER.toString(), "/party join " + leader.getUsername());
        clickable.sendToPlayer(player);
    }

    public void sendInformation(Player player) {
        Language.PARTY_INFORMATION.sendListOfMessage(player, getLeader().getUsername(), getAllPartyMembers().size(), maxSize, getPartyMembers().stream().map(PartyMember::getUsername).collect(Collectors.joining(", ")), privacy.getReadable(), muted ? Language.DISABLED.toString() : Language.ENABLED.toString());
    }

    /**
     * Get all party members, including the leader
     */
    public List<PartyMember> getAllPartyMembers() {
        List<PartyMember> members = new ArrayList<>();
        members.add(leader);
        members.addAll(partyMembers);
        return members;
    }

    public PartyMember getMember(Player player) {
        return getAllPartyMembers().stream().filter(partyMember -> partyMember.getUniqueID().equals(player.getUniqueId())).findFirst().orElse(null);
    }

    public PartyMember getMember(UUID uuid) {
        return getAllPartyMembers().stream().filter(partyMember -> partyMember.getUniqueID().equals(uuid)).findFirst().orElse(null);
    }

    public PartyMember getMember(String username) { //Need to use real name, not disguised name
        return getAllPartyMembers().stream().filter(partyMember -> partyMember.getUsername().equalsIgnoreCase(username)).findFirst().orElse(null);
    }

    public boolean isFull() {
        return getAllPartyMembers().size() >= maxSize;
    }

    public boolean isAllPlayersInState(PlayerState... playerStates) {
        return getAllPartyMembers().stream().map(partyMember -> PlayerProfile.get(partyMember.getUniqueID())).filter(Objects::nonNull).allMatch(practicePlayer -> Arrays.asList(playerStates).contains(practicePlayer.getPlayerState()));
    }

}


Filename: .\main\java\rip\diamond\practice\party\PartyInvite.java
package rip.diamond.practice.party;

import lombok.Getter;
import org.bukkit.entity.Player;

import java.util.UUID;

public class PartyInvite {

	@Getter private final UUID uuid;
	@Getter private final String username;
	private final long expiresAt = System.currentTimeMillis() + 30000L;

	public PartyInvite(Player player) {
		this.uuid = player.getUniqueId();
		this.username = player.getName();
	}

	public boolean isExpired() {
		return System.currentTimeMillis() >= expiresAt;
	}

}


Filename: .\main\java\rip\diamond\practice\party\PartyListener.java
package rip.diamond.practice.party;

import org.bukkit.ChatColor;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.Listener;
import org.bukkit.event.player.AsyncPlayerChatEvent;
import org.bukkit.event.player.PlayerQuitEvent;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.profile.PlayerProfile;

public class PartyListener implements Listener {

    @EventHandler(priority = EventPriority.HIGH, ignoreCancelled = true) //ignoreCancelled because if someone is muted, this event will not perform
    public void onChat(AsyncPlayerChatEvent event) {
        Player player = event.getPlayer();
        String message = event.getMessage();
        Party party = Party.getByPlayer(player);
        if (party == null) {
            return;
        }

        boolean isPartyChat = party.getMember(player).isPartyChat();
        if (message.startsWith("!") || message.startsWith("@") || isPartyChat) {
            event.setCancelled(true);
            if (party.isMuted() && !party.getLeader().getUniqueID().equals(player.getUniqueId())) {
                Language.PARTY_CHAT_OFF.sendMessage(player);
                return;
            }
            party.broadcast(Language.PARTY_PARTY_CHAT_FORMAT.toString(player.getName(), ChatColor.stripColor(isPartyChat ? event.getMessage() : event.getMessage().substring(1))));
        }
    }

    @EventHandler
    public void onQuit(PlayerQuitEvent event) {
        Player player = event.getPlayer();
        PlayerProfile profile = PlayerProfile.get(player);

        //Profile will be null if the profile is not loaded in PlayerJoinEvent
        if (profile == null) {
            return;
        }
        Party party = Party.getByPlayer(player);
        if (party == null) {
            return;
        }

        if (party.getLeader().getUniqueID().equals(player.getUniqueId())) {
            party.broadcast(Language.PARTY_DISBAND_LEADER_LEFT.toString());
            party.disband(false);
        } else {
            party.broadcast(Language.PARTY_QUIT.toString(player.getName()));
            party.leave(player.getUniqueId(), false);
        }
    }

}


Filename: .\main\java\rip\diamond\practice\party\PartyMember.java
package rip.diamond.practice.party;

import lombok.Getter;
import org.bukkit.Bukkit;
import org.bukkit.entity.Player;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.profile.PlayerProfile;
import rip.diamond.practice.util.Common;

import java.util.List;
import java.util.UUID;

@Getter
public class PartyMember {

    private final UUID uniqueID;
    private final String username;
    private boolean partyChat = false;

    public PartyMember(Player player) {
        this.uniqueID = player.getUniqueId();
        this.username = player.getName();
    }

    public PlayerProfile getProfile() {
        return PlayerProfile.get(uniqueID);
    }

    public Player getPlayer() {
        return Bukkit.getPlayer(uniqueID);
    }

    public void sendMessage(String... messages) {
        if (getPlayer() == null) {
            return;
        }
        Common.sendMessage(getPlayer(), messages);
    }

    public void sendMessage(List<String> messages) {
        if (getPlayer() == null) {
            return;
        }
        Common.sendMessage(getPlayer(), messages);
    }

    public void toggleChat() {
        this.partyChat = !this.partyChat;

        Language.PARTY_TOGGLE_PARTY_CHAT.sendMessage(getPlayer(), this.partyChat ? Language.ENABLED.toString() : Language.DISABLED.toString());
    }
}


Filename: .\main\java\rip\diamond\practice\party\PartyPrivacy.java
package rip.diamond.practice.party;

import lombok.AllArgsConstructor;
import lombok.Getter;
import rip.diamond.practice.config.Language;

@AllArgsConstructor
@Getter
public enum PartyPrivacy {

	OPEN(Language.PARTY_PRIVACY_OPEN.toString()),
	CLOSED(Language.PARTY_PRIVACY_CLOSED.toString());

	private final String readable;

}


Filename: .\main\java\rip\diamond\practice\party\command\ChooseMatchTypeCommand.java
package rip.diamond.practice.party.command;

import org.bukkit.entity.Player;
import rip.diamond.practice.arenas.Arena;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.kits.Kit;
import rip.diamond.practice.kits.KitMatchType;
import rip.diamond.practice.party.Party;
import rip.diamond.practice.party.fight.menu.ChooseArenaMenu;
import rip.diamond.practice.party.fight.menu.ChooseKitMenu;
import rip.diamond.practice.party.fight.menu.ChooseMatchTypeMenu;
import rip.diamond.practice.profile.PlayerProfile;
import rip.diamond.practice.profile.PlayerState;
import rip.diamond.practice.util.Checker;
import rip.diamond.practice.util.Common;
import rip.diamond.practice.util.command.Command;
import rip.diamond.practice.util.command.CommandArgs;
import rip.diamond.practice.util.command.argument.CommandArguments;

public class ChooseMatchTypeCommand extends Command {
    @CommandArgs(name = "choosematchtype")
    public void execute(CommandArguments command) {
        Player player = command.getPlayer();
        PlayerProfile profile = PlayerProfile.get(player);
        String[] args = command.getArgs();
        if (profile.getPlayerState() != PlayerState.IN_LOBBY) {
            return;
        }

        Party party = Party.getByPlayer(player);
        if (party == null) {
            Language.PARTY_NOT_IN_A_PARTY.sendMessage(player);
            return;
        }
        if (!party.getLeader().getPlayer().getUniqueId().equals(player.getUniqueId())) {
            Language.PARTY_ONLY_LEADER.sendMessage(player);
            return;
        }

        if (args.length == 0) {
            new ChooseMatchTypeMenu().openMenu(player);
            return;
        } else if (args.length == 1) {
            if (!Checker.isKitMatchType(args[0])) {
                Language.PARTY_INVALID_MATCH_TYPE.sendMessage(player, args[0]);
                return;
            }
            KitMatchType type = KitMatchType.valueOf(args[0]);
            new ChooseKitMenu(type).openMenu(player);
            return;
        } else if (args.length == 2) {
            if (!Checker.isKitMatchType(args[0])) {
                Language.PARTY_INVALID_MATCH_TYPE.sendMessage(player, args[0]);
                return;
            }
            KitMatchType type = KitMatchType.valueOf(args[0]);

            Kit kit = Kit.getByName(args[1]);
            if (kit == null) {
                Language.DUEL_INVALID_KIT.sendMessage(player, args[1]);
                return;
            }
            new ChooseArenaMenu(type, kit).openMenu(player);
            return;
        } else if (args.length == 3) {
            if (!Checker.isKitMatchType(args[0])) {
                Language.PARTY_INVALID_MATCH_TYPE.sendMessage(player, args[0]);
                return;
            }
            KitMatchType type = KitMatchType.valueOf(args[0]);

            Kit kit = Kit.getByName(args[1]);
            if (kit == null) {
                Language.PARTY_INVALID_KIT.sendMessage(player, args[1]);
                return;
            }

            Arena arena = Arena.getEnabledArena(args[2], kit);
            if (arena == null) {
                Language.PARTY_INVALID_ARENA.sendMessage(player, args[2]);
                return;
            }

            plugin.getPartyFightManager().startPartyEvent(player, type, kit, Arena.getEnabledArena(kit));
            return;
        }
    }
}


Filename: .\main\java\rip\diamond\practice\party\command\OtherPartiesCommand.java
package rip.diamond.practice.party.command;

import org.bukkit.entity.Player;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.party.Party;
import rip.diamond.practice.party.fight.menu.OtherPartiesMenu;
import rip.diamond.practice.profile.PlayerProfile;
import rip.diamond.practice.profile.PlayerState;
import rip.diamond.practice.util.command.Command;
import rip.diamond.practice.util.command.CommandArgs;
import rip.diamond.practice.util.command.argument.CommandArguments;

public class OtherPartiesCommand extends Command {
    @CommandArgs(name = "otherparties")
    public void execute(CommandArguments command) {
        Player player = command.getPlayer();
        PlayerProfile profile = PlayerProfile.get(player);
        if (profile.getPlayerState() != PlayerState.IN_LOBBY) {
            return;
        }

        Party party = Party.getByPlayer(player);
        if (party == null) {
            Language.PARTY_NOT_IN_A_PARTY.sendMessage(player);
            return;
        }
        if (!party.getLeader().getPlayer().getUniqueId().equals(player.getUniqueId())) {
            Language.PARTY_ONLY_LEADER.sendMessage(player);
            return;
        }

        new OtherPartiesMenu().openMenu(player);
    }
}


Filename: .\main\java\rip\diamond\practice\party\command\PartyCommand.java
package rip.diamond.practice.party.command;

import org.bukkit.Bukkit;
import org.bukkit.entity.Player;
import rip.diamond.practice.config.Config;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.party.Party;
import rip.diamond.practice.party.PartyMember;
import rip.diamond.practice.party.PartyPrivacy;
import rip.diamond.practice.profile.PlayerProfile;
import rip.diamond.practice.profile.PlayerState;
import rip.diamond.practice.profile.ProfileSettings;
import rip.diamond.practice.util.Checker;
import rip.diamond.practice.util.Util;
import rip.diamond.practice.util.command.Command;
import rip.diamond.practice.util.command.CommandArgs;
import rip.diamond.practice.util.command.argument.CommandArguments;

public class PartyCommand extends Command {
    @CommandArgs(name = "party", aliases = {"team", "p"})
    public void execute(CommandArguments command) {
       Player player = command.getPlayer();
       String[] args = command.getArgs();

        if (args.length == 1) {
            if (args[0].equalsIgnoreCase("create")) {
                if (Party.getByPlayer(player) != null) {
                    Language.PARTY_IN_A_PARTY.sendMessage(player);
                    return;
                }

                PlayerProfile profile = PlayerProfile.get(player);
                if (profile.getPlayerState() != PlayerState.IN_LOBBY) {
                    Language.PARTY_WRONG_STATE.sendMessage(player);
                    return;
                }

                Party party = new Party(player, Config.PARTY_DEFAULT_MAX_SIZE.toInteger());
                return;
            }
            else if (args[0].equalsIgnoreCase("leave") || args[0].equalsIgnoreCase("disband")) {
                Party party = Party.getByPlayer(player);
                if (party == null) {
                    Language.PARTY_NOT_IN_A_PARTY.sendMessage(player);
                    return;
                }
                if (party.getLeader().getUniqueID().equals(player.getUniqueId())) {
                    party.disband(false);
                } else {
                    party.leave(player.getUniqueId(), false);
                }
                return;
            }
            else if (args[0].equalsIgnoreCase("open")) {
                Party party = Party.getByPlayer(player);
                if (party == null) {
                    Language.PARTY_NOT_IN_A_PARTY.sendMessage(player);
                    return;
                }
                if (!party.getLeader().getUniqueID().equals(player.getUniqueId())) {
                    Language.PARTY_ONLY_LEADER.sendMessage(player);
                    return;
                }
                party.setPrivacy(PartyPrivacy.OPEN);
                return;
            }
            else if (args[0].equalsIgnoreCase("close")) {
                Party party = Party.getByPlayer(player);
                if (party == null) {
                    Language.PARTY_NOT_IN_A_PARTY.sendMessage(player);
                    return;
                }
                if (!party.getLeader().getUniqueID().equals(player.getUniqueId())) {
                    Language.PARTY_ONLY_LEADER.sendMessage(player);
                    return;
                }
                party.setPrivacy(PartyPrivacy.CLOSED);
                return;
            }
            else if (args[0].equalsIgnoreCase("chat") || args[0].equalsIgnoreCase("c")) {
                Party party = Party.getByPlayer(player);
                if (party == null) {
                    Language.PARTY_NOT_IN_A_PARTY.sendMessage(player);
                    return;
                }
                party.getMember(player).toggleChat();
                return;
            }
            else if (args[0].equalsIgnoreCase("mute")) {
                Party party = Party.getByPlayer(player);
                if (party == null) {
                    Language.PARTY_NOT_IN_A_PARTY.sendMessage(player);
                    return;
                }
                if (!party.getLeader().getUniqueID().equals(player.getUniqueId())) {
                    Language.PARTY_ONLY_LEADER.sendMessage(player);
                    return;
                }
                party.toggleChatRoom();
                return;
            }
            else if (args[0].equalsIgnoreCase("announce")) {
                Party party = Party.getByPlayer(player);
                if (party == null) {
                    Language.PARTY_NOT_IN_A_PARTY.sendMessage(player);
                    return;
                }
                PlayerProfile profile = PlayerProfile.get(player);
                if (profile.getPlayerState() != PlayerState.IN_LOBBY) {
                    Language.PARTY_WRONG_STATE.sendMessage(player);
                    return;
                }
                if (!party.getLeader().getUniqueID().equals(player.getUniqueId())) {
                    Language.PARTY_ONLY_LEADER.sendMessage(player);
                    return;
                }
                if (!player.hasPermission("eden.party.announce")) {
                    Language.NO_PERMISSION.sendMessage(player);
                    return;
                }
                if (party.getPrivacy() != PartyPrivacy.OPEN) {
                    Language.PARTY_PARTY_NOT_OPEN.sendMessage(player);
                    return;
                }
                if (party.getLastAnnounced() + (Config.PARTY_ANNOUNCE_COOLDOWN.toInteger() * 1000L) > System.currentTimeMillis()) {
                    Language.PARTY_ANNOUNCE_COOLDOWN.sendMessage(player, Config.PARTY_ANNOUNCE_COOLDOWN);
                    return;
                }
                party.announce();
                return;
            }
            else if (args[0].equalsIgnoreCase("list")) {
                Util.performCommand(player, "party list " + player.getName());
                return;
            }
        } else if (args.length == 2) {
            if (args[0].equalsIgnoreCase("join")) {
                Player target = Bukkit.getPlayer(args[1]);
                if (target == null) {
                    Language.PARTY_PLAYER_NOT_FOUND.sendMessage(player, args[1]);
                    return;
                }
                PlayerProfile profile = PlayerProfile.get(player);
                if (profile.getPlayerState() != PlayerState.IN_LOBBY) {
                    Language.PARTY_WRONG_STATE.sendMessage(player);
                    return;
                }
                if (Party.getByPlayer(player) != null) {
                    Language.PARTY_IN_A_PARTY.sendMessage(player);
                    return;
                }
                Party party = Party.getByPlayer(target);
                if (party == null) {
                    Language.PARTY_PARTY_NOT_FOUND.sendMessage(player, target.getName());
                    return;
                }
                if (party.isFull() && !player.hasPermission("eden.party.forcejoin")) {
                    Language.PARTY_FULL.sendMessage(player);
                    return;
                }
                if (party.getAllPartyMembers().stream().map(PartyMember::getUniqueID).anyMatch(uuid -> player.getUniqueId().equals(uuid))) {
                    Language.PARTY_ALREADY_IN_PARTY.sendMessage(player);
                    return;
                }
                if (party.getInvites().containsKey(player.getUniqueId())) {
                    party.getInvites().remove(player.getUniqueId());
                    party.join(player, false);
                } else if (party.getPrivacy() == PartyPrivacy.OPEN) {
                    party.join(player, false);
                } else if (player.hasPermission("eden.party.forcejoin")){
                    party.join(player, true);
                } else {
                    Language.PARTY_NOT_INVITED.sendMessage(player);
                }
                return;
            } else if (args[0].equalsIgnoreCase("list")) {
                Player target = Bukkit.getPlayer(args[1]);
                if (target == null) {
                    Language.PARTY_PLAYER_NOT_FOUND.sendMessage(player, args[1]);
                    return;
                }
                Party party = Party.getByPlayer(target);
                if (party == null) {
                    Language.PARTY_PARTY_NOT_FOUND.sendMessage(player, target.getName());
                    return;
                }
                party.sendInformation(player);
                return;
            } else if (args[0].equalsIgnoreCase("invite")) {
                Player target = Bukkit.getPlayer(args[1]);
                if (target == null) {
                    Language.PARTY_PLAYER_NOT_FOUND.sendMessage(player, args[1]);
                    return;
                }
                if (player == target) {
                    Language.PARTY_CANNOT_INTERACT_SELF.sendMessage(player);
                    return;
                }
                PlayerProfile targetProfile = PlayerProfile.get(player);
                if (targetProfile == null) {
                    Language.PARTY_PLAYER_NOT_FOUND.sendMessage(player, args[1]);
                    return;
                }
                if (!targetProfile.getSettings().get(ProfileSettings.ALLOW_PARTY_INVITE).isEnabled()) {
                    Language.PARTY_DISABLED_PARTY_INVITE.sendMessage(player);
                    return;
                }

                Party party = Party.getByPlayer(player);
                if (party == null) {
                    party = new Party(player, Config.PARTY_DEFAULT_MAX_SIZE.toInteger());
                }

                if (!party.getLeader().getUniqueID().equals(player.getUniqueId())) {
                    Language.PARTY_ONLY_LEADER.sendMessage(player);
                    return;
                }
                if (party.getInvites().values().stream().filter(partyInvite -> !partyInvite.isExpired()).anyMatch(partyInvite -> partyInvite.getUuid().equals(target.getUniqueId()))) {
                    Language.PARTY_ALREADY_INVITE.sendMessage(player);
                    return;
                }
                Party targetParty = Party.getByPlayer(target);
                if (targetParty != null) {
                    Language.PARTY_TARGET_ALREADY_IN_PARTY.sendMessage(player);
                    return;
                }
                party.invite(target);
                return;
            } else if (args[0].equalsIgnoreCase("kick")) {
                Player target = Bukkit.getPlayer(args[1]);
                if (target == null) {
                    Language.PARTY_PLAYER_NOT_FOUND.sendMessage(player, args[1]);
                    return;
                }
                if (player == target) {
                    Language.PARTY_CANNOT_INTERACT_SELF.sendMessage(player);
                    return;
                }
                Party party = Party.getByPlayer(player);
                if (party == null) {
                    Language.PARTY_NOT_IN_A_PARTY.sendMessage(player);
                    return;
                }
                if (!party.getLeader().getUniqueID().equals(player.getUniqueId())) {
                    Language.PARTY_ONLY_LEADER.sendMessage(player);
                    return;
                }
                PartyMember partyMember = party.getMember(target);
                if (partyMember == null) {
                    Language.PARTY_PLAYER_NOT_FOUND.sendMessage(player, args[1]);
                    return;
                }
                party.leave(partyMember.getUniqueID(), true);
                return;
            } else if (args[0].equalsIgnoreCase("size")) {
                if (!Checker.isInteger(args[1])) {
                    Language.PARTY_NOT_INTEGER.sendMessage(player, args[1]);
                    return;
                }
                int size = Integer.parseInt(args[1]);
                if (size < 1) {
                    Language.PARTY_SIZE_BELOW_1.sendMessage(player);
                    return;
                }
                Party party = Party.getByPlayer(player);
                if (party == null) {
                    Language.PARTY_NOT_IN_A_PARTY.sendMessage(player);
                    return;
                }
                if (!party.getLeader().getUniqueID().equals(player.getUniqueId())) {
                    Language.PARTY_ONLY_LEADER.sendMessage(player);
                    return;
                }
                //Should not happen, but just in case
                if (party.getLeader().getPlayer() == null) {
                    Language.PARTY_ERROR_LEADER_NOT_FOUND.sendMessage(player);
                    return;
                }
                int canSetMaxSize = party.getLeader().getPlayer().getEffectivePermissions().stream().filter(permissionAttachmentInfo -> permissionAttachmentInfo.getPermission().contains("eden.party.limits.")).mapToInt(permissionAttachmentInfo -> Integer.parseInt(permissionAttachmentInfo.getPermission().replaceAll("eden.party.limits.", ""))).max().orElse(Config.PARTY_DEFAULT_MAX_SIZE.toInteger());
                if (canSetMaxSize < size) {
                    Language.PARTY_MAX_SIZE.sendMessage(player, canSetMaxSize);
                    return;
                }
                party.setMaxSize(size);
                return;
            }
        }

        Language.PARTY_HELP_MESSAGE.sendListOfMessage(player);
    }
}


Filename: .\main\java\rip\diamond\practice\party\fight\PartyFightManager.java
package rip.diamond.practice.party.fight;

import org.apache.commons.lang3.StringUtils;
import org.bukkit.entity.Player;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.arenas.Arena;
import rip.diamond.practice.arenas.ArenaDetail;
import rip.diamond.practice.kits.Kit;
import rip.diamond.practice.kits.KitMatchType;
import rip.diamond.practice.match.impl.FFAMatch;
import rip.diamond.practice.match.impl.TeamMatch;
import rip.diamond.practice.match.team.Team;
import rip.diamond.practice.match.team.TeamPlayer;
import rip.diamond.practice.party.Party;
import rip.diamond.practice.party.PartyMember;
import rip.diamond.practice.profile.PlayerProfile;
import rip.diamond.practice.profile.PlayerState;
import rip.diamond.practice.util.exception.PracticeUnexpectedException;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;

public class PartyFightManager {

    public void startPartyEvent(Player leader, KitMatchType matchType, Kit kit, Arena arena) {
        Party party = Party.getByPlayer(leader);
        if (party == null) {
            Language.PARTY_NOT_IN_A_PARTY.sendMessage(leader);
            return;
        }
        if (!party.getLeader().getUniqueID().equals(leader.getUniqueId())) {
            Language.PARTY_START_PARTY_FIGHT_ONLY_LEADER.sendMessage(leader);
            return;
        }

        if (party.getAllPartyMembers().size() < 2) {
            Language.PARTY_START_PARTY_FIGHT_NEED_MORE_THAN_2.sendMessage(leader);
            return;
        }

        if (arena.isEdited()) {
            Language.PARTY_START_PARTY_FIGHT_ARENA_DISABLED.sendMessage(leader);
            return;
        }

        ArenaDetail arenaDetail = Arena.getArenaDetail(arena);
        if (arenaDetail == null) {
            Language.PARTY_START_PARTY_FIGHT_CANNOT_FIND_ARENA.sendMessage(leader);
            return;
        }

        List<String> notInLobbyPlayers = new ArrayList<>();
        party.getAllPartyMembers().stream().filter(partyMember -> PlayerProfile.get(partyMember.getPlayer()).getPlayerState() != PlayerState.IN_LOBBY).forEach(pm -> notInLobbyPlayers.add(pm.getUsername()));
        if (!notInLobbyPlayers.isEmpty()) {
            Language.PARTY_START_PARTY_FIGHT_PLAYERS_NOT_IN_LOBBY.sendMessage(leader, StringUtils.join(notInLobbyPlayers, ", "));
            return;
        }

        switch (matchType) {
            case FFA:
                List<Team> teams = new ArrayList<>();
                party.getAllPartyMembers().forEach(partyMember -> teams.add(new Team(new TeamPlayer(partyMember.getPlayer()))));

                FFAMatch ffaMatch = new FFAMatch(arenaDetail, kit, teams);
                ffaMatch.start();
                return;
            case SPLIT:
                List<Player> players = party.getAllPartyMembers().stream().map(PartyMember::getPlayer).collect(Collectors.toList());
                Collections.shuffle(players);

                Team team1 = new Team(new TeamPlayer(players.get(0)));
                Team team2 = new Team(new TeamPlayer(players.get(1)));

                players.stream().filter(player -> !team1.containsPlayer(player) && !team2.containsPlayer(player)).forEach(player -> {
                    if (team1.getTeamPlayers().size() < team2.getTeamPlayers().size()) {
                        team1.getTeamPlayers().add(new TeamPlayer(player));
                    } else {
                        team2.getTeamPlayers().add(new TeamPlayer(player));
                    }
                });

                TeamMatch teamMatch = new TeamMatch(arenaDetail, kit, team1, team2);
                teamMatch.start();
                return;
            default:
                throw new PracticeUnexpectedException("This should not happen");
        }
    }

}


Filename: .\main\java\rip\diamond\practice\party\fight\menu\ChooseArenaMenu.java
package rip.diamond.practice.party.fight.menu;

import lombok.RequiredArgsConstructor;
import org.bukkit.Material;
import org.bukkit.entity.Player;
import org.bukkit.event.inventory.ClickType;
import org.bukkit.inventory.ItemStack;
import rip.diamond.practice.Eden;
import rip.diamond.practice.arenas.Arena;
import rip.diamond.practice.arenas.ArenaDetail;
import rip.diamond.practice.kits.Kit;
import rip.diamond.practice.kits.KitMatchType;
import rip.diamond.practice.util.BasicConfigFile;
import rip.diamond.practice.util.CC;
import rip.diamond.practice.util.Common;
import rip.diamond.practice.util.ItemBuilder;
import rip.diamond.practice.util.menu.Button;
import rip.diamond.practice.util.menu.Menu;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

@RequiredArgsConstructor
public class ChooseArenaMenu extends Menu {
    private final KitMatchType kitMatchType;
    private final Kit kit;
    private final int page;

    public ChooseArenaMenu(KitMatchType kitMatchType, Kit kit) {
        this(kitMatchType, kit, 1);
    }

    @Override
    public String getTitle(Player player) {
        BasicConfigFile config = Eden.INSTANCE.getMenusConfig().getConfig();
        return CC.translate(config.getString("party-choose-arena-menu.title"));
    }

    @Override
    public int getSize() {
        BasicConfigFile config = Eden.INSTANCE.getMenusConfig().getConfig();
        String sizeStr = config.getString("party-choose-arena-menu.size");

        if ("dynamic".equalsIgnoreCase(sizeStr)) {
            if (page > 1) {
                return config.getInt("party-choose-arena-menu.max-size");
            }

            int itemsPerPage = getItemsPerPage(config);
            List<Arena> arenas = getFilteredArenas();
            int itemsOnThisPage = Math.min(arenas.size() - ((page - 1) * itemsPerPage), itemsPerPage);

            boolean hasBorder = config.getBoolean("party-choose-arena-menu.border.enabled");
            int contentSlots = itemsOnThisPage;
            int rowsNeeded = (int) Math.ceil(contentSlots / 7.0);
            int totalRows = rowsNeeded + (hasBorder ? 2 : 0);

            int maxSize = config.getInt("party-choose-arena-menu.max-size");
            int calculatedSize = Math.max(27, Math.min(totalRows * 9, maxSize));

            return ((calculatedSize + 8) / 9) * 9;
        } else {
            return config.getInt("party-choose-arena-menu.size");
        }
    }

    @Override
    public Map<Integer, Button> getButtons(Player player) {
        Map<Integer, Button> buttons = new HashMap<>();
        BasicConfigFile config = Eden.INSTANCE.getMenusConfig().getConfig();
        int itemsPerPage = getItemsPerPage(config);

        // Filler
        if (config.getBoolean("party-choose-arena-menu.filler.enabled")) {
            ItemStack filler = new ItemBuilder(
                    org.bukkit.Material.valueOf(config.getString("party-choose-arena-menu.filler.material")))
                    .durability(config.getInt("party-choose-arena-menu.filler.data"))
                    .name(" ")
                    .build();
            for (int i = 0; i < getSize(); i++) {
                buttons.put(i, new Button() {
                    @Override
                    public ItemStack getButtonItem(Player player) {
                        return filler;
                    }
                });
            }
        }

        // Border
        if (config.getBoolean("party-choose-arena-menu.border.enabled")) {
            ItemStack border = new ItemBuilder(
                    org.bukkit.Material.valueOf(config.getString("party-choose-arena-menu.border.material")))
                    .durability(config.getInt("party-choose-arena-menu.border.data"))
                    .name(" ")
                    .build();
            int size = getSize();
            for (int i = 0; i < size; i++) {
                if (i < 9 || i >= size - 9 || i % 9 == 0 || i % 9 == 8) {
                    buttons.put(i, new Button() {
                        @Override
                        public ItemStack getButtonItem(Player player) {
                            return border;
                        }
                    });
                }
            }
        }

        // Random Arena Button
        int randomSlot = config.getInt("party-choose-arena-menu.items.random-arena-button.slot");
        buttons.put(randomSlot, new Button() {
            @Override
            public ItemStack getButtonItem(Player player) {
                return new ItemBuilder(
                        org.bukkit.Material.valueOf(
                                config.getString("party-choose-arena-menu.items.random-arena-button.material")))
                        .name(config.getString("party-choose-arena-menu.items.random-arena-button.name"))
                        .lore(config.getStringList("party-choose-arena-menu.items.random-arena-button.lore"))
                        .build();
            }

            @Override
            public void clicked(Player player, ClickType clickType) {
                Arena arena = Arena.getEnabledArena(kit);
                if (arena == null) {
                    Common.log("[Eden] There's no available arenas for kit " + kit.getName()
                            + ", consider add more arenas.");
                    return;
                }
                player.closeInventory();
                Eden.INSTANCE.getPartyFightManager().startPartyEvent(player, kitMatchType, kit, arena);
            }
        });

        // Go Back Button
        if (config.getBoolean("party-choose-arena-menu.items.go-back.enabled")) {
            int goBackSlot = config.getInt("party-choose-arena-menu.items.go-back.slot");
            buttons.put(goBackSlot, new Button() {
                @Override
                public ItemStack getButtonItem(Player player) {
                    return new ItemBuilder(
                            org.bukkit.Material
                                    .valueOf(config.getString("party-choose-arena-menu.items.go-back.material")))
                            .name(config.getString("party-choose-arena-menu.items.go-back.name"))
                            .lore(config.getStringList("party-choose-arena-menu.items.go-back.lore"))
                            .build();
                }

                @Override
                public void clicked(Player player, ClickType clickType) {
                    new rip.diamond.practice.party.fight.menu.ChooseKitMenu(kitMatchType).openMenu(player);
                }
            });
        }

        // Arenas
        List<Arena> allArenas = getFilteredArenas();
        int startIndex = (page - 1) * itemsPerPage;
        int endIndex = Math.min(startIndex + itemsPerPage, allArenas.size());

        List<Arena> arenasOnThisPage = allArenas.subList(startIndex, endIndex);

        boolean hasBorder = config.getBoolean("party-choose-arena-menu.border.enabled");
        int arenaIndex = 0;
        for (int slot = 0; slot < getSize() && arenaIndex < arenasOnThisPage.size(); slot++) {
            // Skip border slots and the random arena button slot
            if (hasBorder && (slot < 9 || slot >= getSize() - 9 || slot % 9 == 0 || slot % 9 == 8)) {
                continue;
            }
            // Skip if this slot is the random arena button
            if (slot == randomSlot) {
                continue;
            }

            Arena arena = arenasOnThisPage.get(arenaIndex);
            buttons.put(slot, new Button() {
                @Override
                public ItemStack getButtonItem(Player player) {
                    return new ItemBuilder(arena.getIcon().clone())
                            .name(config.getString("party-choose-arena-menu.items.arena-button.name")
                                    .replace("{arena-name}", arena.getDisplayName()))
                            .lore(config.getStringList("party-choose-arena-menu.items.arena-button.lore"))
                            .build();
                }

                @Override
                public void clicked(Player player, ClickType clickType) {
                    player.closeInventory();
                    Eden.INSTANCE.getPartyFightManager().startPartyEvent(player, kitMatchType, kit, arena);
                }
            });
            arenaIndex++;
        }

        // Pagination
        if (page > 1) {
            int prevSlot = config.getInt("party-choose-arena-menu.items.previous-page.slot");
            buttons.put(prevSlot, new Button() {
                @Override
                public ItemStack getButtonItem(Player player) {
                    return new ItemBuilder(
                            org.bukkit.Material
                                    .valueOf(config.getString("party-choose-arena-menu.items.previous-page.material")))
                            .name(config.getString("party-choose-arena-menu.items.previous-page.name"))
                            .lore(config.getStringList("party-choose-arena-menu.items.previous-page.lore"))
                            .build();
                }

                @Override
                public void clicked(Player player, ClickType clickType) {
                    new ChooseArenaMenu(kitMatchType, kit, page - 1).openMenu(player);
                }
            });
        }

        if (endIndex < allArenas.size()) {
            int nextSlot = config.getInt("party-choose-arena-menu.items.next-page.slot");
            buttons.put(nextSlot, new Button() {
                @Override
                public ItemStack getButtonItem(Player player) {
                    return new ItemBuilder(
                            org.bukkit.Material
                                    .valueOf(config.getString("party-choose-arena-menu.items.next-page.material")))
                            .name(config.getString("party-choose-arena-menu.items.next-page.name"))
                            .lore(config.getStringList("party-choose-arena-menu.items.next-page.lore"))
                            .build();
                }

                @Override
                public void clicked(Player player, ClickType clickType) {
                    new ChooseArenaMenu(kitMatchType, kit, page + 1).openMenu(player);
                }
            });
        }

        return buttons;
    }

    private int getItemsPerPage(BasicConfigFile config) {
        int size;
        if (config.getString("party-choose-arena-menu.size").equalsIgnoreCase("dynamic")) {
            size = config.getInt("party-choose-arena-menu.max-size");
        } else {
            size = config.getInt("party-choose-arena-menu.size");
        }

        if (config.getBoolean("party-choose-arena-menu.border.enabled")) {
            int rows = size / 9;
            return (rows - 2) * 7;
        } else {
            return size - 9;
        }
    }

    private List<Arena> getFilteredArenas() {
        return Arena.getArenas().stream()
                .filter(arena -> {
                    return arena.isEnabled() && !arena.isLocked() && !arena.getArenaDetails().isEmpty()
                            && arena.getAllowedKits().contains(kit.getName());
                })
                .collect(Collectors.toList());
    }
}


Filename: .\main\java\rip\diamond\practice\party\fight\menu\ChooseKitMenu.java
package rip.diamond.practice.party.fight.menu;

import lombok.RequiredArgsConstructor;
import org.bukkit.Material;
import org.bukkit.entity.Player;
import org.bukkit.event.inventory.ClickType;
import org.bukkit.inventory.ItemStack;
import rip.diamond.practice.Eden;
import rip.diamond.practice.arenas.Arena;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.kits.Kit;
import rip.diamond.practice.kits.KitMatchType;
import rip.diamond.practice.profile.PlayerProfile;
import rip.diamond.practice.profile.ProfileSettings;
import rip.diamond.practice.util.BasicConfigFile;
import rip.diamond.practice.util.CC;
import rip.diamond.practice.util.ItemBuilder;
import rip.diamond.practice.util.menu.Button;
import rip.diamond.practice.util.menu.Menu;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

@RequiredArgsConstructor
public class ChooseKitMenu extends Menu {
    private final KitMatchType kitMatchType;
    private final int page;

    public ChooseKitMenu(KitMatchType kitMatchType) {
        this(kitMatchType, 1);
    }

    @Override
    public String getTitle(Player player) {
        BasicConfigFile config = Eden.INSTANCE.getMenusConfig().getConfig();
        return CC.translate(config.getString("party-choose-kit-menu.title"));
    }

    @Override
    public int getSize() {
        BasicConfigFile config = Eden.INSTANCE.getMenusConfig().getConfig();
        String sizeStr = config.getString("party-choose-kit-menu.size");

        if ("dynamic".equalsIgnoreCase(sizeStr)) {
            if (page > 1) {
                return config.getInt("party-choose-kit-menu.max-size");
            }

            int itemsPerPage = getItemsPerPage(config);
            List<Kit> kits = getFilteredKits();
            int kitsOnThisPage = Math.min(kits.size() - ((page - 1) * itemsPerPage), itemsPerPage);

            boolean hasBorder = config.getBoolean("party-choose-kit-menu.border.enabled");
            int contentSlots = kitsOnThisPage;
            int rowsNeeded = (int) Math.ceil(contentSlots / 7.0);
            int totalRows = rowsNeeded + (hasBorder ? 2 : 0);

            int maxSize = config.getInt("party-choose-kit-menu.max-size");
            int calculatedSize = Math.max(27, Math.min(totalRows * 9, maxSize));

            return ((calculatedSize + 8) / 9) * 9;
        } else {
            return config.getInt("party-choose-kit-menu.size");
        }
    }

    @Override
    public Map<Integer, Button> getButtons(Player player) {
        Map<Integer, Button> buttons = new HashMap<>();
        BasicConfigFile config = Eden.INSTANCE.getMenusConfig().getConfig();
        int itemsPerPage = getItemsPerPage(config);

        // Filler
        if (config.getBoolean("party-choose-kit-menu.filler.enabled")) {
            ItemStack filler = new ItemBuilder(
                    org.bukkit.Material.valueOf(config.getString("party-choose-kit-menu.filler.material")))
                    .durability(config.getInt("party-choose-kit-menu.filler.data"))
                    .name(" ")
                    .build();
            for (int i = 0; i < getSize(); i++) {
                buttons.put(i, new Button() {
                    @Override
                    public ItemStack getButtonItem(Player player) {
                        return filler;
                    }
                });
            }
        }

        // Border
        if (config.getBoolean("party-choose-kit-menu.border.enabled")) {
            ItemStack border = new ItemBuilder(
                    org.bukkit.Material.valueOf(config.getString("party-choose-kit-menu.border.material")))
                    .durability(config.getInt("party-choose-kit-menu.border.data"))
                    .name(" ")
                    .build();
            int size = getSize();
            for (int i = 0; i < size; i++) {
                if (i < 9 || i >= size - 9 || i % 9 == 0 || i % 9 == 8) {
                    buttons.put(i, new Button() {
                        @Override
                        public ItemStack getButtonItem(Player player) {
                            return border;
                        }
                    });
                }
            }
        }

        // Kit buttons
        List<Kit> allKits = getFilteredKits();
        int startIndex = (page - 1) * itemsPerPage;
        int endIndex = Math.min(startIndex + itemsPerPage, allKits.size());

        List<Kit> kitsOnThisPage = allKits.subList(startIndex, endIndex);

        boolean hasBorder = config.getBoolean("party-choose-kit-menu.border.enabled");
        int kitIndex = 0;
        for (int slot = 0; slot < getSize() && kitIndex < kitsOnThisPage.size(); slot++) {
            // Skip border slots
            if (hasBorder && (slot < 9 || slot >= getSize() - 9 || slot % 9 == 0 || slot % 9 == 8)) {
                continue;
            }

            Kit kit = kitsOnThisPage.get(kitIndex);
            buttons.put(slot, new Button() {
                @Override
                public ItemStack getButtonItem(Player player) {
                    String name = config.getString("party-choose-kit-menu.items.kit-button.name");
                    if (name == null)
                        name = "&b" + kit.getDisplayName();

                    return new ItemBuilder(kit.getDisplayIcon().getType())
                            .durability(kit.getDisplayIcon().getDurability())
                            .name(name.replace("{kit-name}", kit.getDisplayName()))
                            .lore(config.getStringList("party-choose-kit-menu.items.kit-button.lore"))
                            .build();
                }

                @Override
                public void clicked(Player player, ClickType clickType) {
                    PlayerProfile profile = PlayerProfile.get(player);
                    if (profile.getSettings().get(ProfileSettings.ARENA_SELECTION).isEnabled()) {
                        new ChooseArenaMenu(kitMatchType, kit).openMenu(player);
                        return;
                    }
                    player.closeInventory();
                    Eden.INSTANCE.getPartyFightManager().startPartyEvent(player, kitMatchType, kit,
                            Arena.getEnabledArena(kit));
                }
            });
            kitIndex++;
        }

        // Pagination
        if (page > 1) {
            int prevSlot = config.getInt("party-choose-kit-menu.items.previous-page.slot");
            buttons.put(prevSlot, new Button() {
                @Override
                public ItemStack getButtonItem(Player player) {
                    return new ItemBuilder(
                            org.bukkit.Material
                                    .valueOf(config.getString("party-choose-kit-menu.items.previous-page.material")))
                            .name(config.getString("party-choose-kit-menu.items.previous-page.name"))
                            .lore(config.getStringList("party-choose-kit-menu.items.previous-page.lore"))
                            .build();
                }

                @Override
                public void clicked(Player player, ClickType clickType) {
                    new ChooseKitMenu(kitMatchType, page - 1).openMenu(player);
                }
            });
        }

        if (endIndex < allKits.size()) {
            int nextSlot = config.getInt("party-choose-kit-menu.items.next-page.slot");
            buttons.put(nextSlot, new Button() {
                @Override
                public ItemStack getButtonItem(Player player) {
                    return new ItemBuilder(
                            org.bukkit.Material
                                    .valueOf(config.getString("party-choose-kit-menu.items.next-page.material")))
                            .name(config.getString("party-choose-kit-menu.items.next-page.name"))
                            .lore(config.getStringList("party-choose-kit-menu.items.next-page.lore"))
                            .build();
                }

                @Override
                public void clicked(Player player, ClickType clickType) {
                    new ChooseKitMenu(kitMatchType, page + 1).openMenu(player);
                }
            });
        }

        return buttons;
    }

    private int getItemsPerPage(BasicConfigFile config) {
        int size;
        if (config.getString("party-choose-kit-menu.size").equalsIgnoreCase("dynamic")) {
            size = config.getInt("party-choose-kit-menu.max-size");
        } else {
            size = config.getInt("party-choose-kit-menu.size");
        }

        if (config.getBoolean("party-choose-kit-menu.border.enabled")) {
            int rows = size / 9;
            return (rows - 2) * 7;
        } else {
            return size - 9;
        }
    }

    private List<Kit> getFilteredKits() {
        return Kit.getKits().stream()
                .filter(kit -> kit.getKitMatchTypes().contains(kitMatchType) && kit.isEnabled())
                .collect(Collectors.toList());
    }
}


Filename: .\main\java\rip\diamond\practice\party\fight\menu\ChooseMatchTypeMenu.java
package rip.diamond.practice.party.fight.menu;

import org.bukkit.Material;
import org.bukkit.entity.Player;
import org.bukkit.event.inventory.ClickType;
import org.bukkit.inventory.ItemStack;
import rip.diamond.practice.Eden;
import rip.diamond.practice.kits.KitMatchType;
import rip.diamond.practice.util.BasicConfigFile;
import rip.diamond.practice.util.CC;
import rip.diamond.practice.util.ItemBuilder;
import rip.diamond.practice.util.menu.Button;
import rip.diamond.practice.util.menu.Menu;

import java.util.HashMap;
import java.util.Map;

public class ChooseMatchTypeMenu extends Menu {

    @Override
    public String getTitle(Player player) {
        BasicConfigFile config = Eden.INSTANCE.getMenusConfig().getConfig();
        return CC.translate(config.getString("party-events-menu.title"));
    }

    @Override
    public int getSize() {
        BasicConfigFile config = Eden.INSTANCE.getMenusConfig().getConfig();
        return config.getInt("party-events-menu.size");
    }

    @Override
    public Map<Integer, Button> getButtons(Player player) {
        final Map<Integer, Button> buttons = new HashMap<>();
        BasicConfigFile config = Eden.INSTANCE.getMenusConfig().getConfig();

        // Filler
        if (config.getBoolean("party-events-menu.filler.enabled")) {
            ItemStack filler = new ItemBuilder(Material.valueOf(config.getString("party-events-menu.filler.material")))
                    .durability(config.getInt("party-events-menu.filler.data"))
                    .name(" ")
                    .build();
            for (int i = 0; i < getSize(); i++) {
                buttons.put(i, new Button() {
                    @Override
                    public ItemStack getButtonItem(Player player) {
                        return filler;
                    }
                });
            }
        }

        // Border
        if (config.getBoolean("party-events-menu.border.enabled")) {
            ItemStack border = new ItemBuilder(Material.valueOf(config.getString("party-events-menu.border.material")))
                    .durability(config.getInt("party-events-menu.border.data"))
                    .name(" ")
                    .build();
            int size = getSize();
            for (int i = 0; i < size; i++) {
                if (i < 9 || i >= size - 9 || i % 9 == 0 || i % 9 == 8) {
                    buttons.put(i, new Button() {
                        @Override
                        public ItemStack getButtonItem(Player player) {
                            return border;
                        }
                    });
                }
            }
        }

        // Split Button (Party Fight)
        int splitSlot = config.getInt("party-events-menu.items.split-button.slot");
        buttons.put(splitSlot, new Button() {
            @Override
            public ItemStack getButtonItem(Player player) {
                return new ItemBuilder(
                        Material.valueOf(config.getString("party-events-menu.items.split-button.material")))
                        .durability(config.getInt("party-events-menu.items.split-button.data"))
                        .name(CC.translate(config.getString("party-events-menu.items.split-button.name")))
                        .lore(CC.translate(config.getStringList("party-events-menu.items.split-button.lore")))
                        .build();
            }

            @Override
            public void clicked(Player player, ClickType clickType) {
                new ChooseKitMenu(KitMatchType.SPLIT).openMenu(player);
            }
        });

        // FFA Button
        int ffaSlot = config.getInt("party-events-menu.items.ffa-button.slot");
        buttons.put(ffaSlot, new Button() {
            @Override
            public ItemStack getButtonItem(Player player) {
                return new ItemBuilder(
                        Material.valueOf(config.getString("party-events-menu.items.ffa-button.material")))
                        .durability(config.getInt("party-events-menu.items.ffa-button.data"))
                        .name(CC.translate(config.getString("party-events-menu.items.ffa-button.name")))
                        .lore(CC.translate(config.getStringList("party-events-menu.items.ffa-button.lore")))
                        .build();
            }

            @Override
            public void clicked(Player player, ClickType clickType) {
                new ChooseKitMenu(KitMatchType.FFA).openMenu(player);
            }
        });

        return buttons;
    }
}


Filename: .\main\java\rip\diamond\practice\party\fight\menu\OtherPartiesMenu.java
package rip.diamond.practice.party.fight.menu;

import lombok.RequiredArgsConstructor;
import org.bukkit.Material;
import org.bukkit.entity.Player;
import org.bukkit.event.inventory.ClickType;
import org.bukkit.inventory.ItemStack;
import rip.diamond.practice.Eden;
import rip.diamond.practice.party.Party;
import rip.diamond.practice.party.PartyPrivacy;
import rip.diamond.practice.util.BasicConfigFile;
import rip.diamond.practice.util.CC;
import rip.diamond.practice.util.Common;
import rip.diamond.practice.util.ItemBuilder;
import rip.diamond.practice.util.menu.Button;
import rip.diamond.practice.util.menu.Menu;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

public class OtherPartiesMenu extends Menu {
    private final int page;

    public OtherPartiesMenu() {
        this(1);
    }

    public OtherPartiesMenu(int page) {
        this.page = page;
    }

    @Override
    public String getTitle(Player player) {
        BasicConfigFile config = Eden.INSTANCE.getMenusConfig().getConfig();
        return CC.translate(config.getString("party-other-parties-menu.title"));
    }

    @Override
    public int getSize() {
        BasicConfigFile config = Eden.INSTANCE.getMenusConfig().getConfig();
        String sizeStr = config.getString("party-other-parties-menu.size");

        if ("dynamic".equalsIgnoreCase(sizeStr)) {
            // Calculate dynamic size based on number of parties
            if (page > 1) {
                return config.getInt("party-other-parties-menu.max-size");
            }

            int partiesCount = Party.getParties().values().stream()
                    .filter(party -> party.getPrivacy() == PartyPrivacy.OPEN
                            && party.getAllPartyMembers().size() < party.getMaxSize())
                    .collect(Collectors.toList()).size();

            int itemsPerPage = getItemsPerPage(config);
            int partiesOnThisPage = Math.min(partiesCount - ((page - 1) * itemsPerPage), itemsPerPage);

            boolean hasBorder = config.getBoolean("party-other-parties-menu.border.enabled");
            int contentSlots = partiesOnThisPage;
            int rowsNeeded = (int) Math.ceil(contentSlots / 7.0);
            int totalRows = rowsNeeded + (hasBorder ? 2 : 0);

            int maxSize = config.getInt("party-other-parties-menu.max-size");
            int calculatedSize = Math.max(27, Math.min(totalRows * 9, maxSize));

            return ((calculatedSize + 8) / 9) * 9;
        } else {
            return config.getInt("party-other-parties-menu.size");
        }
    }

    @Override
    public Map<Integer, Button> getButtons(Player player) {
        Map<Integer, Button> buttons = new HashMap<>();
        BasicConfigFile config = Eden.INSTANCE.getMenusConfig().getConfig();
        int itemsPerPage = getItemsPerPage(config);

        // Filler
        if (config.getBoolean("party-other-parties-menu.filler.enabled")) {
            ItemStack filler = new ItemBuilder(
                    Material.valueOf(config.getString("party-other-parties-menu.filler.material")))
                    .durability(config.getInt("party-other-parties-menu.filler.data"))
                    .name(" ")
                    .build();
            for (int i = 0; i < getSize(); i++) {
                buttons.put(i, new Button() {
                    @Override
                    public ItemStack getButtonItem(Player player) {
                        return filler;
                    }
                });
            }
        }

        // Border
        if (config.getBoolean("party-other-parties-menu.border.enabled")) {
            ItemStack border = new ItemBuilder(
                    Material.valueOf(config.getString("party-other-parties-menu.border.material")))
                    .durability(config.getInt("party-other-parties-menu.border.data"))
                    .name(" ")
                    .build();
            int size = getSize();
            for (int i = 0; i < size; i++) {
                if (i < 9 || i >= size - 9 || i % 9 == 0 || i % 9 == 8) {
                    buttons.put(i, new Button() {
                        @Override
                        public ItemStack getButtonItem(Player player) {
                            return border;
                        }
                    });
                }
            }
        }

        // Party buttons with pagination
        List<Party> allParties = Party.getParties().values().stream()
                .filter(party -> party.getPrivacy() == PartyPrivacy.OPEN
                        && party.getAllPartyMembers().size() < party.getMaxSize())
                .collect(Collectors.toList());

        int startIndex = (page - 1) * itemsPerPage;
        int endIndex = Math.min(startIndex + itemsPerPage, allParties.size());

        List<Party> partiesOnThisPage = allParties.subList(startIndex, endIndex);

        // Place parties in available slots (avoiding border)
        int partyIndex = 0;
        for (int slot = 0; slot < getSize() && partyIndex < partiesOnThisPage.size(); slot++) {
            // Skip border slots
            if (buttons.containsKey(slot) && (slot < 9 || slot >= getSize() - 9 || slot % 9 == 0 || slot % 9 == 8)) {
                continue;
            }
            if (buttons.containsKey(slot))
                continue;

            Party party = partiesOnThisPage.get(partyIndex);
            buttons.put(slot, new PartyButton(party, config));
            partyIndex++;
        }

        // Pagination buttons
        if (page > 1) {
            int prevSlot = config.getInt("party-other-parties-menu.items.previous-page.slot");
            buttons.put(prevSlot, new Button() {
                @Override
                public ItemStack getButtonItem(Player player) {
                    return new ItemBuilder(
                            Material.valueOf(config.getString("party-other-parties-menu.items.previous-page.material")))
                            .name(config.getString("party-other-parties-menu.items.previous-page.name"))
                            .lore(config.getStringList("party-other-parties-menu.items.previous-page.lore"))
                            .build();
                }

                @Override
                public void clicked(Player player, ClickType clickType) {
                    new OtherPartiesMenu(page - 1).openMenu(player);
                }
            });
        }

        if (endIndex < allParties.size()) {
            int nextSlot = config.getInt("party-other-parties-menu.items.next-page.slot");
            buttons.put(nextSlot, new Button() {
                @Override
                public ItemStack getButtonItem(Player player) {
                    return new ItemBuilder(
                            Material.valueOf(config.getString("party-other-parties-menu.items.next-page.material")))
                            .name(config.getString("party-other-parties-menu.items.next-page.name"))
                            .lore(config.getStringList("party-other-parties-menu.items.next-page.lore"))
                            .build();
                }

                @Override
                public void clicked(Player player, ClickType clickType) {
                    new OtherPartiesMenu(page + 1).openMenu(player);
                }
            });
        }

        return buttons;
    }

    private int getItemsPerPage(BasicConfigFile config) {
        int size;
        if (config.getString("party-other-parties-menu.size").equalsIgnoreCase("dynamic")) {
            size = config.getInt("party-other-parties-menu.max-size");
        } else {
            size = config.getInt("party-other-parties-menu.size");
        }

        if (config.getBoolean("party-other-parties-menu.border.enabled")) {
            int rows = size / 9;
            return (rows - 2) * 7;
        } else {
            return size - 9;
        }
    }

    @RequiredArgsConstructor
    private static class PartyButton extends Button {
        private final Party party;
        private final BasicConfigFile config;

        @Override
        public ItemStack getButtonItem(Player player) {
            String leaderName = party.getLeader().getUsername();
            int members = party.getAllPartyMembers().size();
            int maxSize = party.getMaxSize();

            // Build member list
            String memberFormat = config.getString("party-other-parties-menu.items.party-button.member-format");
            List<String> memberList = party.getAllPartyMembers().stream()
                    .map(partyMember -> {
                        String memberName = partyMember.getUsername();
                        return memberFormat.replace("{member}", memberName);
                    })
                    .collect(Collectors.toList());

            // Build lore with placeholders
            List<String> lore = config.getStringList("party-other-parties-menu.items.party-button.lore");
            lore = lore.stream()
                    .map(line -> line.replace("{leader}", leaderName))
                    .map(line -> line.replace("{members}", String.valueOf(members)))
                    .map(line -> line.replace("{max-size}", String.valueOf(maxSize)))
                    .map(line -> {
                        if (line.contains("{member-list}")) {
                            // Replace with actual member list
                            return null; // Mark for replacement
                        }
                        return line;
                    })
                    .collect(Collectors.toList());

            // Insert member list where placeholder was
            List<String> finalLore = lore.stream()
                    .flatMap(line -> {
                        if (line == null) {
                            return memberList.stream();
                        }
                        return java.util.stream.Stream.of(line);
                    })
                    .collect(Collectors.toList());

            String name = config.getString("party-other-parties-menu.items.party-button.name")
                    .replace("{leader}", leaderName);

            return new ItemBuilder(
                    Material.valueOf(config.getString("party-other-parties-menu.items.party-button.material")))
                    .durability(config.getInt("party-other-parties-menu.items.party-button.data"))
                    .name(name)
                    .lore(finalLore)
                    .build();
        }

        @Override
        public void clicked(Player player, ClickType clickType) {
            player.closeInventory();
            Common.sendMessage(player, "/party join " + party.getLeader().getUsername());
            player.performCommand("party join " + party.getLeader().getUsername());
        }
    }
}


Filename: .\main\java\rip\diamond\practice\profile\PlayerProfile.java
package rip.diamond.practice.profile;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.Setter;
import org.bson.Document;
import org.bukkit.Bukkit;
import org.bukkit.entity.Player;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.meta.SkullMeta;
import org.bukkit.scheduler.BukkitRunnable;
import rip.diamond.practice.Eden;
import rip.diamond.practice.EdenItems;
import rip.diamond.practice.config.Config;
import rip.diamond.practice.event.PlayerProfileDataLoadEvent;
import rip.diamond.practice.event.PlayerProfileDataSaveEvent;
import rip.diamond.practice.events.EdenEvent;
import rip.diamond.practice.hook.plugin.citizens.CitizensHook;
import rip.diamond.practice.kits.Kit;
import rip.diamond.practice.match.Match;
import rip.diamond.practice.party.Party;
import rip.diamond.practice.profile.cooldown.Cooldown;
import rip.diamond.practice.profile.cooldown.CooldownType;
import rip.diamond.practice.profile.data.ProfileKitData;
import rip.diamond.practice.profile.task.ProfileAutoSaveTask;
import rip.diamond.practice.util.*;
import rip.diamond.practice.util.option.Option;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Consumer;

@Getter
public class PlayerProfile {

    @Getter
    private static final Map<UUID, PlayerProfile> profiles = new ConcurrentHashMap<>();

    private final UUID uniqueId;
    private final String username;
    private final Map<String, ProfileKitData> kitData = new HashMap<>();
    private final Map<ProfileSettings, Option> settings = new HashMap<>();
    private PlayerState playerState = PlayerState.LOADING;
    private final Map<CooldownType, Cooldown> cooldowns = new ConcurrentHashMap<>();
    @Setter
    private Match match;
    @Setter
    private Party party;

    @Setter
    private boolean temporary = false;
    private boolean saving = false;

    public PlayerProfile(UUID uniqueId, String username) {
        this.uniqueId = uniqueId;
        this.username = username;
    }

    public static void init() {
        new ProfileAutoSaveTask();
    }

    public void fromBson(Document document) {
        Document settingsDocument = document.get("settings", Document.class);
        for (String data : settingsDocument.keySet()) {
            try {
                ProfileSettings s = ProfileSettings.valueOf(data);
                Option option = s.find(settingsDocument.getString(data));
                // This happens when the option value name is changed
                if (option == null) {
                    continue;
                }
                settings.put(s, option);
            } catch (IllegalArgumentException e) {
                Common.debug(username + " ÁöÑ SettingsDocument Ë£èÈù¢Êúâ‰∏çÂ≠òÂú®ÁöÑ '" + data + "' Ë®≠ÂÆö, Áî±ÊñºÁÑ°Ê≥ïÊâæÂà∞ÂêàÈÅ©ÁöÑË®≠ÂÆö, ÊâÄ‰ª•Â∑≤ÊääÂÆÉÂøΩÁï•");
            }
        }

        Document kitDataDocument = document.get("kitData", Document.class);
        for (String data : kitDataDocument.keySet()) {
            // In case a kit is removed, kitData.get(data) will return null
            // This is why we need to put a new ProfileKitData, so kitData will also contain
            // removed kit data.
            kitData.putIfAbsent(data, new ProfileKitData());
            kitData.get(data).fromBson(kitDataDocument.get(data, Document.class));
        }

        PlayerProfileDataLoadEvent event = new PlayerProfileDataLoadEvent(this, document);
        event.call();
    }

    public Document toBson() {
        Document settingsDocument = new Document();
        for (Map.Entry<ProfileSettings, Option> options : settings.entrySet()) {
            settingsDocument.put(options.getKey().name(), options.getValue().getValue());
        }

        Document kitDataDocument = new Document();
        for (Map.Entry<String, ProfileKitData> kitDataMap : kitData.entrySet()) {
            kitDataDocument.put(kitDataMap.getKey(), kitDataMap.getValue().toBson());
        }

        // This document is temporary, meaning it is not going to load into profile,
        // only for record purpose
        // This is mainly used to catch leaderboard data
        Document temporaryDocument = new Document()
                .append("globalElo", kitData.values().stream().mapToInt(ProfileKitData::getElo).sum()
                        / (kitData.size() == 0 ? 1 : kitData.size()));
        // temporaryDocument End

        Document document = new Document()
                .append("uuid", uniqueId.toString())
                .append("username", username)
                .append("lowerCaseUsername", username.toLowerCase())
                .append("settings", settingsDocument)
                .append("kitData", kitDataDocument)

                .append("temporary", temporaryDocument);

        PlayerProfileDataSaveEvent event = new PlayerProfileDataSaveEvent(this, document);
        event.call();

        return document;
    }

    public Player getPlayer() {
        if (Util.isNPC(uniqueId)) {
            return Eden.INSTANCE.getHookManager().getCitizensHook().getNPCPlayer(uniqueId);
        }
        return Bukkit.getPlayer(uniqueId);
    }

    public void setPlayerState(PlayerState playerState) {
        this.playerState = playerState;

        // getPlayer might be null because PlayerProfile.setPlayerState might be trigger
        // when player disconnects
        if (getPlayer() != null) {
            VisibilityController.updateVisibility(getPlayer());
        }
    }

    public void setupItems() {
        Player player = getPlayer();
        if (player == null) {
            return;
        }
        player.getInventory().clear();
        player.getInventory().setArmorContents(null);
        if (playerState == PlayerState.IN_LOBBY) {
            if (Party.getByPlayer(player) == null) {
                EdenItems.giveItem(player, EdenItems.LOBBY_UNRANKED_QUEUE);
                EdenItems.giveItem(player, EdenItems.LOBBY_RANKED_QUEUE);
                if (EdenEvent.getOnGoingEvent() == null) {
                    EdenItems.giveItem(player, EdenItems.LOBBY_CREATE_EVENT);
                } else {
                    EdenItems.giveItem(player, EdenItems.LOBBY_JOIN_EVENT);
                }
                EdenItems.giveItem(player, EdenItems.LOBBY_PARTY_OPEN);
                EdenItems.giveItem(player, EdenItems.LOBBY_LEADERBOARD);
                EdenItems.giveItem(player, EdenItems.LOBBY_SETTINGS);
                EdenItems.giveItem(player, EdenItems.LOBBY_EDITOR);
            } else {
                EdenItems.giveItem(player, EdenItems.PARTY_PARTY_LIST);
                EdenItems.giveItem(player, EdenItems.PARTY_PARTY_FIGHT);
                EdenItems.giveItem(player, EdenItems.PARTY_OTHER_PARTIES);
                EdenItems.giveItem(player, EdenItems.PARTY_EDITOR);
                EdenItems.giveItem(player, EdenItems.PARTY_PARTY_LEAVE);
            }
        } else if (playerState == PlayerState.IN_QUEUE) {
            EdenItems.giveItem(player, EdenItems.QUEUE_LEAVE_QUEUE);
        } else if (playerState == PlayerState.IN_MATCH && match != null
                && !match.getTeamPlayer(getPlayer()).isAlive()) {
            EdenItems.giveItem(player, EdenItems.SPECTATE_TELEPORTER);
        } else if (playerState == PlayerState.IN_SPECTATING && match != null) {
            EdenItems.giveItem(player, EdenItems.SPECTATE_TELEPORTER);
            EdenItems.giveItem(player, EdenItems.SPECTATE_LEAVE_SPECTATE);
            EdenItems.giveItem(player,
                    settings.get(ProfileSettings.SPECTATOR_VISIBILITY).isEnabled()
                            ? EdenItems.SPECTATE_TOGGLE_VISIBILITY_OFF
                            : EdenItems.SPECTATE_TOGGLE_VISIBILITY_ON);
        }
        player.updateInventory();
    }

    public void loadDefault() {
        // Load all the current exist kits into profile kit data
        Kit.getKits().forEach(kit -> kitData.putIfAbsent(kit.getName(), new ProfileKitData()));
        // Setup all default cooldown
        for (CooldownType type : CooldownType.values()) {
            cooldowns.put(type, new Cooldown(0));
        }
    }

    public void loadDefaultAfter() {
        // Load it after, if I update the plugin and added a few new settings, then we
        // will need this
        Arrays.asList(ProfileSettings.values())
                .forEach(profileSettings -> settings.putIfAbsent(profileSettings, profileSettings.getDefault()));
    }

    public void load(Consumer<Boolean> callback) {
        if (playerState != PlayerState.LOADING) {
            return;
        }

        Eden.INSTANCE.getDatabaseManager().getHandler().loadProfile(uniqueId, (document) -> {
            load(document, callback);
        });
    }

    public void load(Document document, Consumer<Boolean> callback) {
        if (playerState != PlayerState.LOADING) {
            return;
        }
        Tasks.runAsync(() -> {
            try {
                loadDefault();

                // Document will be null if the player is new, or database is not enabled
                if (document != null) {
                    fromBson(document);
                }

                loadDefaultAfter();

                callback.accept(true);
            } catch (Exception e) {
                e.printStackTrace();
                callback.accept(false);
            }
        });
    }

    public void save(boolean async, Consumer<Boolean> callback) {
        if (async) {
            Tasks.runAsync(() -> save(callback));
            return;
        }
        save(callback);
    }

    private void save(Consumer<Boolean> callback) {
        try {
            saving = true;
            if (playerState != PlayerState.LOADING) {
                Eden.INSTANCE.getDatabaseManager().getHandler().saveProfile(this);
            }
            callback.accept(true);
            saving = false;
        } catch (Exception e) {
            e.printStackTrace();
            callback.accept(false);
        }
    }

    public static PlayerProfile get(Player player) {
        return get(player.getUniqueId());
    }

    public static PlayerProfile get(String username) {
        return profiles.values().stream().filter(profile -> profile.getUsername().equalsIgnoreCase(username)).findAny()
                .orElse(null);
    }

    public static PlayerProfile get(UUID uuid) {
        return profiles.get(uuid);
    }

    public static PlayerProfile createPlayerProfile(Player player) {
        PlayerProfile profile = new PlayerProfile(player.getUniqueId(), player.getName());
        profiles.put(player.getUniqueId(), profile);
        return profile;
    }

    public static PlayerProfile createPlayerProfile(UUID uuid, String username) {
        PlayerProfile profile = new PlayerProfile(uuid, username);
        profiles.put(uuid, profile);
        return profile;
    }

}


Filename: .\main\java\rip\diamond\practice\profile\PlayerState.java
package rip.diamond.practice.profile;

import lombok.AllArgsConstructor;
import lombok.Getter;

@Getter
@AllArgsConstructor
public enum PlayerState {
    LOADING(false),
    IN_LOBBY(false),
    IN_EDIT(true),
    IN_QUEUE(false),
    IN_MATCH(true),
    IN_SPECTATING(false);

    private final boolean ableToMoveItemInInventory;
}


Filename: .\main\java\rip\diamond\practice\profile\ProfileSettings.java
package rip.diamond.practice.profile;

import com.google.common.collect.ImmutableList;
import lombok.AllArgsConstructor;
import lombok.Getter;
import org.bukkit.Material;
import org.bukkit.entity.Player;
import rip.diamond.practice.Eden;
import rip.diamond.practice.config.Config;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.event.SettingsChangeEvent;
import rip.diamond.practice.util.option.FalseOption;
import rip.diamond.practice.util.option.Option;
import rip.diamond.practice.util.option.TrueOption;

import java.util.List;

@Getter
@AllArgsConstructor
public enum ProfileSettings {

    TIME_CHANGER(
            Material.WATCH,
            Language.PROFILE_SETTINGS_TIME_CHANGER_NAME.toString(),
            Language.PROFILE_SETTINGS_TIME_CHANGER_LORE.toStringList(),
            "eden.settings.time-changer",
            ImmutableList.of(
                    new Option(Config.PROFILE_DEFAULT_SETTINGS_TIME_CHANGER.toString().equals("normal"), Language.PROFILE_SETTINGS_TIME_CHANGER_NORMAL_SERVER_TIME.toString()) {
                        @Override
                        public void run(Player player) {
                            player.resetPlayerTime();
                        }

                        @Override
                        public String getValue() {
                            return "normal";
                        }
                    },
                    new Option(Config.PROFILE_DEFAULT_SETTINGS_TIME_CHANGER.toString().equals("day"), Language.PROFILE_SETTINGS_TIME_CHANGER_DAY.toString()) {
                        @Override
                        public void run(Player player) {
                            player.setPlayerTime(1000, false);
                        }

                        @Override
                        public String getValue() {
                            return "day";
                        }
                    },
                    new Option(Config.PROFILE_DEFAULT_SETTINGS_TIME_CHANGER.toString().equals("afternoon"), Language.PROFILE_SETTINGS_TIME_CHANGER_AFTERNOON.toString()) {
                        @Override
                        public void run(Player player) {
                            player.setPlayerTime(6000, false);
                        }

                        @Override
                        public String getValue() {
                            return "afternoon";
                        }
                    },
                    new Option(Config.PROFILE_DEFAULT_SETTINGS_TIME_CHANGER.toString().equals("night"), Language.PROFILE_SETTINGS_TIME_CHANGER_NIGHT.toString()) {
                        @Override
                        public void run(Player player) {
                            player.setPlayerTime(13000, false);
                        }

                        @Override
                        public String getValue() {
                            return "night";
                        }
                    },
                    new Option(Config.PROFILE_DEFAULT_SETTINGS_TIME_CHANGER.toString().equals("midnight"), Language.PROFILE_SETTINGS_TIME_CHANGER_MIDNIGHT.toString()) {
                        @Override
                        public void run(Player player) {
                            player.setPlayerTime(18000, false);
                        }

                        @Override
                        public String getValue() {
                            return "midnight";
                        }
                    }
            )
    ),
    ARENA_SELECTION(
            Material.GRASS,
            Language.PROFILE_SETTINGS_ARENA_SELECTION_NAME.toString(),
            Language.PROFILE_SETTINGS_ARENA_SELECTION_LORE.toStringList(),
            "eden.settings.arena-selection",
            getBooleanDefaultOptions(Config.PROFILE_DEFAULT_SETTINGS_ARENA_SELECTION.toBoolean())
    ),
    MATCH_SCOREBOARD(
            Material.ITEM_FRAME,
            Language.PROFILE_SETTINGS_MATCH_SCOREBOARD_NAME.toString(),
            Language.PROFILE_SETTINGS_MATCH_SCOREBOARD_LORE.toStringList(),
            "eden.settings.match-scoreboard",
            getBooleanDefaultOptions(Config.PROFILE_DEFAULT_SETTINGS_MATCH_SCOREBOARD.toBoolean())
    ),
    ALLOW_DUEL_REQUEST(
            Material.DIAMOND_SWORD,
            Language.PROFILE_SETTINGS_ALLOW_DUEL_REQUEST_NAME.toString(),
            Language.PROFILE_SETTINGS_ALLOW_DUEL_REQUEST_LORE.toStringList(),
            "eden.settings.allow-duel-request",
            getBooleanDefaultOptions(Config.PROFILE_DEFAULT_SETTINGS_ALLOW_DUEL_REQUEST.toBoolean())
    ),
    ALLOW_PARTY_INVITE(
            Material.NETHER_STAR,
            Language.PROFILE_SETTINGS_ALLOW_PARTY_INVITE_NAME.toString(),
            Language.PROFILE_SETTINGS_ALLOW_PARTY_INVITE_LORE.toStringList(),
            "eden.settings.allow-party-invite",
            getBooleanDefaultOptions(Config.PROFILE_DEFAULT_SETTINGS_ALLOW_PARTY_INVITE.toBoolean())
    ),
    SPECTATOR_VISIBILITY(
            Material.SKULL_ITEM,
            Language.PROFILE_SETTINGS_SPECTATOR_VISIBILITY_NAME.toString(),
            Language.PROFILE_SETTINGS_SPECTATOR_VISIBILITY_LORE.toStringList(),
            "eden.settings.spectator-visibility",
            getBooleanDefaultOptions(Config.PROFILE_DEFAULT_SETTINGS_SPECTATOR_VISIBILITY.toBoolean())
    ),
    SPECTATOR_JOIN_LEAVE_MESSAGE(
            Material.FEATHER,
            Language.PROFILE_SETTINGS_SPECTATOR_JOIN_LEAVE_MESSAGE_NAME.toString(),
            Language.PROFILE_SETTINGS_SPECTATOR_JOIN_LEAVE_MESSAGE_LORE.toStringList(),
            "eden.settings.spectator-join-leave-message",
            getBooleanDefaultOptions(Config.PROFILE_DEFAULT_SETTINGS_SPECTATOR_JOIN_LEAVE_MESSAGE.toBoolean())
    ),
    EVENT_ANNOUNCEMENT(
            Material.EMERALD,
            Language.PROFILE_SETTINGS_EVENT_ANNOUNCEMENT_NAME.toString(),
            Language.PROFILE_SETTINGS_EVENT_ANNOUNCEMENT_LORE.toStringList(),
            "eden.settings.event-announcement",
            getBooleanDefaultOptions(Config.PROFILE_DEFAULT_SETTINGS_EVENT_ANNOUNCEMENT.toBoolean())
    ),
    PING_RANGE(
            Material.STICK,
            Language.PROFILE_SETTINGS_PING_RANGE_NAME.toString(),
            Language.PROFILE_SETTINGS_PING_RANGE_LORE.toStringList(),
            "eden.settings.ping-range",
            ImmutableList.of(
                    new Option(Config.PROFILE_DEFAULT_SETTINGS_PING_RANGE.toString().equals("infinite"), Language.PROFILE_SETTINGS_PING_RANGE_UNLIMITED.toString()) {
                        @Override
                        public void run(Player player) {

                        }

                        @Override
                        public String getValue() {
                            return Integer.MAX_VALUE + "";
                        }

                        @Override
                        public String toString() {
                            return "‚àû";
                        }
                    },
                    new Option(Config.PROFILE_DEFAULT_SETTINGS_PING_RANGE.toString().equals("300"), "300") {
                        @Override
                        public void run(Player player) {

                        }

                        @Override
                        public String getValue() {
                            return "300";
                        }
                    },
                    new Option(Config.PROFILE_DEFAULT_SETTINGS_PING_RANGE.toString().equals("200"), "200") {
                        @Override
                        public void run(Player player) {

                        }

                        @Override
                        public String getValue() {
                            return "200";
                        }
                    },
                    new Option(Config.PROFILE_DEFAULT_SETTINGS_PING_RANGE.toString().equals("150"), "150") {
                        @Override
                        public void run(Player player) {

                        }

                        @Override
                        public String getValue() {
                            return "150";
                        }
                    },
                    new Option(Config.PROFILE_DEFAULT_SETTINGS_PING_RANGE.toString().equals("100"), "100") {
                        @Override
                        public void run(Player player) {

                        }

                        @Override
                        public String getValue() {
                            return "100";
                        }
                    },
                    new Option(Config.PROFILE_DEFAULT_SETTINGS_PING_RANGE.toString().equals("50"), "50") {
                        @Override
                        public void run(Player player) {

                        }

                        @Override
                        public String getValue() {
                            return "50";
                        }
                    }
            )
    )
    ;

    private final Material icon;
    private final String name;
    private final List<String> description;
    private final String permission;
    private final List<Option> options;

    public Option getDefault() {
        return options.stream().filter(Option::isDefault_).findFirst().orElse(null);
    }

    public Option getOption(String name) {
        return getOptions().stream().filter(option -> option.getName().equals(name)).findFirst().orElse(null);
    }

    public Option getNextOption(Option option) {
        int index = findIndex(option);
        int nextIndex = index + 1 >= getOptions().size() ? 0 : index + 1;
        return getOptions().get(nextIndex);
    }

    public Option getLastOption(Option option) {
        int index = findIndex(option);
        int nextIndex = index - 1 < 0 ? getOptions().size() - 1 : index - 1;
        return getOptions().get(nextIndex);
    }

    public Option find(String value) {
        return getOptions().stream().filter(option -> option.getValue().equals(value)).findFirst().orElse(null);
    }

    private int findIndex(Option option) {
        return getOptions().indexOf(option);
    }

    public void runSettingsChangeEvent(Player player, PlayerProfile profile) {
        SettingsChangeEvent event = new SettingsChangeEvent(player, profile, this);
        event.call();
    }

    private static List<Option> getBooleanDefaultOptions(boolean defaultValue) {
        return ImmutableList.of(
                new TrueOption(defaultValue),
                new FalseOption(!defaultValue)
        );
    }

}


Filename: .\main\java\rip\diamond\practice\profile\command\SettingsCommand.java
package rip.diamond.practice.profile.command;

import org.bukkit.entity.Player;
import rip.diamond.practice.profile.menu.ProfileSettingsMenu;
import rip.diamond.practice.util.command.Command;
import rip.diamond.practice.util.command.CommandArgs;
import rip.diamond.practice.util.command.argument.CommandArguments;

public class SettingsCommand extends Command {
    @CommandArgs(name = "settings", aliases = {"practicesettings", "psettings", "pracsettings"})
    public void execute(CommandArguments command) {
        Player player = command.getPlayer();

        new ProfileSettingsMenu().openMenu(player);
    }
}


Filename: .\main\java\rip\diamond\practice\profile\command\StatsCommand.java
package rip.diamond.practice.profile.command;

import org.bson.Document;
import org.bukkit.Bukkit;
import org.bukkit.OfflinePlayer;
import org.bukkit.entity.Player;
import rip.diamond.practice.Eden;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.leaderboard.menu.impl.KitStatsMenu;
import rip.diamond.practice.profile.PlayerProfile;
import rip.diamond.practice.util.Tasks;
import rip.diamond.practice.util.command.Command;
import rip.diamond.practice.util.command.CommandArgs;
import rip.diamond.practice.util.command.argument.CommandArguments;

import java.util.UUID;
import java.util.concurrent.CompletableFuture;

public class StatsCommand extends Command {
    @CommandArgs(name = "stats", async = true)
    public void execute(CommandArguments command) {
        Player player = command.getPlayer();
        String[] args = command.getArgs();

        String username;
        if (args.length == 0) {
            username = player.getName();
        } else {
            username = args[0];
        }

        Player target = Bukkit.getPlayer(username);
        if (target != null) {
            PlayerProfile profile = PlayerProfile.get(target);
            new KitStatsMenu(profile).openMenu(player);
            return;
        }

        // If player isn't online...
        // If player isn't online...
        Eden.INSTANCE.getDatabaseManager().getHandler().findProfileByName(username, (document) -> {
            if (document == null) {
                Language.PROFILE_CANNOT_FIND_PLAYER.sendMessage(player);
                return;
            }

            UUID targetUUID = UUID.fromString(document.getString("uuid"));
            String targetName = document.getString("username");

            // The creation logic must run on main thread
            Tasks.run(() -> {
                PlayerProfile finalProfile = PlayerProfile.createPlayerProfile(targetUUID, targetName);
                finalProfile.setTemporary(true);
                finalProfile.load(document, success -> {
                    if (success) {
                        new KitStatsMenu(finalProfile).openMenu(player);
                        PlayerProfile.getProfiles().remove(targetUUID);
                    } else {
                        Language.PROFILE_ERROR_CANNOT_LOAD_PLAYER.sendMessage(player);
                    }
                });
            });
        });
    }
}


Filename: .\main\java\rip\diamond\practice\profile\command\settings\AfternoonCommand.java
package rip.diamond.practice.profile.command.settings;

import org.bukkit.entity.Player;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.profile.PlayerProfile;
import rip.diamond.practice.profile.ProfileSettings;
import rip.diamond.practice.util.command.Command;
import rip.diamond.practice.util.command.CommandArgs;
import rip.diamond.practice.util.command.argument.CommandArguments;

public class AfternoonCommand extends Command {
    @CommandArgs(name = "afternoon", permission = "eden.settings.time-changer")
    public void execute(CommandArguments command) {
        Player player = command.getPlayer();
        PlayerProfile profile = PlayerProfile.get(player);

        ProfileSettings settings = ProfileSettings.TIME_CHANGER;

        profile.getSettings().replace(settings, settings.getOptions().get(2));
        profile.getSettings().get(settings).run(player);
        settings.runSettingsChangeEvent(player, profile);

        Language.PROFILE_SETTINGS_SUCCESSFULLY_CHANGED.sendMessage(player, settings.getName(), profile.getSettings().get(settings).getName());
    }
}


Filename: .\main\java\rip\diamond\practice\profile\command\settings\DayCommand.java
package rip.diamond.practice.profile.command.settings;

import org.bukkit.entity.Player;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.profile.PlayerProfile;
import rip.diamond.practice.profile.ProfileSettings;
import rip.diamond.practice.util.command.Command;
import rip.diamond.practice.util.command.CommandArgs;
import rip.diamond.practice.util.command.argument.CommandArguments;

public class DayCommand extends Command {

    @CommandArgs(name = "day", permission = "eden.settings.time-changer")
    public void execute(CommandArguments command) {
        Player player = command.getPlayer();
        PlayerProfile profile = PlayerProfile.get(player);

        ProfileSettings settings = ProfileSettings.TIME_CHANGER;

        profile.getSettings().replace(settings, settings.getOptions().get(1));
        profile.getSettings().get(settings).run(player);
        settings.runSettingsChangeEvent(player, profile);

        Language.PROFILE_SETTINGS_SUCCESSFULLY_CHANGED.sendMessage(player, settings.getName(), profile.getSettings().get(settings).getName());
    }
}


Filename: .\main\java\rip\diamond\practice\profile\command\settings\MidnightCommand.java
package rip.diamond.practice.profile.command.settings;

import org.bukkit.entity.Player;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.profile.PlayerProfile;
import rip.diamond.practice.profile.ProfileSettings;
import rip.diamond.practice.util.command.Command;
import rip.diamond.practice.util.command.CommandArgs;
import rip.diamond.practice.util.command.argument.CommandArguments;

public class MidnightCommand extends Command {
    @CommandArgs(name = "midnight", permission = "eden.settings.time-changer")
    public void execute(CommandArguments command) {
        Player player = command.getPlayer();
        PlayerProfile profile = PlayerProfile.get(player);

        ProfileSettings settings = ProfileSettings.TIME_CHANGER;

        profile.getSettings().replace(settings, settings.getOptions().get(4));
        profile.getSettings().get(settings).run(player);
        settings.runSettingsChangeEvent(player, profile);

        Language.PROFILE_SETTINGS_SUCCESSFULLY_CHANGED.sendMessage(player, settings.getName(), profile.getSettings().get(settings).getName());
    }
}


Filename: .\main\java\rip\diamond\practice\profile\command\settings\NightCommand.java
package rip.diamond.practice.profile.command.settings;

import org.bukkit.entity.Player;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.profile.PlayerProfile;
import rip.diamond.practice.profile.ProfileSettings;
import rip.diamond.practice.util.command.Command;
import rip.diamond.practice.util.command.CommandArgs;
import rip.diamond.practice.util.command.argument.CommandArguments;

public class NightCommand extends Command {
    @CommandArgs(name = "night", permission = "eden.settings.time-changer")
    public void execute(CommandArguments command) {
        Player player = command.getPlayer();
        PlayerProfile profile = PlayerProfile.get(player);

        ProfileSettings settings = ProfileSettings.TIME_CHANGER;

        profile.getSettings().replace(settings, settings.getOptions().get(3));
        profile.getSettings().get(settings).run(player);
        settings.runSettingsChangeEvent(player, profile);

        Language.PROFILE_SETTINGS_SUCCESSFULLY_CHANGED.sendMessage(player, settings.getName(), profile.getSettings().get(settings).getName());
    }
}


Filename: .\main\java\rip\diamond\practice\profile\command\settings\PingRangeCommand.java
package rip.diamond.practice.profile.command.settings;

import org.bukkit.entity.Player;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.profile.PlayerProfile;
import rip.diamond.practice.profile.ProfileSettings;
import rip.diamond.practice.util.command.Command;
import rip.diamond.practice.util.command.CommandArgs;
import rip.diamond.practice.util.command.argument.CommandArguments;
import rip.diamond.practice.util.option.Option;

import java.util.List;
import java.util.stream.Collectors;

public class PingRangeCommand extends Command {
    @CommandArgs(name = "pingrange", aliases = {"pr"}, permission = "eden.settings.ping-range")
    public void execute(CommandArguments command) {
        String[] args = command.getArgs();
        Player player = command.getPlayer();

        if (args.length == 0) {
            Language.INVALID_SYNTAX.sendMessage(player);
            return;
        }

        PlayerProfile profile = PlayerProfile.get(player);

        ProfileSettings settings = ProfileSettings.PING_RANGE;
        List<String> allowedValues = settings.getOptions().subList(1, settings.getOptions().size() - 1).stream().map(Option::getName).collect(Collectors.toList());
        String userOption = args[0].toLowerCase();

        if (!allowedValues.contains(userOption) && !userOption.equals("unlimited")) {
            Language.INVALID_SYNTAX.sendMessage(player);
            return;
        }

        if (userOption.equals("unlimited")) {
            profile.getSettings().replace(settings, settings.getOptions().get(0));
        } else {
            profile.getSettings().replace(settings, settings.getOption(userOption));
        }
        profile.getSettings().get(settings).run(player);
        settings.runSettingsChangeEvent(player, profile);

        Language.PROFILE_SETTINGS_SUCCESSFULLY_CHANGED.sendMessage(player, settings.getName(), profile.getSettings().get(settings).getName());
    }
}


Filename: .\main\java\rip\diamond\practice\profile\command\settings\ToggleArenaSelectionCommand.java
package rip.diamond.practice.profile.command.settings;

import org.bukkit.entity.Player;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.profile.PlayerProfile;
import rip.diamond.practice.profile.ProfileSettings;
import rip.diamond.practice.util.command.Command;
import rip.diamond.practice.util.command.CommandArgs;
import rip.diamond.practice.util.command.argument.CommandArguments;

public class ToggleArenaSelectionCommand extends Command {
    @CommandArgs(name = "togglearenaselection", permission = "eden.settings.arena-selection")
    public void execute(CommandArguments command) {
        Player player = command.getPlayer();
        PlayerProfile profile = PlayerProfile.get(player);

        ProfileSettings settings = ProfileSettings.ARENA_SELECTION;

        profile.getSettings().replace(settings, settings.getNextOption(profile.getSettings().get(settings)));
        profile.getSettings().get(settings).run(player);
        settings.runSettingsChangeEvent(player, profile);

        Language.PROFILE_SETTINGS_SUCCESSFULLY_CHANGED.sendMessage(player, settings.getName(), profile.getSettings().get(settings).getName());
    }
}


Filename: .\main\java\rip\diamond\practice\profile\command\settings\ToggleDuelRequestCommand.java
package rip.diamond.practice.profile.command.settings;

import org.bukkit.entity.Player;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.profile.PlayerProfile;
import rip.diamond.practice.profile.ProfileSettings;
import rip.diamond.practice.util.command.Command;
import rip.diamond.practice.util.command.CommandArgs;
import rip.diamond.practice.util.command.argument.CommandArguments;

public class ToggleDuelRequestCommand extends Command {
    @CommandArgs(name = "toggleduelrequest", permission = "eden.settings.allow-duel-request")
    public void execute(CommandArguments command) {
        Player player = command.getPlayer();
        PlayerProfile profile = PlayerProfile.get(player);

        ProfileSettings settings = ProfileSettings.ALLOW_DUEL_REQUEST;

        profile.getSettings().replace(settings, settings.getNextOption(profile.getSettings().get(settings)));
        profile.getSettings().get(settings).run(player);
        settings.runSettingsChangeEvent(player, profile);

        Language.PROFILE_SETTINGS_SUCCESSFULLY_CHANGED.sendMessage(player, settings.getName(), profile.getSettings().get(settings).getName());
    }
}


Filename: .\main\java\rip\diamond\practice\profile\command\settings\ToggleEventAnnouncementCommand.java
package rip.diamond.practice.profile.command.settings;

import org.bukkit.entity.Player;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.profile.PlayerProfile;
import rip.diamond.practice.profile.ProfileSettings;
import rip.diamond.practice.util.command.Command;
import rip.diamond.practice.util.command.CommandArgs;
import rip.diamond.practice.util.command.argument.CommandArguments;

public class ToggleEventAnnouncementCommand extends Command {
    @CommandArgs(name = "toggleeventannouncement", permission = "eden.settings.event-announcement")
    public void execute(CommandArguments command) {
        Player player = command.getPlayer();
        PlayerProfile profile = PlayerProfile.get(player);

        ProfileSettings settings = ProfileSettings.EVENT_ANNOUNCEMENT;

        profile.getSettings().replace(settings, settings.getNextOption(profile.getSettings().get(settings)));
        profile.getSettings().get(settings).run(player);
        settings.runSettingsChangeEvent(player, profile);

        Language.PROFILE_SETTINGS_SUCCESSFULLY_CHANGED.sendMessage(player, settings.getName(), profile.getSettings().get(settings).getName());
    }
}


Filename: .\main\java\rip\diamond\practice\profile\command\settings\ToggleMatchScoreboardCommand.java
package rip.diamond.practice.profile.command.settings;

import org.bukkit.entity.Player;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.profile.PlayerProfile;
import rip.diamond.practice.profile.ProfileSettings;
import rip.diamond.practice.util.command.Command;
import rip.diamond.practice.util.command.CommandArgs;
import rip.diamond.practice.util.command.argument.CommandArguments;

public class ToggleMatchScoreboardCommand extends Command {
    @CommandArgs(name = "togglematchscoreboard", permission = "eden.settings.match-scoreboard")
    public void execute(CommandArguments command) {
        Player player = command.getPlayer();
        PlayerProfile profile = PlayerProfile.get(player);

        ProfileSettings settings = ProfileSettings.MATCH_SCOREBOARD;

        profile.getSettings().replace(settings, settings.getNextOption(profile.getSettings().get(settings)));
        profile.getSettings().get(settings).run(player);
        settings.runSettingsChangeEvent(player, profile);

        Language.PROFILE_SETTINGS_SUCCESSFULLY_CHANGED.sendMessage(player, settings.getName(), profile.getSettings().get(settings).getName());
    }
}


Filename: .\main\java\rip\diamond\practice\profile\command\settings\TogglePartyInviteCommand.java
package rip.diamond.practice.profile.command.settings;

import org.bukkit.entity.Player;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.profile.PlayerProfile;
import rip.diamond.practice.profile.ProfileSettings;
import rip.diamond.practice.util.command.Command;
import rip.diamond.practice.util.command.CommandArgs;
import rip.diamond.practice.util.command.argument.CommandArguments;

public class TogglePartyInviteCommand extends Command {
    @CommandArgs(name = "togglepartyinvite", permission = "eden.settings.allow-party-invite")
    public void execute(CommandArguments command) {
        Player player = command.getPlayer();
        PlayerProfile profile = PlayerProfile.get(player);

        ProfileSettings settings = ProfileSettings.ALLOW_PARTY_INVITE;

        profile.getSettings().replace(settings, settings.getNextOption(profile.getSettings().get(settings)));
        profile.getSettings().get(settings).run(player);
        settings.runSettingsChangeEvent(player, profile);

        Language.PROFILE_SETTINGS_SUCCESSFULLY_CHANGED.sendMessage(player, settings.getName(), profile.getSettings().get(settings).getName());
    }
}


Filename: .\main\java\rip\diamond\practice\profile\command\settings\ToggleSpectatorJoinLeaveMessageCommand.java
package rip.diamond.practice.profile.command.settings;

import org.bukkit.entity.Player;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.profile.PlayerProfile;
import rip.diamond.practice.profile.ProfileSettings;
import rip.diamond.practice.util.command.Command;
import rip.diamond.practice.util.command.CommandArgs;
import rip.diamond.practice.util.command.argument.CommandArguments;

public class ToggleSpectatorJoinLeaveMessageCommand extends Command {
    @CommandArgs(name = "togglespectatorjoinleavemessage", permission = "eden.settings.spectator-join-leave-message")
    public void execute(CommandArguments command) {
        Player player = command.getPlayer();
        PlayerProfile profile = PlayerProfile.get(player);

        ProfileSettings settings = ProfileSettings.SPECTATOR_JOIN_LEAVE_MESSAGE;

        profile.getSettings().replace(settings, settings.getNextOption(profile.getSettings().get(settings)));
        profile.getSettings().get(settings).run(player);
        settings.runSettingsChangeEvent(player, profile);

        Language.PROFILE_SETTINGS_SUCCESSFULLY_CHANGED.sendMessage(player, settings.getName(), profile.getSettings().get(settings).getName());
    }
}


Filename: .\main\java\rip\diamond\practice\profile\command\settings\ToggleSpectatorVisibilityCommand.java
package rip.diamond.practice.profile.command.settings;

import org.bukkit.entity.Player;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.profile.PlayerProfile;
import rip.diamond.practice.profile.ProfileSettings;
import rip.diamond.practice.util.command.Command;
import rip.diamond.practice.util.command.CommandArgs;
import rip.diamond.practice.util.command.argument.CommandArguments;

public class ToggleSpectatorVisibilityCommand extends Command {
    @CommandArgs(name = "togglespectatorvisibility", permission = "eden.settings.spectator-visibility")
    public void execute(CommandArguments command) {
        Player player = command.getPlayer();
        PlayerProfile profile = PlayerProfile.get(player);

        ProfileSettings settings = ProfileSettings.SPECTATOR_VISIBILITY;

        profile.getSettings().replace(settings, settings.getNextOption(profile.getSettings().get(settings)));
        profile.getSettings().get(settings).run(player);
        settings.runSettingsChangeEvent(player, profile);

        Language.PROFILE_SETTINGS_SUCCESSFULLY_CHANGED.sendMessage(player, settings.getName(), profile.getSettings().get(settings).getName());
    }
}


Filename: .\main\java\rip\diamond\practice\profile\cooldown\Cooldown.java
package rip.diamond.practice.profile.cooldown;

import lombok.Getter;
import lombok.Setter;

import java.text.DecimalFormat;


@Getter
@Setter
public class Cooldown {

    private static DecimalFormat SECONDS_FORMAT = new DecimalFormat("#0.0");

    private long start;
    private long expire;

    public Cooldown(int seconds) {
        long duration = 1000L * seconds;
        this.start = System.currentTimeMillis();
        this.expire = this.start + duration;
    }

    public Cooldown(long milliSeconds) {
        this.start = System.currentTimeMillis();
        this.expire = this.start + milliSeconds;
    }

    private static String formatSeconds(long time) {
        return SECONDS_FORMAT.format(time / 1000.0F);
    }

    public long getPassed() {
        return System.currentTimeMillis() - this.start;
    }

    public long getRemaining() {
        return this.expire - System.currentTimeMillis();
    }

    public boolean isExpired() {
        return System.currentTimeMillis() >= this.expire;
    }

    public int getSecondsLeft() {
        return (int) getRemaining() / 1000;
    }

    public String getMilliSecondsLeft(boolean allowNegative) {
        if (!allowNegative && getRemaining() < 0) {
            return "0.0";
        }
        return formatSeconds(this.getRemaining());
    }

    public void cancelCountdown() {
        this.expire = 0;
    }

    public void run() {
        if (isExpired()) {
            cancelCountdown();
            runExpired();
        } else {
            runUnexpired();
        }
    }

    public void runUnexpired() {

    }

    public void runExpired() {

    }
}



Filename: .\main\java\rip\diamond\practice\profile\cooldown\CooldownType.java
package rip.diamond.practice.profile.cooldown;

public enum CooldownType {

    SCORE,
    ARROW,
    GOLDEN_HEAD,
    ENDER_PEARL,
    FIREBALL

}


Filename: .\main\java\rip\diamond\practice\profile\data\ProfileKitData.java
package rip.diamond.practice.profile.data;

import lombok.Getter;
import lombok.Setter;
import net.minecraft.server.v1_8_R3.NBTTagCompound;
import net.minecraft.server.v1_8_R3.NBTTagString;
import org.bson.Document;
import org.bukkit.Material;
import org.bukkit.craftbukkit.v1_8_R3.inventory.CraftItemStack;
import org.bukkit.inventory.ItemStack;
import rip.diamond.practice.Eden;
import rip.diamond.practice.config.Config;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.kits.Kit;
import rip.diamond.practice.kits.KitLoadout;
import rip.diamond.practice.util.CC;
import rip.diamond.practice.util.ItemBuilder;

import java.util.ArrayList;
import java.util.List;

public class ProfileKitData {

	@Getter
	private int elo = Config.PROFILE_DEFAULT_ELO.toInteger();
	@Getter
	@Setter
	private int peakElo = Config.PROFILE_DEFAULT_ELO.toInteger();
	@Getter
	@Setter
	private int unrankedWon = 0;
	@Getter
	@Setter
	private int unrankedLost = 0;
	@Getter
	@Setter
	private int rankedWon = 0;
	@Getter
	@Setter
	private int rankedLost = 0;
	@Getter
	@Setter
	private int bestWinstreak = 0;
	@Getter
	@Setter
	private int winstreak = 0;

	// Time-based wins tracking
	@Getter
	@Setter
	private int dailyWins = 0;
	@Getter
	@Setter
	private int weeklyWins = 0;
	@Getter
	@Setter
	private int monthlyWins = 0;

	// Time-based losses tracking
	@Getter
	@Setter
	private int dailyLosses = 0;
	@Getter
	@Setter
	private int weeklyLosses = 0;
	@Getter
	@Setter
	private int monthlyLosses = 0;

	// Time-based winstreak tracking
	@Getter
	@Setter
	private int dailyWinstreak = 0;
	@Getter
	@Setter
	private int weeklyWinstreak = 0;
	@Getter
	@Setter
	private int monthlyWinstreak = 0;

	// Reset timestamps
	@Getter
	@Setter
	private long lastDailyReset = System.currentTimeMillis();
	@Getter
	@Setter
	private long lastWeeklyReset = System.currentTimeMillis();
	@Getter
	@Setter
	private long lastMonthlyReset = System.currentTimeMillis();

	@Setter
	private KitLoadout[] loadouts = new KitLoadout[8];

	public KitLoadout[] getLoadouts() {
		if (loadouts.length < 8) {
			KitLoadout[] newLoadouts = new KitLoadout[8];
			System.arraycopy(loadouts, 0, newLoadouts, 0, loadouts.length);
			loadouts = newLoadouts;
		}
		return loadouts;
	}

	public void fromBson(Document document) {
		elo = document.getInteger("elo");
		peakElo = document.getInteger("peakElo");
		unrankedWon = document.getInteger("unrankedWon");
		unrankedLost = document.getInteger("unrankedLost");
		rankedWon = document.getInteger("rankedWon");
		rankedLost = document.getInteger("rankedLost");
		bestWinstreak = document.getInteger("bestWinstreak");
		winstreak = document.getInteger("winstreak");

		// Time-based wins
		dailyWins = document.containsKey("dailyWins") ? document.getInteger("dailyWins") : 0;
		weeklyWins = document.containsKey("weeklyWins") ? document.getInteger("weeklyWins") : 0;
		monthlyWins = document.containsKey("monthlyWins") ? document.getInteger("monthlyWins") : 0;

		// Time-based losses
		dailyLosses = document.containsKey("dailyLosses") ? document.getInteger("dailyLosses") : 0;
		weeklyLosses = document.containsKey("weeklyLosses") ? document.getInteger("weeklyLosses") : 0;
		monthlyLosses = document.containsKey("monthlyLosses") ? document.getInteger("monthlyLosses") : 0;

		// Time-based winstreaks
		dailyWinstreak = document.containsKey("dailyWinstreak") ? document.getInteger("dailyWinstreak") : 0;
		weeklyWinstreak = document.containsKey("weeklyWinstreak") ? document.getInteger("weeklyWinstreak") : 0;
		monthlyWinstreak = document.containsKey("monthlyWinstreak") ? document.getInteger("monthlyWinstreak") : 0;

		// Reset timestamps
		lastDailyReset = document.containsKey("lastDailyReset") ? document.getLong("lastDailyReset")
				: System.currentTimeMillis();
		lastWeeklyReset = document.containsKey("lastWeeklyReset") ? document.getLong("lastWeeklyReset")
				: System.currentTimeMillis();
		lastMonthlyReset = document.containsKey("lastMonthlyReset") ? document.getLong("lastMonthlyReset")
				: System.currentTimeMillis();

		KitLoadout[] loadedLoadouts = Eden.GSON.fromJson(document.getString("loadouts"), KitLoadout[].class);
		if (loadedLoadouts != null) {
			if (loadedLoadouts.length < 8) {
				System.arraycopy(loadedLoadouts, 0, loadouts, 0, loadedLoadouts.length);
			} else {
				loadouts = loadedLoadouts;
			}
		}
	}

	public Document toBson() {
		return new Document()
				.append("elo", elo)
				.append("peakElo", peakElo)
				.append("unrankedWon", unrankedWon)
				.append("unrankedLost", unrankedLost)
				.append("rankedWon", rankedWon)
				.append("rankedLost", rankedLost)
				.append("won", getWon()) // Used for leaderboard display
				.append("bestWinstreak", bestWinstreak)
				.append("winstreak", winstreak)
				// Time-based wins
				.append("dailyWins", dailyWins)
				.append("weeklyWins", weeklyWins)
				.append("monthlyWins", monthlyWins)
				// Time-based losses
				.append("dailyLosses", dailyLosses)
				.append("weeklyLosses", weeklyLosses)
				.append("monthlyLosses", monthlyLosses)
				// Time-based winstreaks
				.append("dailyWinstreak", dailyWinstreak)
				.append("weeklyWinstreak", weeklyWinstreak)
				.append("monthlyWinstreak", monthlyWinstreak)
				// Reset timestamps
				.append("lastDailyReset", lastDailyReset)
				.append("lastWeeklyReset", lastWeeklyReset)
				.append("lastMonthlyReset", lastMonthlyReset)
				.append("loadouts", Eden.GSON.toJson(loadouts));
	}

	public int getWon() {
		return unrankedWon + rankedWon;
	}

	public void incrementWon(boolean ranked) {
		if (ranked) {
			this.rankedWon++;
		} else {
			this.unrankedWon++;
		}

		// Check and reset time-based wins if needed
		checkAndResetTimePeriods();

		// Increment time-based wins
		dailyWins++;
		weeklyWins++;
		monthlyWins++;
	}

	public void incrementLost(boolean ranked) {
		if (ranked) {
			this.rankedLost++;
		} else {
			this.unrankedLost++;
		}

		// Check and reset time-based losses if needed
		checkAndResetTimePeriods();

		// Increment time-based losses
		dailyLosses++;
		weeklyLosses++;
		monthlyLosses++;
	}

	public void setElo(int elo) {
		this.elo = elo;
		if (peakElo < elo) {
			peakElo = elo;
		}
	}

	public void calculateWinstreak(boolean won) {
		if (won) {
			winstreak++;
			if (bestWinstreak < winstreak)
				bestWinstreak = winstreak;

			// Check and reset time-based winstreaks if needed
			checkAndResetTimePeriods();

			// Increment time-based winstreaks
			dailyWinstreak++;
			weeklyWinstreak++;
			monthlyWinstreak++;
		} else {
			winstreak = 0;
			dailyWinstreak = 0;
			weeklyWinstreak = 0;
			monthlyWinstreak = 0;
		}
	}

	/**
	 * Check and reset all time periods if they have expired
	 */
	private void checkAndResetTimePeriods() {
		long now = System.currentTimeMillis();

		// Check daily reset
		if (!isSameDay(lastDailyReset, now)) {
			dailyWins = 0;
			dailyLosses = 0;
			dailyWinstreak = 0;
			lastDailyReset = now;
		}

		// Check weekly reset
		if (!isSameWeek(lastWeeklyReset, now)) {
			weeklyWins = 0;
			weeklyLosses = 0;
			weeklyWinstreak = 0;
			lastWeeklyReset = now;
		}

		// Check monthly reset
		if (!isSameMonth(lastMonthlyReset, now)) {
			monthlyWins = 0;
			monthlyLosses = 0;
			monthlyWinstreak = 0;
			lastMonthlyReset = now;
		}
	}

	private boolean isSameDay(long time1, long time2) {
		java.util.Calendar cal1 = java.util.Calendar.getInstance();
		cal1.setTimeInMillis(time1);
		java.util.Calendar cal2 = java.util.Calendar.getInstance();
		cal2.setTimeInMillis(time2);
		return cal1.get(java.util.Calendar.YEAR) == cal2.get(java.util.Calendar.YEAR) &&
				cal1.get(java.util.Calendar.DAY_OF_YEAR) == cal2.get(java.util.Calendar.DAY_OF_YEAR);
	}

	private boolean isSameWeek(long time1, long time2) {
		java.util.Calendar cal1 = java.util.Calendar.getInstance();
		cal1.setTimeInMillis(time1);
		java.util.Calendar cal2 = java.util.Calendar.getInstance();
		cal2.setTimeInMillis(time2);
		return cal1.get(java.util.Calendar.YEAR) == cal2.get(java.util.Calendar.YEAR) &&
				cal1.get(java.util.Calendar.WEEK_OF_YEAR) == cal2.get(java.util.Calendar.WEEK_OF_YEAR);
	}

	private boolean isSameMonth(long time1, long time2) {
		java.util.Calendar cal1 = java.util.Calendar.getInstance();
		cal1.setTimeInMillis(time1);
		java.util.Calendar cal2 = java.util.Calendar.getInstance();
		cal2.setTimeInMillis(time2);
		return cal1.get(java.util.Calendar.YEAR) == cal2.get(java.util.Calendar.YEAR) &&
				cal1.get(java.util.Calendar.MONTH) == cal2.get(java.util.Calendar.MONTH);
	}

	public KitLoadout getLoadout(int index) {
		return loadouts[index];
	}

	public void replaceKit(int index, KitLoadout loadout) {
		loadouts[index] = loadout;
	}

	public void deleteKit(int index) {
		loadouts[index] = null;
	}

	public List<ItemStack> getKitItems(Kit kit) {
		List<ItemStack> toReturn = new ArrayList<>();

		for (KitLoadout loadout : loadouts) {
			if (loadout != null) {
				ItemStack itemStack = new ItemBuilder(Material.ENCHANTED_BOOK)
						.name(CC.AQUA + loadout.getCustomName())
						.lore(Language.PROFILE_KIT_RIGHT_CLICK_TO_RECEIVE.toStringList())
						.build();

				net.minecraft.server.v1_8_R3.ItemStack nmsItem = CraftItemStack.asNMSCopy(itemStack);
				NBTTagCompound compound = (nmsItem.hasTag()) ? nmsItem.getTag() : new NBTTagCompound();
				compound.set("armor", new NBTTagString(loadout.getArmorAsBase64()));
				compound.set("contents", new NBTTagString(loadout.getContentsAsBase64()));
				compound.set("name", new NBTTagString(loadout.getCustomName()));
				toReturn.add(CraftItemStack.asBukkitCopy(nmsItem));
			}
		}

		ItemStack itemStack = new ItemBuilder(Material.BOOK)
				.name(CC.AQUA + kit.getKitLoadout().getCustomName())
				.lore(Language.PROFILE_KIT_RIGHT_CLICK_TO_RECEIVE.toStringList())
				.build();
		net.minecraft.server.v1_8_R3.ItemStack nmsItem = CraftItemStack.asNMSCopy(itemStack);
		NBTTagCompound compound = (nmsItem.hasTag()) ? nmsItem.getTag() : new NBTTagCompound();
		compound.set("armor", new NBTTagString(kit.getKitLoadout().getArmorAsBase64()));
		compound.set("contents", new NBTTagString(kit.getKitLoadout().getContentsAsBase64()));
		compound.set("name", new NBTTagString(kit.getKitLoadout().getCustomName()));

		toReturn.add(CraftItemStack.asBukkitCopy(nmsItem));

		return toReturn;
	}

}


Filename: .\main\java\rip\diamond\practice\profile\listener\ProfileListener.java
package rip.diamond.practice.profile.listener;

import lombok.RequiredArgsConstructor;
import net.minecraft.server.v1_8_R3.NBTTagCompound;
import org.bukkit.Bukkit;
import org.bukkit.GameMode;
import org.bukkit.craftbukkit.v1_8_R3.inventory.CraftItemStack;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.Listener;
import org.bukkit.event.block.BlockBreakEvent;
import org.bukkit.event.block.BlockPlaceEvent;
import org.bukkit.event.entity.EntityDamageEvent;
import org.bukkit.event.entity.FoodLevelChangeEvent;
import org.bukkit.event.inventory.InventoryClickEvent;
import org.bukkit.event.player.*;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.PlayerInventory;
import rip.diamond.practice.Eden;
import rip.diamond.practice.EdenItems;
import rip.diamond.practice.config.Config;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.event.PlayerProfileLoadedEvent;
import rip.diamond.practice.event.SettingsChangeEvent;
import rip.diamond.practice.kits.KitLoadout;
import rip.diamond.practice.match.Match;
import rip.diamond.practice.match.menu.SpectateTeleportMenu;
import rip.diamond.practice.profile.PlayerProfile;
import rip.diamond.practice.profile.PlayerState;
import rip.diamond.practice.profile.ProfileSettings;
import rip.diamond.practice.queue.Queue;
import rip.diamond.practice.util.*;
import rip.diamond.practice.util.exception.PracticeUnexpectedException;
import rip.diamond.practice.util.option.Option;

import java.util.List;

@RequiredArgsConstructor
public class ProfileListener implements Listener {

    private final Eden plugin;

    @EventHandler(priority = EventPriority.LOW)
    public void onJoin(PlayerJoinEvent event) {
        event.setJoinMessage(null);

        Player player = event.getPlayer();

        if (PlayerProfile.get(player) != null) {
            player.kickPlayer(CC.RED + "[Eden] Please wait for a few seconds before re-login");
            return;
        }
        PlayerProfile profile = PlayerProfile.createPlayerProfile(player);

        //Reset their inventory and their location, to prevent player stuck in other places or contains illegal items
        PlayerUtil.reset(player);
        plugin.getLobbyManager().teleport(player);

        profile.load((success) -> {
            if (!success) {
                Tasks.run(()-> player.kickPlayer(CC.RED + "[Eden] Unable to load your data. Please try to re-login in a few seconds"));
            } else {
                Language.JOIN_MESSAGE.sendListOfMessage(player);
                plugin.getLobbyManager().sendToSpawnAndReset(player);
                profile.getSettings().get(ProfileSettings.TIME_CHANGER).run(player);

                PlayerProfileLoadedEvent e = new PlayerProfileLoadedEvent(player, profile);
                e.call();
            }
        });
    }

    @EventHandler(priority = EventPriority.HIGH)
    public void onQuit(PlayerQuitEvent event) {
        event.setQuitMessage(null);

        Player player = event.getPlayer();
        PlayerProfile profile = PlayerProfile.get(player);

        if (profile == null) { //Áï∂Âú® PlayerJoinEvent Êú™ËÉΩÂä†ËºâË≥áÊñôÁöÑÊôÇÂÄô, profile Â∞±ÊúÉÊòØ null
            Common.log(player.getName() + "'s profile is not saved due to the profile is null");
            return;
        }

        profile.save(true, (success) -> {
            if (success) {
                PlayerProfile.getProfiles().remove(player.getUniqueId());
            } else {
                Common.log(CC.RED + "[Eden] Unable to save " + player.getName() + "'s profile. Data is not going to clear.");
            }
        });
    }

    //This event is only to prevent players to open block's inventory. We still allow plugins to run all PlayerInteractEvent
    @EventHandler(priority = EventPriority.LOW)
    public void onInteract(PlayerInteractEvent event) {
        Player player = event.getPlayer();
        PlayerProfile profile = PlayerProfile.get(player);

        if (profile.getPlayerState() != PlayerState.IN_MATCH) {
            event.setCancelled(player.getGameMode() != GameMode.CREATIVE);
            //We don't stop the process here, continue the check
        }

        ItemStack item = event.getItem();
        if (item == null) {
            return;
        }

        if (event.getAction().name().startsWith("RIGHT_")) {
            if (profile.getPlayerState() == PlayerState.LOADING) {
                Language.LOADING_PROFILE.sendMessage(player);
                return;
            }

            net.minecraft.server.v1_8_R3.ItemStack nmsItem = CraftItemStack.asNMSCopy(item);
            if (nmsItem.hasTag()) {
                NBTTagCompound compound = nmsItem.getTag();
                if (compound.hasKey("command")) {
                    String command = compound.getString("command");
                    Util.performCommand(player, command);
                }
            }
        }
    }


    @EventHandler
    public void onDamage(EntityDamageEvent event) {
        if (!(event.getEntity() instanceof Player)) {
            return;
        }
        Player player = (Player) event.getEntity();
        if (!Checker.canDamage(player)) {
            event.setCancelled(true);
        }
    }

    @EventHandler
    public void onHunger(FoodLevelChangeEvent event) {
        if (!(event.getEntity() instanceof Player)) {
            return;
        }
        Player player = (Player) event.getEntity();
        if (!Checker.canDamage(player)) {
            event.setFoodLevel(20);
        }
    }

    @EventHandler(priority = EventPriority.HIGHEST)
    public void onPlace(BlockPlaceEvent event) {
        Player player = event.getPlayer();
        PlayerProfile profile = PlayerProfile.get(player);
        if (profile.getPlayerState() != PlayerState.IN_MATCH) {
            event.setCancelled(event.getPlayer().getGameMode() != GameMode.CREATIVE);
        }
    }

    @EventHandler(priority = EventPriority.HIGHEST)
    public void onBreak(BlockBreakEvent event) {
        if (!Checker.canDamage(event.getPlayer())) {
            event.setCancelled(event.getPlayer().getGameMode() != GameMode.CREATIVE);
        }
    }

    @EventHandler
    public void onDrop(PlayerDropItemEvent event) {
        Player player = event.getPlayer();
        if (!Checker.canDamage(player)) {
            event.setCancelled(event.getPlayer().getGameMode() != GameMode.CREATIVE);
        }
    }

    @EventHandler
    public void onPickup(PlayerPickupItemEvent event) {
        Player player = event.getPlayer();
        if (!Checker.canDamage(player)) {
            event.setCancelled(event.getPlayer().getGameMode() != GameMode.CREATIVE);
        }
    }

    @EventHandler
    public void onInventoryClick(InventoryClickEvent event) {
        //Èò≤Ê≠¢Áé©ÂÆ∂ÁßªÂãïÁâ©ÂìÅÊ¨Ñ‰∏≠ÁöÑÁâ©ÂìÅ
        if (event.getWhoClicked() instanceof Player) {
            Player player = (Player) event.getWhoClicked();
            PlayerProfile profile = PlayerProfile.get(player);

            if (event.getClickedInventory() instanceof PlayerInventory && !profile.getPlayerState().isAbleToMoveItemInInventory()) {
                event.setCancelled(player.getGameMode() != GameMode.CREATIVE);
            }
        }
    }

    @EventHandler
    public void onCommand(PlayerCommandPreprocessEvent event) {
        Player player = event.getPlayer();
        PlayerProfile profile = PlayerProfile.get(player);

        if (profile.getPlayerState() == PlayerState.LOADING) {
            Language.LOADING_PROFILE.sendMessage(player);
            event.setCancelled(true);
            return;
        }

        if (profile.getPlayerState() != PlayerState.IN_LOBBY) {
            List<String> usableCommands = Config.LOBBY_ONLY_COMMANDS.toStringList();
            String cmd = event.getMessage().toLowerCase();
            if (!usableCommands.isEmpty() && usableCommands.contains(cmd)) {
                event.setCancelled(true);
                Language.BANNED_COMMAND.sendMessage(player);
                return;
            }
        }
    }

    @EventHandler
    public void onSettingsChange(SettingsChangeEvent event) {
        Player player = event.getPlayer();
        PlayerProfile profile = event.getProfile();
        ProfileSettings settings = event.getSettings();
        Match match = profile.getMatch();

        if (profile.getMatch() != null && settings == ProfileSettings.SPECTATOR_VISIBILITY) {
            if (profile.getPlayerState() == PlayerState.IN_MATCH && match.getTeamPlayer(player).isAlive()) {
                return;
            }
            VisibilityController.updateVisibility(player);
            profile.setupItems();
        }
    }

}


Filename: .\main\java\rip\diamond\practice\profile\menu\ProfileSettingsMenu.java
package rip.diamond.practice.profile.menu;

import org.bukkit.Material;
import org.bukkit.entity.Player;
import org.bukkit.event.inventory.ClickType;
import org.bukkit.inventory.ItemStack;
import rip.diamond.practice.Eden;
import rip.diamond.practice.profile.PlayerProfile;
import rip.diamond.practice.profile.ProfileSettings;
import rip.diamond.practice.util.BasicConfigFile;
import rip.diamond.practice.util.CC;
import rip.diamond.practice.util.ItemBuilder;
import rip.diamond.practice.util.menu.Button;
import rip.diamond.practice.util.menu.Menu;
import rip.diamond.practice.util.option.Option;
import rip.diamond.practice.util.option.TrueOption;
import rip.diamond.practice.util.option.FalseOption;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class ProfileSettingsMenu extends Menu {
    @Override
    public String getTitle(Player player) {
        BasicConfigFile config = Eden.INSTANCE.getMenusConfig().getConfig();
        return CC.translate(config.getString("profile-settings-menu.title"));
    }

    @Override
    public int getSize() {
        BasicConfigFile config = Eden.INSTANCE.getMenusConfig().getConfig();
        String sizeStr = config.getString("profile-settings-menu.size");

        if ("dynamic".equalsIgnoreCase(sizeStr)) {
            // Calculate dynamic size based on number of settings
            int settingsCount = ProfileSettings.values().length;
            boolean hasBorder = config.getBoolean("profile-settings-menu.border.enabled");

            // Calculate needed rows
            int slotsPerRow = hasBorder ? 7 : 9;
            int rowsNeeded = (int) Math.ceil((double) settingsCount / slotsPerRow);
            int totalRows = rowsNeeded + (hasBorder ? 2 : 0);

            // Ensure minimum of 3 rows
            int maxSize = config.getInt("profile-settings-menu.max-size");
            int calculatedSize = Math.max(27, Math.min(totalRows * 9, maxSize));

            // Round to valid inventory size
            return ((calculatedSize + 8) / 9) * 9;
        } else {
            return config.getInt("profile-settings-menu.size");
        }
    }

    @Override
    public Map<Integer, Button> getButtons(Player player) {
        final Map<Integer, Button> buttons = new HashMap<>();
        BasicConfigFile config = Eden.INSTANCE.getMenusConfig().getConfig();

        // Filler
        if (config.getBoolean("profile-settings-menu.filler.enabled")) {
            ItemStack filler = new ItemBuilder(
                    Material.valueOf(config.getString("profile-settings-menu.filler.material")))
                    .durability(config.getInt("profile-settings-menu.filler.data"))
                    .name(" ")
                    .build();
            for (int i = 0; i < getSize(); i++) {
                buttons.put(i, new Button() {
                    @Override
                    public ItemStack getButtonItem(Player player) {
                        return filler;
                    }
                });
            }
        }

        // Border
        if (config.getBoolean("profile-settings-menu.border.enabled")) {
            ItemStack border = new ItemBuilder(
                    Material.valueOf(config.getString("profile-settings-menu.border.material")))
                    .durability(config.getInt("profile-settings-menu.border.data"))
                    .name(" ")
                    .build();
            int size = getSize();
            for (int i = 0; i < size; i++) {
                if (i < 9 || i >= size - 9 || i % 9 == 0 || i % 9 == 8) {
                    buttons.put(i, new Button() {
                        @Override
                        public ItemStack getButtonItem(Player player) {
                            return border;
                        }
                    });
                }
            }
        }

        // Settings buttons
        for (ProfileSettings settings : ProfileSettings.values()) {
            String configKey = settings.name().toLowerCase().replace('_', '-');
            String path = "profile-settings-menu.items." + configKey;

            if (config.getConfiguration().contains(path)) {
                int slot = config.getInt(path + ".slot");
                buttons.put(slot, new Button() {
                    @Override
                    public ItemStack getButtonItem(Player player) {
                        PlayerProfile profile = PlayerProfile.get(player);
                        Option currentOption = profile.getSettings().get(settings);
                        Option defaultOption = settings.getDefault();

                        String optionValue = currentOption.getValue().toLowerCase();
                        if (settings == ProfileSettings.PING_RANGE
                                && optionValue.equals(String.valueOf(Integer.MAX_VALUE))) {
                            optionValue = "unlimited";
                        }
                        String specificPath = path + "." + optionValue;
                        String statePath;

                        // Check if material exists at base path (for settings like ping-range)
                        if (config.getConfiguration().contains(path + ".material")) {
                            statePath = path;
                        }
                        // Check if specific configuration exists for this option value
                        else if (config.getConfiguration().contains(specificPath + ".material")) {
                            statePath = specificPath;
                        } else {
                            // Fallback to enabled/disabled logic
                            boolean isEnabledState;
                            if (settings.getOptions().size() == 2 &&
                                    (settings.getOptions().get(0) instanceof TrueOption ||
                                            settings.getOptions().get(0) instanceof FalseOption)) {
                                // Boolean setting
                                isEnabledState = Boolean.parseBoolean(currentOption.getValue());
                            } else {
                                // Multi-option setting: Non-default is considered "enabled"
                                isEnabledState = !currentOption.equals(defaultOption);
                            }
                            statePath = path + "." + (isEnabledState ? "enabled" : "disabled");
                        }

                        ItemBuilder builder = new ItemBuilder(
                                org.bukkit.Material.valueOf(config.getString(statePath + ".material")))
                                .durability(config.getInt(statePath + ".data"))
                                .name(config.getString(statePath + ".name"));

                        // Handle lore with placeholders for ping-range
                        List<String> lore = config.getStringList(statePath + ".lore");
                        if (settings == ProfileSettings.PING_RANGE) {
                            Option nextOption = settings.getNextOption(currentOption);
                            String currentDisplay = optionValue.equals("unlimited") ? "Unlimited" : optionValue + "ms";
                            String nextValue = nextOption.getValue().toLowerCase();
                            String nextDisplay = nextValue.equals(String.valueOf(Integer.MAX_VALUE)) ? "Unlimited"
                                    : nextValue + "ms";

                            lore = lore.stream()
                                    .map(line -> line.replace("{current}", currentDisplay).replace("{next}",
                                            nextDisplay))
                                    .collect(java.util.stream.Collectors.toList());
                        }
                        builder.lore(lore);

                        if (config.getBoolean(statePath + ".glow")) {
                            builder.glow();
                        }

                        return builder.build();
                    }

                    @Override
                    public void clicked(Player player, ClickType clickType) {
                        PlayerProfile profile = PlayerProfile.get(player);
                        Option currentOption = profile.getSettings().get(settings);

                        if (settings.getPermission() != null && !player.hasPermission(settings.getPermission())) {
                            player.sendMessage(CC.RED + "You don't have permission to change this setting.");
                            return;
                        }

                        // Special handling for PING_RANGE
                        if (settings == ProfileSettings.PING_RANGE) {
                            // Shift click resets to infinite
                            if (clickType.isShiftClick()) {
                                Option infiniteOption = settings.getOptions().get(0); // First option is infinite
                                profile.getSettings().replace(settings, infiniteOption);
                                infiniteOption.run(player);
                            }
                            // Left click: decrease ping range (50 -> 100 -> 150 -> 200 -> 300 -> infinite)
                            else if (clickType.isLeftClick()) {
                                Option last = settings.getLastOption(currentOption);
                                profile.getSettings().replace(settings, last);
                                last.run(player);
                            }
                            // Right click: increase ping range (infinite -> 300 -> 200 -> 150 -> 100 -> 50)
                            else if (clickType.isRightClick()) {
                                Option next = settings.getNextOption(currentOption);
                                profile.getSettings().replace(settings, next);
                                next.run(player);
                            }
                        } else {
                            // Default behavior for other settings
                            if (clickType.isLeftClick()) {
                                Option next = settings.getNextOption(currentOption);
                                profile.getSettings().replace(settings, next);
                                next.run(player);
                            } else if (clickType.isRightClick()) {
                                Option last = settings.getLastOption(currentOption);
                                profile.getSettings().replace(settings, last);
                                last.run(player);
                            }
                        }

                        settings.runSettingsChangeEvent(player, profile);
                    }

                    @Override
                    public boolean shouldUpdate(Player player, ClickType clickType) {
                        return true;
                    }
                });
            }
        }

        return buttons;
    }
}


Filename: .\main\java\rip\diamond\practice\profile\menu\button\SettingsButton.java
package rip.diamond.practice.profile.menu.button;

import lombok.RequiredArgsConstructor;
import org.bukkit.entity.Player;
import org.bukkit.event.inventory.ClickType;
import org.bukkit.inventory.ItemStack;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.event.SettingsChangeEvent;
import rip.diamond.practice.profile.PlayerProfile;
import rip.diamond.practice.profile.ProfileSettings;
import rip.diamond.practice.util.CC;
import rip.diamond.practice.util.ItemBuilder;
import rip.diamond.practice.util.menu.Button;
import rip.diamond.practice.util.option.Option;

import java.util.stream.Collectors;

@RequiredArgsConstructor
public class SettingsButton extends Button {

    private final ProfileSettings settings;

    @Override
    public ItemStack getButtonItem(Player player) {
        PlayerProfile profile = PlayerProfile.get(player);
        rip.diamond.practice.util.BasicConfigFile config = rip.diamond.practice.Eden.INSTANCE.getMenusConfig()
                .getConfig();

        String clickMessage = config.getString("profile-settings-menu.items.settings-click-message");
        String noPermMessage = config.getString("profile-settings-menu.items.settings-no-permission");

        return new ItemBuilder(settings.getIcon())
                .name(CC.AQUA + settings.getName())
                .lore(settings.getDescription())
                .lore(settings.getOptions().stream()
                        .map(options -> (profile.getSettings().get(settings).equals(options) ? CC.GREEN + " ¬ª "
                                : CC.GRAY + "   ") + options.getName())
                        .collect(Collectors.toList()))
                .lore("", hasPermission(player) ? CC.translate(clickMessage) : CC.translate(noPermMessage))
                .build();
    }

    @Override
    public void clicked(Player player, ClickType clickType) {
        PlayerProfile profile = PlayerProfile.get(player);
        Option currentOption = profile.getSettings().get(settings);

        if (!hasPermission(player)) {
            Language.PROFILE_SETTINGS_MENU_NO_PERMISSION.sendMessage(player);
            return;
        }
        if (clickType.isLeftClick()) {
            profile.getSettings().replace(settings, settings.getNextOption(currentOption));
            profile.getSettings().get(settings).run(player);
        } else if (clickType.isRightClick()) {
            profile.getSettings().replace(settings, settings.getLastOption(currentOption));
            profile.getSettings().get(settings).run(player);
        }

        settings.runSettingsChangeEvent(player, profile);
    }

    @Override
    public boolean shouldUpdate(Player player, ClickType clickType) {
        return true;
    }

    private boolean hasPermission(Player player) {
        return settings.getPermission() == null || player.hasPermission(settings.getPermission());
    }
}


Filename: .\main\java\rip\diamond\practice\profile\procedure\Procedure.java
package rip.diamond.practice.profile.procedure;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import org.bukkit.entity.Player;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.util.CC;
import rip.diamond.practice.util.Common;

import java.util.HashMap;
import java.util.Map;
import java.util.UUID;
import java.util.function.Consumer;

@Getter
@RequiredArgsConstructor
public class Procedure {

    @Getter private static final Map<UUID, Procedure> procedures = new HashMap<>();

    private final UUID uuid;
    private final ProcedureType procedureType;
    private final Consumer<Object> callback;

    public static void buildProcedure(Player player, ProcedureType procedureType, Consumer<Object> callback) {
        buildProcedure(player, null, procedureType, callback);
    }

    public static void buildProcedure(Player player, String instructions, ProcedureType procedureType, Consumer<Object> callback) {
        Common.sendMessage(player, instructions == null ? null : CC.YELLOW + CC.BOLD + instructions, Language.PROFILE_PROCEDURE_ENTER_CANCEL_TO_CANCEL.toString());

        Procedure procedure = new Procedure(player.getUniqueId(), procedureType, callback);
        procedures.put(player.getUniqueId(), procedure);
    }

    public void call(Object o) {
        remove();
        callback.accept(o);
    }

    public void remove() {
        procedures.remove(uuid);
    }

}


Filename: .\main\java\rip\diamond\practice\profile\procedure\ProcedureListener.java
package rip.diamond.practice.profile.procedure;

import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.Listener;
import org.bukkit.event.block.Action;
import org.bukkit.event.player.AsyncPlayerChatEvent;
import org.bukkit.event.player.PlayerInteractEvent;
import rip.diamond.practice.config.Language;

public class ProcedureListener implements Listener{

    @EventHandler
    public void onChat(AsyncPlayerChatEvent event) {
        Player player = event.getPlayer();
        Procedure procedure = Procedure.getProcedures().get(player.getUniqueId());
        if (procedure == null) {
            return;
        }

        event.setCancelled(true);

        String message = event.getMessage();
        if (message.equalsIgnoreCase("cancel")) {
            procedure.remove();
            Language.PROFILE_PROCEDURE_SUCCESS_CANCEL.sendMessage(player);
            return;
        }
        if (procedure.getProcedureType() == ProcedureType.CHAT) {
            procedure.call(event.getMessage());
            event.setCancelled(true);
        }
    }

    @EventHandler
    public void onInteract(PlayerInteractEvent event) {
        Player player = event.getPlayer();
        Action action = event.getAction();
        if (action != Action.LEFT_CLICK_BLOCK) {
            return;
        }

        Procedure procedure = Procedure.getProcedures().get(player.getUniqueId());
        if (procedure == null) {
            return;
        }

        event.setCancelled(true);

        if (procedure.getProcedureType() == ProcedureType.BREAK_BLOCK) {
            procedure.call(event.getClickedBlock());
        }
    }

}


Filename: .\main\java\rip\diamond\practice\profile\procedure\ProcedureType.java
package rip.diamond.practice.profile.procedure;

public enum ProcedureType {

    CHAT,
    BREAK_BLOCK

}


Filename: .\main\java\rip\diamond\practice\profile\task\ProfileAutoSaveTask.java
package rip.diamond.practice.profile.task;

import rip.diamond.practice.profile.PlayerProfile;
import rip.diamond.practice.util.TaskTicker;

public class ProfileAutoSaveTask extends TaskTicker {
    public ProfileAutoSaveTask() {
        super(0, 20*60*5, true);
    }

    @Override
    public void onRun() {
        PlayerProfile.getProfiles().values().forEach(playerProfile -> {
            if (!playerProfile.isTemporary()) {
                playerProfile.save(true, (success) -> {
                    if (success && playerProfile.getPlayer() == null) {
                        PlayerProfile.getProfiles().remove(playerProfile.getUniqueId());
                    }
                });
            }
        });
    }

    @Override
    public void preRun() {

    }

    @Override
    public TickType getTickType() {
        return TickType.NONE;
    }

    @Override
    public int getStartTick() {
        return 0;
    }
}


Filename: .\main\java\rip\diamond\practice\profile\task\ProfileCooldownTask.java
package rip.diamond.practice.profile.task;

import rip.diamond.practice.profile.PlayerProfile;
import rip.diamond.practice.profile.cooldown.Cooldown;
import rip.diamond.practice.profile.cooldown.CooldownType;
import rip.diamond.practice.util.TaskTicker;

import java.util.Map;

public class ProfileCooldownTask extends TaskTicker {
    public ProfileCooldownTask() {
        super(0, 1, true);
    }

    @Override
    public synchronized void onRun() {
        for (PlayerProfile profile : PlayerProfile.getProfiles().values()) {
            for (Map.Entry<CooldownType, Cooldown> cooldownTypeCooldownEntry : profile.getCooldowns().entrySet()) {
                Cooldown cooldown = cooldownTypeCooldownEntry.getValue();
                //expire == 0 means the cooldown is cancelled by other stuff
                if (cooldown.getExpire() != 0) {
                    cooldown.run();
                }
            }
        }
    }

    @Override
    public void preRun() {

    }

    @Override
    public TaskTicker.TickType getTickType() {
        return TaskTicker.TickType.NONE;
    }

    @Override
    public int getStartTick() {
        return 0;
    }
}


Filename: .\main\java\rip\diamond\practice\queue\Queue.java
package rip.diamond.practice.queue;

import lombok.Getter;
import org.bukkit.entity.Player;
import rip.diamond.practice.Eden;
import rip.diamond.practice.config.Config;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.kits.Kit;
import rip.diamond.practice.party.Party;
import rip.diamond.practice.profile.PlayerProfile;
import rip.diamond.practice.profile.PlayerState;
import rip.diamond.practice.profile.data.ProfileKitData;
import rip.diamond.practice.queue.task.QueueTask;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.stream.Collectors;

public class Queue {

    @Getter private static final Map<UUID, QueueProfile> players = new HashMap<>();

    public static void init() {
        new QueueTask();
    }

    public static List<QueueProfile> getUnmatchedPlayers() {
        return players.values().stream().filter(qProfile -> !qProfile.isFound()).collect(Collectors.toList());
    }

    public static void joinQueue(Player player, Kit kit, QueueType queueType) {
        if (player == null || !player.isOnline()) {
            return;
        }
        if (players.get(player.getUniqueId()) != null) {
            Language.QUEUE_ERROR_FOUND_QUEUE_PROFILE.sendMessage(player);
            return;
        }
        if (Party.getByPlayer(player) != null) {
            Language.PARTY_IN_A_PARTY.sendMessage(player);
            return;
        }

        PlayerProfile profile = PlayerProfile.get(player);
        if (profile.getPlayerState() != PlayerState.IN_LOBBY) {
            Language.QUEUE_WRONG_STATE.sendMessage(player);
            return;
        }

        if (profile.getKitData().get(kit.getName()) == null) {
            Language.QUEUE_ERROR_KIT_DATA_NOT_FOUND.sendMessage(player);
            return;
        }

        if (queueType == QueueType.RANKED) {
            int required = Config.QUEUE_RANKED_REQUIRED_WINS.toInteger();
            int wins = profile.getKitData().values().stream().mapToInt(ProfileKitData::getUnrankedWon).sum();
            if (wins < required) {
                Language.QUEUE_ERROR_NOT_ENOUGH_WINS.sendMessage(player, required, wins);
                return;
            }
        }

        QueueProfile qProfile = new QueueProfile(player.getUniqueId(), kit, profile.getKitData().get(kit.getName()).getElo(), queueType);
        players.put(player.getUniqueId(), qProfile);
        profile.setPlayerState(PlayerState.IN_QUEUE);
        profile.setupItems();

        Language.QUEUE_SUCCESS_JOIN.sendMessage(player, kit.getDisplayName());
    }

    public static void leaveQueue(Player player) {
        PlayerProfile profile = PlayerProfile.get(player);
        QueueProfile qProfile = players.get(player.getUniqueId());

        if (profile.getPlayerState() != PlayerState.IN_QUEUE) {
            Language.QUEUE_CANNOT_QUIT_QUEUE.sendMessage(player);
            return;
        }
        if (qProfile == null) {
            Language.QUEUE_ERROR_NOT_FOUND_QUEUE_PROFILE.sendMessage(player);
            return;
        }

        players.remove(player.getUniqueId());

        Eden.INSTANCE.getLobbyManager().reset(player);

        Language.QUEUE_SUCCESS_QUIT.sendMessage(player, qProfile.getKit().getDisplayName());
    }

}


Filename: .\main\java\rip\diamond\practice\queue\QueueListener.java
package rip.diamond.practice.queue;

import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.Listener;
import org.bukkit.event.player.PlayerQuitEvent;

public class QueueListener implements Listener {

    @EventHandler(priority = EventPriority.LOW)
    public void onQuit(PlayerQuitEvent event) {
        Player player = event.getPlayer();

        if (!Queue.getPlayers().containsKey(player.getUniqueId())) {
            return;
        }

        Queue.leaveQueue(player);
    }

}


Filename: .\main\java\rip\diamond\practice\queue\QueueProfile.java
package rip.diamond.practice.queue;

import lombok.Getter;
import lombok.Setter;
import rip.diamond.practice.kits.Kit;

import java.util.UUID;

@Getter
@Setter
public class QueueProfile {

	private UUID playerUuid;
	private Kit kit;
	private QueueType queueType;
	private boolean found = false;
	private int elo;
	private int range = 10;
	private long start = System.currentTimeMillis();

	public QueueProfile(UUID playerUuid, Kit kit, int elo, QueueType queueType) {
		this.playerUuid = playerUuid;
		this.kit = kit;
		this.elo = elo;
		this.queueType = queueType;
	}

	public void tickRange() {
		range += 10;
	}

	public boolean isInRange(int elo) {
		return elo >= (this.elo - this.range) && elo <= (this.elo + this.range);
	}

	public int getMinRange() {
		int min = this.elo - this.range;

		return Math.max(min, 0);
	}

	public int getMaxRange() {
		int max = this.elo + this.range;

		return Math.min(max, 2500);
	}

	public long getPassed() {
		return System.currentTimeMillis() - this.start;
	}

	@Override
	public boolean equals(Object o) {
		return o instanceof QueueProfile && ((QueueProfile) o).getPlayerUuid().equals(this.playerUuid);
	}

}


Filename: .\main\java\rip\diamond\practice\queue\QueueType.java
package rip.diamond.practice.queue;

import lombok.AllArgsConstructor;
import lombok.Getter;
import rip.diamond.practice.config.Language;

@Getter
@AllArgsConstructor
public enum QueueType {

    UNRANKED(Language.QUEUE_TYPE_UNRANKED.toString()),
    RANKED(Language.QUEUE_TYPE_RANKED.toString()),
    ;

    private final String readable;

}


Filename: .\main\java\rip\diamond\practice\queue\command\QueueCommand.java
package rip.diamond.practice.queue.command;

import org.bukkit.entity.Player;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.kits.Kit;
import rip.diamond.practice.party.Party;
import rip.diamond.practice.profile.PlayerProfile;
import rip.diamond.practice.profile.PlayerState;
import rip.diamond.practice.queue.Queue;
import rip.diamond.practice.queue.QueueProfile;
import rip.diamond.practice.queue.QueueType;
import rip.diamond.practice.queue.menu.QueueMenu;
import rip.diamond.practice.util.Checker;
import rip.diamond.practice.util.command.Command;
import rip.diamond.practice.util.command.CommandArgs;
import rip.diamond.practice.util.command.argument.CommandArguments;

import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

public class QueueCommand extends Command {
    @CommandArgs(name = "queue")
    public void execute(CommandArguments command) {
        Player player = command.getPlayer();
        PlayerProfile profile = PlayerProfile.get(player);
        String[] args = command.getArgs();

        if (args.length == 1) {
            if (profile.getPlayerState() == PlayerState.IN_QUEUE && args[0].equalsIgnoreCase("leave")) {
                QueueProfile qProfile = Queue.getPlayers().get(player.getUniqueId());
                if (qProfile == null) {
                    Language.QUEUE_CANNOT_QUIT_QUEUE.sendMessage(player);
                    return;
                }
                Queue.leaveQueue(player);
                return;
            }

            if (profile.getPlayerState() != PlayerState.IN_LOBBY) {
                Language.QUEUE_CANNOT_QUEUE.sendMessage(player);
                return;
            }

            if (Party.getByPlayer(player) != null) {
                Language.PARTY_IN_A_PARTY.sendMessage(player);
                return;
            }

            if (!Checker.isQueueType(args[0])) {
                Language.INVALID_SYNTAX.sendMessage(player);
                return;
            }

            QueueType queueType = QueueType.valueOf(args[0].toUpperCase());
            new QueueMenu(queueType).openMenu(player);
            return;
        } else if (args.length == 2) {
            if (!Checker.isQueueType(args[0])) {
                Language.INVALID_SYNTAX.sendMessage(player);
                return;
            }
            QueueType queueType = QueueType.valueOf(args[0].toUpperCase());

            Kit kit = Kit.getByName(args[1]);
            if (kit == null) {
                Language.INVALID_SYNTAX.sendMessage(player);
                return;
            }
            if (queueType == QueueType.RANKED && !kit.isRanked()) {
                Language.INVALID_SYNTAX.sendMessage(player);
                return;
            }

            Queue.joinQueue(player, kit, queueType);
            return;
        }

        Language.QUEUE_USAGE.sendMessage(player);
    }

    @Override
    public List<String> getDefaultTabComplete(CommandArguments command) {
        return Arrays.stream(QueueType.values()).map(Enum::name).collect(Collectors.toList());
    }
}


Filename: .\main\java\rip\diamond\practice\queue\menu\QueueMenu.java
package rip.diamond.practice.queue.menu;

import lombok.RequiredArgsConstructor;
import org.bukkit.entity.Player;
import org.bukkit.event.inventory.ClickType;
import org.bukkit.inventory.ItemStack;
import rip.diamond.practice.Eden;
import rip.diamond.practice.kits.Kit;
import rip.diamond.practice.match.Match;
import rip.diamond.practice.queue.Queue;
import rip.diamond.practice.queue.QueueType;
import rip.diamond.practice.util.BasicConfigFile;
import rip.diamond.practice.util.CC;
import rip.diamond.practice.util.ItemBuilder;
import rip.diamond.practice.util.menu.Button;
import rip.diamond.practice.util.menu.Menu;

import java.util.*;
import java.util.stream.Collectors;

@RequiredArgsConstructor
public class QueueMenu extends Menu {

    private final QueueType queueType;
    private final int page;

    public QueueMenu(QueueType queueType) {
        this(queueType, 1);
    }

    @Override
    public String getTitle(Player player) {
        BasicConfigFile config = Eden.INSTANCE.getMenusConfig().getConfig();
        String title = config.getString("queue-menu.title");
        // Replace {queue-type} placeholder
        title = title.replace("{queue-type}", queueType.getReadable());
        return CC.translate(title);
    }

    @Override
    public int getSize() {
        BasicConfigFile config = Eden.INSTANCE.getMenusConfig().getConfig();
        String sizeStr = config.getString("queue-menu.size");

        if ("dynamic".equalsIgnoreCase(sizeStr)) {
            if (page > 1) {
                return config.getInt("queue-menu.max-size");
            }

            int itemsPerPage = getItemsPerPage(config);
            List<Kit> kits = getFilteredKits();
            int kitsOnThisPage = Math.min(kits.size() - ((page - 1) * itemsPerPage), itemsPerPage);

            boolean hasBorder = config.getBoolean("queue-menu.border.enabled");
            int contentSlots = kitsOnThisPage;
            int rowsNeeded = (int) Math.ceil(contentSlots / 7.0); // 7 slots per row (accounting for borders)
            int totalRows = rowsNeeded + (hasBorder ? 2 : 0); // Add top and bottom border rows

            // Ensure minimum of 3 rows and maximum as configured
            int maxSize = config.getInt("queue-menu.max-size");
            int calculatedSize = Math.max(27, Math.min(totalRows * 9, maxSize));

            // Round to valid inventory size
            return ((calculatedSize + 8) / 9) * 9;
        } else {
            return config.getInt("queue-menu.size");
        }
    }

    @Override
    public Map<Integer, Button> getButtons(Player player) {
        Map<Integer, Button> buttons = new HashMap<>();
        BasicConfigFile config = Eden.INSTANCE.getMenusConfig().getConfig();
        int itemsPerPage = getItemsPerPage(config);

        // Filler
        if (config.getBoolean("queue-menu.filler.enabled")) {
            ItemStack filler = new ItemBuilder(
                    org.bukkit.Material.valueOf(config.getString("queue-menu.filler.material")))
                    .durability(config.getInt("queue-menu.filler.data"))
                    .name(" ")
                    .build();
            for (int i = 0; i < getSize(); i++) {
                buttons.put(i, new Button() {
                    @Override
                    public ItemStack getButtonItem(Player player) {
                        return filler;
                    }
                });
            }
        }

        // Border
        if (config.getBoolean("queue-menu.border.enabled")) {
            ItemStack border = new ItemBuilder(
                    org.bukkit.Material.valueOf(config.getString("queue-menu.border.material")))
                    .durability(config.getInt("queue-menu.border.data"))
                    .name(" ")
                    .build();
            int size = getSize();
            for (int i = 0; i < size; i++) {
                if (i < 9 || i >= size - 9 || i % 9 == 0 || i % 9 == 8) {
                    buttons.put(i, new Button() {
                        @Override
                        public ItemStack getButtonItem(Player player) {
                            return border;
                        }
                    });
                }
            }
        }

        // Kit buttons with pagination
        List<Kit> allKits = getFilteredKits();
        int startIndex = (page - 1) * itemsPerPage;
        int endIndex = Math.min(startIndex + itemsPerPage, allKits.size());

        List<Kit> kitsOnThisPage = allKits.subList(startIndex, endIndex);

        // Place kits in available slots (avoiding border)
        int kitIndex = 0;
        for (int slot = 0; slot < getSize() && kitIndex < kitsOnThisPage.size(); slot++) {
            // Skip border slots
            if (buttons.containsKey(slot) && (slot < 9 || slot >= getSize() - 9 || slot % 9 == 0 || slot % 9 == 8)) {
                continue;
            }

            Kit kit = kitsOnThisPage.get(kitIndex);
            buttons.put(slot, new KitButton(kit, queueType, config));
            kitIndex++;
        }

        // Pagination buttons
        if (page > 1) {
            int prevSlot = config.getInt("queue-menu.items.previous-page.slot");
            buttons.put(prevSlot, new Button() {
                @Override
                public ItemStack getButtonItem(Player player) {
                    return new ItemBuilder(
                            org.bukkit.Material.valueOf(config.getString("queue-menu.items.previous-page.material")))
                            .name(config.getString("queue-menu.items.previous-page.name"))
                            .lore(config.getStringList("queue-menu.items.previous-page.lore"))
                            .build();
                }

                @Override
                public void clicked(Player player, ClickType clickType) {
                    new QueueMenu(queueType, page - 1).openMenu(player);
                }
            });
        }

        if (endIndex < allKits.size()) {
            int nextSlot = config.getInt("queue-menu.items.next-page.slot");
            buttons.put(nextSlot, new Button() {
                @Override
                public ItemStack getButtonItem(Player player) {
                    return new ItemBuilder(
                            org.bukkit.Material.valueOf(config.getString("queue-menu.items.next-page.material")))
                            .name(config.getString("queue-menu.items.next-page.name"))
                            .lore(config.getStringList("queue-menu.items.next-page.lore"))
                            .build();
                }

                @Override
                public void clicked(Player player, ClickType clickType) {
                    new QueueMenu(queueType, page + 1).openMenu(player);
                }
            });
        }

        return buttons;
    }

    private int getItemsPerPage(BasicConfigFile config) {
        int size;
        if (config.getString("queue-menu.size").equalsIgnoreCase("dynamic")) {
            size = config.getInt("queue-menu.max-size");
        } else {
            size = config.getInt("queue-menu.size");
        }

        if (config.getBoolean("queue-menu.border.enabled")) {
            int rows = size / 9;
            return (rows - 2) * 7;
        } else {
            return size - 9;
        }
    }

    private List<Kit> getFilteredKits() {
        return Kit.getKits().stream()
                .filter(Kit::isEnabled)
                .filter(kit -> queueType == QueueType.UNRANKED || kit.isRanked())
                .collect(Collectors.toList());
    }

    @RequiredArgsConstructor
    private static class KitButton extends Button {
        private final Kit kit;
        private final QueueType queueType;
        private final BasicConfigFile config;

        @Override
        public ItemStack getButtonItem(Player player) {
            // Get counts for placeholders
            long queueCount = Queue.getPlayers().values().stream()
                    .filter(profile -> profile.getKit() == kit && profile.getQueueType() == queueType)
                    .count();
            long fightingCount = Match.getMatches().values().stream()
                    .filter(match -> match.getKit() == kit && match.getQueueType() == queueType)
                    .mapToInt(match -> match.getMatchPlayers().size())
                    .sum();

            // Build lore with placeholders
            List<String> lore = config.getStringList("queue-menu.items.kit-button.lore");
            List<String> newLore = new ArrayList<>();

            for (String line : lore) {
                if (line.contains("{description}")) {
                    for (String descLine : kit.getDescription()) {
                        newLore.add(CC.translate(descLine));
                    }
                    continue;
                }

                line = line.replace("{queue-count}", String.valueOf(queueCount))
                        .replace("{fighting-count}", String.valueOf(fightingCount))
                        .replace("{kit-name}", kit.getDisplayName());

                if (line.contains("{top3_")) {
                    rip.diamond.practice.leaderboard.impl.KitLeaderboard leaderboard = Eden.INSTANCE
                            .getLeaderboardManager().getDailyWinstreakLeaderboard().get(kit);

                    if (leaderboard != null) {
                        for (int i = 1; i <= 3; i++) {
                            rip.diamond.practice.leaderboard.LeaderboardPlayerCache entry = leaderboard.getLeaderboard()
                                    .get(i);
                            String name = (entry != null) ? entry.getPlayerName() : "None";
                            String number = (entry != null) ? String.valueOf(entry.getData()) : "0";

                            line = line.replace("{top3_name_" + i + "}", name)
                                    .replace("{top3_number_" + i + "}", number);
                        }
                    } else {
                        for (int i = 1; i <= 3; i++) {
                            line = line.replace("{top3_name_" + i + "}", "None")
                                    .replace("{top3_number_" + i + "}", "0");
                        }
                    }
                }

                newLore.add(line);
            }

            // Assign newLore to lore for final building (or just use newLore in builder)
            return new ItemBuilder(kit.getDisplayIcon().clone())
                    .name(kit.getDisplayName())
                    .lore(newLore)
                    .build();
        }

        @Override
        public void clicked(Player player, ClickType clickType) {
            player.closeInventory();
            Queue.joinQueue(player, kit, queueType);
        }
    }
}


Filename: .\main\java\rip\diamond\practice\queue\task\QueueTask.java
package rip.diamond.practice.queue.task;

import org.bukkit.Bukkit;
import org.bukkit.entity.Player;
import rip.diamond.practice.arenas.Arena;
import rip.diamond.practice.arenas.ArenaDetail;
import rip.diamond.practice.event.QueueMatchFoundEvent;
import rip.diamond.practice.kits.Kit;
import rip.diamond.practice.match.Match;
import rip.diamond.practice.match.impl.SoloMatch;
import rip.diamond.practice.match.team.Team;
import rip.diamond.practice.match.team.TeamPlayer;
import rip.diamond.practice.profile.PlayerProfile;
import rip.diamond.practice.profile.PlayerState;
import rip.diamond.practice.profile.ProfileSettings;
import rip.diamond.practice.queue.Queue;
import rip.diamond.practice.queue.QueueProfile;
import rip.diamond.practice.queue.QueueType;
import rip.diamond.practice.util.TaskTicker;
import rip.diamond.practice.util.Tasks;

public class QueueTask extends TaskTicker {
    public QueueTask() {
        super(0, 20, true);
    }

    @Override
    public void onRun() {
        Queue.getPlayers().entrySet().removeIf(entry -> entry.getValue().isFound());
        Queue.getPlayers().values().forEach(QueueProfile::tickRange);

        for (QueueProfile qProfile1 : Queue.getUnmatchedPlayers()) {
            for (QueueProfile qProfile2 : Queue.getUnmatchedPlayers()) {
                if (qProfile1 == qProfile2) {
                    continue;
                }
                //Double check if the QueueProfile already found a match
                if (qProfile1.isFound() || qProfile2.isFound()) {
                    continue;
                }
                if (qProfile1.getKit() != qProfile2.getKit()) {
                    continue;
                }
                if (qProfile1.getQueueType() != qProfile2.getQueueType()) {
                    continue;
                }
                //No need to check if qProfile2 is ranked again, because if qProfile1 is ranked, then qProfile2 will be ranked also
                if (qProfile1.getQueueType() == QueueType.RANKED) {
                    //If one of the QueueProfile is not in the selected ELO range, then stop the loop
                    if (!qProfile1.isInRange(qProfile2.getElo()) || !qProfile2.isInRange(qProfile1.getElo())) {
                        continue;
                    }
                }

                Player player1 = Bukkit.getPlayer(qProfile1.getPlayerUuid());
                Player player2 = Bukkit.getPlayer(qProfile2.getPlayerUuid());
                if (player1 == null || player2 == null) {
                    continue;
                }

                PlayerProfile profile1 = PlayerProfile.get(qProfile1.getPlayerUuid());
                PlayerProfile profile2 = PlayerProfile.get(qProfile2.getPlayerUuid());
                if (profile1.getPlayerState() != PlayerState.IN_QUEUE || profile2.getPlayerState() != PlayerState.IN_QUEUE) {
                    continue;
                }
                if (player2.spigot().getPing() > Integer.parseInt(profile1.getSettings().get(ProfileSettings.PING_RANGE).getValue()) || player1.spigot().getPing() > Integer.parseInt(profile2.getSettings().get(ProfileSettings.PING_RANGE).getValue())) {
                    continue;
                }

                //Find arena
                Kit kit = qProfile1.getKit();
                ArenaDetail arena = Arena.getAvailableArenaDetail(kit);
                if (arena == null) {
                    //Means no available arena
                    continue;
                }
                //This is to prevent player who's going to be in the same arena as before, to prevent see last match entities because of MatchResetTask in last match isn't triggered yet
                if (Match.getMatches().values().stream().filter(match -> match.getArenaDetail() == arena).anyMatch(match -> match.getTeamPlayer(player1) != null || match.getTeamPlayer(player2) != null)) {
                    continue;
                }

                QueueMatchFoundEvent event = new QueueMatchFoundEvent(player1, player2, qProfile1, qProfile2);
                event.call();
                if (event.isCancelled()) {
                    continue;
                }

                qProfile1.setFound(true);
                qProfile2.setFound(true);

                Team team1 = new Team(new TeamPlayer(player1));
                Team team2 = new Team(new TeamPlayer(player2));
                SoloMatch match = new SoloMatch(arena, kit, team1, team2, qProfile1.getQueueType(), false);
                Tasks.run(match::start);
            }
        }
    }

    @Override
    public void preRun() {

    }

    @Override
    public TickType getTickType() {
        return TickType.NONE;
    }

    @Override
    public int getStartTick() {
        return 0;
    }
}


Filename: .\main\java\rip\diamond\practice\spigot\spigotapi\SpigotAPI.java
package rip.diamond.practice.spigot.spigotapi;

import lombok.Getter;
import lombok.Setter;
import org.bukkit.plugin.java.JavaPlugin;
import rip.diamond.practice.spigot.spigotapi.knockback.AbstractKnockback;
import rip.diamond.practice.spigot.spigotapi.movementhandler.AbstractMovementHandler;

@Getter
public final class SpigotAPI {

    public static SpigotAPI INSTANCE;
    public static JavaPlugin PLUGIN;

    @Setter private SpigotType spigotType;
    private AbstractKnockback knockback;
    @Setter private AbstractMovementHandler movementHandler;

    public SpigotAPI init(JavaPlugin plugin) {
        INSTANCE = this;
        PLUGIN = plugin;

        spigotType = SpigotType.get();
        knockback = SpigotType.getKnockback();
        movementHandler = SpigotType.getMovementHandler();

        return this;
    }

}


Filename: .\main\java\rip\diamond\practice\spigot\spigotapi\SpigotType.java
package rip.diamond.practice.spigot.spigotapi;

import lombok.AllArgsConstructor;
import lombok.SneakyThrows;
import rip.diamond.practice.spigot.spigotapi.knockback.AbstractKnockback;
import rip.diamond.practice.spigot.spigotapi.knockback.impl.*;
import rip.diamond.practice.spigot.spigotapi.movementhandler.AbstractMovementHandler;
import rip.diamond.practice.spigot.spigotapi.movementhandler.impl.*;

import java.util.Arrays;

@AllArgsConstructor
public enum SpigotType {

    SPIGOT("org.spigotmc.SpigotConfig", rip.diamond.practice.spigot.spigotapi.knockback.impl.DefaultKnockback.class, DefaultMovementHandler.class),
    CARBON_SPIGOT("xyz.refinedev.spigot.knockback.KnockbackProfile", CarbonSpigotKnockback.class, CarbonSpigotMovementHandler.class),
    WIND_SPIGOT("ga.windpvp.windspigot.WindSpigot", rip.diamond.practice.spigot.spigotapi.knockback.impl.WindSpigotKnockback.class, DefaultMovementHandler.class), //Although WindSpigot has MovementHandler (In WindSpigot it is called MovementListener), it is not implement in the latest version of release, so we have to use default
    ;

    private final String package_;
    public final Class<?> knockback;
    public final Class<?> movementHandler;

    public String getPackage() {
        return package_;
    }

    /**
     * Detect which spigot is being used and initialize
     * @author Drizzy
     */
    public static SpigotType get() {
        return Arrays
                .stream(SpigotType.values())
                .filter(type -> !type.equals(SpigotType.SPIGOT) && check(type.getPackage()))
                .findFirst()
                .orElse(SpigotType.SPIGOT);
    }

    @SneakyThrows
    public static AbstractKnockback getKnockback() {
        return (AbstractKnockback) get().knockback.newInstance();
    }

    @SneakyThrows
    public static AbstractMovementHandler getMovementHandler() {
        return (AbstractMovementHandler) get().movementHandler.newInstance();
    }

    public static boolean check(String string) {
        try {
            Class.forName(string);
            return true;
        } catch (Exception e) {
            return false;
        }
    }
}


Filename: .\main\java\rip\diamond\practice\spigot\spigotapi\knockback\AbstractKnockback.java
package rip.diamond.practice.spigot.spigotapi.knockback;

import org.bukkit.entity.Player;

public abstract class AbstractKnockback {

    public abstract void applyKnockback(Player player, String knockbackName);

}


Filename: .\main\java\rip\diamond\practice\spigot\spigotapi\knockback\impl\CarbonSpigotKnockback.java
package rip.diamond.practice.spigot.spigotapi.knockback.impl;

import org.bukkit.entity.Player;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.spigot.spigotapi.knockback.AbstractKnockback;
import xyz.refinedev.spigot.api.knockback.KnockbackAPI;
import xyz.refinedev.spigot.knockback.KnockbackProfile;

public class CarbonSpigotKnockback extends AbstractKnockback {
    @Override
    public void applyKnockback(Player player, String knockbackName) {
        KnockbackProfile knockback = KnockbackAPI.getInstance().getProfile(knockbackName);
        if (knockback == null) {
            Language.HOOK_ERROR_KNOCKBACK_NOT_FOUND.sendMessage(player);
            return;
        }
        KnockbackAPI.getInstance().setPlayerProfile(player, knockback);
    }
}


Filename: .\main\java\rip\diamond\practice\spigot\spigotapi\knockback\impl\DefaultKnockback.java
package rip.diamond.practice.spigot.spigotapi.knockback.impl;

import org.bukkit.entity.Player;
import rip.diamond.practice.spigot.spigotapi.knockback.AbstractKnockback;

public class DefaultKnockback extends AbstractKnockback {
    @Override
    public void applyKnockback(Player player, String knockbackName) {

    }
}


Filename: .\main\java\rip\diamond\practice\spigot\spigotapi\knockback\impl\WindSpigotKnockback.java
package rip.diamond.practice.spigot.spigotapi.knockback.impl;

import dev.cobblesword.nachospigot.knockback.KnockbackConfig;
import dev.cobblesword.nachospigot.knockback.KnockbackProfile;
import org.bukkit.entity.Player;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.spigot.spigotapi.knockback.AbstractKnockback;
import rip.diamond.practice.spigot.spigotapi.util.Reflection;

public class WindSpigotKnockback extends AbstractKnockback {
    @Override
    public void applyKnockback(Player player, String knockbackName) {
        KnockbackProfile profile = KnockbackConfig.getKbProfileByName(knockbackName);

        if (profile == null) {
            Language.HOOK_ERROR_KNOCKBACK_NOT_FOUND.sendMessage(player);
            return;
        }
        Reflection.method(player, "setKnockbackProfile", profile);
    }
}


Filename: .\main\java\rip\diamond\practice\spigot\spigotapi\movementhandler\AbstractMovementHandler.java
package rip.diamond.practice.spigot.spigotapi.movementhandler;

import org.bukkit.Location;
import org.bukkit.entity.Player;
import rip.diamond.practice.spigot.spigotapi.util.TriConsumer;

public abstract class AbstractMovementHandler {

    public abstract void injectLocationUpdate(TriConsumer<Player, Location, Location> data);

    public abstract void injectRotationUpdate(TriConsumer<Player, Location, Location> data);

}


Filename: .\main\java\rip\diamond\practice\spigot\spigotapi\movementhandler\impl\CarbonSpigotMovementHandler.java
package rip.diamond.practice.spigot.spigotapi.movementhandler.impl;

import net.minecraft.server.v1_8_R3.PacketPlayInFlying;
import org.bukkit.Location;
import org.bukkit.entity.Player;
import rip.diamond.practice.spigot.spigotapi.SpigotAPI;
import rip.diamond.practice.spigot.spigotapi.movementhandler.AbstractMovementHandler;
import rip.diamond.practice.spigot.spigotapi.util.TriConsumer;
import xyz.refinedev.spigot.api.handlers.PacketAPI;
import xyz.refinedev.spigot.api.handlers.impl.MovementHandler;

public class CarbonSpigotMovementHandler extends AbstractMovementHandler {

    @Override
    public void injectLocationUpdate(TriConsumer<Player, Location, Location> data) {
        MovementHandler movementHandler = new MovementHandler() {
            @Override
            public void handleUpdateLocation(Player player, Location location, Location location1, PacketPlayInFlying packetPlayInFlying) {
                data.accept(player, location, location1);
            }

            @Override
            public void handleUpdateRotation(Player player, Location location, Location location1, PacketPlayInFlying packetPlayInFlying) {

            }
        };
        PacketAPI.getInstance().registerMovementHandler(SpigotAPI.PLUGIN, movementHandler);
    }

    @Override
    public void injectRotationUpdate(TriConsumer<Player, Location, Location> data) {
        MovementHandler movementHandler = new MovementHandler() {
            @Override
            public void handleUpdateLocation(Player player, Location location, Location location1, PacketPlayInFlying packetPlayInFlying) {

            }

            @Override
            public void handleUpdateRotation(Player player, Location location, Location location1, PacketPlayInFlying packetPlayInFlying) {
                data.accept(player, location, location1);
            }
        };
        PacketAPI.getInstance().registerMovementHandler(SpigotAPI.PLUGIN, movementHandler);
    }
}


Filename: .\main\java\rip\diamond\practice\spigot\spigotapi\movementhandler\impl\DefaultMovementHandler.java
package rip.diamond.practice.spigot.spigotapi.movementhandler.impl;

import org.bukkit.Bukkit;
import org.bukkit.Location;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.Listener;
import org.bukkit.event.player.PlayerMoveEvent;
import rip.diamond.practice.spigot.spigotapi.SpigotAPI;
import rip.diamond.practice.spigot.spigotapi.movementhandler.AbstractMovementHandler;
import rip.diamond.practice.spigot.spigotapi.util.TriConsumer;

public class DefaultMovementHandler extends AbstractMovementHandler {

    @Override
    public void injectLocationUpdate(TriConsumer<Player, Location, Location> data) {
        Listener listener = new Listener() {
            @EventHandler
            public void onMove(PlayerMoveEvent event) {
                Player player = event.getPlayer();

                double fromX = event.getFrom().getX();
                double fromY = event.getFrom().getY();
                double fromZ = event.getFrom().getZ();

                double toX = event.getTo().getX();
                double toY = event.getTo().getY();
                double toZ = event.getTo().getZ();

                if (fromX != toX || fromY != toY || fromZ != toZ) {
                    data.accept(player, event.getFrom(), event.getTo());
                }
            }
        };
        Bukkit.getPluginManager().registerEvents(listener, SpigotAPI.PLUGIN);
    }

    @Override
    public void injectRotationUpdate(TriConsumer<Player, Location, Location> data) {
        Listener listener = new Listener() {
            @EventHandler
            public void onMove(PlayerMoveEvent event) {
                Player player = event.getPlayer();

                double fromYaw = event.getFrom().getYaw();
                double fromPitch = event.getFrom().getPitch();

                double toYaw = event.getTo().getYaw();
                double toPitch = event.getTo().getPitch();

                if (fromYaw != toYaw || fromPitch != toPitch) {
                    data.accept(player, event.getFrom(), event.getTo());
                }
            }
        };
        Bukkit.getPluginManager().registerEvents(listener, SpigotAPI.PLUGIN);
    }
}


Filename: .\main\java\rip\diamond\practice\spigot\spigotapi\util\Reflection.java
package rip.diamond.practice.spigot.spigotapi.util;

import lombok.SneakyThrows;
import org.bukkit.Bukkit;

import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

/**
 * A utility class that simplifies reflection in Bukkit plugins
 */
public class Reflection {

    /**
     * Returns is a native 1.7 version
     * @return If is native 1.7 version
     */
    public boolean isNative17() {
        return getBuildVersion().contains("v1_7");
    }

    /**
     * The build version the server is running
     * @return the version of build R- of the server
     */
    public static String getBuildVersion() {
        return Bukkit.getServer().getClass().getPackage().getName().substring(23);
    }

    /**
     * Returns a specified class from its full name
     *
     * @param clazz the class name
     * @return the looked up class
     */
    @SneakyThrows
    public static Class<?> getClass(final String clazz) {
        return Class.forName(clazz);
    }

    /**
     * Returns a class in the net.minecraft.server.VERSION.* package
     *
     * @param clazz the name of the class, excluding the package
     * @return the looked up nms class
     */
    public static Class<?> getNMSClass(final String clazz) {
       return getClass("net.minecraft.server." + getBuildVersion() + "." + clazz);
    }

    /**
     * Returns a class in the org.bukkit.craftbukkit.VERSION.* package
     *
     * @param clazz the name of the class, excluding the package
     * @return the looked up obc class
     */
    public static Class<?> getOBCClass(final String clazz) {
        return getClass("org.bukkit.craftbukkit." + getBuildVersion() + "." + clazz);
    }

    /**
     * Returns a field object for a specific field  name
     *
     * @param target the class instance
     * @param fieldName the name of the field
     * @return the field object
     */
    @SneakyThrows
    public Object getField(final Object target, final String fieldName) {
        final Field field = target.getClass().getField(fieldName);
        field.setAccessible(true);

        return field.get(target);
    }

    /**
     * Returns a declared field object for a specific field  name
     *
     * @param target the class instance
     * @param fieldName the name of the field
     * @return the field object
     */
    @SneakyThrows
    public Object getDeclaredField(final Object target, final String fieldName) {
        final Field field = target.getClass().getDeclaredField(fieldName);
        field.setAccessible(true);

        return field.get(target);
    }

    /**
     * Sets a field object for a specific field objectValue
     *
     * @param target the class instance
     * @param fieldName the name of the field
     * @param objectValue the value to set
     */
    @SneakyThrows
    public void setField(final Object target, final String fieldName, final Object objectValue) {
        final Field field = target.getClass().getField(fieldName);
        field.setAccessible(true);
        field.set(target, objectValue);
    }

    /**
     * Sets a declared field object for a specific field objectValue
     *
     * @param target the class instance
     * @param fieldName the name of the field
     * @param objectValue the value to set
     */
    @SneakyThrows
    public void setDeclaredField(final Object target, final String fieldName, final Object objectValue) {
        final Field field = target.getClass().getDeclaredField(fieldName);
        field.setAccessible(true);
        field.set(target, objectValue);
    }

    /**
     * Invoke a method on a specific target object
     *
     * @param target the target object
     * @param methodName the method name
     * @param params the params to pass to the method
     * @return An object that invokes this specific method
     */
    @SneakyThrows
    public static Object method(final Object target, final String methodName, final Object... params) {
        final List<Method> methodList = Arrays.stream(target.getClass().getMethods())
                .filter(m -> m.getName().equals(methodName))
                .filter(m -> m.getParameters().length == params.length)
                .collect(Collectors.toList());

        return methodList.get(0).invoke(target, params);
    }

    /**
     * Invoke a method on a specific target object
     *
     * @param target the target class
     * @param methodName the method name
     * @param params the params to pass to the method
     * @return An object that invokes this specific method
     */
    @SneakyThrows
    public static Object method(final Class<?> target, final String methodName, final Object... params) {
        final List<Method> methodList = Arrays.stream(target.getDeclaredMethods())
                .filter(m -> m.getName().equals(methodName))
                .collect(Collectors.toList());

        return methodList.get(0).invoke(target, params);
    }


    /**
     * Invoke a method on a specific target object
     *
     * @param target the target class
     * @param methodName the method name
     * @param classes the expected parameters
     * @param params - the params to pass to the method
     * @return An object that invokes this specific method
     */
    @SneakyThrows
    public static Object method(final Object target, final String methodName, final Class<?>[] classes, final Object... params) {
        return target.getClass().getMethod(methodName, classes).invoke(target, params);
    }

    /**
     * Invoke a constructor for a specific class
     *
     * @param target the target class
     * @param params the expected parameters
     * @return An object that invokes this constructor
     */
    @SneakyThrows
    public static Object constructor(final Class<?> target, final Object... params) {
        final List<Constructor<?>> constructorList = Arrays.stream(target.getConstructors())
                .filter(constructor -> constructor.getParameters().length == params.length)
                .collect(Collectors.toList());

        return constructorList.get(0).newInstance(params);
    }
}


Filename: .\main\java\rip\diamond\practice\spigot\spigotapi\util\TriConsumer.java
package rip.diamond.practice.spigot.spigotapi.util;

@FunctionalInterface
public interface TriConsumer<T, U, V> {
    void accept(T t, U u, V v);
}


Filename: .\main\java\rip\diamond\practice\util\BaseEvent.java
package rip.diamond.practice.util;

import org.bukkit.Bukkit;
import org.bukkit.event.*;

public class BaseEvent extends Event {

    private static final HandlerList handlers = new HandlerList();

    public static HandlerList getHandlerList() {
        return handlers;
    }

    public void call() {
        Bukkit.getPluginManager().callEvent(this);
    }

    @Override
    public HandlerList getHandlers() {
        return handlers;
    }
}

Filename: .\main\java\rip\diamond\practice\util\BasicConfigFile.java
package rip.diamond.practice.util;

import lombok.Getter;
import lombok.Setter;
import org.bukkit.ChatColor;
import org.bukkit.configuration.file.YamlConfiguration;
import org.bukkit.plugin.java.JavaPlugin;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

@Getter
@Setter
public class BasicConfigFile {
    private JavaPlugin plugin;
    private String fileName;
    private YamlConfiguration configuration;

    private File file;

    public BasicConfigFile(JavaPlugin plugin, String fileName) {
        this.plugin = plugin;
        this.fileName = fileName;
        this.file = new File(plugin.getDataFolder(), fileName);
        if (!this.file.exists()) {
            plugin.saveResource(fileName, false);
        }
        this.configuration = YamlConfiguration.loadConfiguration(this.file);
    }

    public boolean getBoolean(String path) {
        return (this.configuration.contains(path)) && (this.configuration.getBoolean(path));
    }

    public double getDouble(String path) {
        if (this.configuration.contains(path)) {
            return this.configuration.getDouble(path);
        }
        return 0.0D;
    }

    public File getFile() {
        return this.file;
    }

    public int getInt(String path) {
        if (this.configuration.contains(path)) {
            return this.configuration.getInt(path);
        }
        return 0;
    }

    public String getString(String path) {
        if (this.configuration.contains(path)) {
            return ChatColor.translateAlternateColorCodes('&', this.configuration.getString(path));
        }
        return path;
    }

    public List<String> getStringList(String path) {
        if (this.configuration.contains(path)) {
            ArrayList<String> strings = new ArrayList<String>();
            for (String string : this.configuration.getStringList(path)) {
                strings.add(ChatColor.translateAlternateColorCodes('&', string));
            }
            return strings;
        }
        return Collections.singletonList(path);
    }

    public void load() {
        this.file = new File(plugin.getDataFolder(), fileName);
        if (!this.file.exists()) {
            plugin.saveResource(fileName, false);
        }
        this.configuration = YamlConfiguration.loadConfiguration(this.file);
    }

    public void save() {
        try {
            this.configuration.save(this.file);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}


Filename: .\main\java\rip\diamond\practice\util\CC.java
package rip.diamond.practice.util;

import org.bukkit.ChatColor;

import java.util.*;

public class CC {

	private static final Map<String, ChatColor> MAP;

	public static final String BLUE;
	public static final String AQUA;
	public static final String YELLOW;
	public static final String RED;
	public static final String GRAY;
	public static final String GOLD;
	public static final String GREEN;
	public static final String WHITE;
	public static final String BLACK;
	public static final String BOLD;
	public static final String ITALIC;
	public static final String UNDER_LINE;
	public static final String STRIKE_THROUGH;
	public static final String RESET;
	public static final String MAGIC;
	public static final String DARK_BLUE;
	public static final String DARK_AQUA;
	public static final String DARK_GRAY;
	public static final String DARK_GREEN;
	public static final String DARK_PURPLE;
	public static final String DARK_RED;
	public static final String PINK;
	public static final String MENU_BAR;
	public static final String CHAT_BAR;
	public static final String SB_BAR;

	static {
		MAP = new HashMap<>();
		MAP.put("pink", ChatColor.LIGHT_PURPLE);
		MAP.put("orange", ChatColor.GOLD);
		MAP.put("purple", ChatColor.DARK_PURPLE);

		for (ChatColor chatColor : ChatColor.values()) {
			MAP.put(chatColor.name().toLowerCase().replace("_", ""), chatColor);
		}

		BLUE = ChatColor.BLUE.toString();
		AQUA = ChatColor.AQUA.toString();
		YELLOW = ChatColor.YELLOW.toString();
		RED = ChatColor.RED.toString();
		GRAY = ChatColor.GRAY.toString();
		GOLD = ChatColor.GOLD.toString();
		GREEN = ChatColor.GREEN.toString();
		WHITE = ChatColor.WHITE.toString();
		BLACK = ChatColor.BLACK.toString();
		BOLD = ChatColor.BOLD.toString();
		ITALIC = ChatColor.ITALIC.toString();
		UNDER_LINE = ChatColor.UNDERLINE.toString();
		STRIKE_THROUGH = ChatColor.STRIKETHROUGH.toString();
		RESET = ChatColor.RESET.toString();
		MAGIC = ChatColor.MAGIC.toString();
		DARK_BLUE = ChatColor.DARK_BLUE.toString();
		DARK_AQUA = ChatColor.DARK_AQUA.toString();
		DARK_GRAY = ChatColor.DARK_GRAY.toString();
		DARK_GREEN = ChatColor.DARK_GREEN.toString();
		DARK_PURPLE = ChatColor.DARK_PURPLE.toString();
		DARK_RED = ChatColor.DARK_RED.toString();
		PINK = ChatColor.LIGHT_PURPLE.toString();
		MENU_BAR = ChatColor.GRAY.toString() + ChatColor.STRIKETHROUGH.toString() + "------------------------";
		CHAT_BAR = ChatColor.GRAY.toString() + ChatColor.STRIKETHROUGH.toString() + "------------------------------------------------";
		SB_BAR = ChatColor.GRAY.toString() + ChatColor.STRIKETHROUGH.toString() + "----------------------";
	}

	public static Set<String> getColorNames() {
		return MAP.keySet();
	}

	public static ChatColor getColorFromName(String name) {
		if (MAP.containsKey(name.trim().toLowerCase())) {
			return MAP.get(name.trim().toLowerCase());
		}

		ChatColor color;

		try {
			color = ChatColor.valueOf(name.toUpperCase().replace(" ", "_"));
		} catch (Exception e) {
			return null;
		}

		return color;
	}

	public static String translate(String in) {
		return ChatColor.translateAlternateColorCodes('&', in);
	}

	public static List<String> translate(List<String> lines) {
		List<String> toReturn = new ArrayList<>();

		for (String line : lines) {
			toReturn.add(ChatColor.translateAlternateColorCodes('&', line));
		}

		return toReturn;
	}

	public static List<String> translate(String[] lines) {
		List<String> toReturn = new ArrayList<>();

		for (String line : lines) {
			if (line != null) {
				toReturn.add(ChatColor.translateAlternateColorCodes('&', line));
			}
		}

		return toReturn;
	}

}


Filename: .\main\java\rip\diamond\practice\util\CenteredMessageSender.java
package rip.diamond.practice.util;

import org.bukkit.ChatColor;

public class CenteredMessageSender {

    private final static int CENTER_PX = 154;

    public static String getCenteredMessage(String message){
        if(message == null || message.equals("")) {
            return "";
        }

        message = ChatColor.translateAlternateColorCodes('&', message);

        int messagePxSize = 0;
        boolean previousCode = false;
        boolean isBold = false;

        for(char c : message.toCharArray()){
            if(c == ChatColor.COLOR_CHAR){
                previousCode = true;
            } else if(previousCode) {
                previousCode = false;
                isBold = c == 'l' || c == 'L';
            } else {
                DefaultFontInfo dFI = DefaultFontInfo.getDefaultFontInfo(c);
                messagePxSize += isBold ? dFI.getBoldLength() : dFI.getLength();
                messagePxSize++;
            }
        }

        int halvedMessageSize = messagePxSize / 2;
        int toCompensate = CENTER_PX - halvedMessageSize;
        int spaceLength = DefaultFontInfo.SPACE.getLength() + 1;
        int compensated = 0;
        StringBuilder sb = new StringBuilder();
        while(compensated < toCompensate){
            sb.append(" ");
            compensated += spaceLength;
        }
        return sb.toString() + message;
    }

    public enum DefaultFontInfo {
        A('A', 5),
        a('a', 5),
        B('B', 5),
        b('b', 5),
        C('C', 5),
        c('c', 5),
        D('D', 5),
        d('d', 5),
        E('E', 5),
        e('e', 5),
        F('F', 5),
        f('f', 4),
        G('G', 5),
        g('g', 5),
        H('H', 5),
        h('h', 5),
        I('I', 3),
        i('i', 1),
        J('J', 5),
        j('j', 5),
        K('K', 5),
        k('k', 4),
        L('L', 5),
        l('l', 1),
        M('M', 5),
        m('m', 5),
        N('N', 5),
        n('n', 5),
        O('O', 5),
        o('o', 5),
        P('P', 5),
        p('p', 5),
        Q('Q', 5),
        q('q', 5),
        R('R', 5),
        r('r', 5),
        S('S', 5),
        s('s', 5),
        T('T', 5),
        t('t', 4),
        U('U', 5),
        u('u', 5),
        V('V', 5),
        v('v', 5),
        W('W', 5),
        w('w', 5),
        X('X', 5),
        x('x', 5),
        Y('Y', 5),
        y('y', 5),
        Z('Z', 5),
        z('z', 5),
        NUM_1('1', 5),
        NUM_2('2', 5),
        NUM_3('3', 5),
        NUM_4('4', 5),
        NUM_5('5', 5),
        NUM_6('6', 5),
        NUM_7('7', 5),
        NUM_8('8', 5),
        NUM_9('9', 5),
        NUM_0('0', 5),
        EXCLAMATION_POINT('!', 1),
        AT_SYMBOL('@', 6),
        NUM_SIGN('#', 5),
        DOLLAR_SIGN('$', 5),
        PERCENT('%', 5),
        UP_ARROW('^', 5),
        AMPERSAND('&', 5),
        ASTERISK('*', 5),
        LEFT_PARENTHESIS('(', 4),
        RIGHT_PERENTHESIS(')', 4),
        MINUS('-', 5),
        UNDERSCORE('_', 5),
        PLUS_SIGN('+', 5),
        EQUALS_SIGN('=', 5),
        LEFT_CURL_BRACE('{', 4),
        RIGHT_CURL_BRACE('}', 4),
        LEFT_BRACKET('[', 3),
        RIGHT_BRACKET(']', 3),
        COLON(':', 1),
        SEMI_COLON(';', 1),
        DOUBLE_QUOTE('"', 3),
        SINGLE_QUOTE('\'', 1),
        LEFT_ARROW('<', 4),
        RIGHT_ARROW('>', 4),
        QUESTION_MARK('?', 5),
        SLASH('/', 5),
        BACK_SLASH('\\', 5),
        LINE('|', 1),
        TILDE('~', 5),
        TICK('`', 2),
        PERIOD('.', 1),
        COMMA(',', 1),
        SPACE(' ', 3),
        DEFAULT('a', 4);

        private char character;
        private int length;

        DefaultFontInfo(char character, int length) {
            this.character = character;
            this.length = length;
        }

        public char getCharacter() {
            return this.character;
        }

        public int getLength() {
            return this.length;
        }

        public int getBoldLength() {
            if (this == DefaultFontInfo.SPACE) return this.getLength();
            return this.length + 1;
        }

        public static DefaultFontInfo getDefaultFontInfo(char c) {
            for (DefaultFontInfo dFI : DefaultFontInfo.values()) {
                if (dFI.getCharacter() == c) return dFI;
            }
            return DefaultFontInfo.DEFAULT;
        }
    }
}


Filename: .\main\java\rip\diamond\practice\util\Checker.java
package rip.diamond.practice.util;

import org.bukkit.Bukkit;
import org.bukkit.Material;
import org.bukkit.enchantments.Enchantment;
import org.bukkit.entity.Player;
import org.bukkit.inventory.ItemFlag;
import org.bukkit.potion.PotionEffectType;
import rip.diamond.practice.events.EventType;
import rip.diamond.practice.kits.KitMatchType;
import rip.diamond.practice.match.MatchState;
import rip.diamond.practice.profile.PlayerProfile;
import rip.diamond.practice.profile.PlayerState;
import rip.diamond.practice.queue.QueueType;

import java.util.UUID;

public class Checker {

    public static boolean isPluginEnabled(String pluginName) {
        return Bukkit.getPluginManager().getPlugin(pluginName) != null;
    }

    public static boolean isInteger(String index) {
        try {
            Integer.parseInt(index);
            return true;
        } catch (Exception ignored) {
            return false;
        }
    }

    public static boolean isDouble(String index) {
        try {
            Double.parseDouble(index);
            return true;
        } catch (Exception ignored) {
            return false;
        }
    }

    public static boolean isFloat(String index) {
        try {
            Float.parseFloat(index);
            return true;
        } catch (Exception ignored) {
            return false;
        }
    }

    public static boolean isBoolean(String index) {
        return index.equals("true") || index.equals("false");
    }

    public static boolean isUUID(String index) {
        try {
            UUID.fromString(index);
            return true;
        } catch (Exception ignored) {
            return false;
        }
    }

    public static boolean isMaterial(String index) {
        try {
            Material.valueOf(index.toUpperCase());
            return true;
        } catch (Exception ignored) {
            return false;
        }
    }

    public static boolean isEnchantment(String index) {
        try {
            Enchantment.getByName(index.toUpperCase());
            return true;
        } catch (Exception ignored) {
            return false;
        }
    }

    public static boolean isPotionEffect(String index) {
        try {
            PotionEffectType.getByName(index);
            return true;
        } catch (Exception ignored) {
            return false;
        }
    }

    public static boolean isItemFlag(String index) {
        try {
            ItemFlag.valueOf(index.toUpperCase());
            return true;
        } catch (Exception ignored) {
            return false;
        }
    }

    public static boolean isQueueType(String index) {
        try {
            QueueType.valueOf(index.toUpperCase());
            return true;
        } catch (Exception ignored) {
            return false;
        }
    }

    public static boolean isEventType(String index) {
        try {
            EventType.valueOf(index.toUpperCase());
            return true;
        } catch (Exception ignored) {
            return false;
        }
    }

    public static boolean isKitMatchType(String index) {
        try {
            KitMatchType.valueOf(index.toUpperCase());
            return true;
        } catch (Exception ignored) {
            return false;
        }
    }

    public static boolean isClassExists(String string) {
        try {
            Class.forName(string);
            return true;
        } catch (Exception e) {
            return false;
        }
    }

    public static boolean canDamage(Player player) {
        PlayerProfile profile = PlayerProfile.get(player);
        if (Util.isNPC(player)) {
            return profile != null;
        }
        return profile.getPlayerState() == PlayerState.IN_MATCH
                && profile.getMatch() != null
                && profile.getMatch().getTeamPlayer(player).isAlive()
                && !profile.getMatch().getTeamPlayer(player).isRespawning()
                && profile.getMatch().getState() == MatchState.FIGHTING;
    }

}


Filename: .\main\java\rip\diamond\practice\util\Clickable.java
package rip.diamond.practice.util;

import lombok.*;
import net.md_5.bungee.api.chat.*;
import org.bukkit.entity.*;

import java.util.*;

@NoArgsConstructor
@Getter
public class Clickable {

    private final List<TextComponent> components = new ArrayList<>();
    private String hoverText;
    private String text;

    public Clickable(String msg) {
        TextComponent message = new TextComponent(CC.translate(msg));

        this.components.add(message);
        this.text = msg;
    }

    public Clickable(String msg, String hoverMsg, String clickString) {
        this.add(msg, hoverMsg, clickString);
        this.text = msg;
        this.hoverText = hoverMsg;
    }

    public TextComponent add(String msg, String hoverMsg, String clickString) {
        TextComponent message = new TextComponent(CC.translate(msg));

        if (hoverMsg != null) {
            message.setHoverEvent(new HoverEvent(HoverEvent.Action.SHOW_TEXT, new ComponentBuilder(CC.translate(hoverMsg)).create()));
        }

        if (clickString != null) {
            message.setClickEvent(new ClickEvent(ClickEvent.Action.RUN_COMMAND, clickString));
        }

        this.components.add(message);
        this.text = msg;
        this.hoverText = hoverMsg;

        return message;
    }

    public void add(String message) {
        this.components.add(new TextComponent(message));
    }

    public void sendToPlayer(Player player) {
        player.spigot().sendMessage(this.asComponents());
    }

    public void sendToPlayer(Player player, String hoverPermission) {
        if (!player.hasPermission(hoverPermission)) {
            player.sendMessage(this.text);
        } else {
            player.spigot().sendMessage(this.asComponents());
        }
    }

    public TextComponent[] asComponents() {
        return this.components.toArray(new TextComponent[0]);
    }
}

Filename: .\main\java\rip\diamond\practice\util\Common.java
package rip.diamond.practice.util;

import org.bukkit.Bukkit;
import org.bukkit.Sound;
import org.bukkit.command.CommandSender;
import org.bukkit.entity.Player;
import org.github.paperspigot.Title;
import rip.diamond.practice.Eden;
import rip.diamond.practice.config.Config;

import java.util.List;

public class Common {

    public static void log(String... str) {
        for (String string : str) {
            Bukkit.getConsoleSender().sendMessage(CC.RED + "[LOG] " + CC.translate(string));
        }
    }

    public static void debug(String... str) {
        for (String string : str) {
             debug(string);
        }
    }

    public static void debug(String str) {
        if (Config.DEBUG.toBoolean()) {
            Bukkit.getConsoleSender().sendMessage(CC.RED + "[Èô§ÈåØ] " + CC.translate(str));

            for (Player player : Bukkit.getOnlinePlayers()) {
                if (player.hasPermission("eden.debug")) {
                    sendMessage(player, CC.DARK_GRAY + "[Èô§ÈåØ] " + str);
                }
            }
        }
    }

    public static void broadcastMessage(String... str) {
        for (String string : str) {
            Bukkit.broadcastMessage(CC.translate(string));
        }
    }

    public static void broadcastMessage(List<String> str) {
        for (String string : str) {
            Bukkit.broadcastMessage(CC.translate(string));
        }
    }

    public static void broadcastSound(Sound sound) {
        for (Player player : Bukkit.getOnlinePlayers()) {
            player.playSound(player.getLocation(), sound, 10, 1);
        }
    }

    public static void broadcastSound(Sound sound, float v, float v1) {
        for (Player player : Bukkit.getOnlinePlayers()) {
            player.playSound(player.getLocation(), sound, v, v1);
        }
    }

    public static void sendMessage(CommandSender sender, String... str) {
        if (sender == null) {
            return;
        }
        for (String s : str) {
            sender.sendMessage(CC.translate(s));
        }
    }

    public static void sendMessage(Player player, String... str) {
        if (player == null) {
            return;
        }
        for (String s : str) {
            if (Util.isNull(s)) {
                continue;
            }
            player.sendMessage(CC.translate(s));
        }
    }

    public static void sendMessage(Player player, List<String> str) {
        if (player == null) {
            return;
        }
        for (String s : str) {
            if (Util.isNull(s)) {
                continue;
            }
            player.sendMessage(CC.translate(s));
        }
    }

    public static void playSound(Player player, Sound sound) {
        if (player == null) {
            return;
        }
        player.playSound(player.getLocation(), sound, 1f, 1f);
    }

    public static void playSound(Player player, Sound sound, float v, float v1) {
        if (player == null) {
            return;
        }
        player.playSound(player.getLocation(), sound, v, v1);
    }

    public static boolean hasPermission(CommandSender sender, List<String> permissions) {
        for (String permission : permissions) {
            if (sender.hasPermission(permission)) return true;
        }
        return false;
    }

}


Filename: .\main\java\rip\diamond\practice\util\DamageCalculator.java
package rip.diamond.practice.util;

import net.minecraft.server.v1_8_R3.DamageSource;
import org.bukkit.craftbukkit.v1_8_R3.entity.CraftPlayer;
import org.bukkit.enchantments.Enchantment;
import org.bukkit.entity.Player;
import org.bukkit.inventory.ItemStack;

public class DamageCalculator {

    public static double getDamage(ItemStack weapon) {
        double damage;
        switch(weapon.getType()) {
            case STONE_SPADE:
            case WOOD_PICKAXE:
            case GOLD_PICKAXE:
                damage = 2;
                break;
            case IRON_SPADE:
            case WOOD_AXE:
            case GOLD_AXE:
            case STONE_PICKAXE:
                damage = 3;
                break;
            case WOOD_SWORD:
            case GOLD_SWORD:
            case STONE_AXE:
            case IRON_PICKAXE:
            case DIAMOND_SPADE:
                damage = 4;
                break;
            case STONE_SWORD:
            case IRON_AXE:
            case DIAMOND_PICKAXE:
                damage = 5;
                break;
            case IRON_SWORD:
            case DIAMOND_AXE:
                damage = 6;
                break;
            case DIAMOND_SWORD:
                damage = 7;
                break;
            default:
                damage = 0;
                break;
        }
        return damage;
    }

    //Credit: Sentinel (https://github.com/mcmonkeyprojects/Sentinel/blob/master/src/main/java/org/mcmonkey/sentinel/SentinelTrait.java)
    public static double getEnchantedDamage(ItemStack weapon) {
        double enchantBoost = weapon.getEnchantmentLevel(Enchantment.DAMAGE_ALL) * 1.25;
        return getDamage(weapon) + enchantBoost;
    }

}


Filename: .\main\java\rip\diamond\practice\util\EntityHider.java
package rip.diamond.practice.util;

import com.comphenix.protocol.PacketType;
import com.comphenix.protocol.ProtocolLibrary;
import com.comphenix.protocol.ProtocolManager;
import com.comphenix.protocol.events.PacketAdapter;
import com.comphenix.protocol.events.PacketEvent;
import com.comphenix.protocol.wrappers.BlockPosition;
import com.google.common.base.Preconditions;
import com.google.common.collect.HashBasedTable;
import com.google.common.collect.Table;
import lombok.SneakyThrows;
import net.minecraft.server.v1_8_R3.EntityItem;
import net.minecraft.server.v1_8_R3.MathHelper;
import net.minecraft.server.v1_8_R3.PacketPlayOutEntityDestroy;
import org.bukkit.Bukkit;
import org.bukkit.Location;
import org.bukkit.Material;
import org.bukkit.craftbukkit.v1_8_R3.entity.CraftEntity;
import org.bukkit.craftbukkit.v1_8_R3.entity.CraftPlayer;
import org.bukkit.entity.*;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.HandlerList;
import org.bukkit.event.Listener;
import org.bukkit.event.entity.EntityDeathEvent;
import org.bukkit.event.entity.PotionSplashEvent;
import org.bukkit.event.player.PlayerQuitEvent;
import org.bukkit.event.world.ChunkUnloadEvent;
import org.bukkit.inventory.ItemStack;
import org.bukkit.plugin.Plugin;
import rip.diamond.practice.Eden;
import rip.diamond.practice.profile.PlayerProfile;

import java.lang.reflect.Field;
import java.util.Collections;
import java.util.Map;

/**
 * Entity hider which aims to fix spigot visibility
 * of projectiles, particle effects and sounds
 * <p>
 * Originally coded by Lipchya and cleaned/improved and maintained by DevDrizzy
 * Now maintained by GoodestEnglish to make this class fit this project
 *
 * @since 9/13/2021
 *        Project: Eden
 */
public class EntityHider {

    protected Table<Integer, Integer, Boolean> observerEntityMap = HashBasedTable.create();

    public Field itemOwner;
    private final PacketType[] ENTITY_PACKETS = {
            PacketType.Play.Server.ENTITY_EQUIPMENT, PacketType.Play.Server.BED, PacketType.Play.Server.ANIMATION,
            PacketType.Play.Server.NAMED_ENTITY_SPAWN,
            PacketType.Play.Server.COLLECT, PacketType.Play.Server.SPAWN_ENTITY,
            PacketType.Play.Server.SPAWN_ENTITY_LIVING, PacketType.Play.Server.SPAWN_ENTITY_PAINTING,
            PacketType.Play.Server.SPAWN_ENTITY_EXPERIENCE_ORB,
            PacketType.Play.Server.ENTITY_VELOCITY, PacketType.Play.Server.REL_ENTITY_MOVE,
            PacketType.Play.Server.ENTITY_LOOK, PacketType.Play.Server.ENTITY_MOVE_LOOK,
            PacketType.Play.Server.ENTITY_TELEPORT,
            PacketType.Play.Server.ENTITY_HEAD_ROTATION, PacketType.Play.Server.ENTITY_STATUS,
            PacketType.Play.Server.ATTACH_ENTITY, PacketType.Play.Server.ENTITY_METADATA,
            PacketType.Play.Server.ENTITY_EFFECT, PacketType.Play.Server.REMOVE_ENTITY_EFFECT,
            PacketType.Play.Server.BLOCK_BREAK_ANIMATION,
            PacketType.Play.Server.WORLD_EVENT,
            PacketType.Play.Server.NAMED_SOUND_EFFECT
    };

    public enum Policy {
        /**
         * All entities are invisible by default. Only entities specifically made
         * visible may be seen.
         */
        WHITELIST,

        /**
         * All entities are visible by default. An entity can only be hidden explicitly.
         */
        BLACKLIST,
    }

    private final ProtocolManager manager;
    private final Eden plugin;

    private final Listener bukkitListener;
    private final PacketAdapter protocolListener;

    protected final Policy policy;

    public EntityHider(Eden plugin, Policy policy) {
        Preconditions.checkNotNull(plugin, "plugin cannot be NULL.");

        this.plugin = plugin;
        this.policy = policy;
        this.manager = ProtocolLibrary.getProtocolManager();

        this.bukkitListener = constructBukkit();
        this.protocolListener = constructProtocol(plugin);
    }

    @SneakyThrows
    public EntityHider init() {
        manager.addPacketListener(protocolListener);
        plugin.getServer().getPluginManager().registerEvents(bukkitListener, plugin);

        itemOwner = EntityItem.class.getDeclaredField("f");
        itemOwner.setAccessible(true);

        return this;
    }

    /**
     * Set the visibility status of a given entity for a particular observer.
     * 
     * @param observer - the observer player.
     * @param entityID - ID of the entity that will be hidden or made visible.
     * @param visible  - TRUE if the entity should be made visible, FALSE if not.
     * @return TRUE if the entity was visible before this method call, FALSE
     *         otherwise.
     */
    protected boolean setVisibility(Player observer, int entityID, boolean visible) {
        switch (policy) {
            case BLACKLIST:
                // Non-membership means they are visible
                return !setMembership(observer, entityID, !visible);
            case WHITELIST:
                return setMembership(observer, entityID, visible);
            default:
                throw new IllegalArgumentException("Unknown policy: " + policy);
        }
    }

    /**
     * Add or remove the given entity and observer entry from the table.
     *
     * @param observer - the player observer.
     * @param entityID - ID of the entity.
     * @param member   - TRUE if they should be present in the table, FALSE
     *                 otherwise.
     * @return TRUE if they already were present, FALSE otherwise.
     */
    // Helper method
    protected boolean setMembership(Player observer, int entityID, boolean member) {
        if (member) {
            return observerEntityMap.put(observer.getEntityId(), entityID, true) != null;
        } else {
            return observerEntityMap.remove(observer.getEntityId(), entityID) != null;
        }
    }

    /**
     * Determine if the given entity and observer is present in the table.
     *
     * @param observer - the player observer.
     * @param entityID - ID of the entity.
     * @return TRUE if they are present, FALSE otherwise.
     */
    protected boolean getMembership(Player observer, int entityID) {
        return observerEntityMap.contains(observer.getEntityId(), entityID);
    }

    /**
     * Determine if a given entity is visible for a particular observer.
     *
     * @param observer - the observer player.
     * @param entityID - ID of the entity that we are testing for visibility.
     * @return TRUE if the entity is visible, FALSE otherwise.
     */
    protected boolean isVisible(Player observer, int entityID) {
        // If we are using a whitelist, presence means visibility - if not, the opposite
        // is the case

        boolean presence = getMembership(observer, entityID);

        return (policy == Policy.WHITELIST) == presence;
    }

    /**
     * Remove the given entity from the underlying map.
     *
     * @param entity - the entity to remove.
     */
    protected void removeEntity(Entity entity) {
        int entityID = entity.getEntityId();

        for (Map<Integer, Boolean> maps : observerEntityMap.rowMap().values()) {
            maps.remove(entityID);
        }
    }

    /**
     * Invoked when a player logs out.
     *
     * @param player - the player that used logged out.
     */
    protected void removePlayer(Player player) {
        // Cleanup
        observerEntityMap.rowMap().remove(player.getEntityId());
    }

    /**
     * Construct the Bukkit event listener.
     *
     * @return Our listener.
     */
    private Listener constructBukkit() {
        return new Listener() {
            @EventHandler
            public void onEntityDeath(EntityDeathEvent e) {
                removeEntity(e.getEntity());
            }

            @EventHandler
            public void onChunkUnload(ChunkUnloadEvent e) {
                for (Entity entity : e.getChunk().getEntities()) {
                    removeEntity(entity);
                }
            }

            @EventHandler
            public void onPlayerQuit(PlayerQuitEvent e) {
                removePlayer(e.getPlayer());
            }

            @EventHandler(priority = EventPriority.MONITOR)
            public void onPotionSplash(PotionSplashEvent event) {
                ThrownPotion potion = event.getEntity();
                if (!(potion.getShooter() instanceof Player))
                    return;

                Player shooter = (Player) potion.getShooter();

                for (LivingEntity livingEntity : event.getAffectedEntities()) {
                    if (!(livingEntity instanceof Player))
                        return;

                    Player receiver = (Player) livingEntity;
                    if (!receiver.canSee(shooter)) {
                        event.setIntensity(receiver, 0.0D);
                    }
                }
            }
        };
    }

    /**
     * Construct the packet listener that will be used to intercept every
     * entity-related packet.
     *
     * @param plugin - the parent plugin.
     * @return The packet listener.
     */
    private PacketAdapter constructProtocol(Plugin plugin) {
        return new PacketAdapter(plugin, ENTITY_PACKETS) {
            @Override
            public void onPacketSending(PacketEvent event) {
                if (event.getPlayer() == null)
                    return;
                if (event.getPacket() == null)
                    return;

                int entityID = event.getPacket().getIntegers().read(0);

                // See if this packet should be cancelled
                if (!isVisible(event.getPlayer(), entityID)) {
                    event.setCancelled(true);
                    return;
                }

                PacketType type = event.getPacketType();
                Player receiver = event.getPlayer();

                if (type == PacketType.Play.Server.WORLD_EVENT) {
                    int effect = event.getPacket().getIntegers().read(0);
                    if (effect != 2002)
                        return;

                    BlockPosition position = event.getPacket().getBlockPositionModifier().read(0);

                    int x = position.getX();
                    int y = position.getY();
                    int z = position.getZ();

                    boolean isVisible = false;
                    boolean isInMatch = false;

                    for (ThrownPotion potion : receiver.getWorld().getEntitiesByClass(ThrownPotion.class)) {
                        int potionX = MathHelper.floor(x);
                        int potionY = MathHelper.floor(y);
                        int potionZ = MathHelper.floor(z);

                        if (!(potion.getShooter() instanceof Player))
                            continue;
                        if (x != potionX || y != potionY || z != potionZ)
                            continue;

                        isInMatch = true;
                        Player shooter = (Player) potion.getShooter();
                        if (receiver.canSee(shooter))
                            isVisible = true;
                    }

                    if (isInMatch && !isVisible) {
                        event.setCancelled(true);
                        return;
                    }
                } else if (type == PacketType.Play.Server.NAMED_SOUND_EFFECT) {
                    String sound = event.getPacket().getStrings().read(0);

                    if (sound.equals("random.bow") || sound.equals("random.bowhit") || sound.equals("random.pop")
                            || sound.equals("game.player.hurt")) {
                        int x = event.getPacket().getIntegers().read(0);
                        int y = event.getPacket().getIntegers().read(1);
                        int z = event.getPacket().getIntegers().read(2);

                        // Credit: Array Practice
                        boolean hasAnyPlayable = false;
                        boolean hasAtleastOneMatch = false;

                        for (Entity entity : receiver.getWorld().getEntitiesByClasses(Player.class, Projectile.class)) {
                            Player player;
                            if (entity instanceof Player) {
                                player = (Player) entity;
                            } else if (entity instanceof Projectile) {
                                Projectile projectile = (Projectile) entity;
                                if (projectile.getShooter() instanceof Player) {
                                    player = (Player) projectile.getShooter();
                                } else {
                                    continue;
                                }
                            } else {
                                continue;
                            }
                            Location location = entity.getLocation();
                            if (((int) (location.getX() * 8.0D) == x) && ((int) (location.getY() * 8.0D) == y)
                                    && ((int) (location.getZ() * 8.0D) == z)) {
                                boolean pass = false;
                                if (sound.equals("random.bow")) {
                                    ItemStack hand = player.getItemInHand();
                                    if (hand != null) {
                                        if (hand.getType() == Material.POTION || hand.getType() == Material.BOW
                                                || hand.getType() == Material.ENDER_PEARL) {
                                            pass = true;
                                        }
                                    }
                                } else if (sound.equals("random.bowhit")) {
                                    if (entity instanceof Arrow) {
                                        pass = true;
                                    }
                                } else {
                                    if (entity instanceof Player) {
                                        pass = true;
                                    }
                                }
                                if (pass) {
                                    hasAtleastOneMatch = true;
                                    if (receiver.canSee(player)) {
                                        hasAnyPlayable = true;
                                    }
                                }
                            }
                        }
                        if (hasAtleastOneMatch && !hasAnyPlayable) {
                            event.setCancelled(true);
                        }
                    }
                } else {
                    Entity entity = receiver.getWorld().getEntities().stream().filter(e -> e.getEntityId() == entityID)
                            .findFirst().orElse(null);

                    if (entity instanceof Player) {
                        Player player = (Player) entity;
                        if (receiver.canSee(player))
                            return;

                        event.setCancelled(true);
                        return;
                    } else if (entity instanceof Projectile) {
                        Projectile projectile = (Projectile) entity;
                        if (!(projectile.getShooter() instanceof Player))
                            return;

                        Player shooter = (Player) projectile.getShooter();
                        if (receiver.canSee(shooter))
                            return;

                        event.setCancelled(true);
                        return;
                    } else if (entity instanceof Item) {
                        Item item = (Item) entity;

                        Player dropper = getPlayerWhoDropped(item);
                        if (dropper == null)
                            return;
                        if (receiver.canSee(dropper))
                            return;
                        if (PlayerProfile.get(receiver) != null && PlayerProfile.get(dropper) != null
                                && PlayerProfile.get(receiver).getMatch() == PlayerProfile.get(dropper).getMatch())
                            return;

                        event.setCancelled(true);
                        return;
                    }
                }
            }
        };
    }

    /**
     * Toggle the visibility status of an entity for a player.
     * <p>
     * If the entity is visible, it will be hidden. If it is hidden, it will become
     * visible.
     *
     * @param observer - the player observer.
     * @param entity   - the entity to toggle.
     * @return TRUE if the entity was visible before, FALSE otherwise.
     */
    public final boolean toggleEntity(Player observer, Entity entity) {
        if (isVisible(observer, entity.getEntityId())) {
            return hideEntity(observer, entity);
        } else {
            return !showEntity(observer, entity);
        }
    }

    /**
     * Allow the observer to see an entity that was previously hidden.
     *
     * @param observer - the observer.
     * @param entity   - the entity to show.
     * @return TRUE if the entity was hidden before, FALSE otherwise.
     */
    public final boolean showEntity(Player observer, Entity entity) {
        validate(observer, entity);
        boolean hiddenBefore = !setVisibility(observer, entity.getEntityId(), true);

        // Resend packets
        if (manager != null && hiddenBefore) {
            manager.updateEntity(entity, Collections.singletonList(observer));
        }
        return hiddenBefore;
    }

    /**
     * Prevent the observer from seeing a given entity.
     *
     * @param observer - the player observer.
     * @param entity   - the entity to hide.
     * @return TRUE if the entity was previously visible, FALSE otherwise.
     */
    public final boolean hideEntity(Player observer, Entity entity) {
        validate(observer, entity);
        boolean visibleBefore = setVisibility(observer, entity.getEntityId(), false);

        if (visibleBefore) {
            // Make the entity disappear
            try {
                destroy(observer, entity.getEntityId());
            } catch (Exception e) {
                throw new RuntimeException("Cannot send server packet.", e);
            }

        }
        return visibleBefore;
    }

    /**
     * Determine if the given entity has been hidden from an observer.
     * Note that the entity may very well be occluded or out of range from the
     * perspective
     * of the observer. This method simply checks if an entity has been completely
     * hidden
     * for that observer.
     *
     * @param observer - the observer.
     * @param entity   - the entity that may be hidden.
     * @return TRUE if the player may see the entity, FALSE if the entity has been
     *         hidden.
     */
    public final boolean canSee(Player observer, Entity entity) {
        validate(observer, entity);

        return isVisible(observer, entity.getEntityId());
    }

    // For validating the input parameters
    private void validate(Player observer, Entity entity) {
        Preconditions.checkNotNull(observer, "observer cannot be NULL.");
        Preconditions.checkNotNull(entity, "entity cannot be NULL.");
    }

    /**
     * Retrieve the current visibility policy.
     *
     * @return The current visibility policy.
     */
    public Policy getPolicy() {
        return policy;
    }

    public void close() {
        HandlerList.unregisterAll(bukkitListener);
        manager.removePacketListener(protocolListener);
        itemOwner.setAccessible(false);
    }

    private Player getPlayerWhoDropped(Item item) {
        try {
            String name = (String) itemOwner.get(((CraftEntity) item).getHandle());
            if (name == null)
                return null;
            return Bukkit.getPlayer(name);
        } catch (Exception e) {
            return null;
        }
    }

    public void setPlayerWhoDropped(Item item, String owner) {
        setPlayerWhoDropped(((CraftEntity) item).getHandle(), owner);
    }

    public void setPlayerWhoDropped(net.minecraft.server.v1_8_R3.Entity entity, String owner) {
        try {
            itemOwner.set(entity, owner);
        } catch (IllegalAccessException e) {
            throw new RuntimeException(e);
        }
    }

    public void destroy(Player player, int entityId) {
        PacketPlayOutEntityDestroy packet = new PacketPlayOutEntityDestroy(entityId);
        ((CraftPlayer) player).getHandle().playerConnection.sendPacket(packet);
    }

}


Filename: .\main\java\rip\diamond\practice\util\FireballUtil.java
package rip.diamond.practice.util;

import org.bukkit.Bukkit;
import org.bukkit.entity.Fireball;
import org.bukkit.util.Vector;
import rip.diamond.practice.Eden;
import rip.diamond.practice.config.Config;

import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

//Credit: https://gist.github.com/aaron1998ish/1dd3f183d8d55902f65ea187019058ac

public class FireballUtil {

    private static Field fieldFireballDirX;
    private static Field fieldFireballDirY;
    private static Field fieldFireballDirZ;

    private static Method craftFireballHandle;

    static {
        String version = Bukkit.getServer().getClass().getPackage().getName().replace(".", ",").split(",")[3] + ".";
        String nmsFireball = "net.minecraft.server." + version + "EntityFireball";
        String craftFireball = "org.bukkit.craftbukkit." + version + "entity.CraftFireball";
        try {
            Class<?> fireballClass = Class.forName(nmsFireball);

            //should be accessible by default.
            fieldFireballDirX = fireballClass.getDeclaredField("dirX");
            fieldFireballDirY = fireballClass.getDeclaredField("dirY");
            fieldFireballDirZ = fireballClass.getDeclaredField("dirZ");

            craftFireballHandle = Class.forName(craftFireball).getDeclaredMethod("getHandle");

        } catch (ClassNotFoundException e) {
            e.printStackTrace();
            Bukkit.shutdown();
        } catch (NoSuchFieldException | NoSuchMethodException e) {
            e.printStackTrace();
        }
    }


    public static Fireball setDirection(Fireball fireball, Vector direction) {
        double speed = Config.MATCH_FIREBALL_SPEED.toDouble();

        try {
            Object handle = craftFireballHandle.invoke(fireball);
            fieldFireballDirX.set(handle, direction.getX() * 0.10D * speed);
            fieldFireballDirY.set(handle, direction.getY() * 0.10D * speed);
            fieldFireballDirZ.set(handle, direction.getZ() * 0.10D * speed);

        } catch (IllegalAccessException | InvocationTargetException e) {
            e.printStackTrace();
        }
        return fireball;
    }


}


Filename: .\main\java\rip\diamond\practice\util\GsonType.java
package rip.diamond.practice.util;

import com.google.gson.reflect.TypeToken;
import rip.diamond.practice.kits.KitExtraItem;
import rip.diamond.practice.kits.KitGameRules;
import rip.diamond.practice.kits.KitMatchType;

import java.lang.reflect.Type;
import java.util.List;
import java.util.UUID;

public class GsonType {

    public static final Type STRING_LIST = new TypeToken<List<String>>() {}.getType();
    public static final Type UUID_LIST = new TypeToken<List<UUID>>() {}.getType();
    public static final Type KIT_GAME_RULES = new TypeToken<KitGameRules>() {}.getType();
    public static final Type KIT_MATCH_TYPES = new TypeToken<List<KitMatchType>>() {}.getType();
    public static final Type KIT_EXTRA_ITEM = new TypeToken<List<KitExtraItem>>() {}.getType();
}


Filename: .\main\java\rip\diamond\practice\util\HeadUtil.java
package rip.diamond.practice.util;

import com.mojang.authlib.GameProfile;
import com.mojang.authlib.properties.Property;
import net.minecraft.server.v1_8_R3.EntityPlayer;
import org.bukkit.craftbukkit.v1_8_R3.entity.CraftPlayer;
import org.bukkit.entity.Player;

import java.util.Map;

public class HeadUtil {

    public static String getValue(Player player) {
        if (player != null) {
            EntityPlayer entityPlayer = ((CraftPlayer)player).getHandle();
            GameProfile gameProfile = entityPlayer.getProfile();

            for (Map.Entry<String, Property> entry : gameProfile.getProperties().entries()) {
                return entry.getValue().getValue();
            }
        }

        return null;
    }

    public static String[] getValues(Player player) {
        return getValues(null, player);
    }

    public static String[] getValues(String key, Player player) {
        if (player != null) {
            EntityPlayer entityPlayer = ((CraftPlayer)player).getHandle();
            GameProfile gameProfile = entityPlayer.getProfile();

            for (Map.Entry<String, Property> entry : gameProfile.getProperties().entries()) {
                if (key == null || entry.getKey().equals(key)) {
                    return new String[]{entry.getValue().getValue(), entry.getValue().getSignature()};
                }
            }
        }

        return null;
    }

}


Filename: .\main\java\rip\diamond\practice\util\HealingMethod.java
package rip.diamond.practice.util;

import lombok.AllArgsConstructor;
import lombok.Getter;
import org.bukkit.Material;
import org.bukkit.inventory.ItemStack;
import rip.diamond.practice.config.Language;

@Getter
@AllArgsConstructor
public enum HealingMethod {
    POTION(Language.MATCH_HEALING_METHOD_POTION.toString(), new ItemBuilder(Material.POTION).durability(16421).build().clone()),
    SOUP(Language.MATCH_HEALING_METHOD_SOUP.toString(), new ItemStack(Material.MUSHROOM_SOUP).clone()),
    GOLDEN_APPLE(Language.MATCH_HEALING_METHOD_GOLDEN_APPLE.toString(), new ItemStack(Material.GOLDEN_APPLE).clone()),
    GOD_APPLE(Language.MATCH_HEALING_METHOD_GOD_APPLE.toString(), new ItemBuilder(Material.GOLDEN_APPLE).durability(1).build().clone());

    private final String name;
    private final ItemStack item;

    public static HealingMethod getHealingMethod(ItemStack[] contents) {
        for (ItemStack itemStack : contents) {
            if (itemStack == null) {
                continue;
            }
            if (itemStack.isSimilar(HealingMethod.POTION.getItem())) {
                return HealingMethod.POTION;
            } else if (itemStack.isSimilar(HealingMethod.SOUP.getItem())) {
                return HealingMethod.SOUP;
            } else if (itemStack.isSimilar(HealingMethod.GOLDEN_APPLE.getItem())) {
                return HealingMethod.GOLDEN_APPLE;
            } else if (itemStack.isSimilar(HealingMethod.GOD_APPLE.getItem())) {
                return HealingMethod.GOD_APPLE;
            }
        }
        return null;
    }

    public static int getHealingLeft(HealingMethod healingMethod, ItemStack[] contents) {
        if (healingMethod == null) {
            return -1;
        }

        int amount = 0;
        for (ItemStack itemStack : contents) {
            if (itemStack != null && itemStack.isSimilar(healingMethod.getItem())) {
                amount += itemStack.getAmount();
            }
        }
        return amount;
    }
}

Filename: .\main\java\rip\diamond\practice\util\InsertUtil.java
package rip.diamond.practice.util;

public class InsertUtil {

    public static InsertType check(String str) {
        if (Checker.isUUID(str)) {
            return InsertType.UUID;
        }
        return InsertType.STRING;
    }

    public enum InsertType {
        STRING,
        UUID
    }

}


Filename: .\main\java\rip\diamond\practice\util\InventoryUtil.java
package rip.diamond.practice.util;

import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.Recipe;
import rip.diamond.practice.Eden;
import rip.diamond.practice.config.Config;

import java.util.Iterator;

public class InventoryUtil {

	public static ItemStack[] fixInventoryOrder(ItemStack[] source) {
		ItemStack[] fixed = new ItemStack[36];

		System.arraycopy(source, 0, fixed, 27, 9);
		System.arraycopy(source, 9, fixed, 0, 27);

		return fixed;
	}

	public static void handleRemoveCrafting() {
		if (!Config.CRAFTING_ENABLED.toBoolean()) {
			Iterator<Recipe> iterator = Eden.INSTANCE.getServer().recipeIterator();

			while (iterator.hasNext()) {
				Recipe recipe = iterator.next();
				if (recipe != null && !Config.CRAFTING_WHITELISTED_ITEMS.toStringList().contains(recipe.getResult().getType().name())) {
					iterator.remove();
				}
			}
		}
	}

}


Filename: .\main\java\rip\diamond\practice\util\ItemBuilder.java
package rip.diamond.practice.util;

import com.mojang.authlib.GameProfile;
import com.mojang.authlib.properties.Property;
import net.minecraft.server.v1_8_R3.NBTTagCompound;
import net.minecraft.server.v1_8_R3.NBTTagString;
import org.bukkit.Bukkit;
import org.bukkit.ChatColor;
import org.bukkit.Material;
import org.bukkit.craftbukkit.v1_8_R3.inventory.CraftItemStack;
import org.bukkit.enchantments.Enchantment;
import org.bukkit.event.Listener;
import org.bukkit.inventory.ItemFlag;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.meta.ItemMeta;
import org.bukkit.inventory.meta.SkullMeta;

import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.UUID;

public class ItemBuilder implements Listener {

	private ItemStack is;

	public ItemBuilder(Material mat) {
		is = new ItemStack(mat);
	}

	public ItemBuilder(ItemStack is) {
		this.is = is;
	}

	public ItemBuilder amount(int amount) {
		is.setAmount(amount);
		return this;
	}

	public ItemBuilder name(String name) {
		ItemMeta meta = is.getItemMeta();
		meta.setDisplayName(ChatColor.translateAlternateColorCodes('&', name));
		is.setItemMeta(meta);
		return this;
	}

	public ItemBuilder lore(String name) {
		ItemMeta meta = is.getItemMeta();
		List<String> lore = meta.getLore();

		if (lore == null) {
			lore = new ArrayList<>();
		}

		if (name != null) {
			lore.add(ChatColor.translateAlternateColorCodes('&', name));
		}
		meta.setLore(lore);

		is.setItemMeta(meta);

		return this;
	}

	public ItemBuilder lore(String... lore) {
		ItemMeta meta = is.getItemMeta();
		List<String> toSet = meta.getLore();

		if (toSet == null) {
			toSet = new ArrayList<>();
		}

		for (String string : lore) {
			if (string != null) {
				toSet.add(ChatColor.translateAlternateColorCodes('&', string));
			}
		}

		meta.setLore(toSet);
		is.setItemMeta(meta);

		return this;
	}

	public ItemBuilder lore(List<String> lore) {
		ItemMeta meta = is.getItemMeta();
		List<String> toSet = meta.getLore();

		if (toSet == null) {
			toSet = new ArrayList<>();
		}

		for (String string : lore) {
			if (string != null) {
				toSet.add(ChatColor.translateAlternateColorCodes('&', string));
			}
		}

		meta.setLore(toSet);
		is.setItemMeta(meta);

		return this;
	}

	public ItemBuilder durability(int durability) {
		is.setDurability((short) durability);
		return this;
	}

	public ItemBuilder enchantments(Map<Enchantment, Integer> enchantments) {
		this.is.addUnsafeEnchantments(enchantments);
		return this;
	}

	public ItemBuilder enchantment(Enchantment enchantment, int level) {
		is.addUnsafeEnchantment(enchantment, level);
		return this;
	}

	public ItemBuilder enchantment(Enchantment enchantment) {
		is.addUnsafeEnchantment(enchantment, 1);
		return this;
	}

	public ItemBuilder type(Material material) {
		is.setType(material);
		return this;
	}

	public ItemBuilder clearLore() {
		ItemMeta meta = is.getItemMeta();

		meta.setLore(new ArrayList<>());
		is.setItemMeta(meta);

		return this;
	}

	public ItemBuilder clearEnchantments() {
		for (Enchantment e : is.getEnchantments().keySet()) {
			is.removeEnchantment(e);
		}

		return this;
	}

	public ItemBuilder unbreakable() {
		ItemMeta im = this.is.getItemMeta();
		im.spigot().setUnbreakable(true);
		this.is.setItemMeta(im);
		return this;
	}

	public ItemBuilder hideItemFlags() {
		ItemMeta im = is.getItemMeta();
		im.addItemFlags(ItemFlag.HIDE_ENCHANTS);
		im.addItemFlags(ItemFlag.HIDE_ATTRIBUTES);
		im.addItemFlags(ItemFlag.HIDE_POTION_EFFECTS);
		im.addItemFlags(ItemFlag.HIDE_PLACED_ON);
		im.addItemFlags(ItemFlag.HIDE_DESTROYS);
		im.addItemFlags(ItemFlag.HIDE_UNBREAKABLE);
		is.setItemMeta(im);
		return this;
	}

	public ItemBuilder glow() {
		is.addUnsafeEnchantment(Enchantment.DURABILITY, 1);
		ItemMeta im = is.getItemMeta();
		im.addItemFlags(ItemFlag.HIDE_ENCHANTS);
		is.setItemMeta(im);
		return this;
	}

	public ItemBuilder addNBTTag(String s1, String s2) {
		net.minecraft.server.v1_8_R3.ItemStack nmsItem = CraftItemStack.asNMSCopy(is);
		NBTTagCompound compound = (nmsItem.hasTag()) ? nmsItem.getTag() : new NBTTagCompound();
		compound.set(s1, new NBTTagString(s2));
		is = CraftItemStack.asBukkitCopy(nmsItem);
		return this;
	}

	public ItemBuilder headTexture(String texture) {
		if (texture != null) {
			SkullMeta hm = (SkullMeta) is.getItemMeta();
			GameProfile profile = new GameProfile(new UUID(texture.hashCode(), texture.hashCode()), null);
			profile.getProperties().put("textures", new Property("Value", texture));

			try{
				Field profileField = hm.getClass().getDeclaredField("profile");
				profileField.setAccessible(true);
				profileField.set(hm, profile);
			} catch(NoSuchFieldException | IllegalArgumentException | IllegalAccessException e) {
				e.printStackTrace();
			}

			is.setItemMeta(hm);
		}
		return this;
	}

	public ItemBuilder skull(String owner) {
		try {
			SkullMeta im = (SkullMeta) is.getItemMeta();
			im.setOwner(owner);
			is.setItemMeta(im);
		} catch (ClassCastException e) {
			e.printStackTrace();
		}
		return this;
	}

	public ItemStack build() {
		return is;
	}

}

Filename: .\main\java\rip\diamond\practice\util\PlayerUtil.java
package rip.diamond.practice.util;

import net.minecraft.server.v1_8_R3.PacketPlayOutTitle;
import org.bukkit.GameMode;
import org.bukkit.craftbukkit.v1_8_R3.entity.CraftPlayer;
import org.bukkit.entity.Player;
import org.bukkit.inventory.ItemStack;

public class PlayerUtil {

	public static void reset(Player player) {
		reset(player, true);
	}

	public static void reset(Player player, boolean resetHeldSlot) {
		if (player == null) {
			return;
		}
		player.setHealth(20.0D);
		player.setSaturation(0.0F);
		player.setFallDistance(0.0F);
		player.setFoodLevel(20);
		player.setFireTicks(0);
		player.setMaximumNoDamageTicks(20);
		player.setExp(0.0F);
		player.setLevel(0);
		player.setAllowFlight(false);
		player.setFlying(false);
		player.setGameMode(GameMode.SURVIVAL);
		player.setItemOnCursor(null);
		player.getOpenInventory().getTopInventory().clear();
		player.getInventory().setArmorContents(new ItemStack[4]);
		player.getInventory().setContents(new ItemStack[36]);
		player.getActivePotionEffects().forEach(effect -> player.removePotionEffect(effect.getType()));
		player.spigot().setCollidesWithEntities(true);

		clearArrow(player);

		//Since Player#sendTitle only reset the title, not subtitle, so we do some tricky stuff here
		TitleSender.sendTitle(player, "&r", PacketPlayOutTitle.EnumTitleAction.TITLE, 1, 10, 1);
		TitleSender.sendTitle(player, "&r", PacketPlayOutTitle.EnumTitleAction.SUBTITLE, 1, 10, 1);

		if (resetHeldSlot) {
			player.getInventory().setHeldItemSlot(0);
		}

		player.updateInventory();
	}

	public static void spectator(Player player) {
		reset(player);

		player.setGameMode(GameMode.ADVENTURE);
		player.setAllowFlight(true);
		player.setFlying(true);

		player.setAllowFlight(true);
		player.setFlying(true);
		player.spigot().setCollidesWithEntities(false);

		clearArrow(player);
	}

	public static void clearArrow(Player player) {
		((CraftPlayer) player).getHandle().getDataWatcher().watch(9, (byte) 0);
	}
}

Filename: .\main\java\rip\diamond\practice\util\Symbols.java
package rip.diamond.practice.util;


import org.apache.commons.lang.*;
import org.bukkit.*;

public class Symbols {

    public static String HEALTH = StringEscapeUtils.unescapeJava("\u2764");
    public static String ARROW_LEFT = StringEscapeUtils.unescapeJava("\u00AB");
    public static String ARROW_RIGHT = StringEscapeUtils.unescapeJava("\u00BB");
    public static String X = StringEscapeUtils.unescapeJava("\u2716");
    public static String ALERT = StringEscapeUtils.unescapeJava("\u26A0");
    public static String BULLET = "\u2022";
}

Filename: .\main\java\rip\diamond\practice\util\Tasks.java
package rip.diamond.practice.util;

import com.google.common.util.concurrent.ThreadFactoryBuilder;
import org.bukkit.scheduler.BukkitScheduler;
import rip.diamond.practice.Eden;

import java.util.concurrent.ThreadFactory;

public class Tasks {

    public static ThreadFactory newThreadFactory(String name) {
        return new ThreadFactoryBuilder().setNameFormat(name).build();
    }

    public static void run(Runnable runnable, boolean async) {
        if(async) {
            Eden.INSTANCE.getServer().getScheduler().runTaskAsynchronously(Eden.INSTANCE, runnable);
        } else {
            runnable.run();
        }
    }

    public static void run(Runnable runnable) {
        Eden.INSTANCE.getServer().getScheduler().runTask(Eden.INSTANCE, runnable);
    }

    public static void runAsync(Runnable runnable) {
        Eden.INSTANCE.getServer().getScheduler().runTaskAsynchronously(Eden.INSTANCE, runnable);
    }

    public static void runLater(Runnable runnable, long delay) {
        Eden.INSTANCE.getServer().getScheduler().runTaskLater(Eden.INSTANCE, runnable, delay);
    }

    public static void runAsyncLater(Runnable runnable, long delay) {
        Eden.INSTANCE.getServer().getScheduler().runTaskLaterAsynchronously(Eden.INSTANCE, runnable, delay);
    }

    public static void runTimer(Runnable runnable, long delay, long interval) {
        Eden.INSTANCE.getServer().getScheduler().runTaskTimer(Eden.INSTANCE, runnable, delay, interval);
    }

    public static void runAsyncTimer(Runnable runnable, long delay, long interval) {
        Eden.INSTANCE.getServer().getScheduler().runTaskTimerAsynchronously(Eden.INSTANCE, runnable, delay, interval);
    }

    public static BukkitScheduler getScheduler() {
        return Eden.INSTANCE.getServer().getScheduler();
    }
}


Filename: .\main\java\rip\diamond\practice\util\TaskTicker.java
package rip.diamond.practice.util;

import lombok.Getter;
import lombok.Setter;
import org.bukkit.plugin.java.JavaPlugin;
import org.bukkit.scheduler.BukkitRunnable;
import rip.diamond.practice.Eden;

import java.util.ArrayList;
import java.util.List;

public abstract class TaskTicker extends BukkitRunnable {

    @Getter private static final List<TaskTicker> tickers = new ArrayList<>();

    @Getter @Setter private int ticks;
    private boolean finishPreRun = false;

    public TaskTicker(int delay, int period, boolean async) {
        if (async) {
            this.runTaskTimerAsynchronously(Eden.INSTANCE, delay, period);
        } else {
            this.runTaskTimer(Eden.INSTANCE, delay, period);
        }
        tickers.add(this);
    }

    @Override
    public void run() {
        if (!finishPreRun) {
            ticks = getStartTick();
            preRun();
            finishPreRun = true;
        }
        onRun();
        if (getTickType() == TickType.COUNT_UP) {
            countUp();
        } else if (getTickType() == TickType.COUNT_DOWN) {
            countDown();
        }
    }

    public abstract void onRun();

    public void preRun() {

    }

    @Override
    public synchronized void cancel() throws IllegalStateException {
        super.cancel();

        tickers.remove(this);
    }

    public abstract TickType getTickType();

    public abstract int getStartTick();

    public void countUp() {
        ticks++;
    }

    public void countDown() {
        ticks--;
    }

    public enum TickType {
        COUNT_UP,
        COUNT_DOWN,
        NONE
    }

}

Filename: .\main\java\rip\diamond\practice\util\TimeUtil.java
package rip.diamond.practice.util;

import java.sql.Timestamp;
import java.text.DecimalFormat;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public final class TimeUtil {

	private static final String HOUR_FORMAT = "%02d:%02d:%02d";
	private static final String MINUTE_FORMAT = "%02d:%02d";

	private TimeUtil() {
		throw new RuntimeException("Cannot instantiate a utility class.");
	}

	public static String millisToTimer(long millis) {
		long seconds = millis / 1000L;

		if (seconds > 3600L) {
			return String.format(HOUR_FORMAT, seconds / 3600L, seconds % 3600L / 60L, seconds % 60L);
		} else {
			return String.format(MINUTE_FORMAT, seconds / 60L, seconds % 60L);
		}
	}

	/**
	 * Return the amount of seconds from milliseconds.
	 * Note: We explicitly use 1000.0F (float) instead of 1000L (long).
	 *
	 * @param millis the amount of time in milliseconds
	 * @return the seconds
	 */
	public static String millisToSeconds(long millis) {
		return new DecimalFormat("#0.0").format(millis / 1000.0F);
	}

	public static String dateToString(Date date, String secondaryColor) {
		Calendar calendar = Calendar.getInstance();
		calendar.setTime(date);

		return new SimpleDateFormat("MMM dd yyyy " + (secondaryColor == null ? "" : secondaryColor) +
		                            "(hh:mm aa zz)").format(date);
	}

	public static Timestamp addDuration(long duration) {
		return truncateTimestamp(new Timestamp(System.currentTimeMillis() + duration));
	}

	public static Timestamp truncateTimestamp(Timestamp timestamp) {
		if (timestamp.toLocalDateTime().getYear() > 2037) {
			timestamp.setYear(2037);
		}

		return timestamp;
	}

	public static Timestamp addDuration(Timestamp timestamp) {
		return truncateTimestamp(new Timestamp(System.currentTimeMillis() + timestamp.getTime()));
	}

	public static Timestamp fromMillis(long millis) {
		return new Timestamp(millis);
	}

	public static Timestamp getCurrentTimestamp() {
		return new Timestamp(System.currentTimeMillis());
	}

	public static String millisToRoundedTime(long millis) {
		millis += 1L;

		long seconds = millis / 1000L;
		long minutes = seconds / 60L;
		long hours = minutes / 60L;
		long days = hours / 24L;
		long weeks = days / 7L;
		long months = weeks / 4L;
		long years = months / 12L;

		if (years > 0) {
			return years + " year" + (years == 1 ? "" : "s");
		} else if (months > 0) {
			return months + " month" + (months == 1 ? "" : "s");
		} else if (weeks > 0) {
			return weeks + " week" + (weeks == 1 ? "" : "s");
		} else if (days > 0) {
			return days + " day" + (days == 1 ? "" : "s");
		} else if (hours > 0) {
			return hours + " hour" + (hours == 1 ? "" : "s");
		} else if (minutes > 0) {
			return minutes + " minute" + (minutes == 1 ? "" : "s");
		} else {
			return seconds + " second" + (seconds == 1 ? "" : "s");
		}
	}

	public static long parseTime(String time) {
		long totalTime = 0L;
		boolean found = false;
		Matcher matcher = Pattern.compile("\\d+\\D+").matcher(time);

		while (matcher.find()) {
			String s = matcher.group();
			Long value = Long.parseLong(s.split("(?<=\\D)(?=\\d)|(?<=\\d)(?=\\D)")[0]);
			String type = s.split("(?<=\\D)(?=\\d)|(?<=\\d)(?=\\D)")[1];

			switch (type) {
				case "s":
					totalTime += value;
					found = true;
					break;
				case "m":
					totalTime += value * 60;
					found = true;
					break;
				case "h":
					totalTime += value * 60 * 60;
					found = true;
					break;
				case "d":
					totalTime += value * 60 * 60 * 24;
					found = true;
					break;
				case "w":
					totalTime += value * 60 * 60 * 24 * 7;
					found = true;
					break;
				case "M":
					totalTime += value * 60 * 60 * 24 * 30;
					found = true;
					break;
				case "y":
					totalTime += value * 60 * 60 * 24 * 365;
					found = true;
					break;
			}
		}

		return !found ? -1 : totalTime * 1000;
	}

}


Filename: .\main\java\rip\diamond\practice\util\TitleSender.java
package rip.diamond.practice.util;

import net.minecraft.server.v1_8_R3.IChatBaseComponent;
import net.minecraft.server.v1_8_R3.PacketPlayOutChat;
import net.minecraft.server.v1_8_R3.PacketPlayOutTitle;
import org.bukkit.ChatColor;
import org.bukkit.craftbukkit.v1_8_R3.entity.CraftPlayer;
import org.bukkit.entity.Player;

// TODO: 7/5/2023 Replace this to paperspigot title api
public class TitleSender {

    public static void sendTitle(Player player, String text, PacketPlayOutTitle.EnumTitleAction titleAction, int fadeInTime, int showTime, int fadeOutTime) {
        if (Util.isNull(text)) {
            return;
        }
        IChatBaseComponent chatTitle = IChatBaseComponent.ChatSerializer.a("{\"text\": \"" + CC.translate(text) + "\",color:" + ChatColor.GOLD.name().toLowerCase() + "}");

        PacketPlayOutTitle title = new PacketPlayOutTitle(titleAction, chatTitle);
        PacketPlayOutTitle length = new PacketPlayOutTitle(fadeInTime, showTime, fadeOutTime);

        ((CraftPlayer) player).getHandle().playerConnection.sendPacket(title);
        ((CraftPlayer) player).getHandle().playerConnection.sendPacket(length);
    }

    public static void sendActionBar(Player p, String text) {
        if (Util.isNull(text)) {
            return;
        }
        CraftPlayer cp = (CraftPlayer) p;
        IChatBaseComponent cbc = IChatBaseComponent.ChatSerializer.a("{\"text\": \"" + CC.translate(text) + "\"}");
        PacketPlayOutChat ppoc = new PacketPlayOutChat(cbc, (byte) 2);
        cp.getHandle().playerConnection.sendPacket(ppoc);
    }

}


Filename: .\main\java\rip\diamond\practice\util\Util.java
package rip.diamond.practice.util;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableSet;
import net.minecraft.server.v1_8_R3.*;
import org.bukkit.Bukkit;
import org.bukkit.Location;
import org.bukkit.Material;
import org.bukkit.block.Block;
import org.bukkit.craftbukkit.v1_8_R3.CraftServer;
import org.bukkit.craftbukkit.v1_8_R3.CraftWorld;
import org.bukkit.craftbukkit.v1_8_R3.entity.CraftItem;
import org.bukkit.craftbukkit.v1_8_R3.entity.CraftLivingEntity;
import org.bukkit.craftbukkit.v1_8_R3.entity.CraftPlayer;
import org.bukkit.craftbukkit.v1_8_R3.entity.CraftTNTPrimed;
import org.bukkit.craftbukkit.v1_8_R3.inventory.CraftItemStack;
import org.bukkit.entity.*;
import org.bukkit.entity.Item;
import org.bukkit.event.entity.EntityDamageByEntityEvent;
import org.bukkit.event.entity.EntityDamageEvent;
import org.bukkit.event.player.PlayerCommandPreprocessEvent;
import org.bukkit.event.player.PlayerInteractEvent;
import org.bukkit.inventory.ItemStack;
import org.bukkit.plugin.Plugin;
import rip.diamond.practice.Eden;
import rip.diamond.practice.config.Config;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.match.Match;
import rip.diamond.practice.match.team.Team;

import java.io.IOException;
import java.lang.reflect.Field;
import java.net.URL;
import java.security.CodeSource;
import java.util.*;
import java.util.jar.JarEntry;
import java.util.jar.JarFile;

public class Util {

    public static boolean isNull(String str) {
        return str == null || str.equalsIgnoreCase("null") || str.equalsIgnoreCase("");
    }

    public static boolean isNotNull(String str) {
        return !isNull(str);
    }

    public static List<Player> getOnlinePlayers() {
        if (Eden.INSTANCE.getHookManager().getCitizensHook() != null) {
            return Eden.INSTANCE.getHookManager().getCitizensHook().getOnlinePlayers();
        } else {
            return ImmutableList.copyOf(Bukkit.getOnlinePlayers());
        }
    }

    public static void damage(Player player, double damage) {
        EntityDamageEvent event = new EntityDamageEvent(player, EntityDamageEvent.DamageCause.CUSTOM, damage);
        Bukkit.getPluginManager().callEvent(event);

        if (!event.isCancelled()) {
            if (Util.isNPC(player)) {
                ((CraftPlayer)player).getHandle().invulnerableTicks = 0;
            }
            player.damage(damage);
        }
    }
    
    public static void performCommand(Player player, String command) {
        PlayerCommandPreprocessEvent event = new PlayerCommandPreprocessEvent(player, "/" + command);
        Bukkit.getPluginManager().callEvent(event);
        
        if (!event.isCancelled()) {
            player.performCommand(command);
        }
    }

    public static void setBlockFast(final Location location, final Material material, final boolean applyPhysics) {
        setBlockFast(location.getWorld(), location.getBlockX(), location.getBlockY(), location.getBlockZ(), material.getId(), (byte) 0, applyPhysics);
    }
    public static void setBlockFast(final org.bukkit.World world, final int x, final int y, final int z, final int blockId, final byte data, final boolean applyPhysics) {
        try {
            final net.minecraft.server.v1_8_R3.World w = ((CraftWorld) world).getHandle();
            final net.minecraft.server.v1_8_R3.Chunk chunk = w.getChunkAt(x >> 4, z >> 4);
            final BlockPosition bp = new BlockPosition(x, y, z);
            final int combined = blockId + (data << 12);
            final IBlockData ibd = net.minecraft.server.v1_8_R3.Block.getByCombinedId(combined);
            w.setTypeAndData(bp, ibd, applyPhysics ? 3 : 2);
            chunk.a(bp, ibd);
        } catch (final Throwable throwable) {
            throwable.printStackTrace();
        }
    }

    public static Location getBedBlockNearBy(Location location) {
        Location bedLocation2 = location.clone();

        if (location.clone().add(1,0,0).getBlock().getType() == Material.BED_BLOCK) {
            return location.clone().add(1,0,0);
        }if (location.clone().add(-1,0,0).getBlock().getType() == Material.BED_BLOCK) {
            return location.clone().add(-1,0,0);
        }if (location.clone().add(0,0,1).getBlock().getType() == Material.BED_BLOCK) {
            return location.clone().add(0,0,1);
        }if (location.clone().add(0,0,-1).getBlock().getType() == Material.BED_BLOCK) {
            return location.clone().add(0,0,-1);
        }
        Common.log("Cannot get another side of bed block!");
        return bedLocation2;
    }

    public static int getNewRating(int rating, int opponentRating, double score) {
        double kFactor = Config.EXPERIMENT_K_FACTOR.toDouble();
        double expectedScore = 1.0 / (1.0 + Math.pow(10.0, ((double) (opponentRating - rating) / 400.0)));
        return rating + (int) (kFactor * (score - expectedScore));
    }

    public static String getProgressBar(int current, int max, int totalBars, String symbol, String completedColor, String notCompletedColor) {
        float percent = (float) current / max;
        int progressBars = (int) ((int) totalBars * percent);
        int leftOver = (totalBars - progressBars);
        StringBuilder sb = new StringBuilder();
        sb.append(CC.translate(completedColor));
        for (int i = 0; i < progressBars; i++) {
            sb.append(symbol);
        }
        sb.append(CC.translate(notCompletedColor));
        for (int i = 0; i < leftOver; i++) {
            sb.append(symbol);
        }
        return sb.toString();
    }

    public static String renderPointsAsBar(Team team, int maxPoints) {
        return Util.getProgressBar(team.getPoints(), maxPoints, maxPoints, "‚¨§", team.getTeamColor().getColor(), CC.GRAY);
    }

    public static String renderBuildLimit(int current, int max) {
        int height = max - current;
        if (height <= 0) {
            return CC.GRAY + " ‚îÉ " + CC.RED + Language.REACHED_BUILD_LIMIT.toString();
        } else if (height <= 5) {
            return CC.GRAY + " ‚îÉ " + CC.GOLD + height;
        } else if (height <= 10) {
            return CC.GRAY + " ‚îÉ " + CC.YELLOW + height;
        } else if (height <= 15) {
            return CC.GRAY + " ‚îÉ " + CC.GREEN + height;
        }
        return "";
    }

    public static Collection<Class<?>> getClassesInPackage(Plugin plugin, String packageName) {
        Collection<Class<?>> classes = new ArrayList<>();

        CodeSource codeSource = plugin.getClass().getProtectionDomain().getCodeSource();
        URL resource = codeSource.getLocation();
        String relPath = packageName.replace('.', '/');
        String resPath = resource.getPath().replace("%20", " ");
        String jarPath = resPath.replaceFirst("[.]jar[!].*", ".jar").replaceFirst("file:", "");
        JarFile jarFile;

        try {
            jarFile = new JarFile(jarPath);
        } catch (IOException e) {
            throw (new RuntimeException("Unexpected IOException reading JAR File '" + jarPath + "'", e));
        }

        Enumeration<JarEntry> entries = jarFile.entries();

        while (entries.hasMoreElements()) {
            JarEntry entry = entries.nextElement();
            String entryName = entry.getName();
            String className = null;

            if (entryName.endsWith(".class") && entryName.startsWith(relPath) && entryName.length() > (relPath.length() + "/".length())) {
                className = entryName.replace('/', '.').replace('\\', '.').replace(".class", "");
            }

            if (className != null) {
                Class<?> clazz = null;

                try {
                    clazz = Class.forName(className);
                } catch (ClassNotFoundException e) {
                    e.printStackTrace();
                }

                if (clazz != null) {
                    classes.add(clazz);
                }
            }
        }

        try {
            jarFile.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

        return (ImmutableSet.copyOf(classes));
    }

    //Credit: https://github.com/lulu2002/DatouNms/blob/master/src/main/java/me/lulu/datounms/v1_8_R3/CraftCommonNMS.java
    public static void playDeathAnimation(Player player, List<Player> viewers) {
        MinecraftServer nmsServer = ((CraftServer) Bukkit.getServer()).getServer();
        WorldServer nmsWorld = (( CraftWorld ) player.getWorld()).getHandle();
        CraftPlayer cp = (CraftPlayer) player;
        EntityPlayer npc = new EntityPlayer(nmsServer, nmsWorld, cp.getProfile(), new PlayerInteractManager(nmsWorld));
        npc.setLocation(player.getLocation().getX(), player.getLocation().getY(), player.getLocation().getZ(), player.getLocation().getYaw(), player.getLocation().getPitch());
        PacketPlayOutPlayerInfo removeRealPlayer = new PacketPlayOutPlayerInfo(PacketPlayOutPlayerInfo.EnumPlayerInfoAction.REMOVE_PLAYER, cp.getHandle());
        PacketPlayOutPlayerInfo addPlayer = new PacketPlayOutPlayerInfo(PacketPlayOutPlayerInfo.EnumPlayerInfoAction.ADD_PLAYER, npc);
        PacketPlayOutPlayerInfo removePlayer = new PacketPlayOutPlayerInfo(PacketPlayOutPlayerInfo.EnumPlayerInfoAction.REMOVE_PLAYER, npc);
        PacketPlayOutPlayerInfo addRealPlayer = new PacketPlayOutPlayerInfo(PacketPlayOutPlayerInfo.EnumPlayerInfoAction.ADD_PLAYER, cp.getHandle());
        PacketPlayOutNamedEntitySpawn entitySpawn = new PacketPlayOutNamedEntitySpawn(npc);
        PacketPlayOutEntityStatus entityDeath = new PacketPlayOutEntityStatus(npc, ( byte ) 3);
        
        for (Player o : viewers) {
            PlayerConnection connection = ((CraftPlayer) o).getHandle().playerConnection;
            connection.sendPacket(removeRealPlayer);
            connection.sendPacket(addPlayer);
            connection.sendPacket(entitySpawn);
            connection.sendPacket(entityDeath);
        }

        Tasks.runAsyncLater(()-> {
            for (Player o : viewers) {
                if (o.isOnline()) {
                    PlayerConnection connection = ((CraftPlayer) o).getHandle().playerConnection;

                    connection.sendPacket(removePlayer);
                    if (cp.isOnline()) {
                        connection.sendPacket(addRealPlayer);
                    }
                }
            }
        }, 2L);
    }

    //Need a custom dropItemNaturally function, so I can modify the f value of EntityItem
    //World#dropItemNaturally doesn't work in this case because dropItemNaturally will spawn the item before returning the item itself
    public static Item dropItemNaturally(Location loc, ItemStack item, Player player) {
        net.minecraft.server.v1_8_R3.World world = ((CraftWorld) loc.getWorld()).getHandle();
        double xs = world.random.nextFloat() * 0.7F - 0.35D;
        double ys = world.random.nextFloat() * 0.7F - 0.35D;
        double zs = world.random.nextFloat() * 0.7F - 0.35D;
        loc = loc.clone();
        randomLocationWithinBlock(loc, xs, ys, zs);
        EntityItem entity = new EntityItem(world, loc.getX(), loc.getY(), loc.getZ(), CraftItemStack.asNMSCopy(item));
        entity.pickupDelay = 10;
        Eden.INSTANCE.getEntityHider().setPlayerWhoDropped(entity, player.getName());
        Tasks.run(() -> world.addEntity(entity));

        return new CraftItem(world.getServer(), entity);
    }

    private static void randomLocationWithinBlock(Location loc, double xs, double ys, double zs) {
        double prevX = loc.getX();
        double prevY = loc.getY();
        double prevZ = loc.getZ();
        loc.add(xs, ys, zs);
        if (loc.getX() < Math.floor(prevX)) {
            loc.setX(Math.floor(prevX));
        }
        if (loc.getX() >= Math.ceil(prevX)) {
            loc.setX(Math.ceil(prevX - 0.01));
        }
        if (loc.getY() < Math.floor(prevY)) {
            loc.setY(Math.floor(prevY));
        }
        if (loc.getY() >= Math.ceil(prevY)) {
            loc.setY(Math.ceil(prevY - 0.01));
        }
        if (loc.getZ() < Math.floor(prevZ)) {
            loc.setZ(Math.floor(prevZ));
        }
        if (loc.getZ() >= Math.ceil(prevZ)) {
            loc.setZ(Math.ceil(prevZ - 0.01));
        }
    }

    public static void setSource(final TNTPrimed tntPrimed, final Player player) {
        EntityLiving handle = ((CraftLivingEntity)player).getHandle();
        EntityTNTPrimed handle2 = ((CraftTNTPrimed)tntPrimed).getHandle();
        try {
            Field declaredField = EntityTNTPrimed.class.getDeclaredField("source");
            declaredField.setAccessible(true);
            declaredField.set(handle2, handle);
        }
        catch (Exception ex) {
            ex.printStackTrace();
        }
    }

    public static void pushAway(Player player, Location l, double hf, double rf) {
        final Location loc = player.getLocation();

        double hf1 = Math.max(-4, Math.min(4, hf));
        double rf1 = Math.max(-4, Math.min(4, -1 * rf));

        player.setVelocity(l.toVector().subtract(loc.toVector()).normalize().multiply(rf1).setY(hf1));
    }

    public static List<Block> getBlocksAroundCenter(Location loc, int radius) {
        List<Block> blocks = new ArrayList<>();

        for (int x = (loc.getBlockX() - radius); x <= (loc.getBlockX() + radius); x++) {
            for (int y = (loc.getBlockY() - radius); y <= (loc.getBlockY() + radius); y++) {
                for (int z = (loc.getBlockZ() - radius); z <= (loc.getBlockZ() + radius); z++) {
                    Location l = new Location(loc.getWorld(), x, y, z);
                    if (l.distance(loc) <= radius) {
                        blocks.add(l.getBlock());
                    }
                }
            }
        }

        return blocks;
    }

    public static void teleport(Player player, Location location) {

        player.teleport(location);
    }

    public static void sendArrowHitMessage(EntityDamageByEntityEvent event) {
        Player entity = (Player) event.getEntity();
        Player damager = event.getDamager() instanceof Arrow ? (Player) ((Arrow) event.getDamager()).getShooter() : (Player) event.getDamager();

        double damage = event.getFinalDamage();
        double absorptionHealth = ((CraftPlayer) entity).getHandle().getAbsorptionHearts();
        final double absorptionDamage = Math.ceil(absorptionHealth - damage) / 2.0;
        if (absorptionDamage > 0.0D) {
            absorptionHealth = absorptionDamage;
            damage = 0.0;
        } else {
            damage -= absorptionHealth;
            absorptionHealth = 0.0;
        }
        final double health = Math.ceil(entity.getHealth() - damage) / 2.0D;
        if (health > 0) {
            Language.MATCH_ARROW_DAMAGE.sendMessage(damager, entity.getName(), Eden.DECIMAL.format(health), Eden.DECIMAL.format(absorptionHealth));
        }
    }

    public static void throwEnderPearl(PlayerInteractEvent event) {
        Player player = event.getPlayer();
        ItemStack itemStack = player.getItemInHand();

        event.setCancelled(true);
        player.launchProjectile(EnderPearl.class);
        itemStack.setAmount(itemStack.getAmount() - 1);
    }

    public static int getArrowSlot(Match match, Player player) {
        int slot = -1;
        //No KitLoadout is received. This will be null when a player didn't select a kit
        //Should not happen anymore because kitLoadout is now automatically applied, but just in-case
        if (match.getTeamPlayer(player).getKitLoadout() != null) {
            for (int i = 0; i < 36; i++) {
                if (match.getTeamPlayer(player).getKitLoadout().getContents()[i] != null && match.getTeamPlayer(player).getKitLoadout().getContents()[i].getType() == Material.ARROW) slot = i;
            }
        }
        return slot;
    }

    public static void giveBackArrow(Match match, Player player) {
        int slot = getArrowSlot(match, player);
        if (slot == -1 || player.getInventory().getItem(slot) != null) {
            player.getInventory().addItem(new ItemStack(Material.ARROW));
        } else {
            player.getInventory().setItem(slot, new ItemStack(Material.ARROW));
        }
        player.updateInventory();
    }

    public static boolean isNPC(Player player) {
        return isNPC(player.getUniqueId());
    }

    public static boolean isNPC(UUID uuid) {
        if (Eden.INSTANCE.getHookManager().getCitizensHook() == null) {
            return false;
        }
        return Eden.INSTANCE.getHookManager().getCitizensHook().isNPC(uuid);
    }

}


Filename: .\main\java\rip\diamond\practice\util\VisibilityController.java
package rip.diamond.practice.util;

import lombok.experimental.UtilityClass;
import org.bukkit.Bukkit;
import org.bukkit.entity.Player;
import rip.diamond.practice.Eden;
import rip.diamond.practice.config.Config;
import rip.diamond.practice.match.Match;
import rip.diamond.practice.party.Party;
import rip.diamond.practice.profile.PlayerProfile;
import rip.diamond.practice.profile.PlayerState;
import rip.diamond.practice.profile.ProfileSettings;

//Credit: https://github.com/DevDrizzy/PotPvPReprised/blob/master/src/main/java/net/frozenorb/potpvp/util/VisibilityUtils.java
//I am too lazy to use all my braincells to code a visibility controller

@UtilityClass
public class VisibilityController {

    public void updateVisibility(Player player) {
        Tasks.run(() -> {
            for (Player target : Util.getOnlinePlayers()) {
                if (shouldSeePlayer(target, player)) {
                    target.showPlayer(player);
                } else {
                    target.hidePlayer(player);
                }

                if (shouldSeePlayer(player, target)) {
                    player.showPlayer(target);
                } else {
                    player.hidePlayer(target);
                }
            }
        });
    }

    private boolean shouldSeePlayer(Player viewer, Player target) {
        if (viewer == null || target == null) {
            return false;
        }

        if (viewer == target) {
            return true;
        }

        PlayerProfile pViewer = PlayerProfile.get(viewer);
        PlayerProfile pTarget = PlayerProfile.get(target);

        if (pViewer == null || pTarget == null || pViewer.getPlayerState() == PlayerState.LOADING || pTarget.getPlayerState() == PlayerState.LOADING) {
            return false;
        }


        Match targetMatch = pTarget.getMatch();

        if (targetMatch == null) {
            //We're not in a match, so we hide other players based on their party/match
            Party targetParty = Party.getByPlayer(target);

            boolean configSettings = Config.LOBBY_DISPLAY_PLAYERS.toBoolean();
            boolean viewerPlayingMatch = pViewer.getPlayerState() == PlayerState.IN_MATCH && pViewer.getMatch() != null;
            boolean viewerSameParty = targetParty != null && targetParty.getMember(viewer.getUniqueId()) != null;

            return configSettings || viewerPlayingMatch || viewerSameParty;
        } else {
            //We're in a match, so we only hide other spectators (if our settings say so)
            boolean targetIsSpectator = targetMatch.getSpectators().contains(target) || !targetMatch.getTeamPlayer(target).isAlive() || targetMatch.getTeamPlayer(target).isRespawning();
            boolean viewerSpectateSetting = pViewer.getSettings().get(ProfileSettings.SPECTATOR_VISIBILITY).isEnabled();
            boolean viewerIsSpectator = pViewer.getPlayerState() == PlayerState.IN_SPECTATING && pViewer.getMatch() != null;
            //Also check if the match is the same or not
            boolean viewerMatchIsSame = targetMatch == pViewer.getMatch();

            return (!targetIsSpectator || (viewerSpectateSetting && viewerIsSpectator)) && viewerMatchIsSame;
        }
    }

}


Filename: .\main\java\rip\diamond\practice\util\WordUtil.java
package rip.diamond.practice.util;

import org.apache.commons.lang.StringUtils;

import java.util.ArrayList;
import java.util.List;

public class WordUtil {
    
    public static String toCapital(String word) {
        return word.substring(0, 1).toUpperCase() + word.substring(1).toLowerCase();
    }

    public static String toCapitalEachWord(String word) {
        List<String> words = new ArrayList<>();
        for (String s : word.split(" ")) {
            words.add(toCapital(s));
        }
        return StringUtils.join(words, " ");
    }

    public static String formatWords(String word) {
        return toCapitalEachWord(word.replace("_", " "));
    }
    
}


Filename: .\main\java\rip\diamond\practice\util\command\Command.java
package rip.diamond.practice.util.command;

import lombok.Getter;
import org.bukkit.Bukkit;
import org.bukkit.ChatColor;
import org.bukkit.command.CommandSender;
import org.bukkit.command.ConsoleCommandSender;
import org.bukkit.command.defaults.BukkitCommand;
import org.bukkit.entity.HumanEntity;
import rip.diamond.practice.Eden;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.util.Tasks;
import rip.diamond.practice.util.command.argument.CommandArguments;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

@Getter
public abstract class Command {

    public Eden plugin;
    private CommandExecutor executor;
    private CommandArgs assigned;

    public Command() {
        this.plugin = Eden.INSTANCE;
        this.register();
    }

    public void register() {
        this.assigned = Arrays.stream(this.getClass().getMethods()).filter(method -> method.getAnnotation(CommandArgs.class) != null).map(method -> method.getAnnotation(CommandArgs.class)).findFirst().orElse(null);

        if (assigned != null) {
            this.executor = new CommandExecutor(assigned.name(), assigned);
            this.plugin.getCommandManager().registerCommand(this, executor);
        }
    }

    public abstract void execute(CommandArguments command);

    public List<String> onTabComplete(CommandArguments command) {
        return new ArrayList<>();
    }

    //This is default tab complete which should return a list of online players
    public List<String> getDefaultTabComplete(CommandArguments command) {
        List<String> completors = new ArrayList<>();

        List<String> values = Bukkit.getOnlinePlayers().stream().map(HumanEntity::getName).collect(Collectors.toList());

        String[] args = command.getArgs();

        if (args.length == 0) return new ArrayList<>();

        if (!args[args.length - 1].equalsIgnoreCase("")) {
            values.forEach(value -> {
                if (value.toLowerCase().startsWith(args[args.length - 1].toLowerCase())) {
                    completors.add(value);
                }
            });
        } else {
            completors.addAll(values);
        }
        return completors;
    }

    public class CommandExecutor extends BukkitCommand {

        private final boolean inGameOnly;
        private final boolean async;
        private CommandArguments executeArguments;

        public CommandExecutor(String name, CommandArgs assigned) {
            super(name);
            this.setAliases(Arrays.asList(assigned.aliases()));
            this.setPermission(assigned.permission());
            this.inGameOnly = assigned.inGameOnly();
            this.async = assigned.async();
        }

        @Override
        public boolean execute(CommandSender sender, String label, String[] args) {
            if (this.inGameOnly && sender instanceof ConsoleCommandSender) {
                sender.sendMessage(ChatColor.RED + "This is for player use only!");
                return false;
            }
            if (this.getPermission().length() > 0 && !sender.hasPermission(this.getPermission())) {
                sender.sendMessage(Language.NO_PERMISSION.toString());
                return false;
            }

            this.executeArguments = new CommandArguments(sender, label, args);

            if (this.async) {
                Tasks.runAsync(() -> Command.this.execute(executeArguments));
            } else {
                Command.this.execute(executeArguments);
            }
            return false;
        }

        @Override
        public List<String> tabComplete(CommandSender sender, String alias, String[] args) throws IllegalArgumentException {
            List<String> completors = onTabComplete(new CommandArguments(sender, null, args));

            if (completors.isEmpty()) {
                completors.addAll(getDefaultTabComplete(new CommandArguments(sender, null, args)));
            }
            return completors;
        }
    }
}


Filename: .\main\java\rip\diamond\practice\util\command\CommandArgs.java
package rip.diamond.practice.util.command;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface CommandArgs {

    String name();

    String permission() default "";

    String[] aliases() default {};

    boolean inGameOnly() default true;

    boolean async() default false;
}


Filename: .\main\java\rip\diamond\practice\util\command\CommandManager.java
package rip.diamond.practice.util.command;

import lombok.Getter;
import org.bukkit.command.CommandMap;
import org.bukkit.plugin.PluginManager;
import org.bukkit.plugin.SimplePluginManager;
import rip.diamond.practice.Eden;
import rip.diamond.practice.util.command.Command;

import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.List;

@Getter
public class CommandManager {

    private Eden plugin;

    private List<Command> loadedCommands = new ArrayList<>();

    public CommandManager(Eden plugin) {
        this.plugin = plugin;
    }

    private CommandMap getCommandMap() {
        PluginManager manager = plugin.getServer().getPluginManager();
        try {
            Field field = SimplePluginManager.class.getDeclaredField("commandMap");
            field.setAccessible(true);
            return (CommandMap) field.get(manager);
        } catch (IllegalArgumentException | SecurityException | NoSuchFieldException | IllegalAccessException e) {
            e.printStackTrace();
        }
        return null;
    }

    public void registerCommand(Command base, Command.CommandExecutor command) {
        if (this.getCommandMap() != null) {
            this.getCommandMap().register(this.plugin.getDescription().getName().toLowerCase(), command);
        }
        this.loadedCommands.add(base);
    }

    public void registerCommand(Command base, Command.CommandExecutor command, List<String> aliases) {
        if (base.getAssigned() == null) return;

        command.getAliases().addAll(aliases);

        if (this.getCommandMap() != null) {
            this.getCommandMap().register(this.plugin.getDescription().getName().toLowerCase(), command);
        }

        this.loadedCommands.removeIf(loaded -> loaded.getAssigned().name().equalsIgnoreCase(base.getAssigned().name()));
        this.loadedCommands.add(base);
    }
}


Filename: .\main\java\rip\diamond\practice\util\command\argument\CommandArguments.java
package rip.diamond.practice.util.command.argument;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import org.bukkit.command.CommandSender;
import org.bukkit.entity.Player;

@RequiredArgsConstructor
@Getter
public class CommandArguments {

    private final CommandSender sender;
    private final String label;
    private final String[] args;

    public int length() {
        return this.args.length;
    }

    public Player getPlayer() {
        if (!(sender instanceof Player)) return null;
        return (Player) sender;
    }
}


Filename: .\main\java\rip\diamond\practice\util\cuboid\Cuboid.java
package rip.diamond.practice.util.cuboid;

import com.google.common.base.Preconditions;
import org.bukkit.*;
import org.bukkit.block.Block;
import org.bukkit.configuration.serialization.ConfigurationSerializable;
import org.bukkit.entity.Player;
import org.bukkit.util.Vector;

import java.util.*;

public class Cuboid implements Iterable<Block>, Cloneable, ConfigurationSerializable {

    private String worldName;
    private int x1;
    private int y1;
    private int z1;
    private int x2;
    private int y2;
    private int z2;

    public Cuboid(World world, int x1, int y1, int z1, int x2, int y2, int z2) {
        this(((World) Preconditions.checkNotNull((Object) world)).getName(), x1, y1, z1, x2, y2, z2);
    }

    private Cuboid(String worldName, int x1, int y1, int z1, int x2, int y2, int z2) {
        this.worldName = worldName;
        this.x1 = Math.min(x1, x2);
        this.y1 = Math.min(y1, y2);
        this.z1 = Math.min(z1, z2);
        this.x2 = Math.max(x1, x2);
        this.y2 = Math.max(y1, y2);
        this.z2 = Math.max(z1, z2);
    }

    public Cuboid(Location first, Location second) {
        this.worldName = first.getWorld().getName();
        this.x1 = Math.min(first.getBlockX(), second.getBlockX());
        this.y1 = Math.min(first.getBlockY(), second.getBlockY());
        this.z1 = Math.min(first.getBlockZ(), second.getBlockZ());
        this.x2 = Math.max(first.getBlockX(), second.getBlockX());
        this.y2 = Math.max(first.getBlockY(), second.getBlockY());
        this.z2 = Math.max(first.getBlockZ(), second.getBlockZ());
    }

    public Map<String, Object> serialize() {
        LinkedHashMap<String, Object> map = new LinkedHashMap<>();
        map.put("worldName", this.worldName);
        map.put("x1", this.x1);
        map.put("y1", this.y1);
        map.put("z1", this.z1);
        map.put("x2", this.x2);
        map.put("y2", this.y2);
        map.put("z2", this.z2);

        return map;
    }

    public boolean hasBothPositionsSet() {
        return this.getMinimumPoint() != null && this.getMaximumPoint() != null;
    }

    public int getMinimumX() {
        return Math.min(this.x1, this.x2);
    }

    public int getMinimumZ() {
        return Math.min(this.z1, this.z2);
    }

    public int getMaximumX() {
        return Math.max(this.x1, this.x2);
    }

    public int getMaximumZ() {
        return Math.max(this.z1, this.z2);
    }

    public List<Vector> edges() {
        return this.edges(-1, -1, -1, -1);
    }

    public List<Vector> edges(int fixedMinX, int fixedMaxX, int fixedMinZ, int fixedMaxZ) {
        Vector v1 = this.getMinimumPoint().toVector();
        Vector v2 = this.getMaximumPoint().toVector();
        int minX = v1.getBlockX();
        int maxX = v2.getBlockX();
        int minZ = v1.getBlockZ();
        int maxZ = v2.getBlockZ();
        int capacity = (maxX - minX) * 4 + (maxZ - minZ) * 4;

        ArrayList<Vector> result = new ArrayList<>(capacity += 4);
        if (capacity <= 0) {
            return result;
        }

        int minY = v1.getBlockY();
        int maxY = v1.getBlockY();
        for (int x = minX; x <= maxX; ++x) {
            result.add(new Vector(x, minY, minZ));
            result.add(new Vector(x, minY, maxZ));
            result.add(new Vector(x, maxY, minZ));
            result.add(new Vector(x, maxY, maxZ));
        }
        for (int z = minZ; z <= maxZ; ++z) {
            result.add(new Vector(minX, minY, z));
            result.add(new Vector(minX, maxY, z));
            result.add(new Vector(maxX, minY, z));
            result.add(new Vector(maxX, maxY, z));
        }

        return result;
    }

    public Set<Player> getPlayers() {
        HashSet<Player> players = new HashSet<>();
        for (Player player : Bukkit.getOnlinePlayers()) {
            if (!this.contains(player)) continue;
            players.add(player);
        }

        return players;
    }

    public Location getLowerNE() {
        return new Location(this.getWorld(), this.x1, this.y1, this.z1);
    }

    public Location getUpperSW() {
        return new Location(this.getWorld(), this.x2, this.y2, this.z2);
    }

    public Location getCenter() {
        int x1 = this.x2 + 1;
        int y1 = this.y2 + 1;
        int z1 = this.z2 + 1;

        return new Location(this.getWorld(), (double) this.x1 + (double) (x1 - this.x1) / 2.0, (double) this.y1 + (double) (y1 - this.y1) / 2.0, (double) this.z1 + (double) (z1 - this.z1) / 2.0);
    }

    public World getWorld() {
        return Bukkit.getWorld(this.worldName);
    }

    public int getSizeX() {
        return this.x2 - this.x1 + 1;
    }

    public int getSizeY() {
        return this.y2 - this.y1 + 1;
    }

    public int getSizeZ() {
        return this.z2 - this.z1 + 1;
    }

    public Location[] getCornerLocations() {
        Location[] result = new Location[8];
        Block[] cornerBlocks = this.getCornerBlocks();
        for (int i = 0; i < cornerBlocks.length; ++i) {
            result[i] = cornerBlocks[i].getLocation();
        }

        return result;
    }

    public Block[] getCornerBlocks() {
        Block[] result = new Block[8];
        World world = this.getWorld();
        result[0] = world.getBlockAt(this.x1, this.y1, this.z1);
        result[1] = world.getBlockAt(this.x1, this.y1, this.z2);
        result[2] = world.getBlockAt(this.x1, this.y2, this.z1);
        result[3] = world.getBlockAt(this.x1, this.y2, this.z2);
        result[4] = world.getBlockAt(this.x2, this.y1, this.z1);
        result[5] = world.getBlockAt(this.x2, this.y1, this.z2);
        result[6] = world.getBlockAt(this.x2, this.y2, this.z1);
        result[7] = world.getBlockAt(this.x2, this.y2, this.z2);

        return result;
    }

    public Cuboid shift(CuboidDirection direction, int amount) throws IllegalArgumentException {
        return this.expand(direction, amount).expand(direction.opposite(), -amount);
    }

    public Cuboid inset(CuboidDirection direction, int amount) throws IllegalArgumentException {
        return this.outset(direction, -amount);
    }

    public Cuboid expand(CuboidDirection direction, int amount) throws IllegalArgumentException {
        switch (direction) {
            case NORTH: {
                return new Cuboid(this.worldName, this.x1 - amount, this.y1, this.z1, this.x2, this.y2, this.z2);
            }
            case SOUTH: {
                return new Cuboid(this.worldName, this.x1, this.y1, this.z1, this.x2 + amount, this.y2, this.z2);
            }
            case EAST: {
                return new Cuboid(this.worldName, this.x1, this.y1, this.z1 - amount, this.x2, this.y2, this.z2);
            }
            case WEST: {
                return new Cuboid(this.worldName, this.x1, this.y1, this.z1, this.x2, this.y2, this.z2 + amount);
            }
            case DOWN: {
                return new Cuboid(this.worldName, this.x1, this.y1 - amount, this.z1, this.x2, this.y2, this.z2);
            }
            case UP: {
                return new Cuboid(this.worldName, this.x1, this.y1, this.z1, this.x2, this.y2 + amount, this.z2);
            }
        }
        throw new IllegalArgumentException("Invalid direction " + direction);
    }

    public Cuboid outset(CuboidDirection direction, int amount) throws IllegalArgumentException {
        switch (direction) {
            case HORIZONTAL: {
                return this.expand(CuboidDirection.NORTH, amount).expand(CuboidDirection.SOUTH, amount).expand(CuboidDirection.EAST, amount).expand(CuboidDirection.WEST, amount);
            }
            case VERTICAL: {
                return this.expand(CuboidDirection.DOWN, amount).expand(CuboidDirection.UP, amount);
            }
            case BOTH: {
                return this.outset(CuboidDirection.HORIZONTAL, amount).outset(CuboidDirection.VERTICAL, amount);
            }
        }
        throw new IllegalArgumentException("Invalid direction " + direction);
    }

    public boolean contains(Cuboid cuboid) {
        return this.contains(cuboid.getMinimumPoint()) || this.contains(cuboid.getMaximumPoint());
    }

    public boolean contains(Player player) {
        return this.contains(player.getLocation());
    }

    public boolean contains(World world, int x, int z) {
        return (world == null || this.getWorld().equals(world)) && x >= this.x1 && x <= this.x2 && z >= this.z1 && z <= this.z2;
    }

    public boolean contains(int x, int y, int z) {
        return x >= this.x1 && x <= this.x2 && y >= this.y1 && y <= this.y2 && z >= this.z1 && z <= this.z2;
    }

    public boolean containsWithoutY(Player player) {
        return this.containsWithoutY(player.getLocation());
    }

    public boolean containsWithoutY(Location location) {
        return this.containsWithoutY(location.getX(), location.getZ());
    }

    public boolean containsWithoutY(double x, double z) {
        return x >= this.x1 && x <= this.x2 && z >= this.z1 && z <= this.z2;
    }

    public boolean containsWithoutY(double x, double z, int offset) {
        Cuboid cuboid = outset(CuboidDirection.HORIZONTAL, offset);
        return cuboid.containsWithoutY(x,z);
    }

    public boolean contains(Block block) {
        return this.contains(block.getLocation());
    }

    public boolean contains(Location location) {
        if (location == null || this.worldName == null) {
            return false;
        }
        World world = location.getWorld();

        return world != null && this.worldName.equals(location.getWorld().getName()) && this.contains(location.getBlockX(), location.getBlockY(), location.getBlockZ());
    }

    public int getVolume() {
        return this.getSizeX() * this.getSizeY() * this.getSizeZ();
    }

    public int getArea() {
        Location min = this.getMinimumPoint();
        Location max = this.getMaximumPoint();

        return (max.getBlockX() - min.getBlockX() + 1) * (max.getBlockZ() - min.getBlockZ() + 1);
    }

    public byte getAverageLightLevel() {
        long total = 0L;
        int count = 0;
        for (Block block : this) {
            if (!block.isEmpty()) continue;
            total += block.getLightLevel();
            ++count;
        }

        return count > 0 ? (byte) (total / (long) count) : (byte) 0;
    }

    public Location getMinimumPoint() {
        return new Location(this.getWorld(), Math.min(this.x1, this.x2), Math.min(this.y1, this.y2), Math.min(this.z1, this.z2));
    }

    public Location getMaximumPoint() {
        return new Location(this.getWorld(), Math.max(this.x1, this.x2), Math.max(this.y1, this.y2), Math.max(this.z1, this.z2));
    }

    public int getWidth() {
        return this.getMaximumPoint().getBlockX() - this.getMinimumPoint().getBlockX();
    }

    public int getHeight() {
        return this.getMaximumPoint().getBlockY() - this.getMinimumPoint().getBlockY();
    }

    public int getLength() {
        return this.getMaximumPoint().getBlockZ() - this.getMinimumPoint().getBlockZ();
    }

    public Cuboid contract() {
        return this.contract(CuboidDirection.DOWN).contract(CuboidDirection.SOUTH).contract(CuboidDirection.EAST).contract(CuboidDirection.UP).contract(CuboidDirection.NORTH).contract(CuboidDirection.WEST);
    }

    public Cuboid contract(CuboidDirection direction) {
        Cuboid face = this.getFace(direction.opposite());
        switch (direction) {
            case DOWN: {
                while (face.containsOnly(Material.AIR) && face.y1 > this.y1) {
                    face = face.shift(CuboidDirection.DOWN, 1);
                }
                return new Cuboid(this.worldName, this.x1, this.y1, this.z1, this.x2, face.y2, this.z2);
            }
            case UP: {
                while (face.containsOnly(Material.AIR) && face.y2 < this.y2) {
                    face = face.shift(CuboidDirection.UP, 1);
                }
                return new Cuboid(this.worldName, this.x1, face.y1, this.z1, this.x2, this.y2, this.z2);
            }
            case NORTH: {
                while (face.containsOnly(Material.AIR) && face.x1 > this.x1) {
                    face = face.shift(CuboidDirection.NORTH, 1);
                }
                return new Cuboid(this.worldName, this.x1, this.y1, this.z1, face.x2, this.y2, this.z2);
            }
            case SOUTH: {
                while (face.containsOnly(Material.AIR) && face.x2 < this.x2) {
                    face = face.shift(CuboidDirection.SOUTH, 1);
                }
                return new Cuboid(this.worldName, face.x1, this.y1, this.z1, this.x2, this.y2, this.z2);
            }
            case EAST: {
                while (face.containsOnly(Material.AIR) && face.z1 > this.z1) {
                    face = face.shift(CuboidDirection.EAST, 1);
                }
                return new Cuboid(this.worldName, this.x1, this.y1, this.z1, this.x2, this.y2, face.z2);
            }
            case WEST: {
                while (face.containsOnly(Material.AIR) && face.z2 < this.z2) {
                    face = face.shift(CuboidDirection.WEST, 1);
                }
                return new Cuboid(this.worldName, this.x1, this.y1, face.z1, this.x2, this.y2, this.z2);
            }
        }
        throw new IllegalArgumentException("Invalid direction " + direction);
    }

    public Cuboid getFace(CuboidDirection direction) {
        switch (direction) {
            case DOWN: {
                return new Cuboid(this.worldName, this.x1, this.y1, this.z1, this.x2, this.y1, this.z2);
            }
            case UP: {
                return new Cuboid(this.worldName, this.x1, this.y2, this.z1, this.x2, this.y2, this.z2);
            }
            case NORTH: {
                return new Cuboid(this.worldName, this.x1, this.y1, this.z1, this.x1, this.y2, this.z2);
            }
            case SOUTH: {
                return new Cuboid(this.worldName, this.x2, this.y1, this.z1, this.x2, this.y2, this.z2);
            }
            case EAST: {
                return new Cuboid(this.worldName, this.x1, this.y1, this.z1, this.x2, this.y2, this.z1);
            }
            case WEST: {
                return new Cuboid(this.worldName, this.x1, this.y1, this.z2, this.x2, this.y2, this.z2);
            }
        }
        throw new IllegalArgumentException("Invalid direction " + direction);
    }

    public boolean containsOnly(Material material) {
        for (Block block : this) {
            if (block.getType() == material) continue;
            return false;
        }

        return true;
    }

    public Cuboid getBoundingCuboid(Cuboid other) {
        if (other == null) {
            return this;
        }
        int xMin = Math.min(this.x1, other.x1);
        int yMin = Math.min(this.y1, other.y1);
        int zMin = Math.min(this.z1, other.z1);
        int xMax = Math.max(this.x2, other.x2);
        int yMax = Math.max(this.y2, other.y2);
        int zMax = Math.max(this.z2, other.z2);

        return new Cuboid(this.worldName, xMin, yMin, zMin, xMax, yMax, zMax);
    }

    public Block getRelativeBlock(int x, int y, int z) {
        return this.getWorld().getBlockAt(this.x1 + x, this.y1 + y, this.z1 + z);
    }

    public Block getRelativeBlock(World world, int x, int y, int z) {
        return world.getBlockAt(this.x1 + x, this.y1 + y, this.z1 + z);
    }

    public List<Chunk> getChunks() {
        World world = this.getWorld();
        int x1 = this.x1 & -16;
        int x2 = this.x2 & -16;
        int z1 = this.z1 & -16;
        int z2 = this.z2 & -16;

        ArrayList<Chunk> result = new ArrayList<>(x2 - x1 + 16 + (z2 - z1) * 16);
        for (int x3 = x1; x3 <= x2; x3 += 16) {
            for (int z3 = z1; z3 <= z2; z3 += 16) {
                result.add(world.getChunkAt(x3 >> 4, z3 >> 4));
            }
        }

        return result;
    }

    @Override
    public Iterator<Block> iterator() {
        return new CuboidBlockIterator(this.getWorld(), this.x1, this.y1, this.z1, this.x2, this.y2, this.z2);
    }

    public Iterator<Location> locationIterator() {
        return new CuboidLocationIterator(this.getWorld(), this.x1, this.y1, this.z1, this.x2, this.y2, this.z2);
    }

    public Cuboid clone() {
        try {
            return (Cuboid) super.clone();
        } catch (CloneNotSupportedException ex) {
            throw new RuntimeException("This could never happen", ex);
        }
    }

    public String toString() {
        return "Cuboid: " + this.worldName + ',' + this.x1 + ',' + this.y1 + ',' + this.z1 + "=>" + this.x2 + ',' + this.y2 + ',' + this.z2;
    }

    public String getWorldName() {
        return this.worldName;
    }

    public int getX1() {
        return this.x1;
    }

    public int getY1() {
        return this.y1;
    }

    public int getZ1() {
        return this.z1;
    }

    public int getX2() {
        return this.x2;
    }

    public int getY2() {
        return this.y2;
    }

    public int getZ2() {
        return this.z2;
    }

    public void setWorldName(String worldName) {
        this.worldName = worldName;
    }

    public void setX1(int x1) {
        this.x1 = x1;
    }

    public void setY1(int y1) {
        this.y1 = y1;
    }

    public void setZ1(int z1) {
        this.z1 = z1;
    }

    public void setX2(int x2) {
        this.x2 = x2;
    }

    public void setY2(int y2) {
        this.y2 = y2;
    }

    public void setZ2(int z2) {
        this.z2 = z2;
    }
}



Filename: .\main\java\rip\diamond\practice\util\cuboid\CuboidBlockIterator.java
package rip.diamond.practice.util.cuboid;

import org.bukkit.World;
import org.bukkit.block.Block;

import java.util.Iterator;

public class CuboidBlockIterator implements Iterator<Block> {

    private World world;
    private int baseX;
    private int baseY;
    private int baseZ;
    private int sizeX;
    private int sizeY;
    private int sizeZ;
    private int x;
    private int y;
    private int z;

    CuboidBlockIterator(World world, int x1, int y1, int z1, int x2, int y2, int z2) {
        this.world = world;
        this.baseX = x1;
        this.baseY = y1;
        this.baseZ = z1;
        this.sizeX = Math.abs(x2 - x1) + 1;
        this.sizeY = Math.abs(y2 - y1) + 1;
        this.sizeZ = Math.abs(z2 - z1) + 1;
        this.z = 0;
        this.y = 0;
        this.x = 0;
    }

    @Override
    public boolean hasNext() {
        return this.x < this.sizeX && this.y < this.sizeY && this.z < this.sizeZ;
    }

    @Override
    public Block next() {
        Block block = this.world.getBlockAt(this.baseX + this.x, this.baseY + this.y, this.baseZ + this.z);
        if (++this.x >= this.sizeX) {
            this.x = 0;
            if (++this.y >= this.sizeY) {
                this.y = 0;
                ++this.z;
            }
        }
        return block;
    }

    @Override
    public void remove() throws UnsupportedOperationException {
        throw new UnsupportedOperationException();
    }

    public World getWorld() {
        return this.world;
    }

    public int getBaseX() {
        return this.baseX;
    }

    public int getBaseY() {
        return this.baseY;
    }

    public int getBaseZ() {
        return this.baseZ;
    }

    public int getSizeX() {
        return this.sizeX;
    }

    public int getSizeY() {
        return this.sizeY;
    }

    public int getSizeZ() {
        return this.sizeZ;
    }

    public int getX() {
        return this.x;
    }

    public int getY() {
        return this.y;
    }

    public int getZ() {
        return this.z;
    }
}



Filename: .\main\java\rip\diamond\practice\util\cuboid\CuboidDirection.java
package rip.diamond.practice.util.cuboid;

public enum CuboidDirection {

    NORTH, EAST, SOUTH, WEST,
    UP, DOWN, HORIZONTAL, VERTICAL, BOTH,
    UNKNOWN;

    private CuboidDirection() {

    }

    public CuboidDirection opposite() {
        switch (this) {
            case NORTH: {
                return SOUTH;
            }
            case EAST: {
                return WEST;
            }
            case SOUTH: {
                return NORTH;
            }
            case WEST: {
                return EAST;
            }
            case HORIZONTAL: {
                return VERTICAL;
            }
            case VERTICAL: {
                return HORIZONTAL;
            }
            case UP: {
                return DOWN;
            }
            case DOWN: {
                return UP;
            }
            case BOTH: {
                return BOTH;
            }
        }
        return UNKNOWN;
    }
}



Filename: .\main\java\rip\diamond\practice\util\cuboid\CuboidLocationIterator.java
package rip.diamond.practice.util.cuboid;

import org.bukkit.Location;
import org.bukkit.World;

import java.util.Iterator;

public class CuboidLocationIterator implements Iterator<Location> {

    private World world;
    private int baseX;
    private int baseY;
    private int baseZ;
    private int sizeX;
    private int sizeY;
    private int sizeZ;
    private int x;
    private int y;
    private int z;

    CuboidLocationIterator(World world, int x1, int y1, int z1, int x2, int y2, int z2) {
        this.world = world;
        this.baseX = x1;
        this.baseY = y1;
        this.baseZ = z1;
        this.sizeX = Math.abs(x2 - x1) + 1;
        this.sizeY = Math.abs(y2 - y1) + 1;
        this.sizeZ = Math.abs(z2 - z1) + 1;
        this.z = 0;
        this.y = 0;
        this.x = 0;
    }

    @Override
    public boolean hasNext() {
        return this.x < this.sizeX && this.y < this.sizeY && this.z < this.sizeZ;
    }

    @Override
    public Location next() {
        Location location = new Location(this.world, this.baseX + this.x, this.baseY + this.y, this.baseZ + this.z);
        if (++this.x >= this.sizeX) {
            this.x = 0;
            if (++this.y >= this.sizeY) {
                this.y = 0;
                ++this.z;
            }
        }
        return location;
    }

    @Override
    public void remove() throws UnsupportedOperationException {
        throw new UnsupportedOperationException();
    }

    public World getWorld() {
        return this.world;
    }

    public int getBaseX() {
        return this.baseX;
    }

    public int getBaseY() {
        return this.baseY;
    }

    public int getBaseZ() {
        return this.baseZ;
    }

    public int getSizeX() {
        return this.sizeX;
    }

    public int getSizeY() {
        return this.sizeY;
    }

    public int getSizeZ() {
        return this.sizeZ;
    }

    public int getX() {
        return this.x;
    }

    public int getY() {
        return this.y;
    }

    public int getZ() {
        return this.z;
    }
}



Filename: .\main\java\rip\diamond\practice\util\exception\PracticeUnexpectedException.java
package rip.diamond.practice.util.exception;

public class PracticeUnexpectedException extends RuntimeException {
    public PracticeUnexpectedException(String reason) {
        super(reason);
    }
}


Filename: .\main\java\rip\diamond\practice\util\menu\Button.java
package rip.diamond.practice.util.menu;

import org.apache.commons.lang.StringUtils;
import org.bukkit.Material;
import org.bukkit.Sound;
import org.bukkit.entity.Player;
import org.bukkit.event.inventory.ClickType;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.meta.ItemMeta;

public abstract class Button {

	public static Button placeholder(final Material material, final byte data, String... title) {
		return (new Button() {
			public ItemStack getButtonItem(Player player) {
				ItemStack it = new ItemStack(material, 1, data);
				ItemMeta meta = it.getItemMeta();

				meta.setDisplayName(StringUtils.join(title));
				it.setItemMeta(meta);

				return it;
			}
		});
	}

	public static void playFail(Player player) {
		player.playSound(player.getLocation(), Sound.DIG_GRASS, 20F, 0.1F);

	}

	public static void playSuccess(Player player) {
		player.playSound(player.getLocation(), Sound.NOTE_PIANO, 20F, 15F);
	}

	public static void playNeutral(Player player) {
		player.playSound(player.getLocation(), Sound.CLICK, 20F, 1F);
	}

	public abstract ItemStack getButtonItem(Player player);

	public void clicked(Player player, ClickType clickType) {}

	public void clicked(Player player, int slot, ClickType clickType, int hotbarSlot) {}

	public boolean shouldCancel(Player player, ClickType clickType) {
		return true;
	}

	public boolean shouldUpdate(Player player, ClickType clickType) {
		return false;
	}

}

Filename: .\main\java\rip\diamond\practice\util\menu\Menu.java
package rip.diamond.practice.util.menu;

import lombok.Getter;
import lombok.Setter;
import org.bukkit.Bukkit;
import org.bukkit.Material;
import org.bukkit.entity.Player;
import org.bukkit.inventory.Inventory;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.meta.ItemMeta;
import rip.diamond.practice.Eden;
import rip.diamond.practice.event.MenuOpenEvent;
import rip.diamond.practice.event.MenuUpdateEvent;
import rip.diamond.practice.util.CC;
import rip.diamond.practice.util.menu.task.MenuUpdateTask;

import java.util.Map;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;

@Getter
@Setter
public abstract class Menu {

	public static Map<UUID, Menu> currentlyOpenedMenus = new ConcurrentHashMap<>();

	@Getter protected Eden plugin = Eden.INSTANCE;
	private Map<Integer, Button> buttons = new ConcurrentHashMap<>();
	private boolean autoUpdate = false;
	private boolean closedByMenu = false;
	private boolean placeholder = false;
	public Button placeholderButton = Button.placeholder(Material.STAINED_GLASS_PANE, (byte) 15, " ");

	public static void init() {
		new MenuUpdateTask();
	}

	private ItemStack createItemStack(Player player, Button button) {
		ItemStack item = button.getButtonItem(player);

		if (item.getType() != Material.SKULL_ITEM) {
			ItemMeta meta = item.getItemMeta();

			if (meta != null && meta.hasDisplayName()) {
				meta.setDisplayName(meta.getDisplayName());
			}

			item.setItemMeta(meta);
		}

		return item;
	}

	public void openMenu(final Player player) {
		try {
			//Eden Start - Recoded how menu opens. Might contain bugs
			Menu previousMenu = Menu.currentlyOpenedMenus.get(player.getUniqueId());
			if (previousMenu != null) {
				previousMenu.onClose(player);
				previousMenu.setClosedByMenu(true);
				Menu.currentlyOpenedMenus.remove(player.getUniqueId());

				MenuUpdateEvent event = new MenuUpdateEvent(this);
				event.call();
			} else {
				MenuOpenEvent event = new MenuOpenEvent(this);
				event.call();
			}

			this.buttons = this.getButtons(player);
			String title = CC.translate(CC.AQUA + this.getTitle(player));
			if (title.length() > 32) {
				title = title.substring(0, 32);
			}
			int size = this.getSize() == -1 ? this.size(this.buttons) : this.getSize();

			Inventory inventory = Bukkit.createInventory(player, size, title);

			for (Map.Entry<Integer, Button> buttonEntry : this.buttons.entrySet()) {
				inventory.setItem(buttonEntry.getKey(), createItemStack(player, buttonEntry.getValue()));
			}

			if (this.isPlaceholder()) {
				for (int index = 0; index < size; index++) {
					if (this.buttons.get(index) == null) {
						this.buttons.put(index, this.placeholderButton);
						inventory.setItem(index, this.placeholderButton.getButtonItem(player));
					}
				}
			}

			player.openInventory(inventory);
			Menu.currentlyOpenedMenus.put(player.getUniqueId(), this);
			this.onOpen(player);
			this.setClosedByMenu(false);
			//Eden End
		} catch (Exception e) {
			e.printStackTrace();
			player.closeInventory();
		}
	}

	public int size(Map<Integer, Button> buttons) {
		int highest = 0;

		for (int buttonValue : buttons.keySet()) {
			if (buttonValue > highest) {
				highest = buttonValue;
			}
		}

		return (int) (Math.ceil((highest + 1) / 9D) * 9D);
	}

	public int getSize() {
		return -1;
	}

	public int getSlot(int x, int y) {
		return ((9 * y) + x);
	}

	public abstract String getTitle(Player player);

	public String getID() {
		return getClass().getSimpleName();
	}

	public abstract Map<Integer, Button> getButtons(Player player);

	public void onOpen(Player player) {
	}

	public void onClose(Player player) {
	}

}


Filename: .\main\java\rip\diamond\practice\util\menu\MenuListener.java
package rip.diamond.practice.util.menu;

import org.bukkit.Bukkit;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.Listener;
import org.bukkit.event.inventory.ClickType;
import org.bukkit.event.inventory.InventoryClickEvent;
import org.bukkit.event.inventory.InventoryCloseEvent;
import rip.diamond.practice.Eden;

public class MenuListener implements Listener {

	private final Eden plugin;

	public MenuListener(Eden plugin) {
		this.plugin = plugin;
	}

	@EventHandler(ignoreCancelled = true, priority = EventPriority.MONITOR)
	public void onButtonPress(InventoryClickEvent event) {

		Player player = (Player) event.getWhoClicked();
		Menu openMenu = Menu.currentlyOpenedMenus.get(player.getUniqueId());

		if (openMenu != null) {
			if (event.getSlot() != event.getRawSlot()) {
				if ((event.getClick() == ClickType.SHIFT_LEFT || event.getClick() == ClickType.SHIFT_RIGHT)) {
					event.setCancelled(true);
				}

				return;
			}

			if (openMenu.getButtons().containsKey(event.getSlot())) {
				Button button = openMenu.getButtons().get(event.getSlot());
				boolean cancel = button.shouldCancel(player, event.getClick());

				if (!cancel && (event.getClick() == ClickType.SHIFT_LEFT || event.getClick() == ClickType.SHIFT_RIGHT)) {
					event.setCancelled(true);

					if (event.getCurrentItem() != null) {
						player.getInventory().addItem(event.getCurrentItem());
					}
				} else {
					event.setCancelled(cancel);
				}

				button.clicked(player, event.getClick());
				button.clicked(player, event.getSlot(), event.getClick(), event.getHotbarButton());

				if (Menu.currentlyOpenedMenus.containsKey(player.getUniqueId())) {
					Menu newMenu = Menu.currentlyOpenedMenus.get(player.getUniqueId());

					if (newMenu == openMenu) {
						boolean buttonUpdate = button.shouldUpdate(player, event.getClick());

						if (buttonUpdate) {
							openMenu.setClosedByMenu(true);
							newMenu.openMenu(player);
						}
					}
				} else if (button.shouldUpdate(player, event.getClick())) {
					openMenu.setClosedByMenu(true);
					openMenu.openMenu(player);
				}

				if (event.isCancelled()) {
					Bukkit.getScheduler().runTaskLater(plugin, player::updateInventory, 1L);
				}
			} else {
				if (event.getCurrentItem() != null) {
					event.setCancelled(true);
				}

				if ((event.getClick() == ClickType.SHIFT_LEFT || event.getClick() == ClickType.SHIFT_RIGHT)) {
					event.setCancelled(true);
				}
			}
		}
	}

	@EventHandler(priority = EventPriority.HIGH)
	public void onInventoryClose(InventoryCloseEvent event) {
		Player player = (Player) event.getPlayer();
		Menu openMenu = Menu.currentlyOpenedMenus.get(player.getUniqueId());

		if (openMenu != null) {
			openMenu.onClose(player);

			Menu.currentlyOpenedMenus.remove(player.getUniqueId());
		}
	}

}

Filename: .\main\java\rip\diamond\practice\util\menu\TypeCallback.java
package rip.diamond.practice.util.menu;

import java.io.Serializable;

public interface TypeCallback<T> extends Serializable {

	/**
	 * A callback for running a task on a set of data.
	 *
	 * @param data the data needed to run the task.
	 */
	void callback(T data);

}


Filename: .\main\java\rip\diamond\practice\util\menu\button\BackButton.java
package rip.diamond.practice.util.menu.button;

import lombok.AllArgsConstructor;
import lombok.RequiredArgsConstructor;
import org.bukkit.Material;
import org.bukkit.entity.Player;
import org.bukkit.event.inventory.ClickType;
import org.bukkit.inventory.ItemStack;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.util.ItemBuilder;
import rip.diamond.practice.util.menu.Button;
import rip.diamond.practice.util.menu.Menu;

@RequiredArgsConstructor
@AllArgsConstructor
public class BackButton extends Button {

	private final Material material;
	private int durability = 0;
	private final Menu back;

	@Override
	public ItemStack getButtonItem(Player player) {
		return new ItemBuilder(material)
				.name(Language.BUTTON_BACK_NAME.toString())
				.durability(durability)
				.lore(Language.BUTTON_BACK_LORE.toStringList(player))
				.build();
	}

	@Override
	public void clicked(Player player, ClickType clickType) {
		Button.playNeutral(player);
		back.openMenu(player);
	}

}


Filename: .\main\java\rip\diamond\practice\util\menu\button\ConfirmationButton.java
package rip.diamond.practice.util.menu.button;

import lombok.AllArgsConstructor;
import org.bukkit.Material;
import org.bukkit.Sound;
import org.bukkit.entity.Player;
import org.bukkit.event.inventory.ClickType;
import org.bukkit.inventory.ItemStack;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.util.ItemBuilder;
import rip.diamond.practice.util.menu.Button;
import rip.diamond.practice.util.menu.Menu;
import rip.diamond.practice.util.menu.TypeCallback;

@AllArgsConstructor
public class ConfirmationButton extends Button {

	private boolean confirm;
	private TypeCallback<Boolean> callback;
	private boolean closeAfterResponse;

	@Override
	public ItemStack getButtonItem(Player player) {
		return new ItemBuilder(Material.STAINED_GLASS_PANE)
				.durability(this.confirm ? 5 : 14)
				.name(this.confirm ? Language.BUTTON_CONFIRM_NAME_CONFIRM.toString() : Language.BUTTON_CONFIRM_NAME_CANCEL.toString())
				.build();
	}

	@Override
	public void clicked(Player player, ClickType clickType) {
		if (this.confirm) {
			player.playSound(player.getLocation(), Sound.NOTE_PIANO, 20f, 0.1f);
		} else {
			player.playSound(player.getLocation(), Sound.DIG_GRAVEL, 20f, 0.1F);
		}

		if (this.closeAfterResponse) {
			Menu menu = Menu.currentlyOpenedMenus.get(player.getUniqueId());

			if (menu != null) {
				menu.setClosedByMenu(true);
			}

			player.closeInventory();
		}

		this.callback.callback(this.confirm);
	}

}


Filename: .\main\java\rip\diamond\practice\util\menu\button\DisplayButton.java
package rip.diamond.practice.util.menu.button;

import rip.diamond.practice.util.menu.Button;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;
import org.bukkit.Material;
import org.bukkit.entity.Player;
import org.bukkit.event.inventory.ClickType;
import org.bukkit.inventory.ItemStack;

@AllArgsConstructor
@Getter
@Setter
public class DisplayButton extends Button {

	private ItemStack itemStack;
	private boolean cancel;

	@Override
	public ItemStack getButtonItem(Player player) {
		if (this.itemStack == null) {
			return new ItemStack(Material.AIR);
		} else {
			return this.itemStack;
		}
	}

	@Override
	public boolean shouldCancel(Player player, ClickType clickType) {
		return this.cancel;
	}

}


Filename: .\main\java\rip\diamond\practice\util\menu\button\JumpToMenuButton.java
package rip.diamond.practice.util.menu.button;

import rip.diamond.practice.util.menu.Button;
import rip.diamond.practice.util.menu.Menu;
import org.bukkit.entity.Player;
import org.bukkit.event.inventory.ClickType;
import org.bukkit.inventory.ItemStack;

public class JumpToMenuButton extends Button {

	private Menu menu;
	private ItemStack itemStack;

	public JumpToMenuButton(Menu menu, ItemStack itemStack) {
		this.menu = menu;
		this.itemStack = itemStack;
	}

	@Override
	public ItemStack getButtonItem(Player player) {
		return itemStack;
	}

	@Override
	public void clicked(Player player, ClickType clickType) {
		menu.openMenu(player);
	}

}


Filename: .\main\java\rip\diamond\practice\util\menu\button\ToggleButton.java
package rip.diamond.practice.util.menu.button;

import org.bukkit.Material;
import org.bukkit.entity.Player;
import org.bukkit.event.inventory.ClickType;
import org.bukkit.inventory.ItemStack;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.util.CC;
import rip.diamond.practice.util.ItemBuilder;
import rip.diamond.practice.util.menu.Button;

public abstract class ToggleButton extends Button {

    @Override
    public ItemStack getButtonItem(Player player) {
        return new ItemBuilder(isEnabled(player) ? Material.REDSTONE_TORCH_ON : Material.LEVER)
                .name(Language.BUTTON_TOGGLE_NAME.toString(getOptionName()))
                .lore("", CC.GRAY + getDescription(), "", CC.GREEN + (isEnabled(player) ? " ¬ª " : "   ") + Language.ENABLED.toString(), CC.RED + (!isEnabled(player) ? " ¬ª " : "   ") + Language.DISABLED.toString(), "")
                .build();
    }

    public abstract String getOptionName();

    public abstract String getDescription();

    public abstract boolean isEnabled(Player player);

    @Override
    public void clicked(Player player, int slot, ClickType clickType, int hotbarSlot) {
        playNeutral(player);
        onClick(player, slot, clickType, hotbarSlot);
    }

    public abstract void onClick(Player player, int slot, ClickType clickType, int hotbarSlot);
}


Filename: .\main\java\rip\diamond\practice\util\menu\menus\ConfirmMenu.java
package rip.diamond.practice.util.menu.menus;

import rip.diamond.practice.config.Language;
import rip.diamond.practice.util.CC;
import rip.diamond.practice.util.menu.Button;
import rip.diamond.practice.util.menu.Menu;
import rip.diamond.practice.util.menu.TypeCallback;
import rip.diamond.practice.util.menu.button.ConfirmationButton;
import org.bukkit.entity.Player;

import java.util.HashMap;
import java.util.Map;

public class ConfirmMenu extends Menu {

	private final String title;
	private final TypeCallback<Boolean> response;
	private final boolean closeAfterResponse;
	private final Button centerButtons;

	public ConfirmMenu(TypeCallback<Boolean> response, boolean closeAfter, Button centerButtons) {
		this.title = CC.YELLOW + Language.CONFIRM_TITLE;
		this.response = response;
		this.closeAfterResponse = closeAfter;
		this.centerButtons = centerButtons;
	}

	@Override
	public Map<Integer, Button> getButtons(Player player) {
		HashMap<Integer, Button> buttons = new HashMap<>();

		for (int x = 0; x < 3; x++) {
			for (int y = 0; y < 3; y++) {
				buttons.put(getSlot(x, y), new ConfirmationButton(true, response, closeAfterResponse));
				buttons.put(getSlot(8 - x, y), new ConfirmationButton(false, response, closeAfterResponse));
			}
		}

		if (centerButtons != null) {
			buttons.put(getSlot(4, 1), centerButtons);
		}

		return buttons;
	}

	@Override
	public String getTitle(Player player) {
		return title;
	}

}


Filename: .\main\java\rip\diamond\practice\util\menu\pagination\FilterablePaginatedMenu.java
package rip.diamond.practice.util.menu.pagination;

import rip.diamond.practice.util.menu.Button;
import lombok.Getter;
import lombok.Setter;
import org.bukkit.entity.Player;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public abstract class FilterablePaginatedMenu<T> extends PaginatedMenu {

	@Getter private final List<PageFilter<T>> filters;
	@Getter @Setter private int scrollIndex = 0;

	{
		filters = generateFilters();
	}

	@Override
	public Map<Integer, Button> getGlobalButtons(Player player) {
		Map<Integer, Button> buttons = new HashMap<>();
		buttons.put(7, new PageFilterButton<>(this));
		return buttons;
	}

	@Override
	public Map<Integer, Button> getAllPagesButtons(Player player) {
		return getFilteredButtons(player);
	}

	public abstract Map<Integer, Button> getFilteredButtons(Player player);

	public List<PageFilter<T>> generateFilters() {
		return new ArrayList<>();
	}

}


Filename: .\main\java\rip\diamond\practice\util\menu\pagination\JumpToPageButton.java
package rip.diamond.practice.util.menu.pagination;

import lombok.AllArgsConstructor;
import org.bukkit.Material;
import org.bukkit.entity.Player;
import org.bukkit.event.inventory.ClickType;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.meta.ItemMeta;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.util.menu.Button;

@AllArgsConstructor
public class JumpToPageButton extends Button {

	private int page;
	private PaginatedMenu menu;
	private boolean current;

	@Override
	public ItemStack getButtonItem(Player player) {
		ItemStack itemStack = new ItemStack(this.current ? Material.ENCHANTED_BOOK : Material.BOOK, this.page);
		ItemMeta itemMeta = itemStack.getItemMeta();

		itemMeta.setDisplayName(Language.BUTTON_JUMP_TO_PAGE_NAME.toString(this.page));

		if (this.current) {
			itemMeta.setLore(Language.BUTTON_JUMP_TO_PAGE_CURRENT_PAGE_LORE.toStringList(player));
		}

		itemStack.setItemMeta(itemMeta);

		return itemStack;
	}

	@Override
	public void clicked(Player player, ClickType clickType) {
		this.menu.modPage(player, this.page - this.menu.getPage());
		Button.playNeutral(player);
	}

}


Filename: .\main\java\rip\diamond\practice\util\menu\pagination\PageButton.java
package rip.diamond.practice.util.menu.pagination;

import lombok.AllArgsConstructor;
import org.bukkit.Material;
import org.bukkit.entity.Player;
import org.bukkit.event.inventory.ClickType;
import org.bukkit.inventory.ItemStack;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.util.ItemBuilder;
import rip.diamond.practice.util.menu.Button;

@AllArgsConstructor
public class PageButton extends Button {

	private int mod;
	private PaginatedMenu menu;

	@Override
	public ItemStack getButtonItem(Player player) {
		if (this.mod > 0) {
			if (hasNext(player)) {
				return new ItemBuilder(Material.ARROW)
						.name(Language.BUTTON_PAGE_NEXT_PAGE_AVAILABLE_NAME.toString(player))
						.lore(Language.BUTTON_PAGE_NEXT_PAGE_AVAILABLE_LORE.toStringList(player))
						.build();
			} else {
				return new ItemBuilder(Material.ARROW)
						.name(Language.BUTTON_PAGE_NEXT_PAGE_CURRENT_NAME.toString(player))
						.lore(Language.BUTTON_PAGE_NEXT_PAGE_CURRENT_LORE.toStringList(player))
						.build();
			}
		} else {
			if (hasPrevious(player)) {
				return new ItemBuilder(Material.ARROW)
						.name(Language.BUTTON_PAGE_PREVIOUS_PAGE_AVAILABLE_NAME.toString(player))
						.lore(Language.BUTTON_PAGE_PREVIOUS_PAGE_AVAILABLE_LORE.toStringList(player))
						.build();
			} else {
				return new ItemBuilder(Material.ARROW)
						.name(Language.BUTTON_PAGE_PREVIOUS_PAGE_CURRENT_NAME.toString(player))
						.lore(Language.BUTTON_PAGE_PREVIOUS_PAGE_CURRENT_LORE.toStringList(player))
						.build();
			}
		}
	}

	@Override
	public void clicked(Player player, ClickType clickType) {
		if (this.mod > 0) {
			if (hasNext(player)) {
				this.menu.modPage(player, this.mod);
				Button.playNeutral(player);
			} else {
				Button.playFail(player);
			}
		} else {
			if (hasPrevious(player)) {
				this.menu.modPage(player, this.mod);
				Button.playNeutral(player);
			} else {
				Button.playFail(player);
			}
		}
	}

	private boolean hasNext(Player player) {
		int pg = this.menu.getPage() + this.mod;
		return this.menu.getPages(player) >= pg;
	}

	private boolean hasPrevious(Player player) {
		int pg = this.menu.getPage() + this.mod;
		return pg > 0;
	}

}


Filename: .\main\java\rip\diamond\practice\util\menu\pagination\PageFilter.java
package rip.diamond.practice.util.menu.pagination;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.Setter;

import java.util.function.Predicate;

@RequiredArgsConstructor
public class PageFilter<T> {

	@Getter private final String name;
	@Getter @Setter private boolean enabled;
	private final Predicate<T> predicate;

	public boolean test(T t) {
		return !enabled || predicate.test(t);
	}

	@Override
	public boolean equals(Object object) {
		return object instanceof PageFilter && ((PageFilter) object).getName().equals(name);
	}

}


Filename: .\main\java\rip\diamond\practice\util\menu\pagination\PageFilterButton.java
package rip.diamond.practice.util.menu.pagination;

import rip.diamond.practice.config.Language;
import rip.diamond.practice.util.CC;
import rip.diamond.practice.util.ItemBuilder;
import rip.diamond.practice.util.menu.Button;
import lombok.AllArgsConstructor;
import org.apache.commons.lang.StringEscapeUtils;
import org.bukkit.ChatColor;
import org.bukkit.Material;
import org.bukkit.entity.Player;
import org.bukkit.event.inventory.ClickType;
import org.bukkit.inventory.ItemStack;

import java.util.ArrayList;
import java.util.List;

@AllArgsConstructor
public class PageFilterButton<T> extends Button {

	private FilterablePaginatedMenu<T> menu;

	@Override
	public ItemStack getButtonItem(Player player) {
		if (menu.getFilters() == null || menu.getFilters().isEmpty()) {
			return new ItemStack(Material.AIR);
		}

		List<String> lore = new ArrayList<>();
		lore.add(CC.MENU_BAR);

		for (PageFilter filter : menu.getFilters()) {
			String color;
			String decoration = "";
			String icon;

			if (filter.isEnabled()) {
				color = ChatColor.GREEN.toString();
				icon = StringEscapeUtils.unescapeJava("\u2713");
			} else {
				color = ChatColor.RED.toString();
				icon = StringEscapeUtils.unescapeJava("\u2717");
			}

			if (menu.getFilters().get(menu.getScrollIndex()).equals(filter)) {
				decoration = ChatColor.YELLOW + StringEscapeUtils.unescapeJava("¬ª ") + " ";
			}

			lore.add(decoration + color + icon + " " + filter.getName());
		}

		lore.addAll(Language.BUTTON_PAGE_FILTER_LORE.toStringList(player));

		return new ItemBuilder(Material.HOPPER)
				.name(Language.BUTTON_PAGE_FILTER_NAME.toString())
				.lore(lore)
				.build();
	}

	@Override
	public void clicked(Player player, ClickType clickType) {
		if (menu.getFilters() == null || menu.getFilters().isEmpty()) {
			Language.BUTTON_PAGE_FILTER_NO_FILTERS.sendMessage(player);
		} else {
			if (clickType == ClickType.LEFT) {
				if (menu.getScrollIndex() == menu.getFilters().size() - 1) {
					menu.setScrollIndex(0);
				} else {
					menu.setScrollIndex(menu.getScrollIndex() + 1);
				}
			} else if (clickType == ClickType.RIGHT) {
				PageFilter<T> filter = menu.getFilters().get(menu.getScrollIndex());
				filter.setEnabled(!filter.isEnabled());
			}
		}
	}

	@Override
	public boolean shouldUpdate(Player player, ClickType clickType) {
		return true;
	}

}


Filename: .\main\java\rip\diamond\practice\util\menu\pagination\PaginatedMenu.java
package rip.diamond.practice.util.menu.pagination;

import rip.diamond.practice.util.menu.Button;
import rip.diamond.practice.util.menu.Menu;
import lombok.Getter;
import org.bukkit.entity.Player;

import java.util.HashMap;
import java.util.Map;

public abstract class PaginatedMenu extends Menu {

	@Getter public int page = 1;

	@Override
	public String getTitle(Player player) {
		return getPrePaginatedTitle(player);
	}

	/**
	 * Changes the page number
	 *
	 * @param player player viewing the inventory
	 * @param mod    delta to modify the page number by
	 */
	public final void modPage(Player player, int mod) {
		page += mod;
		getButtons().clear();
		openMenu(player);
	}

	/**
	 * @param player player viewing the inventory
	 */
	public final int getPages(Player player) {
		int buttonAmount = getAllPagesButtons(player).size();

		if (buttonAmount == 0) {
			return 1;
		}

		return (int) Math.ceil(buttonAmount / (double) getMaxItemsPerPage(player));
	}

	@Override
	public Map<Integer, Button> getButtons(Player player) {
		int minIndex = (int) ((double) (page - 1) * getMaxItemsPerPage(player));
		int maxIndex = (int) ((double) (page) * getMaxItemsPerPage(player));
		int topIndex = 0;

		HashMap<Integer, Button> buttons = new HashMap<>();

		for (Map.Entry<Integer, Button> entry : getAllPagesButtons(player).entrySet()) {
			int index = entry.getKey();

			if (index >= minIndex && index < maxIndex) {
				index -= (int) ((double) (getMaxItemsPerPage(player)) * (page - 1)) - 9;
				buttons.put(index, entry.getValue());

				if (index > topIndex) {
					topIndex = index;
				}
			}
		}

		buttons.put(0, new PageButton(-1, this));
		buttons.put(8, new PageButton(1, this));

		for (int i = 1; i < 8; i++) {
			buttons.put(i, getPlaceholderButton());
		}

		Map<Integer, Button> global = getGlobalButtons(player);

		if (global != null) {
			buttons.putAll(global);
		}

		return buttons;
	}

	public int getMaxItemsPerPage(Player player) {
		return 18;
	}

	/**
	 * @param player player viewing the inventory
	 *
	 * @return a Map of button that returns items which will be present on all pages
	 */
	public Map<Integer, Button> getGlobalButtons(Player player) {
		return null;
	}

	/**
	 * @param player player viewing the inventory
	 *
	 * @return title of the inventory before the page number is added
	 */
	public abstract String getPrePaginatedTitle(Player player);

	/**
	 * @param player player viewing the inventory
	 *
	 * @return a map of button that will be paginated and spread across pages
	 */
	public abstract Map<Integer, Button> getAllPagesButtons(Player player);

}


Filename: .\main\java\rip\diamond\practice\util\menu\pagination\ViewAllPagesMenu.java
package rip.diamond.practice.util.menu.pagination;

import org.bukkit.Material;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.util.menu.Button;
import rip.diamond.practice.util.menu.Menu;
import rip.diamond.practice.util.menu.button.BackButton;
import lombok.Getter;
import lombok.NonNull;
import lombok.RequiredArgsConstructor;
import org.bukkit.entity.Player;

import java.util.HashMap;
import java.util.Map;

@RequiredArgsConstructor
public class ViewAllPagesMenu extends Menu {

	@NonNull
	@Getter
	PaginatedMenu menu;

	@Override
	public String getTitle(Player player) {
		return Language.MENU_VIEW_ALL_PAGES_TITLE.toString();
	}

	@Override
	public Map<Integer, Button> getButtons(Player player) {
		HashMap<Integer, Button> buttons = new HashMap<>();

		buttons.put(0, new BackButton(Material.REDSTONE, menu));

		int index = 10;

		for (int i = 1; i <= menu.getPages(player); i++) {
			buttons.put(index++, new JumpToPageButton(i, menu, menu.getPage() == i));

			if ((index - 8) % 9 == 0) {
				index += 2;
			}
		}

		return buttons;
	}

	@Override
	public boolean isAutoUpdate() {
		return true;
	}

}


Filename: .\main\java\rip\diamond\practice\util\menu\task\MenuUpdateTask.java
package rip.diamond.practice.util.menu.task;

import org.bukkit.Bukkit;
import org.bukkit.entity.Player;
import rip.diamond.practice.util.TaskTicker;
import rip.diamond.practice.util.menu.Menu;

import java.util.Iterator;
import java.util.Map;
import java.util.UUID;

public class MenuUpdateTask extends TaskTicker {

	public MenuUpdateTask() {
		super(0, 20, false);
	}

	@Override
	public void onRun() {
		Iterator<Map.Entry<UUID, Menu>> menuIterator = Menu.currentlyOpenedMenus.entrySet().iterator();
		while (menuIterator.hasNext()) {
			Map.Entry<UUID, Menu> menuMap = menuIterator.next();
			UUID uuid = menuMap.getKey();
			Menu menu = menuMap.getValue();
			if (uuid == null || menu == null) {
				menuIterator.remove();
				continue;
			}
			final Player player = Bukkit.getPlayer(uuid);
			if (player == null) return;
			if (menu.isAutoUpdate()) {
				menu.openMenu(player);
			}
		}
	}

	@Override
	public TickType getTickType() {
		return TickType.NONE;
	}

	@Override
	public int getStartTick() {
		return 0;
	}

}

Filename: .\main\java\rip\diamond\practice\util\nametags\NameTagManager.java
package rip.diamond.practice.util.nametags;

import lombok.Getter;
import lombok.Setter;
import org.bukkit.Bukkit;
import org.bukkit.entity.Player;
import org.bukkit.scheduler.BukkitRunnable;
import rip.diamond.practice.Eden;
import rip.diamond.practice.util.Tasks;
import rip.diamond.practice.util.Util;
import rip.diamond.practice.util.exception.PracticeUnexpectedException;
import rip.diamond.practice.util.nametags.construct.NameTagComparator;
import rip.diamond.practice.util.nametags.construct.NameTagInfo;
import rip.diamond.practice.util.nametags.construct.NametagUpdate;
import rip.diamond.practice.util.nametags.listener.NameTagListener;
import rip.diamond.practice.util.nametags.packet.ScoreboardTeamPacketMod;
import rip.diamond.practice.util.nametags.provider.NameTagProvider;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

@Getter @Setter
public class NameTagManager {

    private final Eden plugin;

    private final Map<String, Map<String, NameTagInfo>> teamMap = new ConcurrentHashMap<>();
    private final List<NameTagProvider> providers = new ArrayList<>();
    private final List<NameTagInfo> registeredTeams = Collections.synchronizedList(new ArrayList<>());

    private boolean initiated = false;
    private boolean async = true;
    private static int teamCreateIndex = 1;

    public NameTagManager(Eden plugin) {
        this.plugin = plugin;
        this.initiated = true;

        this.plugin.getServer().getPluginManager().registerEvents(new NameTagListener(), this.plugin);

        new BukkitRunnable() {
            @Override
            public void run() {
                Util.getOnlinePlayers().forEach(player -> reload(player));
            }
        }.runTaskTimerAsynchronously(plugin, 0, 2);
    }

    public void registerAdapter(NameTagProvider newProvider) {
        this.providers.add(newProvider);
        this.providers.sort(new NameTagComparator());
    }

    public void reload(Player player) {
        reloadPlayer(player);
        reloadOthersFor(player);
    }

    public void reloadPlayer(Player toRefresh) {
        NametagUpdate update = new NametagUpdate(toRefresh);

        applyUpdate(update);
    }

    public void reloadOthersFor(Player refreshFor) {
        this.plugin.getServer().getOnlinePlayers().forEach(toRefresh -> {
            if (refreshFor != toRefresh) {
                reloadPlayer(toRefresh, refreshFor);
            }
        });
    }

    public void reloadPlayer(Player toRefresh, Player refreshFor) {
        NametagUpdate update = new NametagUpdate(toRefresh, refreshFor);

        applyUpdate(update);
    }

    public void applyUpdate(NametagUpdate nametagUpdate) {
        if (async) {
            Tasks.runAsync(() -> {
                if (nametagUpdate.getToRefresh() != null){
                    Player toRefreshPlayer = Bukkit.getPlayerExact(nametagUpdate.getToRefresh());

                    if (toRefreshPlayer == null) return;

                    if (nametagUpdate.getRefreshFor() == null) {
                        Bukkit.getOnlinePlayers().forEach(refreshFor -> reloadPlayerInternal(toRefreshPlayer, refreshFor));
                    } else {
                        Player refreshForPlayer = Bukkit.getPlayerExact(nametagUpdate.getRefreshFor());

                        if(refreshForPlayer != null) {
                            reloadPlayerInternal(toRefreshPlayer, refreshForPlayer);
                        }
                    }
                }
            });
        } else throw new PracticeUnexpectedException("Nametag update should be run async");
    }

    public void reloadPlayerInternal(Player toRefresh, Player refreshFor) {
        if (!refreshFor.hasMetadata("nametag-logged-in")) return;

        NameTagInfo provided = null;

        for (NameTagProvider nametagProvider : providers) {
            provided = nametagProvider.fetchNameTag(toRefresh, refreshFor);
            if (provided != null){
                break;
            }
        }

        if (provided == null) return;

        Map<String, NameTagInfo> teamInfoMap = new HashMap<>();
        
        if (teamMap.containsKey(refreshFor.getName())) {
            teamInfoMap = teamMap.get(refreshFor.getName());
        }

        new ScoreboardTeamPacketMod(provided.getName(), Collections.singletonList(toRefresh.getName()), 3).sendToPlayer(refreshFor);
        teamInfoMap.put(toRefresh.getName(), provided);
        teamMap.put(refreshFor.getName(), teamInfoMap);        
    }

    public void initiatePlayer(Player player) {
        registeredTeams.forEach(teamInfo -> teamInfo.getTeamAddPacket().sendToPlayer(player));
    }

    public synchronized NameTagInfo getOrCreate(String prefix, String suffix) {
        for( NameTagInfo teamInfo : registeredTeams ) {
            if (teamInfo.getPrefix().equals(prefix) && teamInfo.getSuffix().equals(suffix)) {
                return (teamInfo);
            }
        }

        NameTagInfo newTeam = new NameTagInfo(String.valueOf(teamCreateIndex++), prefix, suffix);
        registeredTeams.add(newTeam);

        ScoreboardTeamPacketMod addPacket = newTeam.getTeamAddPacket();
        this.plugin.getServer().getOnlinePlayers().forEach(addPacket::sendToPlayer);

        return (newTeam);
    }
}

Filename: .\main\java\rip\diamond\practice\util\nametags\construct\NameTagComparator.java
package rip.diamond.practice.util.nametags.construct;

import com.google.common.primitives.Ints;
import rip.diamond.practice.util.nametags.provider.NameTagProvider;

import java.util.Comparator;

public class NameTagComparator implements Comparator<NameTagProvider> {

    public int compare(NameTagProvider a,NameTagProvider b) {
        return Ints.compare(b.getWeight(), a.getWeight());
    }

}


Filename: .\main\java\rip\diamond\practice\util\nametags\construct\NameTagInfo.java
package rip.diamond.practice.util.nametags.construct;

import lombok.Getter;
import rip.diamond.practice.util.nametags.packet.ScoreboardTeamPacketMod;

import java.util.ArrayList;

@Getter
public class NameTagInfo {

    private final String name;
    private final String prefix;
    private final String suffix;
    private final ScoreboardTeamPacketMod teamAddPacket;

    public NameTagInfo(String name, String prefix, String suffix) {
        this.name = name;
        this.prefix = prefix;
        this.suffix = suffix;

        teamAddPacket = new ScoreboardTeamPacketMod(name, prefix, suffix, new ArrayList<String>(), 0);
    }
}

Filename: .\main\java\rip\diamond\practice\util\nametags\construct\NametagUpdate.java
package rip.diamond.practice.util.nametags.construct;

import lombok.Getter;
import org.bukkit.entity.Player;

@Getter
public class NametagUpdate {

    private String toRefresh;
    private String refreshFor;

    public NametagUpdate(Player toRefresh) {
        if(toRefresh == null) return;

        this.toRefresh = toRefresh.getName();
    }

    public NametagUpdate(Player toRefresh, Player refreshFor) {
        this.toRefresh = toRefresh.getName();
        this.refreshFor = refreshFor.getName();
    }
}

Filename: .\main\java\rip\diamond\practice\util\nametags\listener\NameTagListener.java
package rip.diamond.practice.util.nametags.listener;

import net.minecraft.server.v1_8_R3.PacketPlayOutScoreboardTeam;
import org.bukkit.Bukkit;
import org.bukkit.craftbukkit.v1_8_R3.entity.CraftPlayer;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.Listener;
import org.bukkit.event.player.PlayerJoinEvent;
import org.bukkit.event.player.PlayerQuitEvent;
import org.bukkit.metadata.FixedMetadataValue;
import rip.diamond.practice.Eden;
import rip.diamond.practice.util.Tasks;

import java.lang.reflect.Field;
import java.util.Collections;

public final class NameTagListener implements Listener {

    private final Eden plugin = Eden.INSTANCE;

    @EventHandler(priority = EventPriority.HIGH)
    public void onPlayerJoin(PlayerJoinEvent event) {
        event.getPlayer().setMetadata("nametag-logged-in", new FixedMetadataValue(plugin, true));

        try {
            PacketPlayOutScoreboardTeam a = new PacketPlayOutScoreboardTeam();
            team_mode.set(a, 3);
            team_name.set(a, "zLane");
            team_display.set(a, "zLane");
            team_color.set(a, -1);
            team_players.set(a, Collections.singletonList(event.getPlayer().getName()));

            for (Player other : Bukkit.getOnlinePlayers()) {
                Tasks.runAsync(() -> ((CraftPlayer) other).getHandle().playerConnection.sendPacket(a));
            }
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        }

        plugin.getNameTagManager().initiatePlayer(event.getPlayer());
        plugin.getNameTagManager().reloadPlayer(event.getPlayer());
        plugin.getNameTagManager().reloadOthersFor(event.getPlayer());
    }

    @EventHandler
    public void onPlayerQuit(PlayerQuitEvent event) {
        event.getPlayer().removeMetadata("nametag-logged-in", plugin);
        plugin.getNameTagManager().getTeamMap().remove(event.getPlayer().getName());
    }


    private Field team_name;
    private Field team_display;
    private Field team_players;
    private Field team_mode;
    private Field team_color;

    {
        try {
            team_name = PacketPlayOutScoreboardTeam.class.getDeclaredField("a");
            team_name.setAccessible(true);
            team_display = PacketPlayOutScoreboardTeam.class.getDeclaredField("b");
            team_display.setAccessible(true);
            Field team_prefix = PacketPlayOutScoreboardTeam.class.getDeclaredField("c");
            team_prefix.setAccessible(true);
            Field team_suffix = PacketPlayOutScoreboardTeam.class.getDeclaredField("d");
            team_suffix.setAccessible(true);
            team_players = PacketPlayOutScoreboardTeam.class.getDeclaredField("g");
            team_players.setAccessible(true);
            team_color = PacketPlayOutScoreboardTeam.class.getDeclaredField("f");
            team_color.setAccessible(true);
            team_mode = PacketPlayOutScoreboardTeam.class.getDeclaredField("h");
            team_mode.setAccessible(true);
            Field team_nametag = PacketPlayOutScoreboardTeam.class.getDeclaredField("e");
            team_nametag.setAccessible(true);
        } catch (NoSuchFieldException e) {
            e.printStackTrace();
        }
    }

}

Filename: .\main\java\rip\diamond\practice\util\nametags\packet\ScoreboardTeamPacketMod.java
package rip.diamond.practice.util.nametags.packet;

import net.minecraft.server.v1_8_R3.PacketPlayOutScoreboardTeam;
import org.bukkit.craftbukkit.v1_8_R3.entity.CraftPlayer;
import org.bukkit.entity.Player;

import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.Collection;

public final class ScoreboardTeamPacketMod {

	private final PacketPlayOutScoreboardTeam packet;

	public ScoreboardTeamPacketMod(String name, String prefix, String suffix, Collection<String> players, int paramInt) {
		packet = new PacketPlayOutScoreboardTeam();

		setField("a", name);
		setField("h", paramInt);

		if(paramInt == 0 || paramInt == 2) {
			setField("b", name);
			setField("c", prefix);
			setField("d", suffix);
			setField("i", 1);
		}

		if (paramInt == 0) addAll(players);
	}

	public ScoreboardTeamPacketMod(String name, Collection<String> players, int paramInt) {
		packet = new PacketPlayOutScoreboardTeam();

		if (players == null) players = new ArrayList<String>();

		setField("a", name);
		setField("h", paramInt);
		addAll(players);
	}

	public void sendToPlayer(Player bukkitPlayer) {
		((CraftPlayer) bukkitPlayer).getHandle().playerConnection.sendPacket(packet);
	}

	private void setField(String field, Object value) {
		try {
			Field fieldObject = packet.getClass().getDeclaredField(field);

			fieldObject.setAccessible(true);
			fieldObject.set(packet, value);
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	private void addAll(Collection col) {
		try {
			Field fieldObject = packet.getClass().getDeclaredField("g");

			fieldObject.setAccessible(true);
			((Collection) fieldObject.get(packet)).addAll(col);
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}

Filename: .\main\java\rip\diamond\practice\util\nametags\provider\DefaultNameTagProvider.java
package rip.diamond.practice.util.nametags.provider;

import org.bukkit.entity.Player;
import rip.diamond.practice.util.nametags.construct.NameTagInfo;

public class DefaultNameTagProvider extends NameTagProvider {

    public DefaultNameTagProvider() {
        super("Default Provider", 0);
    }

    @Override
    public NameTagInfo fetchNameTag(Player toRefresh, Player refreshFor) {
        return (createNameTag(toRefresh.getDisplayName().replace(toRefresh.getName(),""), ""));
    }

}


Filename: .\main\java\rip\diamond\practice\util\nametags\provider\NameTagProvider.java
package rip.diamond.practice.util.nametags.provider;

import lombok.AllArgsConstructor;
import lombok.Getter;
import org.bukkit.entity.Player;
import rip.diamond.practice.Eden;
import rip.diamond.practice.util.CC;
import rip.diamond.practice.util.nametags.construct.NameTagInfo;

@Getter
@AllArgsConstructor
public abstract class NameTagProvider {

    private final Eden plugin = Eden.INSTANCE;

    private final String name;
    private final int weight;

    public abstract NameTagInfo fetchNameTag(Player toRefresh, Player refreshFor);

    public NameTagInfo createNameTag(String prefix, String suffix) {
        return (plugin.getNameTagManager().getOrCreate(CC.translate(prefix), CC.translate(suffix)));
    }
}

Filename: .\main\java\rip\diamond\practice\util\option\FalseOption.java
package rip.diamond.practice.util.option;

import lombok.Getter;
import org.bukkit.entity.Player;
import rip.diamond.practice.config.Language;

@Getter
public class FalseOption extends Option {

    public FalseOption(boolean default_) {
        super(default_, Language.DISABLED.toString());
    }

    @Override
    public void run(Player player) {

    }

    @Override
    public boolean isEnabled() {
        return false;
    }

    @Override
    public String getValue() {
        return "false";
    }
}


Filename: .\main\java\rip\diamond\practice\util\option\Option.java
package rip.diamond.practice.util.option;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import org.bukkit.entity.Player;
import rip.diamond.practice.util.exception.PracticeUnexpectedException;

@Getter
@RequiredArgsConstructor
public abstract class Option {

    private final boolean default_;
    private final String name;

    @Override
    public boolean equals(Object obj) {
        return obj instanceof Option && ((Option) obj).getName().equals(name);
    }

    public abstract void run(Player player);

    public boolean isEnabled() {
        throw new PracticeUnexpectedException("isEnabled is not supported by Option class");
    }

    public abstract String getValue();

    @Override
    public String toString() {
        return getValue();
    }
}


Filename: .\main\java\rip\diamond\practice\util\option\TrueOption.java
package rip.diamond.practice.util.option;

import lombok.Getter;
import org.bukkit.entity.Player;
import rip.diamond.practice.config.Language;

@Getter
public class TrueOption extends Option {

    public TrueOption(boolean default_) {
        super(default_, Language.ENABLED.toString());
    }

    @Override
    public void run(Player player) {

    }

    @Override
    public boolean isEnabled() {
        return true;
    }

    @Override
    public String getValue() {
        return "true";
    }
}


Filename: .\main\java\rip\diamond\practice\util\serialization\BukkitSerialization.java
package rip.diamond.practice.util.serialization;

import org.bukkit.Bukkit;
import org.bukkit.inventory.Inventory;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.PlayerInventory;
import org.bukkit.util.io.BukkitObjectInputStream;
import org.bukkit.util.io.BukkitObjectOutputStream;
import org.yaml.snakeyaml.external.biz.base64Coder.Base64Coder;

import javax.imageio.ImageIO;
import java.awt.image.BufferedImage;
import java.awt.image.RenderedImage;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.UncheckedIOException;
import java.util.Base64;

public class BukkitSerialization {

    /**
     * Converts the player inventory to a String array of Base64 strings. First string is the content and second string is the armor.
     *
     * @param playerInventory to turn into an array of strings.
     * @return Array of strings: [ main content, armor content ]
     * @throws IllegalStateException
     */
    public static String[] playerInventoryToBase64(PlayerInventory playerInventory) throws IllegalStateException {
        //get the main content part, this doesn't return the armor
        String content = toBase64(playerInventory);
        String armor = itemStackArrayToBase64(playerInventory.getArmorContents());

        return new String[]{content, armor};
    }

    /**
     * A method to serialize an {@link ItemStack} array to Base64 String.
     * <p>
     * <p/>
     * <p>
     * Based off of {@link #toBase64(Inventory)}.
     *
     * @param items to turn into a Base64 String.
     * @return Base64 string of the items.
     */
    public static String itemStackArrayToBase64(ItemStack[] items) {
        try {
            ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
            BukkitObjectOutputStream dataOutput = new BukkitObjectOutputStream(outputStream);

            // Write the size of the inventory
            dataOutput.writeInt(items.length);

            // Save every element in the list
            for (int i = 0; i < items.length; i++) {
                dataOutput.writeObject(items[i]);
            }

            // Serialize that array
            dataOutput.close();
            return Base64Coder.encodeLines(outputStream.toByteArray());
        } catch (Exception e) {
            throw new IllegalStateException("Unable to save item stacks.", e);
        }
    }

    public static String itemStackToBase64(ItemStack item) {
        try {
            ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
            BukkitObjectOutputStream dataOutput = new BukkitObjectOutputStream(outputStream);

            // Save every element in the list
            dataOutput.writeObject(item);

            // Serialize that array
            dataOutput.close();
            return Base64Coder.encodeLines(outputStream.toByteArray());
        } catch (Exception e) {
            throw new IllegalStateException("Unable to save item stack.", e);
        }
    }

    /**
     * A method to serialize an inventory to Base64 string.
     * <p>
     * <p/>
     * <p>
     * Special thanks to Comphenix in the Bukkit forums or also known
     * as aadnk on GitHub.
     *
     * <a href="https://gist.github.com/aadnk/8138186">Original Source</a>
     *
     * @param inventory to serialize
     * @return Base64 string of the provided inventory
     * @throws IllegalStateException
     */
    public static String toBase64(Inventory inventory) {
        try {
            ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
            BukkitObjectOutputStream dataOutput = new BukkitObjectOutputStream(outputStream);

            // Write the size of the inventory
            dataOutput.writeInt(inventory.getSize());

            // Save every element in the list
            for (int i = 0; i < inventory.getSize(); i++) {
                dataOutput.writeObject(inventory.getItem(i));
            }

            // Serialize that array
            dataOutput.close();
            return Base64Coder.encodeLines(outputStream.toByteArray());
        } catch (Exception e) {
            throw new IllegalStateException("Unable to save item stacks.", e);
        }
    }

    /**
     * A method to get an {@link Inventory} from an encoded, Base64, string.
     * <p>
     * <p/>
     * <p>
     * Special thanks to Comphenix in the Bukkit forums or also known
     * as aadnk on GitHub.
     *
     * <a href="https://gist.github.com/aadnk/8138186">Original Source</a>
     *
     * @param data Base64 string of data containing an inventory.
     * @return Inventory created from the Base64 string.
     * @throws IOException
     */
    public static Inventory fromBase64(String data) {
        try {
            ByteArrayInputStream inputStream = new ByteArrayInputStream(Base64Coder.decodeLines(data));
            BukkitObjectInputStream dataInput = new BukkitObjectInputStream(inputStream);
            Inventory inventory = Bukkit.getServer().createInventory(null, dataInput.readInt());

            // Read the serialized inventory
            for (int i = 0; i < inventory.getSize(); i++) {
                inventory.setItem(i, (ItemStack) dataInput.readObject());
            }

            dataInput.close();
            return inventory;
        } catch (ClassNotFoundException | IOException e) {
            e.printStackTrace();
        }
        return null;
    }

    /**
     * Gets an array of ItemStacks from Base64 string.
     * <p>
     * <p/>
     * <p>
     * Base off of {@link #fromBase64(String)}.
     *
     * @param data Base64 string to convert to ItemStack array.
     * @return ItemStack array created from the Base64 string.
     * @throws IOException
     */
    public static ItemStack[] itemStackArrayFromBase64(String data) {
        try {
            ByteArrayInputStream inputStream = new ByteArrayInputStream(Base64Coder.decodeLines(data));
            BukkitObjectInputStream dataInput = new BukkitObjectInputStream(inputStream);
            ItemStack[] items = new ItemStack[dataInput.readInt()];

            // Read the serialized inventory
            for (int i = 0; i < items.length; i++) {
                items[i] = (ItemStack) dataInput.readObject();
            }

            dataInput.close();
            return items;
        } catch (ClassNotFoundException | IOException e) {
            e.printStackTrace();
        }
        return null;
    }

    public static ItemStack itemStackFromBase64(String data) {
        try {
            ByteArrayInputStream inputStream = new ByteArrayInputStream(Base64Coder.decodeLines(data));
            BukkitObjectInputStream dataInput = new BukkitObjectInputStream(inputStream);
            ItemStack item = (ItemStack) dataInput.readObject();

            dataInput.close();
            return item;
        } catch (ClassNotFoundException | IOException e) {
            e.printStackTrace();
        }
        return null;
    }

    public static String imgToBase64String(RenderedImage img, final String formatName) {
        final ByteArrayOutputStream os = new ByteArrayOutputStream();

        try {
            ImageIO.write(img, formatName, os);
            return Base64.getEncoder().encodeToString(os.toByteArray());
        } catch (IOException ioe) {
            throw new UncheckedIOException(ioe);
        }
    }

    public static BufferedImage base64StringToImg(final String base64String) {
        try {
            return ImageIO.read(new ByteArrayInputStream(Base64.getDecoder().decode(base64String)));
        } catch (final IOException ioe) {
            throw new UncheckedIOException(ioe);
        }
    }
}


Filename: .\main\java\rip\diamond\practice\util\serialization\EffectSerialization.java
package rip.diamond.practice.util.serialization;


import org.bukkit.potion.PotionEffect;
import org.bukkit.potion.PotionEffectType;

import java.util.ArrayList;
import java.util.Collection;

public class EffectSerialization {

    public static String serializeEffects(Collection<PotionEffect> effects) {
        StringBuilder builder = new StringBuilder();
        for (PotionEffect potionEffect : effects) {
            builder.append(serializePotionEffect(potionEffect));
            builder.append(";");
        }
        return builder.toString();
    }

    public static Collection<PotionEffect> deserializeEffects(String source) {
        if (!source.contains(":")) {
            return new ArrayList<>();
        }
        Collection<PotionEffect> effects = new ArrayList<>();
        String[] split = source.split(";");

        for (String piece : split) {
            effects.add(deserializePotionEffect(piece));
        }

        return effects;
    }

    public static String serializePotionEffect(PotionEffect potionEffect) {
        StringBuilder builder = new StringBuilder();

        if (potionEffect == null) {
            return "null";
        }
        String name = potionEffect.getType().getName();
        builder.append("n@").append(name);

        String duration = String.valueOf(potionEffect.getDuration());
        builder.append(":d@").append(String.valueOf(duration));

        String amplifier = String.valueOf(potionEffect.getAmplifier());
        builder.append(":a@").append(amplifier);

        return builder.toString();
    }

    public static PotionEffect deserializePotionEffect(String source) {
        String name = "";
        String duration = "";
        String amplifier = "";

        if (source.equals("null")) {
            return null;
        }
        String[] split = source.split(":");

        for (String effectInfo : split) {
            String[] itemAttribute = effectInfo.split("@");
            String s2 = itemAttribute[0];

            if (s2.equalsIgnoreCase("n")) {
                name = itemAttribute[1];
            }
            if (s2.equalsIgnoreCase("d")) {
                duration = itemAttribute[1];
            }
            if (s2.equalsIgnoreCase("a")) {
                amplifier = itemAttribute[1];
            }
        }
        return new PotionEffect(PotionEffectType.getByName(name), Integer.parseInt(duration), Integer.parseInt(amplifier));
    }
}


Filename: .\main\java\rip\diamond\practice\util\serialization\LocationSerialization.java
package rip.diamond.practice.util.serialization;

import org.bukkit.Bukkit;
import org.bukkit.Location;
import org.bukkit.World;
import org.bukkit.WorldCreator;
import rip.diamond.practice.Eden;
import rip.diamond.practice.config.Language;
import rip.diamond.practice.util.CC;

public class LocationSerialization {

    public static Location deserializeLocation(String input) {
        if (input == null || input.equals("null")) {
            return null;
        }
        String[] attributes = input.split(":");

        World world = null;
        Double x = null;
        Double y = null;
        Double z = null;
        Float pitch = null;
        Float yaw = null;

        for (String attribute : attributes) {
            String[] split = attribute.split(";");

            if (split[0].equalsIgnoreCase("#w")) {
                if (Bukkit.getWorld(split[1]) == null) {
                    world = Bukkit.createWorld(new WorldCreator(split[1]));
                } else {
                    world = Bukkit.getWorld(split[1]);
                }
                continue;
            }

            if (split[0].equalsIgnoreCase("#x")) {
                x = Double.parseDouble(split[1]);
                continue;
            }

            if (split[0].equalsIgnoreCase("#y")) {
                y = Double.parseDouble(split[1]);
                continue;
            }

            if (split[0].equalsIgnoreCase("#z")) {
                z = Double.parseDouble(split[1]);
                continue;
            }

            if (split[0].equalsIgnoreCase("#p")) {
                pitch = Float.parseFloat(split[1]);
                continue;
            }

            if (split[0].equalsIgnoreCase("#yaw")) {
                yaw = Float.parseFloat(split[1]);
            }
        }

        if (world == null || x == null || y == null || z == null || pitch == null || yaw == null) {
            return null;
        }

        return new Location(world, x, y, z, yaw, pitch);
    }

    public static String serializeLocation(Location location) {
        if (location == null) {
            return "null";
        }
        return "#w;" + location.getWorld().getName() +
                ":#x;" + location.getX() +
                ":#y;" + location.getY() +
                ":#z;" + location.getZ() +
                ":#p;" + location.getPitch() +
                ":#yaw;" + location.getYaw();
    }

    public static String toReadable(Location location) {
        if (location == null) {
            return Language.LOCATION_NOT_FOUND.toString();
        }
        return CC.AQUA + "X: " + CC.GREEN + Eden.DECIMAL.format(location.getX()) + CC.AQUA + " Y: " + CC.GREEN + Eden.DECIMAL.format(location.getY()) + CC.AQUA + " Z: " + CC.GREEN + Eden.DECIMAL.format(location.getZ()) + CC.AQUA + " Pitch: " + CC.GREEN + Eden.DECIMAL.format(location.getPitch()) + CC.AQUA + " Yaw: " + CC.GREEN + Eden.DECIMAL.format(location.getYaw());
    }
}


Filename: .\main\java\rip\diamond\practice\util\tablist\ImanityTabAdapter.java
/*
 * MIT License
 *
 * Copyright (c) 2021 Imanity
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

package rip.diamond.practice.util.tablist;

import org.bukkit.entity.Player;
import rip.diamond.practice.util.tablist.util.BufferedTabObject;

import java.util.Set;

public interface ImanityTabAdapter {

    Set<BufferedTabObject> getSlots(Player player);

    String getFooter(Player player);

    String getHeader(Player player);

}


Filename: .\main\java\rip\diamond\practice\util\tablist\ImanityTabHandler.java
/*
 * MIT License
 *
 * Copyright (c) 2021 Imanity
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

package rip.diamond.practice.util.tablist;

import com.comphenix.protocol.PacketType;
import com.comphenix.protocol.ProtocolLibrary;
import com.comphenix.protocol.events.PacketAdapter;
import com.comphenix.protocol.events.PacketEvent;
import com.google.common.util.concurrent.ThreadFactoryBuilder;
import lombok.Getter;
import org.bukkit.Bukkit;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.Listener;
import org.bukkit.event.player.PlayerJoinEvent;
import org.bukkit.event.player.PlayerQuitEvent;
import rip.diamond.practice.Eden;
import rip.diamond.practice.config.Config;
import rip.diamond.practice.util.Checker;
import rip.diamond.practice.util.Common;
import rip.diamond.practice.util.tablist.util.IImanityTabImpl;
import rip.diamond.practice.util.tablist.util.impl.ProtocolLibTabImpl;
import rip.diamond.practice.util.tablist.util.packet.WrapperPlayServerLogin;

import java.util.HashMap;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

@Getter
public class ImanityTabHandler {

    private static final Map<UUID, ImanityTablist> tablists = new HashMap<>();

    private final ImanityTabAdapter adapter;
    private ScheduledExecutorService thread;
    private IImanityTabImpl implementation;

    private PacketAdapter protocolListener;

    //Tablist Ticks
    private final long ticks;

    public ImanityTabHandler(ImanityTabAdapter adapter) {
        this.adapter = adapter;

        this.ticks = Config.FANCY_TABLIST_UPDATE_TICKS.toInteger();

        this.registerImplementation();
        this.setup();
    }

    private void registerImplementation() {
        if (Checker.isPluginEnabled("ProtocolLib")) {
            this.implementation = new ProtocolLibTabImpl();
        } else {
            Common.log("Cannot enable tablist implementation because ProtocolLib isn't enabled!");
        }
    }

    public void registerPlayerTablist(Player player) {
        ImanityTablist tablist = new ImanityTablist(player);
        tablists.put(player.getUniqueId(), tablist);
    }

    public void removePlayerTablist(Player player) {
        tablists.remove(player.getUniqueId());
    }

    private void setup() {
        //Ensure that the thread has stopped running
        if (this.thread != null) {
            this.thread.shutdown();
            this.thread = null;
        }

        // To ensure client will display 60 slots on 1.7
        if (Bukkit.getMaxPlayers() < 60) {
            protocolListener = new PacketAdapter(Eden.INSTANCE, PacketType.Play.Server.LOGIN) {
                @Override
                public void onPacketSending(PacketEvent event) {
                    WrapperPlayServerLogin packet = new WrapperPlayServerLogin(event.getPacket());
                    packet.setMaxPlayers(60);
                    event.setPacket(packet.getHandle());
                }
            };
            ProtocolLibrary.getProtocolManager().addPacketListener(protocolListener);
        }

        Eden.INSTANCE.getServer().getPluginManager().registerEvents(new Listener() {
            @EventHandler
            public void onJoin(PlayerJoinEvent event) {
                registerPlayerTablist(event.getPlayer());
            }
            @EventHandler
            public void onLeave(PlayerQuitEvent event) {
                removePlayerTablist(event.getPlayer());
            }
        }, Eden.INSTANCE);

        //Start Thread
        this.thread = Executors.newSingleThreadScheduledExecutor(new ThreadFactoryBuilder()
                .setNameFormat("Imanity-Tablist-Thread")
                .setDaemon(true)
                .setUncaughtExceptionHandler((thread1, throwable) -> throwable.printStackTrace())
            .build());

        this.thread.scheduleAtFixedRate(() -> {
            for (Player player : Bukkit.getOnlinePlayers()) {
                ImanityTablist tablist = tablists.get(player.getUniqueId());

                if (tablist != null) {
                    try {
                        tablist.update();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                    }
                }
            }
        }, ticks * 50L, ticks * 50L, TimeUnit.MILLISECONDS);
    }

    public void stop() {
        if (this.thread != null) {
            this.thread.shutdown();
            this.thread = null;
        }
        if (this.protocolListener != null) {
            ProtocolLibrary.getProtocolManager().removePacketListener(protocolListener);
        }
    }
}


Filename: .\main\java\rip\diamond\practice\util\tablist\ImanityTablist.java
/*
 * MIT License
 *
 * Copyright (c) 2021 Imanity
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

package rip.diamond.practice.util.tablist;

import lombok.Getter;
import org.bukkit.ChatColor;
import org.bukkit.entity.Player;
import rip.diamond.practice.Eden;
import rip.diamond.practice.util.CC;
import rip.diamond.practice.util.tablist.util.*;

import java.util.Collections;
import java.util.HashSet;
import java.util.Set;

@Getter
public class ImanityTablist {

    private final Player player;
    private final Set<TabEntry> currentEntries = new HashSet<>();

    private String header;
    private String footer;

    public ImanityTablist(Player player) {
        this.player = player;
        this.setup();
    }

    private void setup() {
        final int possibleSlots = TablistUtil.getPossibleSlots(player);

        for (int i = 1; i <= possibleSlots; i++) {
            final TabColumn tabColumn = TabColumn.getFromSlot(player, i);
            if (tabColumn == null) {
                continue;
            }

            TabEntry tabEntry = Eden.INSTANCE.getTabHandler().getImplementation().createFakePlayer(
                    this,
                    "0" + (i > 9 ? i : "0" + i) + "|Tab",
                    tabColumn,
                    tabColumn.getNumb(player, i),
                    i
            );
            if (TablistUtil.getProtocolVersion(player) == 4 || TablistUtil.getProtocolVersion(player) == 5) {
                TablistUtil.sendTeam(
                        player,
                        LegacyClientUtil.name(i - 1),
                        "",
                        "",
                        Collections.singleton(LegacyClientUtil.entry(i - 1)),
                        0
                );
            }
            currentEntries.add(tabEntry);
        }
    }

    public void update() {
        ImanityTabAdapter adapter = Eden.INSTANCE.getTabHandler().getAdapter();

        Set<TabEntry> previous = new HashSet<>(currentEntries);

        Set<BufferedTabObject> processedObjects = adapter.getSlots(player);
        if (processedObjects == null) {
            processedObjects = new HashSet<>();
        }

        for (BufferedTabObject scoreObject : processedObjects) {
            TabEntry tabEntry = getEntry(scoreObject.getColumn(), scoreObject.getSlot());
            if (tabEntry != null) {
                previous.remove(tabEntry);
                Eden.INSTANCE.getTabHandler().getImplementation().updateFakeLatency(this, tabEntry, scoreObject.getPing());
                Eden.INSTANCE.getTabHandler().getImplementation().updateFakeName(this, tabEntry, scoreObject.getText());
                if (TablistUtil.getProtocolVersion(player) > 5 && !tabEntry.getTexture().toString().equals(scoreObject.getSkin().toString())) {
                    Eden.INSTANCE.getTabHandler().getImplementation().updateFakeSkin(this, tabEntry, scoreObject.getSkin());
                }
            }
        }

        for (TabEntry tabEntry : previous) {
            Eden.INSTANCE.getTabHandler().getImplementation().updateFakeName(this, tabEntry, "");
            Eden.INSTANCE.getTabHandler().getImplementation().updateFakeLatency(this, tabEntry, 0);
            if (TablistUtil.getProtocolVersion(player) > 5) {
                Eden.INSTANCE.getTabHandler().getImplementation().updateFakeSkin(this, tabEntry, Skin.GRAY);
            }
        }

        previous.clear();

        String headerNow = adapter.getHeader(player);
        String footerNow = adapter.getFooter(player);

        if (headerNow != null && footerNow != null) {
            if (!headerNow.equals(this.header) || !footerNow.equals(this.footer)) {
                this.header = CC.translate(headerNow);
                this.footer = CC.translate(footerNow);
                Eden.INSTANCE.getTabHandler().getImplementation().updateHeaderAndFooter(this, headerNow, footerNow);
            }
        }
    }

    public TabEntry getEntry(TabColumn column, Integer slot){
        for (TabEntry entry : currentEntries){
            if (entry.getColumn().name().equalsIgnoreCase(column.name()) && entry.getSlot() == slot){
                return entry;
            }
        }
        return null;
    }

    public static String[] splitStrings(String text, int rawSlot) {
        if (text.length() > 16) {
            String prefix = text.substring(0, 16);
            String suffix;

            if (prefix.charAt(15) == ChatColor.COLOR_CHAR || prefix.charAt(15) == '&') {
                prefix = prefix.substring(0, 15);
                suffix = text.substring(15);
            } else if (prefix.charAt(14) == ChatColor.COLOR_CHAR || prefix.charAt(14) == '&') {
                prefix = prefix.substring(0, 14);
                suffix = text.substring(14);
            } else {
                suffix = ChatColor.getLastColors(ChatColor.translateAlternateColorCodes('&',prefix)) + text.substring(16, text.length());
            }

            if (suffix.length() > 16) {
                suffix = suffix.substring(0, 16);
            }

            //Bukkit.broadcastMessage(prefix + " |||| " + suffix);
            return new String[] {
                    prefix,
                    suffix
            };
        } else {
            return new String[] {
                    text
            };
        }
    }
}

Filename: .\main\java\rip\diamond\practice\util\tablist\util\BufferedTabObject.java
/*
 * MIT License
 *
 * Copyright (c) 2021 Imanity
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

package rip.diamond.practice.util.tablist.util;

import lombok.Getter;
import org.bukkit.entity.Player;

@Getter
public class BufferedTabObject {
    private TabColumn column;
    private Integer ping;
    private int slot;
    private String text;
    private Skin skin;

    public BufferedTabObject() {
        this.column = TabColumn.LEFT;
        this.ping = 0;
        this.slot = 1;
        this.text = "";
        this.skin = Skin.GRAY;
    }

    public BufferedTabObject text(String text) {
        this.text = text;
        return this;
    }

    public BufferedTabObject skin(Skin skin) {
        this.skin = skin;
        return this;
    }

    public BufferedTabObject slot(Integer slot) {
        this.slot = slot;
        return this;
    }

    public BufferedTabObject rawSlot(Player player, Integer slot) {
        this.slot = (slot % 20) + 1;
        this.column = TabColumn.getFromSlot(player, slot + 1);
        return this;
    }

    public BufferedTabObject ping(Integer ping) {
        this.ping = ping;
        return this;
    }

    public BufferedTabObject column(TabColumn tabColumn) {
        this.column = tabColumn;
        return this;
    }
}


Filename: .\main\java\rip\diamond\practice\util\tablist\util\IImanityTabImpl.java
/*
 * MIT License
 *
 * Copyright (c) 2021 Imanity
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

package rip.diamond.practice.util.tablist.util;

import org.bukkit.entity.Player;
import rip.diamond.practice.util.tablist.ImanityTablist;

public interface IImanityTabImpl {

    default void removeSelf(Player player) {}

    void registerLoginListener();

    TabEntry createFakePlayer(ImanityTablist imanityTablist, String string, TabColumn column, Integer slot, Integer rawSlot);

    void updateFakeName(ImanityTablist imanityTablist, TabEntry tabEntry, String text);

    void updateFakeLatency(ImanityTablist imanityTablist, TabEntry tabEntry, Integer latency);

    void updateFakeSkin(ImanityTablist imanityTablist, TabEntry tabEntry, Skin skin);

    void updateHeaderAndFooter(ImanityTablist imanityTablist, String header, String footer);
}


Filename: .\main\java\rip\diamond\practice\util\tablist\util\LegacyClientUtil.java
/*
 * MIT License
 *
 * Copyright (c) 2021 Imanity
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

package rip.diamond.practice.util.tablist.util;

import org.bukkit.ChatColor;

import java.util.ArrayList;
import java.util.List;

public class LegacyClientUtil {

    private static final String[] TAB_ENTRIES;
    private static final String[] TEAM_NAMES;

    static {
        List<String> list = new ArrayList<>();
        for (int i = 1; i <= 15; i++) {
            String entry = ChatColor.values()[i].toString();
            list.add(ChatColor.RED + entry);
            list.add(ChatColor.GREEN + entry);
            list.add(ChatColor.DARK_RED + entry);
            list.add(ChatColor.DARK_GREEN + entry);
            list.add(ChatColor.BLUE + entry);
            list.add(ChatColor.DARK_BLUE + entry);
        }
        TAB_ENTRIES = list.toArray(new String[0]);

        list = new ArrayList<>();
        for (int i = 0; i < 80; i++) {
            String s = (i < 10 ? "\\u00010" : "\\u0001") + i;
            list.add(s);
        }
        TEAM_NAMES = list.toArray(new String[0]);
    }

    public static String entry(int rawSlot) {
        return TAB_ENTRIES[rawSlot];
    }

    public static String name(int rawSlot) {
        return TEAM_NAMES[rawSlot];
    }
}


Filename: .\main\java\rip\diamond\practice\util\tablist\util\Skin.java
/*
 * MIT License
 *
 * Copyright (c) 2020 - 2020 Imanity
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

package rip.diamond.practice.util.tablist.util;

import com.github.benmanes.caffeine.cache.CacheLoader;
import com.github.benmanes.caffeine.cache.Caffeine;
import com.github.benmanes.caffeine.cache.LoadingCache;
import com.mojang.authlib.GameProfile;
import com.mojang.authlib.properties.Property;
import lombok.RequiredArgsConstructor;
import lombok.Setter;
import net.minecraft.server.v1_8_R3.EntityPlayer;
import org.bukkit.Bukkit;
import org.bukkit.craftbukkit.v1_8_R3.entity.CraftPlayer;
import org.bukkit.entity.Player;
import org.checkerframework.checker.nullness.qual.NonNull;
import org.checkerframework.checker.nullness.qual.Nullable;

import java.util.Objects;
import java.util.concurrent.TimeUnit;

@Setter
@RequiredArgsConstructor
public class Skin {

    private static final LoadingCache<String, Skin> SKIN_CACHE = Caffeine.newBuilder()
            .expireAfterAccess(60L, TimeUnit.SECONDS)
            .initialCapacity(60)
            .build(new CacheLoader<String, Skin>() {
                @Override
                public @Nullable Skin load(@NonNull String s) {
                    Player player = Bukkit.getPlayer(s);
                    if (player != null) {
                        EntityPlayer playerNMS = ((CraftPlayer) player).getHandle();
                        GameProfile profile = playerNMS.getProfile();

                        if (!profile.getProperties().get("textures").isEmpty()) {
                            Property property = profile.getProperties().get("textures").iterator().next();
                            String texture = property.getValue();
                            String signature = property.getSignature();

                            return new Skin(texture, signature);
                        }
                        return null;
                    }
                    return null;
                }
            });

    public static Skin GRAY = new Skin(
            "eyJ0aW1lc3RhbXAiOjE0MTEyNjg3OTI3NjUsInByb2ZpbGVJZCI6IjNmYmVjN2RkMGE1ZjQwYmY5ZDExODg1YTU0NTA3MTEyIiwicHJvZmlsZU5hbWUiOiJsYXN0X3VzZXJuYW1lIiwidGV4dHVyZXMiOnsiU0tJTiI6eyJ1cmwiOiJodHRwOi8vdGV4dHVyZXMubWluZWNyYWZ0Lm5ldC90ZXh0dXJlLzg0N2I1Mjc5OTg0NjUxNTRhZDZjMjM4YTFlM2MyZGQzZTMyOTY1MzUyZTNhNjRmMzZlMTZhOTQwNWFiOCJ9fX0=",
            "u8sG8tlbmiekrfAdQjy4nXIcCfNdnUZzXSx9BE1X5K27NiUvE1dDNIeBBSPdZzQG1kHGijuokuHPdNi/KXHZkQM7OJ4aCu5JiUoOY28uz3wZhW4D+KG3dH4ei5ww2KwvjcqVL7LFKfr/ONU5Hvi7MIIty1eKpoGDYpWj3WjnbN4ye5Zo88I2ZEkP1wBw2eDDN4P3YEDYTumQndcbXFPuRRTntoGdZq3N5EBKfDZxlw4L3pgkcSLU5rWkd5UH4ZUOHAP/VaJ04mpFLsFXzzdU4xNZ5fthCwxwVBNLtHRWO26k/qcVBzvEXtKGFJmxfLGCzXScET/OjUBak/JEkkRG2m+kpmBMgFRNtjyZgQ1w08U6HHnLTiAiio3JswPlW5v56pGWRHQT5XWSkfnrXDalxtSmPnB5LmacpIImKgL8V9wLnWvBzI7SHjlyQbbgd+kUOkLlu7+717ySDEJwsFJekfuR6N/rpcYgNZYrxDwe4w57uDPlwNL6cJPfNUHV7WEbIU1pMgxsxaXe8WSvV87qLsR7H06xocl2C0JFfe2jZR4Zh3k9xzEnfCeFKBgGb4lrOWBu1eDWYgtKV67M2Y+B3W5pjuAjwAxn0waODtEn/3jKPbc/sxbPvljUCw65X+ok0UUN1eOwXV5l2EGzn05t3Yhwq19/GxARg63ISGE8CKw="
    );

    public final String skinValue;
    public final String skinSignature;

    @Override
    public String toString() {
        return skinSignature + skinValue;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        Skin skin = (Skin) o;

        if (!Objects.equals(skinValue, skin.skinValue)) return false;
        return Objects.equals(skinSignature, skin.skinSignature);
    }

    @Override
    public int hashCode() {
        int result = skinValue != null ? skinValue.hashCode() : 0;
        result = 31 * result + (skinSignature != null ? skinSignature.hashCode() : 0);
        return result;
    }

    public static Skin fromPlayer(Player player) {
        Skin skin = SKIN_CACHE.get(player.getName());

        if (skin == null) {
            EntityPlayer playerNMS = ((CraftPlayer) player).getHandle();
            GameProfile profile = playerNMS.getProfile();

            if (!profile.getProperties().get("textures").isEmpty()) {
                Property property = profile.getProperties().get("textures").iterator().next();
                skin = new Skin(property.getValue(), property.getSignature());
                SKIN_CACHE.put(player.getName(), skin);
                return skin;
            }
        }

        return skin == null ? Skin.GRAY : skin;
    }
}


Filename: .\main\java\rip\diamond\practice\util\tablist\util\TabColumn.java
/*
 * MIT License
 *
 * Copyright (c) 2021 Imanity
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

package rip.diamond.practice.util.tablist.util;

import lombok.Getter;
import org.bukkit.entity.Player;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

@Getter
public enum TabColumn {

    LEFT(0,"Left", -2, 1, 3),
    MIDDLE(1,"Middle", -1, 21, 3),
    RIGHT(2,"Right", 0, 41, 3),
    /**
     * Far Right Column
     * Note: This Column is only visible on 1.8+ player versions.
     */
    FAR_RIGHT(3,"Far-Right", 60, 61, 1);

    private int startNumber;
    private int incrementBy;
    private int rawStart;
    private List<Integer> numbers = new ArrayList<>();
    private String identifier;
    private int ordinal;

    TabColumn(int ordinal, String identifier, int rawStart, int startNumber, int incrementBy){
        this.ordinal = ordinal;
        this.identifier = identifier;
        this.rawStart = rawStart;
        this.startNumber = startNumber;
        this.incrementBy = incrementBy;
        generate();
    }

    public static TabColumn getColumn(String identifier){
        for (TabColumn tabColumn : TabColumn.values()){
            if (tabColumn.getIdentifier().equalsIgnoreCase(identifier)){
                return tabColumn;
            }
        }
        return null;
    }

    private void generate(){
        for (int i = 1; i <= 20; i++){
            Integer numb = rawStart + (i * incrementBy);
            this.numbers.add(numb);
        }
    }

    public static TabColumn getFromSlot(Player player, Integer slot) {
        /* Player Version 1.7 */
        if (TablistUtil.getProtocolVersion(player) == 4 || TablistUtil.getProtocolVersion(player) == 5) {
            return Arrays.stream(TabColumn.values())
                    .filter(tabColumn -> tabColumn.getNumbers().contains(slot))
                    .findFirst().get();
            /* Player Version 1.8+ */
        } else {
            /* Left Column */
            if (isBetween(slot, 1, 20)) return LEFT;
            /* Middle Column */
            if (isBetween(slot, 21, 40)) return MIDDLE;
            /* Right Column */
            if (isBetween(slot, 41, 60)) return RIGHT;
            /* Far Right Column */
            if (isBetween(slot, 61, 80)) return FAR_RIGHT;
            return null;
        }
    }

    public Integer getNumb(Player player, int raw){
        /* Check if the Player is not a 1.7 User */
        if (TablistUtil.getProtocolVersion(player) > 5) {
            return raw - startNumber + 1;
        }
        int number = 0;
        for (int integer : numbers) {
            number++;
            if (integer == raw) {
                return number;
            }
        }
        return number;
    }

    public static TabColumn getFromOrdinal(int ordinal){
        for (TabColumn column : TabColumn.values()) {
            if (column.getOrdinal() == ordinal) {
                return column;
            }
        }
        return null;
    }

    private static boolean isBetween(int base, int from, int to) {
        return from <= base && base <= to;
    }

}



Filename: .\main\java\rip\diamond\practice\util\tablist\util\TabEntry.java
/*
 * MIT License
 *
 * Copyright (c) 2021 Imanity
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

package rip.diamond.practice.util.tablist.util;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;
import rip.diamond.practice.util.tablist.ImanityTablist;

import java.util.UUID;

@Getter @Setter @AllArgsConstructor
public class TabEntry {

    private String id;
    private UUID uuid;
    private String text;
    private ImanityTablist tab;
    private Skin texture;
    private TabColumn column;
    private int slot; //slot means 1-20 + TabColumn.startNumber
    private int rawSlot; //rawSlot means 1-80
    private int latency;

}


Filename: .\main\java\rip\diamond\practice\util\tablist\util\TablistUtil.java
package rip.diamond.practice.util.tablist.util;

import com.viaversion.viaversion.api.Via;
import org.bukkit.Bukkit;
import org.bukkit.entity.Player;
import org.bukkit.plugin.PluginManager;
import rip.diamond.practice.util.Common;
import rip.diamond.practice.util.tablist.util.packet.WrapperPlayServerScoreboardTeam;

import java.util.Collection;

public class TablistUtil {

    /**
     * Get the protocol version of the client.
     * <br>
     * Had to be made because 1.8+ doesn't have a NetworkManager#getVersion method, which is required for legacy support on tab.
     *
     * @param player the player to get the version of
     * @return the version, or -1 if none of the plugins are supported.
     */
    public static int getProtocolVersion(Player player) {
        final PluginManager pluginManager = Bukkit.getPluginManager();

        if (pluginManager.getPlugin("ViaVersion") != null) {
            return Via.getAPI().getPlayerVersion(player.getUniqueId());
        } /*else if(pluginManager.getPlugin("ProtocolSupport") != null) {
            return ProtocolSupportAPI.getProtocolVersion(player).getId();
        }*/

        return -1;
    }

    public static void sendTeam(Player player, String name, String prefix, String suffix, Collection<String> nameSet, int type) {
        WrapperPlayServerScoreboardTeam packet = new WrapperPlayServerScoreboardTeam();

        packet.setTeamName(name);
        packet.setTeamDisplayName("");
        packet.setTeamPrefix(prefix);
        packet.setTeamSuffix(suffix);
        packet.setPlayers(nameSet);
        packet.setPacketMode(type);

        packet.sendPacket(player);
    }

    public static int getPossibleSlots(Player player) {
        return getProtocolVersion(player) == 4 || getProtocolVersion(player) == 5 ? 60 : 80;
    }

}


Filename: .\main\java\rip\diamond\practice\util\tablist\util\impl\ProtocolLibTabImpl.java
/*
 * MIT License
 *
 * Copyright (c) 2021 Imanity
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

package rip.diamond.practice.util.tablist.util.impl;

import com.comphenix.protocol.PacketType;
import com.comphenix.protocol.ProtocolLibrary;
import com.comphenix.protocol.events.PacketAdapter;
import com.comphenix.protocol.events.PacketContainer;
import com.comphenix.protocol.events.PacketEvent;
import com.comphenix.protocol.wrappers.*;
import org.bukkit.ChatColor;
import org.bukkit.entity.Player;
import rip.diamond.practice.Eden;
import rip.diamond.practice.util.CC;
import rip.diamond.practice.util.tablist.ImanityTablist;
import rip.diamond.practice.util.tablist.util.*;

import java.lang.reflect.InvocationTargetException;
import java.util.Collections;
import java.util.UUID;

public class ProtocolLibTabImpl implements IImanityTabImpl {

    public ProtocolLibTabImpl() {
    }

    @Override
    public void registerLoginListener() {
        ProtocolLibrary.getProtocolManager().addPacketListener(new PacketAdapter(Eden.INSTANCE, PacketType.Play.Server.LOGIN) {
            @Override
            public void onPacketSending(PacketEvent event) {
                event.getPacket().getIntegers().write(2, 60);
            }
        });
    }

    @Override
    public TabEntry createFakePlayer(ImanityTablist tablist, String string, TabColumn column, Integer slot, Integer rawSlot) {
        UUID uuid = UUID.randomUUID();
        final Player player = tablist.getPlayer();
        final int protocolVersion = TablistUtil.getProtocolVersion(player);

        PacketContainer packet = ProtocolLibrary.getProtocolManager().createPacket(PacketType.Play.Server.PLAYER_INFO);
        packet.getPlayerInfoAction().write(0, EnumWrappers.PlayerInfoAction.ADD_PLAYER);
        WrappedGameProfile profile = new WrappedGameProfile(uuid, protocolVersion > 5  ? string : LegacyClientUtil.entry(rawSlot - 1) + "");
        PlayerInfoData playerInfoData = new PlayerInfoData(profile, 1, EnumWrappers.NativeGameMode.SURVIVAL, WrappedChatComponent.fromText(protocolVersion > 5 ?  "" : profile.getName()));
        if (protocolVersion > 5) {
            playerInfoData.getProfile().getProperties().put("texture", new WrappedSignedProperty("textures", Skin.GRAY.skinValue, Skin.GRAY.skinSignature));
        }
        packet.getPlayerInfoDataLists().write(0, Collections.singletonList(playerInfoData));
        sendPacket(player, packet);
        return new TabEntry(string, uuid, "", tablist, Skin.GRAY, column, slot, rawSlot, 10000); //Lunar Client will not display ping icon when the object ping is over 10000
    }

    @Override
    public void updateFakeName(ImanityTablist tablist, TabEntry tabEntry, String text) {
        if (tabEntry.getText().equals(text)) {
            return;
        }

        final Player player = tablist.getPlayer();
        final int protocolVersion = TablistUtil.getProtocolVersion(player);
        String[] newStrings = ImanityTablist.splitStrings(text, tabEntry.getRawSlot());
        if (protocolVersion == 4 || protocolVersion == 5) {
            TablistUtil.sendTeam(
                    player,
                    LegacyClientUtil.name(tabEntry.getRawSlot() - 1),
                    CC.translate(newStrings[0]),
                    newStrings.length > 1 ? CC.translate(newStrings[1]) : "",
                    Collections.singleton(LegacyClientUtil.entry(tabEntry.getRawSlot() - 1)),
                    2
            );
        } else {
            PacketContainer packet = ProtocolLibrary.getProtocolManager().createPacket(PacketType.Play.Server.PLAYER_INFO);
            packet.getPlayerInfoAction().write(0, EnumWrappers.PlayerInfoAction.UPDATE_DISPLAY_NAME);
            WrappedGameProfile profile = new WrappedGameProfile(
                    tabEntry.getUuid(),
                    tabEntry.getId()
            );
            PlayerInfoData playerInfoData = new PlayerInfoData(
                    profile,
                    1,
                    EnumWrappers.NativeGameMode.SURVIVAL,
                    WrappedChatComponent.fromText(ChatColor.translateAlternateColorCodes('&', newStrings.length > 1 ? newStrings[0] + newStrings[1] : newStrings[0]))
            );
            packet.getPlayerInfoDataLists().write(0, Collections.singletonList(playerInfoData));
            sendPacket(player, packet);
        }
        tabEntry.setText(text);
    }

    @Override
    public void updateFakeLatency(ImanityTablist tablist, TabEntry tabEntry, Integer latency) {
        if (tabEntry.getLatency() == latency) {
            return;
        }

        PacketContainer packet = ProtocolLibrary.getProtocolManager().createPacket(PacketType.Play.Server.PLAYER_INFO);
        packet.getPlayerInfoAction().write(0, EnumWrappers.PlayerInfoAction.UPDATE_LATENCY);

        WrappedGameProfile profile = new WrappedGameProfile(
                tabEntry.getUuid(),
                tabEntry.getId()
        );

        PlayerInfoData playerInfoData = new PlayerInfoData(
                profile,
                latency,
                EnumWrappers.NativeGameMode.SURVIVAL,
                WrappedChatComponent.fromText(ChatColor.translateAlternateColorCodes('&', tabEntry.getText()))
        );

        packet.getPlayerInfoDataLists().write(0, Collections.singletonList(playerInfoData));
        sendPacket(tablist.getPlayer(), packet);
        tabEntry.setLatency(latency);
    }

    @Override
    public void updateFakeSkin(ImanityTablist tablist, TabEntry tabEntry, Skin skin) {
        if (tabEntry.getTexture() == skin) {
            return;
        }

        final Player player = tablist.getPlayer();
        final int protocolVersion = TablistUtil.getProtocolVersion(player);

        WrappedGameProfile profile = new WrappedGameProfile(tabEntry.getUuid(), protocolVersion > 5  ? tabEntry.getId() : LegacyClientUtil.entry(tabEntry.getRawSlot() - 1) + "");
        PlayerInfoData playerInfoData = new PlayerInfoData(profile, 1, EnumWrappers.NativeGameMode.SURVIVAL, WrappedChatComponent.fromText(tabEntry.getText()));

        if (protocolVersion > 5) {
            playerInfoData.getProfile().getProperties().put("texture", new WrappedSignedProperty("textures", skin.skinValue, skin.skinSignature));
        }

        PacketContainer remove = ProtocolLibrary.getProtocolManager().createPacket(PacketType.Play.Server.PLAYER_INFO);
        remove.getPlayerInfoAction().write(0, EnumWrappers.PlayerInfoAction.REMOVE_PLAYER);
        remove.getPlayerInfoDataLists().write(0, Collections.singletonList(playerInfoData));


        PacketContainer add = ProtocolLibrary.getProtocolManager().createPacket(PacketType.Play.Server.PLAYER_INFO);
        add.getPlayerInfoAction().write(0, EnumWrappers.PlayerInfoAction.ADD_PLAYER);
        add.getPlayerInfoDataLists().write(0, Collections.singletonList(playerInfoData));

        sendPacket(player, remove);
        sendPacket(player, add);

        tabEntry.setTexture(skin);
    }

    @Override
    public void updateHeaderAndFooter(ImanityTablist tablist, String header, String footer) {
        PacketContainer headerAndFooter = new PacketContainer(PacketType.Play.Server.PLAYER_LIST_HEADER_FOOTER);

        final Player player = tablist.getPlayer();
        final int protocolVersion = TablistUtil.getProtocolVersion(player);

        if (protocolVersion > 5) {

            headerAndFooter.getChatComponents().write(0, WrappedChatComponent.fromText(header));
            headerAndFooter.getChatComponents().write(1, WrappedChatComponent.fromText(footer));

            sendPacket(player, headerAndFooter);
        }
    }

    private static void sendPacket(Player player, PacketContainer packetContainer){
        try {
            ProtocolLibrary.getProtocolManager().sendServerPacket(player, packetContainer);
        } catch (InvocationTargetException e) {
            e.printStackTrace();
        }
    }

}


Filename: .\main\java\rip\diamond\practice\util\tablist\util\packet\AbstractPacket.java
/*
 *  PacketWrapper - Contains wrappers for each packet in Minecraft.
 *  Copyright (C) 2012 Kristian S. Stangeland
 *
 *  This program is free software; you can redistribute it and/or modify it under the terms of the 
 *  GNU Lesser General Public License as published by the Free Software Foundation; either version 2 of 
 *  the License, or (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; 
 *  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
 *  See the GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along with this program; 
 *  if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
 *  02111-1307 USA
 */

package rip.diamond.practice.util.tablist.util.packet;

import com.comphenix.protocol.PacketType;
import com.comphenix.protocol.ProtocolLibrary;
import com.comphenix.protocol.events.PacketContainer;
import com.google.common.base.Objects;
import org.bukkit.entity.Player;

import java.lang.reflect.InvocationTargetException;

public abstract class AbstractPacket {
	// The packet we will be modifying
	protected PacketContainer handle;

	/**
	 * Constructs a new strongly typed wrapper for the given packet.
	 * @param handle - handle to the raw packet data.
	 * @param type - the packet type.
	 */
	protected AbstractPacket(PacketContainer handle, PacketType type) {
		// Make sure we're given a valid packet
		if (handle == null)
			throw new IllegalArgumentException("Packet handle cannot be NULL.");
		if (!Objects.equal(handle.getType(), type))
			throw new IllegalArgumentException(
					handle.getHandle() + " is not a packet of type " + type);
		
		this.handle = handle;
	}

	/**
	 * Retrieve a handle to the raw packet data.
	 * @return Raw packet data.
	 */
	public PacketContainer getHandle() {
		return handle;
	}
	
	/**
	 * Send the current packet to the given receiver.
	 * @param receiver - the receiver.
	 * @throws RuntimeException If the packet cannot be sent.
	 */
	public void sendPacket(Player receiver) {
		try {
			ProtocolLibrary.getProtocolManager().sendServerPacket(receiver, getHandle());
		} catch (InvocationTargetException e) {
			throw new RuntimeException("Cannot send packet.", e);
		}
	}
	
	/**
	 * Simulate receiving the current packet from the given sender.
	 * @param sender - the sender.
	 * @throws RuntimeException If the packet cannot be received.
	 */
	public void receivePacket(Player sender) {
		try {
			ProtocolLibrary.getProtocolManager().recieveClientPacket(sender, getHandle());
		} catch (Exception e) {
			throw new RuntimeException("Cannot receive packet.", e);
		}
	}
}

Filename: .\main\java\rip\diamond\practice\util\tablist\util\packet\WrapperPlayServerLogin.java
package rip.diamond.practice.util.tablist.util.packet;

import org.bukkit.World;
import org.bukkit.WorldType;
import org.bukkit.entity.Entity;

import com.comphenix.protocol.PacketType;
import com.comphenix.protocol.events.PacketContainer;
import com.comphenix.protocol.events.PacketEvent;
import com.comphenix.protocol.wrappers.EnumWrappers.Difficulty;
import com.comphenix.protocol.wrappers.EnumWrappers.NativeGameMode;

public class WrapperPlayServerLogin extends AbstractPacket {
    public static final PacketType TYPE = PacketType.Play.Server.LOGIN;
    
    public WrapperPlayServerLogin() {
        super(new PacketContainer(TYPE), TYPE);
        handle.getModifier().writeDefaults();
    }
    
    public WrapperPlayServerLogin(PacketContainer packet) {
        super(packet, TYPE);
    }
    
    /**
     * Retrieve the player's Entity ID.
     * @return The current Entity ID
    */
    public int getEntityId() {
        return handle.getIntegers().read(0);
    }
    
    /**
     * Set the player's Entity ID.
     * @param value - new value.
    */
    public void setEntityId(int value) {
        handle.getIntegers().write(0, value);
    }
    
    /**
     * Retrieve the player's entity object.
     * @param world - the word the player has joined.
     * @return The player's entity.
     */
    public Entity getEntity(World world) {
    	return handle.getEntityModifier(world).read(0);
    }

    /**
     * Retrieve the player's entity object.
     * @param event - the packet event.
     * @return The player's entity.
     */
    public Entity getEntity(PacketEvent event) {
    	return getEntity(event.getPlayer().getWorld());
    }
    
    /**
     * Retrieve the game mode of the initial world.
     * @return The current gamemode.
    */
    public NativeGameMode getGamemode() {
        return handle.getGameModes().read(0);
    }
    
    /**
     * Set the game mode of the initial world.
     * @param value - new value.
    */
    public void setGamemode(NativeGameMode value) {
        handle.getGameModes().write(0, value);
    }
    
    /**
     * Retrieve whether or not this is a hardcore world.
     * @return TRUE if it is, FALSE otherwise.
    */
    public boolean isHardcore() {
        return handle.getBooleans().read(0);
    }
    
    /**
     * Set whether or not this is a hardcore world.
     * @param value - TRUE if it is, FALSE otherwise.
    */
    public void setHardcore(boolean value) {
        handle.getBooleans().write(0, value);
    }
    
    /**
     * Retrieve -1: nether, 0: overworld, 1: end.
     * @return The current Dimension
    */
    public int getDimension() {
        return handle.getIntegers().read(1);
    }
    
    /**
     * Set -1: nether, 0: overworld, 1: end.
     * @param value - new value.
    */
    public void setDimension(int value) {
    	handle.getIntegers().write(1, value);
    }
    
    /**
     * Retrieve the difficulty of the initial world.
     * @return The current difficulty
    */
    public Difficulty getDifficulty() {
        return handle.getDifficulties().read(0);
    }
    
    /**
     * Set the difficulty of the initial world.
     * @param difficulty - new difficulty.
    */
    public void setDifficulty(Difficulty difficulty) {
        handle.getDifficulties().write(0, difficulty);
    }
    
    /**
     * Retrieve the maximum number of players.
     * <p>
     * This is used by the client to draw the player list.
     * @return The current max players.
    */
    public byte getMaxPlayers() {
        return handle.getIntegers().read(2).byteValue();
    }
    
    /**
     * Set used by the client to draw the player list.
     * @param value - new value.
    */
    public void setMaxPlayers(int value) {
        handle.getIntegers().write(2, value);
    }
    
    /**
     * Retrieve the world type.
     * <p>
     * This is the level-type setting (default, flat, or largeBiomes) in server.properties.
     * @return The current world type.
    */
    public WorldType getLevelType() {
        return handle.getWorldTypeModifier().read(0);
    }
    
    /**
     * Set the world type.
     * <p>
     * This is the level-type setting (default, flat, or largeBiomes) in server.properties.
     * @param type - new value.
    */
    public void setLevelType(WorldType type) {
        handle.getWorldTypeModifier().write(0, type);
    }    
}



Filename: .\main\java\rip\diamond\practice\util\tablist\util\packet\WrapperPlayServerScoreboardTeam.java
/*
 *  PacketWrapper - Contains wrappers for each packet in Minecraft.
 *  Copyright (C) 2012 Kristian S. Stangeland
 *
 *  This program is free software; you can redistribute it and/or modify it under the terms of the 
 *  GNU Lesser General Public License as published by the Free Software Foundation; either version 2 of 
 *  the License, or (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; 
 *  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
 *  See the GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along with this program; 
 *  if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
 *  02111-1307 USA
 */

package rip.diamond.practice.util.tablist.util.packet;

import com.comphenix.protocol.PacketType;
import com.comphenix.protocol.events.PacketContainer;
import com.comphenix.protocol.reflect.IntEnum;

import java.util.Collection;

public class WrapperPlayServerScoreboardTeam extends AbstractPacket {
    public static final PacketType TYPE = PacketType.Play.Server.SCOREBOARD_TEAM;
    
    /**
     * Enumeration of all the known packet modes.
     * 
     * @author Kristian
     */
    public static class Modes extends IntEnum {
    	public static final int TEAM_CREATED = 0;
    	public static final int TEAM_REMOVED = 1;
    	public static final int TEAM_UPDATED = 2;
    	public static final int PLAYERS_ADDED = 3;
    	public static final int PLAYERS_REMOVED = 4;
    	
    	private static final Modes INSTANCE = new Modes();
    	
    	public static Modes getInstance() {
    		return INSTANCE;
    	}
    }
    
    public WrapperPlayServerScoreboardTeam() {
        super(new PacketContainer(TYPE), TYPE);
        handle.getModifier().writeDefaults();
    }
    
    public WrapperPlayServerScoreboardTeam(PacketContainer packet) {
        super(packet, TYPE);
    }
    
    /**
     * Retrieve an unique name for the team. (Shared with scoreboard)..
     * @return The current Team Name
    */
    public String getTeamName() {
        return handle.getStrings().read(0);
    }
    
    /**
     * Set an unique name for the team. (Shared with scoreboard)..
     * @param value - new value.
    */
    public void setTeamName(String value) {
        handle.getStrings().write(0, value);
    }
    
    /**
     * Retrieve the current packet {@link Modes}.
     * <p>
     * This determines whether or not team information is added or removed.
     * @return The current packet mode.
    */
    public byte getPacketMode() {
        return handle.getIntegers().read(0).byteValue();
    }
    
    /**
     * Set the current packet {@link Modes}.
     * <p>
     * This determines whether or not team information is added or removed.
     * @param value - new value.
    */
    public void setPacketMode(int value) {
        handle.getIntegers().write(0, value);
    }
    
    /**
     * Retrieve the team display name.
     * <p>
     * A team must be created or updated.
     * @return The current display name.
    */
    public String getTeamDisplayName() {
        return handle.getStrings().read(1);
    }
    
    /**
     * Set the team display name.
     * <p>
     * A team must be created or updated.
     * @param value - new value.
    */
    public void setTeamDisplayName(String value) {
    	handle.getStrings().write(1, value);
    }
    
    /**
     * Retrieve the team prefix. This will be inserted before the name of each team member.
     * <p>
     * A team must be created or updated.
     * @return The current Team Prefix
    */
    public String getTeamPrefix() {
        return handle.getStrings().read(2);
    }
    
    /**
     * Set the team prefix. This will be inserted before the name of each team member.
     * <p>
     * A team must be created or updated.
     * @param value - new value.
    */
    public void setTeamPrefix(String value) {
        handle.getStrings().write(2, value);
    }
    
    /**
     * Set the team suffix. This will be inserted after the name of each team member.
     * <p>
     * A team must be created or updated.
     * @return The current Team Suffix
    */
    public String getTeamSuffix() {
        return handle.getStrings().read(3);
    }
    
    /**
     * Set only if Mode = 0 or 2. This will be after before the name of each team member.
     * <p>
     * A team must be created or updated.
     * @param value - new value.
    */
    public void setTeamSuffix(String value) {
        handle.getStrings().write(3, value);
    }
    
    /**
     * Retrieve whether or not friendly fire is enabled.
     * <p>
     * A team must be created or updated.
     * @return The current Friendly fire
    */
    public byte getFriendlyFire() {
        return handle.getIntegers().read(1).byteValue();
    }
    
    /**
     * Set whether or not friendly fire is enabled.
     * <p>
     * A team must be created or updated.
     * @param value - new value.
    */
    public void setFriendlyFire(byte value) {
    	handle.getIntegers().write(1, (int) value);
    }
    
    /**
     * Retrieve the list of player names.
     * <p>
     * Packet mode must be one of the following for this to be valid:
     * <ul>
     *  <li>{@link Modes#TEAM_CREATED}</li>
     *  <li>{@link Modes#PLAYERS_ADDED}</li>
     *  <li>{@link Modes#PLAYERS_REMOVED}</li>
     * </ul>
     * @return A list of player names.
    */
    @SuppressWarnings("unchecked")
	public Collection<String> getPlayers() {
        return handle.getSpecificModifier(Collection.class).read(0);
    }
    
    /**
     * Set the list of player names.
     * <p>
     * Packet mode must be one of the following for this to be valid:
     * <ul>
     *  <li>{@link Modes#TEAM_CREATED}</li>
     *  <li>{@link Modes#PLAYERS_ADDED}</li>
     *  <li>{@link Modes#PLAYERS_REMOVED}</li>
     * </ul>
     * @param players - new players.
    */
    public void setPlayers(Collection<String> players) {
    	handle.getSpecificModifier(Collection.class).write(0, players);
    }
}

Filename: .\main\resources\arena.yml


Filename: .\main\resources\config.yml
## Developer option, set to false if GoodestEnglish didn't tell you to set to true
debug: false
## Should arena and kit auto save after you make a changes?
## If auto save is disabled, you have to use command '/kit save <Kit Name>' or '/arena save <Arena Name>' to save them manually
## NOTE: Auto save will save each process after you made a changes into arena and kit, and changes are final (which means it cannot be reverted) if you set this to true
arena-kit-auto-save: false
## Should Eden disable auto saving world?
## Note that you have to manually do `/save-all` if you want to save the world if this option is set to true
## Disable auto saving world will not save the world after you do `/stop`
disable-save-world: true
## What command should only be able to use in lobby?
## Command like /nick, /skin should ONLY be usable while in lobby
lobby-only-commands: []
## MongoDB login information
mongo:
  ## This option should be ALWAYS true. Unless you want to test specific stuff without modifying the database
  ## If it is disabled, player stats will not be loaded and saved
  enabled: true
  uri-mode: false
  normal:
    host: 127.0.0.1
    port: 27017
    auth:
      enabled: false
      username: ''
      password: ''
  uri:
    database: Practice
    connection-string: mongodb://127.0.0.1:27017/Eden
## Storage Type
## Options: MONGODB, FLATFILE
storage-type: FLATFILE
## Built-in tablist editor
## Note that some user might experience tablist column incorrectly format. If that happens, please do not use this tablist function
fancy-tablist:
  ## Toggle if the fancy tablist should be enabled or not
  enabled: true
  ## How should each tab element shown
  ## This supports PlaceholderAPI, so if you wish to show player prefix, you can do it!
  format: "&a{player-name}"
  ## The ticks of how often the tablist will be updated
  ## Default is 20, which is 1 second. 1 tick is equal to 0.05 second
  update-ticks: 20
nametag:
  ## Toggle if the plugin should modify the nametag color or not
  enabled: true
  ## Nametag prefix
  prefix:
    ## What prefix should the nametag display when the player is in lobby?
    lobby: "&9"
    ## What prefix should the nametag display when the player is a spectator?
    spectator: "&7"
    ## What prefix should the nametag display when the player is a teammate?
    teammate: "&a"
    ## What prefix should the nametag display when the player is an opponent?
    opponent: "&c"
    ## If it doesn't match any of the above, what prefix should the nametag display?
    ## One of the scenario is a spectator tries to view match players. Those match players nametag will display as the follow prefix
    other: "&e"
party:
  ## When player creates a party, what is the default size?
  default-max-size: 30
  ## How many seconds should the party leader wait after use the announce command?
  announce-cooldown: 10
lobby:
  ## Should player allow to see other players?
  display-players: false
queue:
  ## How many wins should a player have to have access to queue ranked matches?
  ranked-required-wins: 10
match:
  ## Should player allow to pre-fire their arrow before the match countdown?
  allow-prefire: true
  ## This option will give a 'Play Again' item to match players when a match is ended, like Minemen Club
  allow-requeue: true
  ## When player is outside the cuboid (which uses arena min/max), should player receive a instant death damage?
  outside-cuboid-instant-death: true
  ## Should Eden remove cactus and sugar cane's physics?
  ## If true, when player places a block near cactus and sugar cane, cactus won't be destroyed
  remove-cactus-sugar-cane-physics: true
  death-lightning: true
  death-animation: true
  ## When a player dies, should Eden teleport the player 2 blocks up?
  tp-2-blocks-up-when-die: true
  ## When player dies and if the kit allows respawn, should Eden teleport the player to their spawn?
  respawn-teleport-to-spawn-when-die: true
  ## Command when the player wins. Only trigger when the player is playing unranked/ranked matches and not a custom duel match.
  ## You can use {player} as the placeholder for the winner's name, and {loser-player} as the placeholder for the loser's name.
  ## Example:
  ## win-commands:
  ## - "say {player} hello you win!"
  ## - "pay {player} 100"
  ## lose-commands:
  ## - "say {player} hello you lost!"
  ## - "pay {player} 1"
  win-commands: []
  lose-commands: []
  ## The saturation for all players when match starts
  start-saturation: 15
  ## So each arena is a 'rectangle', which works similar to WorldEdit (Refer to https://github.com/diamond-rip/Eden/wiki/Arenas-Setup#edit-arenas-location)
  ## This option will expend the 'rectangle' for spectator so spectator can spectate in a better view
  ## This option will expend in horizontal, meaning it will expend in East/West/North/South side
  spectate-expend-cuboid: 50
  ## Golden apple settings for instant gapple in kit game rules
  golden-apple:
    ## When player consume a golden apple, should the system gives normal effects to the player (which contains instantly regenerate to full health, saturation and absorption hearts), or just regenerate to full health?
    ## If false, then system will only set the player health to full, no effects are given
    instant-gapple-effects: true
    ## Should Eden gives absorption hearts everytime when a player consume a golden apple?
    ## Disable this if you want Hypixel styled golden apple in bridge
    give-absorption-hearts-everytime: false
  ## Snow related options - Only works in spleef kit game rules
  snow:
    ## Chance of getting snowball when break a snow block (In 0 - 100)
    snowball-drop-chance: 50
    ## When you break the snow block, how many snowball should system give you?
    snowball-drop-amount: 4
  ## Titles - Which type of title should be shown?
  title:
    ## Shows title when someone scores a point?
    score: true
    ## Shows title when the match has a result?
    end: true
  ## The ticks which represents between from match ends to send the player to lobby and reset the arena
  ## 20 ticks is 1 second, so if 100 ticks then it will be 5 seconds
  ## Default is 100, and is recommended. Change this value with caution
  end-duration: 100
  ## What block should player allow to break when kit game rule has build enabled?
  ## Do not let player break blocks which contain tile entities (For example: chest, sign)
  allow-breaking-blocks:
    - DEAD_BUSH
    - GRASS
    - LONG_GRASS
    - CACTUS
  ## Fireball - Settings related to fireball
  fireball:
    ## Should Eden handle how fireball works? (Including modify the value of fireball, explosion, speed, etc.)
    enabled: true
    ## Should Eden modify the fireball damage?
    ## The damage will be original damage divide by 'divide-damage'
    ## For example, if original damage is 10, 'divide-damage' is 5, then player will take 2 damage (10 / 5 = 2)
    divide-damage: 5.0
    ## How fast should the fireball speed goes?
    ## This value is a double, meaning it can include decimal points
    speed: 2.0
    ## The power of the fireball's explosion
    ## This value is a float, meaning it can include decimal points
    yield: 2.0
    ## The block which allow to break by the explosion
    ## Blocks which is placed by match players will ALWAYS allow breaking
    allowed-breaking-blocks:
      - WOOD
      - ENDER_STONE
    ## The knockback when player takes damage by fireball
    knockback:
      ## Should Eden use our own knockback mechanism?
      enabled: true
      ## The knockback vertical multiplier
      vertical: 1.1
      ## The knockback horizontal multiplier
      horizontal: 1.2
  ## TNT - Settings related to TNT
  tnt:
    ## Should Eden handle how TNT works?
    enabled: true
    ## Should Eden modify the TNT damage?
    ## The damage will be original damage divide by 'divide-damage'
    ## For example, if original damage is 10, 'divide-damage' is 5, then player will take 2 damage (10 / 5 = 2)
    divide-damage: 5.0
    ## The power of the TNT explosion
    ## This value is a float, meaning it can include decimal points
    ## Default value of Minecraft's TNT yield is 4.0
    yield: 4.0
    ## The ticks of the tnt explosion
    ## Remember: 20 ticks is equals to 1 second. Meaning 50 ticks is 2.5 seconds
    fuse-ticks: 50
    ## The block which allow to break by the explosion
    ## Blocks which is placed by match players will ALWAYS allow breaking
    allowed-breaking-blocks:
      - WOOD
      - ENDER_STONE
    ## The knockback when player takes damage by TNT
    knockback:
      ## Should Eden use our own knockback mechanism?
      enabled: true
      ## The knockback vertical multiplier
      vertical: 1.1
      ## The knockback horizontal multiplier
      horizontal: 1.2
  ##Option to set golden head related stuff
  golden-head:
    ## A potion effect is separated to 3 parts - Effect Type, Duration and Amplifier. Each part is separated by using ';'
    ## Effect Type means the actual effect name. You can find effect name here: https://helpch.at/docs/1.10/index.html?org/bukkit/potion/PotionEffectType.html
    ## Duration is the duration of the effect. Note that 20 ticks is equal to 1 second. Meaning 200 ticks will be 10 seconds.
    ## Amplifier is the level if the effect. Level 1 potion effect will be 0; Level 3 potion effect will be 2, etc
    effects:
      - "REGENERATION;200;2"
      - "ABSORPTION;2400;0"
      - "SPEED;200;0"
    ## How much food level should system gives to player when they eat a golden head?
    food-level: 6
## Overall event config
event:
  ## Sumo Event configuration
  sumo-event:
    ## Which arena should allow for Sumo Event to use?
    ## Arena which listed in here cannot be used in normal fight
    arenas:
      - "sumoevent"
    ## Which kit you want to be used in this event?
    ## You should not change this unless your sumo kit has a different kit ID
    kit: "sumo"
## Simple chat format
chat-format:
  ## Set this to true if you want to enable chat format
  enabled: true
  ## What is the format should be? (This supports PlaceholderAPI)
  ## Use %1$s for player's name and %2$s for player's message
  format: "&a%1$s&f: %2$s"
## Player profile options
profile:
  ## The default elo for the player
  default-elo: 1000
  ## Should Eden save all online player data while server is stopping
  ## Disable this if you used Eden's API to modify eden's player data document
  save-on-server-stop: true
  ## The default settings for a player
  ## Player can customize their settings via '/settings' menu, however, permissions are required to change the settings.
  ## Check https://github.com/diamond-rip/Eden/wiki/Permissions#Settings for more information about permissions
  default-settings:
    ## Available options: normal, day, afternoon, night, midnight
    ## 'normal' means the player will have server-sided time displayed
    time-changer: "normal"
    ## Available options: true, false
    arena-selection: false
    ## Available options: true, false
    match-scoreboard: true
    ## Available options: true, false
    allow-duel-request: true
    ## Available options: true, false
    allow-party-invite: true
    ## Available options: true, false
    spectator-visibility: true
    ## Available options: true, false
    spectator-join-leave-message: true
    ## Available options: true, false
    event-announcement: true
    ## Available options: infinite, 300, 200, 150, 100, 50
    ping-range: "infinite"
## Option about crafting (Using crafting table/player's crafting inventory)
crafting:
  ## Should Eden allow crafting?
  enabled: false
  ## If Eden disallow crafting, what item should player allow to craft?
  whitelisted-items:
    - MUSHROOM_SOUP
## These options will only works if you are using ImanitySpigot
## If you are not using, then turn every imanity related settings off
imanity:
  teleport-async: true
## Optimization related settings
## These settings will sightly improve performance, but unexpected behavior might occur.
optimization:
  ## If true, Eden will use NMS instead of bukkit API to set specific block
  set-block-fast: true
## Experiment settings
## Avoid to change any of these settings if the developer didn't tell you to change
experiment:
  disable-original-arena: false
  new-arena-chunk-cache: false
  k-factor: 32
## Kit Editor Mode
## Options: GUI, LEGACY
kit-editor-mode: GUI

Filename: .\main\resources\item-tw.yml
items:
  lobby:
    unranked-queue:
      enabled: true
      name: "&bÂåπÈÖçÁ∂ìÂÖ∏Ê®°Âºè &7(ÈªûÊìäÂè≥Èçµ)"
      lore:
        - "&7ÈªûÊìäÂåπÈÖçÁ∂ìÂÖ∏Ê®°Âºè"
      material: IRON_SWORD
      durability: 0
      slot: 0
      command: "eden:queue unranked"
    ranked-queue:
      enabled: true
      name: "&bÂåπÈÖçÊéí‰ΩçÊ®°Âºè &7(ÈªûÊìäÂè≥Èçµ)"
      lore:
        - "&7ÈªûÊìäÂåπÈÖçÊéí‰ΩçÊ®°Âºè"
      material: DIAMOND_SWORD
      durability: 0
      slot: 1
      command: "eden:queue ranked"
    create-event:
      enabled: true
      name: "&bËàâËæ¶Ê¥ªÂãï &7(ÈªûÊìäÂè≥Èçµ)"
      lore:
        - "&7ÈªûÊìäËàâËæ¶Ê¥ªÂãï"
      material: EYE_OF_ENDER
      durability: 0
      slot: 2
      command: "eden:event create"
    join-event:
      enabled: true
      name: "&bÂä†ÂÖ•Ê¥ªÂãï &7(ÈªûÊìäÂè≥Èçµ)"
      lore:
        - "&7ÈªûÊìäÂä†ÂÖ•Ê¥ªÂãï"
      material: ENDER_PEARL
      durability: 0
      slot: 2
      command: "eden:joinevent"
    party-open:
      enabled: true
      name: "&bÂª∫Á´ãÈöä‰ºç &7(ÈªûÊìäÂè≥Èçµ)"
      lore:
        - "&7ÈªûÊìäÂª∫Á´ã‰∏ÄÂÄãÊñ∞ÁöÑÈöä‰ºç"
      material: NETHER_STAR
      durability: 0
      slot: 4
      command: "eden:party create"
    leaderboard:
      enabled: true
      name: "&bÊ™¢Ë¶ñÊéíË°åÊ¶ú &7(ÈªûÊìäÂè≥Èçµ)"
      lore:
        - "&7ÈªûÊìäÈñãÂïüÊéíË°åÊ¶úÊ∏ÖÂñÆ"
      material: EMERALD
      durability: 0
      slot: 6
      command: "eden:stats"
    settings:
      enabled: true
      name: "&bÁ∑®ËºØË®≠ÂÆö &7(ÈªûÊìäÂè≥Èçµ)"
      lore:
        - "&7ÈªûÊìäÁ∑®ËºØ‰Ω†ÁöÑÂÄã‰∫∫Ë®≠ÂÆö"
      material: WATCH
      durability: 0
      slot: 7
      command: "eden:settings"
    editor:
      enabled: true
      name: "&bÁ∑®ËºØÊéíÁâà &7(ÈªûÊìäÂè≥Èçµ)"
      lore:
        - "&7ÈñãÂïüÁ∑®ËºØÊéíÁâàÊ∏ÖÂñÆ"
      material: BOOK
      durability: 0
      slot: 8
      command: "eden:editkits"
  party:
    party-list:
      enabled: true
      name: "&b‰Ω†ÁöÑÈöä‰ºç &7(ÈªûÊìäÂè≥Èçµ)"
      lore:
        - "&7ÈªûÊìäÊü•Áúã‰Ω†ÁöÑÈöä‰ºçÁãÄÊÖã"
      material: NETHER_STAR
      durability: 0
      slot: 0
      command: "eden:party list"
    party-fight:
      enabled: true
      name: "&bÈöä‰ºçÊ¥ªÂãï &7(ÈªûÊìäÂè≥Èçµ)"
      lore:
        - "&7ÈªûÊìäËàâËæ¶Èöä‰ºçÊ¥ªÂãï"
      material: COMPASS
      durability: 0
      slot: 1
      command: "eden:choosematchtype"
    other-parties:
      enabled: true
      name: "&bÂÖ∂‰ªñÈöä‰ºç &7(ÈªûÊìäÂè≥Èçµ)"
      lore:
        - "&7ÈªûÊìäÈñãÂïüÂÖ∂‰ªñÈöä‰ºçÊ∏ÖÂñÆ"
      material: SKULL_ITEM
      durability: 0
      slot: 6
      command: "eden:otherparties"
    editor:
      enabled: true
      name: "&bÁ∑®ËºØÊéíÁâà &7(ÈªûÊìäÂè≥Èçµ)"
      lore:
        - "&7ÈñãÂïüÁ∑®ËºØÊéíÁâàÊ∏ÖÂñÆ"
      material: BOOK
      durability: 0
      slot: 7
      command: "eden:editkits"
    party-leave:
      enabled: true
      name: "&cÈõ¢ÈñãÈöä‰ºç &7(ÈªûÊìäÂè≥Èçµ)"
      lore:
        - "&7ÈªûÊìäÈõ¢ÈñãÁèæÊôÇÁöÑÈöä‰ºç"
      material: INK_SACK
      durability: 1
      slot: 8
      command: "eden:party leave"
  queue:
    leave-queue:
      enabled: true
      name: "&cÈõ¢ÈñãÂåπÈÖç &7(ÈªûÊìäÂè≥Èçµ)"
      lore:
        - "&7ÈªûÊìäÈõ¢ÈñãÂåπÈÖç"
      material: INK_SACK
      durability: 1
      slot: 8
      command: "eden:queue leave"
  match:
    requeue:
      enabled: true
      name: "&bÂÜçÁé©‰∏ÄÊ¨° &7(ÈªûÊìäÂè≥Èçµ)"
      lore:
        - "&7ÈªûÊìäÂåπÈÖçÁõ∏ÂêåÁöÑÊ®°Âºè"
      material: PAPER
      durability: 0
      slot: -1
      command: "eden:requeue"
  spectate:
    teleporter:
      enabled: true
      name: "&bÁé©ÂÆ∂ÂÇ≥ÈÄÅ &7(ÈªûÊìäÂè≥Èçµ)"
      lore:
        - "&7ÈªûÊìäÈñãÂïüÁé©ÂÆ∂ÂÇ≥ÈÄÅÊ∏ÖÂñÆ"
      material: COMPASS
      durability: 0
      slot: 3
      command: "eden:teleporter"
    leave-spectate:
      enabled: true
      name: "&cÈõ¢ÈñãËßÄÊà∞ &7(ÈªûÊìäÂè≥Èçµ)"
      lore:
        - "&7ÈªûÊìäÈõ¢ÈñãËßÄÊà∞"
      material: INK_SACK
      durability: 1
      slot: 4
      command: "eden:leavespectate"
    toggle-visibility-off:
      enabled: true
      name: "&bÈóúÈñâËßÄÂØüËÄÖÈ°ØÁ§∫ &7(ÈªûÊìäÂè≥Èçµ)"
      lore:
        - "&7ÈªûÊìäÊõ¥ÊîπËßÄÂØüËÄÖÈ°ØÁ§∫ÁöÑÁãÄÊÖã"
      material: REDSTONE_TORCH_ON
      durability: 0
      slot: 5
      command: "eden:togglespectatorvisibility"
    toggle-visibility-on:
      enabled: true
      name: "&bÈñãÂïüËßÄÂØüËÄÖÈ°ØÁ§∫ &7(ÈªûÊìäÂè≥Èçµ)"
      lore:
        - "&7ÈªûÊìäÊõ¥ÊîπËßÄÂØüËÄÖÈ°ØÁ§∫ÁöÑÁãÄÊÖã"
      material: LEVER
      durability: 0
      slot: 5
      command: "eden:togglespectatorvisibility"


Filename: .\main\resources\item.yml
items:
  lobby:
    unranked-queue:
      enabled: true
      name: "&bUnranked Queue &7(Right-Click)"
      lore:
        - ""
      material: IRON_SWORD
      durability: 0
      slot: 0
      command: "eden:queue unranked"
    ranked-queue:
      enabled: true
      name: "&bRanked Queue &7(Right-Click)"
      lore:
        - ""
      material: DIAMOND_SWORD
      durability: 0
      slot: 1
      command: "eden:queue ranked"
    create-event:
      enabled: true
      name: "&bCreate Event &7(Right-Click)"
      lore:
        - ""
      material: EYE_OF_ENDER
      durability: 0
      slot: 2
      command: "eden:event create"
    join-event:
      enabled: true
      name: "&bJoin Event &7(Right-Click)"
      lore:
        - ""
      material: ENDER_PEARL
      durability: 0
      slot: 2
      command: "eden:joinevent"
    party-open:
      enabled: true
      name: "&bCreate Party &7(Right-Click)"
      lore:
        - ""
      material: NETHER_STAR
      durability: 0
      slot: 4
      command: "eden:party create"
    leaderboard:
      enabled: true
      name: "&bView Leaderboard &7(Right-Click)"
      lore:
        - ""
      material: EMERALD
      durability: 0
      slot: 6
      command: "eden:stats"
    settings:
      enabled: true
      name: "&bEdit Settings &7(Right-Click)"
      lore:
        - ""
      material: WATCH
      durability: 0
      slot: 7
      command: "eden:settings"
    editor:
      enabled: true
      name: "&bEdit Kits &7(Right-Click)"
      lore:
        - ""
      material: BOOK
      durability: 0
      slot: 8
      command: "eden:editkits"
  party:
    party-list:
      enabled: true
      name: "&bYour Party &7(Right-Click)"
      lore:
        - ""
      material: NETHER_STAR
      durability: 0
      slot: 0
      command: "eden:party list"
    party-fight:
      enabled: true
      name: "&bParty Events &7(Right-Click)"
      lore:
        - ""
      material: COMPASS
      durability: 0
      slot: 1
      command: "eden:choosematchtype"
    other-parties:
      enabled: true
      name: "&bOther Parties &7(Right-Click)"
      lore:
        - ""
      material: SKULL_ITEM
      durability: 0
      slot: 6
      command: "eden:otherparties"
    editor:
      enabled: true
      name: "&bEdit kits &7(Right-Click)"
      lore:
        - ""
      material: BOOK
      durability: 0
      slot: 7
      command: "eden:editkits"
    party-leave:
      enabled: true
      name: "&cLeave Party &7(Right-Click)"
      lore:
        - ""
      material: INK_SACK
      durability: 1
      slot: 8
      command: "eden:party leave"
  queue:
    leave-queue:
      enabled: true
      name: "&cLeave Queue &7(Right-Click)"
      lore:
        - ""
      material: INK_SACK
      durability: 1
      slot: 8
      command: "eden:queue leave"
  match:
    requeue:
      enabled: true
      name: "&bPlay Again &7(Right-Click)"
      lore:
        - ""
      material: PAPER
      durability: 0
      slot: -1
      command: "eden:requeue"
  spectate:
    teleporter:
      enabled: true
      name: "&bTeleportation Tool &7(Right-Click)"
      lore:
        - ""
      material: COMPASS
      durability: 0
      slot: 3
      command: "eden:teleporter"
    leave-spectate:
      enabled: true
      name: "&cLeave Spectate &7(Right-Click)"
      lore:
        - ""
      material: INK_SACK
      durability: 1
      slot: 4
      command: "eden:leavespectate"
    toggle-visibility-off:
      enabled: true
      name: "&bDisable Spectators &7(Right-Click)"
      lore:
        - ""
      material: REDSTONE_TORCH_ON
      durability: 0
      slot: 5
      command: "eden:togglespectatorvisibility"
    toggle-visibility-on:
      enabled: true
      name: "&bEnable Spectators &7(Right-Click)"
      lore:
        - ""
      material: LEVER
      durability: 0
      slot: 5
      command: "eden:togglespectatorvisibility"

Filename: .\main\resources\kit.yml


Filename: .\main\resources\language-tw.yml
scoreboard:
  title: "&bÊà∞È¨•Á∑¥Áøí"
  boxing-counter:
    no-combo: "&fÊ≤íÊúâÈÄ£Êìä"
    text-solo: "{match-solo-boxing-difference-color}{match-solo-boxing-combo} ÈÄ£Êìä"
    text-team: "{match-team-boxing-difference-color}{match-team-boxing-combo} ÈÄ£Êìä"
  loading:
    - "&7&m----------------------"
    - "&c‰Ω†ÁöÑË≥áÊñôÊ≠£Âú®Âä†Ëºâ‰∏≠..."
    - "&cË´ãÁ≠âÂæÖ‰∏ÄÊúÉÂÖí, Â¶ÇÊûúË≥áÊñôÊ≤íÊúâÂä†ËºâÊàêÂäü, Ë´ãËÅØÁπ´‰º∫ÊúçÂô®ÁÆ°ÁêÜÂì°, ‰∏¶ÂòóË©¶ÈáçÊñ∞ÁôªÂÖ•"
    - ""
    - "&bdiamond.rip"
    - "&7&m----------------------"
  in-lobby:
    - "&7&m----------------------"
    - "&b&l‚îÉ &fÁé©ÂÆ∂: &b{online-players}"
    - "&b&l‚îÉ &fÁ≠âÂæÖ‰∏≠: &b{queue-players}"
    - "&b&l‚îÉ &fÊà∞È¨•‰∏≠: &b{match-players}"
    - "{event-information}"
    - ""
    - "&bdiamond.rip"
    - "&7&m----------------------"
  in-party:
    - "&7&m----------------------"
    - "&b&l‚îÉ &fÁé©ÂÆ∂: &b{online-players}"
    - "&b&l‚îÉ &fÁ≠âÂæÖ‰∏≠: &b{queue-players}"
    - "&b&l‚îÉ &fÊà∞È¨•‰∏≠: &b{match-players}"
    - ""
    - "&b&l‚îÉ &fÈöä‰ºç:"
    - "&b&l‚îÉ &f ÈöäÈï∑: &b{party-leader}"
    - "&b&l‚îÉ &f ‰∫∫Êï∏: &b{party-members}&7/&b{party-max}"
    - "{event-information}"
    - ""
    - "&bdiamond.rip"
    - "&7&m----------------------"
  in-edit:
    - "&7&m----------------------"
    - "&b&l‚îÉ &fÂè≥ÈçµÈªûÊìä&bÈêµÁ†ß&f‰æÜÂÑ≤Â≠ò, ËÆÄÂèñÊàñÂà™Èô§‰Ω†ÁöÑÊéíÁâà"
    - "&b&l‚îÉ &fÊüê‰∫õÁâπÂÆöËÅ∑Ê•≠ÂÖÅË®±È°çÂ§ñÁâ©ÂìÅ, Âè≥ÈçµÈªûÊìä&bÁÆ±Â≠ê&fÂéªÁç≤ÂèñÊõ¥Â§öÁöÑÈ°çÂ§ñÁâ©ÂìÅ"
    - "&b&l‚îÉ &fÁï∂‰Ω†ÁµêÊùüÁ∑®ËºØ‰Ω†ÁöÑÊéíÁâàÊôÇ, Âè≥ÈçµÈªûÊìä&bÂëäÁ§∫Áâå&f‰æÜÂõûÂà∞Â§ßÂª≥"
    - ""
    - "&bdiamond.rip"
    - "&7&m----------------------"
  in-queue-unranked:
    - "&7&m----------------------"
    - "&b&l‚îÉ &fÁé©ÂÆ∂: &b{online-players}"
    - "&b&l‚îÉ &fÁ≠âÂæÖ‰∏≠: &b{queue-players}"
    - "&b&l‚îÉ &fÊà∞È¨•‰∏≠: &b{match-players}"
    - ""
    - "&b&l‚îÉ &fÊ≠£Âú®ÂåπÈÖç: &b{queue-kit}"
    - "&b&l‚îÉ &fÁ≠âÂæÖÊôÇÈñì: &b{queue-time}"
    - "&b&l‚îÉ &fÂåπÈÖçÂª∂ÈÅ≤: &b{ping-range}"
    - "{event-information}"
    - ""
    - "&bdiamond.rip"
    - "&7&m----------------------"
  in-queue-ranked:
    - "&7&m----------------------"
    - "&b&l‚îÉ &fÁé©ÂÆ∂: &b{online-players}"
    - "&b&l‚îÉ &fÁ≠âÂæÖ‰∏≠: &b{queue-players}"
    - "&b&l‚îÉ &fÊà∞È¨•‰∏≠: &b{match-players}"
    - ""
    - "&b&l‚îÉ &fÊ≠£Âú®ÂåπÈÖç: &b{queue-kit}"
    - "&b&l‚îÉ &fÁ≠âÂæÖÊôÇÈñì: &b{queue-time}"
    - "&b&l‚îÉ &fÂåπÈÖçÂª∂ÈÅ≤: &b{ping-range}"
    - "&b&l‚îÉ &fÂåπÈÖçÁØÑÂúç: &7[&b{queue-ranked-min} &9-> &b{queue-ranked-max}&7]"
    - "{event-information}"
    - ""
    - "&bdiamond.rip"
    - "&7&m----------------------"
  in-match-solo:
    fighting:
      - "&7&m----------------------"
      - "&b&l‚îÉ &fÂ∞çÊâã: &b{match-solo-opponent}"
      - ""
      - "&b&l‚îÉ &fÊàëÊñπÂª∂ÈÅ≤: &b{match-solo-self-ping}ms"
      - "&b&l‚îÉ &fÂ∞çÊâãÂª∂ÈÅ≤: &b{match-solo-opponent-ping}ms"
      - ""
      - "&bdiamond.rip"
      - "&7&m----------------------"
    boxing:
      - "&7&m----------------------"
      - "&b&l‚îÉ &fÂ∞çÊâã: &b{match-solo-opponent}"
      - ""
      - "&b&l‚îÉ &bÊìä‰∏≠Ê¨°Êï∏: {match-solo-boxing-difference-color}({match-solo-boxing-difference-symbol}{match-solo-boxing-difference})"
      - "&b&l‚îÉ &a ÊàëÊñπ: &f{match-solo-boxing-self-hit}"
      - "&b&l‚îÉ &c Â∞çÊñπ: &f{match-solo-boxing-opponent-hit}"
      - "&b&l‚îÉ &f {match-solo-boxing-difference-text}"
      - ""
      - "&b&l‚îÉ &fÊàëÊñπÂª∂ÈÅ≤: &b{match-solo-self-ping}ms"
      - "&b&l‚îÉ &fÂ∞çÊâãÂª∂ÈÅ≤: &b{match-solo-opponent-ping}ms"
      - ""
      - "&bdiamond.rip"
      - "&7&m----------------------"
    bed:
      - "&7&m----------------------"
      - "&b&l‚îÉ &fÂ∞çÊâã: &b{match-solo-opponent}"
      - ""
      - "&b&l‚îÉ &f{match-team1-logo}&7: &f{match-team1-bed-status}"
      - "&b&l‚îÉ &f{match-team2-logo}&7: &f{match-team2-bed-status}"
      - ""
      - "&b&l‚îÉ &fÂª∫ÁØâÈ´òÂ∫¶: &b{match-build-limit}{match-build-limit-difference}"
      - ""
      - "&b&l‚îÉ &fÊàëÊñπÂª∂ÈÅ≤: &b{match-solo-self-ping}ms"
      - "&b&l‚îÉ &fÂ∞çÊâãÂª∂ÈÅ≤: &b{match-solo-opponent-ping}ms"
      - ""
      - "&bdiamond.rip"
      - "&7&m----------------------"
    point:
      - "&7&m----------------------"
      - "&b&l‚îÉ &fÂ∞çÊâã: &b{match-solo-opponent}"
      - ""
      - "&b&l‚îÉ &f{match-team1-logo}&7: &f{match-team1-points}"
      - "&b&l‚îÉ &f{match-team2-logo}&7: &f{match-team2-points}"
      - ""
      - "&b&l‚îÉ &fÊàëÊñπÂª∂ÈÅ≤: &b{match-solo-self-ping}ms"
      - "&b&l‚îÉ &fÂ∞çÊâãÂª∂ÈÅ≤: &b{match-solo-opponent-ping}ms"
      - ""
      - "&bdiamond.rip"
      - "&7&m----------------------"
    ending:
      - "&7&m----------------------"
      - "&b&l‚îÉ &aÊú¨Â†¥Êà∞È¨•Â∑≤ÁµêÊùü!"
      - "&b&l‚îÉ &fÂãùÂà©ËÄÖ: &b{match-solo-winner}"
      - ""
      - "&bdiamond.rip"
      - "&7&m----------------------"
  in-match-teams:
    fighting:
      - "&7&m----------------------"
      - "&b&l‚îÉ &aÊàëÊñπÈöä‰ºç: &7(&b{match-team-self-alive}&7/&b{match-team-self-size}&7)"
      - "&b&l‚îÉ &cÊïµÊñπÈöä‰ºç: &7(&b{match-team-opponent-alive}&7/&b{match-team-opponent-size}&7)"
      - ""
      - "&bdiamond.rip"
      - "&7&m----------------------"
    boxing:
      - "&7&m----------------------"
      - "&b&l‚îÉ &bÊìä‰∏≠Ê¨°Êï∏: {match-team-boxing-difference-color}({match-team-boxing-difference-symbol}{match-team-boxing-difference})"
      - "&b&l‚îÉ &a ÊàëÊñπ: &f{match-team-boxing-self-hit}"
      - "&b&l‚îÉ &c Â∞çÊñπ: &f{match-team-boxing-opponent-hit}"
      - "&b&l‚îÉ &f {match-solo-boxing-difference-text}"
      - ""
      - "&b&l‚îÉ &aÊàëÊñπÈöä‰ºç: &7(&b{match-team-self-alive}&7/&b{match-team-self-size}&7)"
      - "&b&l‚îÉ &cÊïµÊñπÈöä‰ºç: &7(&b{match-team-opponent-alive}&7/&b{match-team-opponent-size}&7)"
      - ""
      - "&bdiamond.rip"
      - "&7&m----------------------"
    bed:
      - "&7&m----------------------"
      - "&b&l‚îÉ &f{match-team1-logo}&7: &f{match-team1-bed-status}"
      - "&b&l‚îÉ &f{match-team2-logo}&7: &f{match-team2-bed-status}"
      - ""
      - "&b&l‚îÉ &fÂª∫ÁØâÈ´òÂ∫¶: &b{match-build-limit}{match-build-limit-difference}"
      - ""
      - "&b&l‚îÉ &aÊàëÊñπÈöä‰ºç: &7(&b{match-team-self-alive}&7/&b{match-team-self-size}&7)"
      - "&b&l‚îÉ &cÊïµÊñπÈöä‰ºç: &7(&b{match-team-opponent-alive}&7/&b{match-team-opponent-size}&7)"
      - ""
      - "&bdiamond.rip"
      - "&7&m----------------------"
    point:
      - "&7&m----------------------"
      - "&b&l‚îÉ &f{match-team1-logo}&7: &f{match-team1-points}"
      - "&b&l‚îÉ &f{match-team2-logo}&7: &f{match-team2-points}"
      - ""
      - "&b&l‚îÉ &fÂª∫ÁØâÈ´òÂ∫¶: &b{match-build-limit}{match-build-limit-difference}"
      - ""
      - "&b&l‚îÉ &aÊàëÊñπÈöä‰ºç: &7(&b{match-team-self-alive}&7/&b{match-team-self-size}&7)"
      - "&b&l‚îÉ &cÊïµÊñπÈöä‰ºç: &7(&b{match-team-opponent-alive}&7/&b{match-team-opponent-size}&7)"
      - ""
      - "&bdiamond.rip"
      - "&7&m----------------------"
    ending:
      - "&7&m----------------------"
      - "&b&l‚îÉ &aÊú¨Â†¥Êà∞È¨•Â∑≤ÁµêÊùü!"
      - "&b&l‚îÉ &fÂãùÂà©ËÄÖ: &b{match-team-winner}ÁöÑÈöä‰ºç"
      - ""
      - "&bdiamond.rip"
      - "&7&m----------------------"
  in-match-ffa:
    fighting:
      - "&7&m----------------------"
      - "&b&l‚îÉ &fÁîüÂ≠òÁé©ÂÆ∂: &7(&b{match-ffa-alive}&7/&b{match-ffa-player-size}&7)"
      - ""
      - "&bdiamond.rip"
      - "&7&m----------------------"
    ending:
      - "&7&m----------------------"
      - "&b&l‚îÉ &aÊú¨Â†¥Êà∞È¨•Â∑≤ÁµêÊùü!"
      - "&b&l‚îÉ &fÂãùÂà©ËÄÖ: &b{match-ffa-winner}"
      - ""
      - "&bdiamond.rip"
      - "&7&m----------------------"
  in-spectate-solo:
    fighting:
      - "&7&m----------------------"
      - "&b&l‚îÉ &fËÅ∑Ê•≠: &b{spectate-kit}"
      - "&b&l‚îÉ &fÊôÇÈñì: &b{spectate-duration}"
      - ""
      - "&b&l‚îÉ &f{spectate-solo-player1}ÁöÑÂª∂ÈÅ≤: &b{spectate-solo-player1-ping}ms"
      - "&b&l‚îÉ &f{spectate-solo-player2}ÁöÑÂª∂ÈÅ≤: &b{spectate-solo-player2-ping}ms"
      - ""
      - "&bdiamond.rip"
      - "&7&m----------------------"
    boxing:
      - "&7&m----------------------"
      - "&b&l‚îÉ &fËÅ∑Ê•≠: &b{spectate-kit}"
      - "&b&l‚îÉ &fÊôÇÈñì: &b{spectate-duration}"
      - ""
      - "&b&l‚îÉ &bÊìä‰∏≠Ê¨°Êï∏:"
      - "&b&l‚îÉ &f {spectate-solo-player1}: &b{spectate-solo-boxing-player1-hit}"
      - "&b&l‚îÉ &f {spectate-solo-player2}: &b{spectate-solo-boxing-player2-hit}"
      - ""
      - "&b&l‚îÉ &f{spectate-solo-player1}ÁöÑÂª∂ÈÅ≤: &b{spectate-solo-player1-ping}ms"
      - "&b&l‚îÉ &f{spectate-solo-player2}ÁöÑÂª∂ÈÅ≤: &b{spectate-solo-player2-ping}ms"
      - ""
      - "&bdiamond.rip"
      - "&7&m----------------------"
    bed:
      - "&7&m----------------------"
      - "&b&l‚îÉ &fËÅ∑Ê•≠: &b{spectate-kit}"
      - "&b&l‚îÉ &fÊôÇÈñì: &b{spectate-duration}"
      - ""
      - "&b&l‚îÉ &f{spectate-team1-logo}&7: &f{spectate-team1-bed-status}"
      - "&b&l‚îÉ &f{spectate-team2-logo}&7: &f{spectate-team2-bed-status}"
      - ""
      - "&b&l‚îÉ &f{spectate-solo-player1}ÁöÑÂª∂ÈÅ≤: &b{spectate-solo-player1-ping}ms"
      - "&b&l‚îÉ &f{spectate-solo-player2}ÁöÑÂª∂ÈÅ≤: &b{spectate-solo-player2-ping}ms"
      - ""
      - "&bdiamond.rip"
      - "&7&m----------------------"
    point:
      - "&7&m----------------------"
      - "&b&l‚îÉ &fËÅ∑Ê•≠: &b{spectate-kit}"
      - "&b&l‚îÉ &fÊôÇÈñì: &b{spectate-duration}"
      - ""
      - "&b&l‚îÉ &f{spectate-team1-logo}&7: &f{spectate-team1-points}"
      - "&b&l‚îÉ &f{spectate-team2-logo}&7: &f{spectate-team2-points}"
      - ""
      - "&b&l‚îÉ &f{spectate-solo-player1}ÁöÑÂª∂ÈÅ≤: &b{spectate-solo-player1-ping}ms"
      - "&b&l‚îÉ &f{spectate-solo-player2}ÁöÑÂª∂ÈÅ≤: &b{spectate-solo-player2-ping}ms"
      - ""
      - "&bdiamond.rip"
      - "&7&m----------------------"
    ending:
      - "&7&m----------------------"
      - "&b&l‚îÉ &aÊú¨Â†¥Êà∞È¨•Â∑≤ÁµêÊùü!"
      - "&b&l‚îÉ &fÂãùÂà©ËÄÖ: &b{spectate-solo-winner}"
      - ""
      - "&bdiamond.rip"
      - "&7&m----------------------"
  in-spectate-teams:
    fighting:
      - "&7&m----------------------"
      - "&b&l‚îÉ &f{spectate-team1-leader}ÁöÑÈöä‰ºç: &7(&b{spectate-team1-alive}&7/&b{spectate-team1-size}&7)"
      - "&b&l‚îÉ &f{spectate-team2-leader}ÁöÑÈöä‰ºç: &7(&b{spectate-team2-alive}&7/&b{spectate-team2-size}&7)"
      - ""
      - "&bdiamond.rip"
      - "&7&m----------------------"
    boxing:
      - "&7&m----------------------"
      - "&b&l‚îÉ &bÊìä‰∏≠Ê¨°Êï∏:"
      - "&b&l‚îÉ &f {spectate-team1-leader}ÁöÑÈöä‰ºç: &b{spectate-team1-boxing-hit}"
      - "&b&l‚îÉ &f {spectate-team2-leader}ÁöÑÈöä‰ºç: &b{spectate-team2-boxing-hit}"
      - ""
      - "&b&l‚îÉ &f{spectate-team1-leader}ÁöÑÈöä‰ºç: &7(&b{spectate-team1-alive}&7/&b{spectate-team1-size}&7)"
      - "&b&l‚îÉ &f{spectate-team2-leader}ÁöÑÈöä‰ºç: &7(&b{spectate-team2-alive}&7/&b{spectate-team2-size}&7)"
      - ""
      - "&bdiamond.rip"
      - "&7&m----------------------"
    bed:
      - "&7&m----------------------"
      - "&b&l‚îÉ &f{spectate-team1-logo}&7: &f{spectate-team1-bed-status}"
      - "&b&l‚îÉ &f{spectate-team2-logo}&7: &f{spectate-team2-bed-status}"
      - ""
      - "&b&l‚îÉ &f{spectate-team1-leader}ÁöÑÈöä‰ºç: &7(&b{spectate-team1-alive}&7/&b{spectate-team1-size}&7)"
      - "&b&l‚îÉ &f{spectate-team2-leader}ÁöÑÈöä‰ºç: &7(&b{spectate-team2-alive}&7/&b{spectate-team2-size}&7)"
      - ""
      - "&bdiamond.rip"
      - "&7&m----------------------"
    point:
      - "&7&m----------------------"
      - "&b&l‚îÉ &f{spectate-team1-logo}&7: &f{spectate-team1-points}"
      - "&b&l‚îÉ &f{spectate-team2-logo}&7: &f{spectate-team2-points}"
      - ""
      - "&b&l‚îÉ &f{spectate-team1-leader}ÁöÑÈöä‰ºç: &7(&b{spectate-team1-alive}&7/&b{spectate-team1-size}&7)"
      - "&b&l‚îÉ &f{spectate-team2-leader}ÁöÑÈöä‰ºç: &7(&b{spectate-team2-alive}&7/&b{spectate-team2-size}&7)"
      - ""
      - "&bdiamond.rip"
      - "&7&m----------------------"
    ending:
      - "&7&m----------------------"
      - "&b&l‚îÉ &aÊú¨Â†¥Êà∞È¨•Â∑≤ÁµêÊùü!"
      - "&b&l‚îÉ &fÂãùÂà©ËÄÖ: &b{spectate-team-winner}ÁöÑÈöä‰ºç"
      - ""
      - "&bdiamond.rip"
      - "&7&m----------------------"
  in-spectate-ffa:
    fighting:
      - "&7&m----------------------"
      - "&b&l‚îÉ &fÁîüÂ≠òÁé©ÂÆ∂: &7(&b{spectate-ffa-alive}&7/&b{spectate-ffa-player-size}&7)"
      - ""
      - "&bdiamond.rip"
      - "&7&m----------------------"
    ending:
      - "&7&m----------------------"
      - "&b&l‚îÉ &aÊú¨Â†¥Êà∞È¨•Â∑≤ÁµêÊùü!"
      - "&b&l‚îÉ &fÂãùÂà©ËÄÖ: &b{spectate-ffa-winner}"
      - ""
      - "&bdiamond.rip"
      - "&7&m----------------------"
join-message:
- "&7&m------------------------------------------------"
- ""
- "&fÊ≠°Ëøé‰æÜÂà∞ &bÈëΩÁü≥&eÊà∞È¨•Á∑¥Áøí"
- ""
- "&7&m------------------------------------------------"
loading-profile: "&c[Eden] Á≥ªÁµ±Ê≠£Âú®Âä†ËºâÊÇ®ÁöÑË≥áÊñô... Ë´ãÁ≠âÂæÖÂπæÁßíÂæåÂÜçË©¶"
invalid-syntax: "&cÊ†ºÂºèÈåØË™§, Ë´ãÈáçË©¶"
location-not-found: "&c‰ΩçÁΩÆÊú™ÊâæÂà∞"
location-changed: "&aÊàêÂäüÊõ¥Êîπ {0}"
no-permission: "&c‰Ω†Ê≤íÊúâÊ¨äÈôêÂü∑Ë°åÈÄôÂÄãÊåá‰ª§"
enabled: "ÈñãÂïü"
disabled: "ÈóúÈñâ"
confirm-title: "‰Ω†Á¢∫ÂÆöÂóé?"
reached-build-limit: "Â∑≤Âà∞‰∏äÈôê"
banned-command: "&c‰Ω†Âè™ËÉΩÂú®Â§ßÂª≥ÁãÄÊÖã‰ΩøÁî®ÈÄôÂÄãÊåá‰ª§"
arena:
  exists: "&cÂ†¥Âú∞ '{0}' Â∑≤Â≠òÂú®!"
  not-exists: "&cÂ†¥Âú∞ '{0}' ‰∏çÂ≠òÂú®! Ë´ãÂÖà‰ΩøÁî®Êåá‰ª§ '/arena create {0}' ÂéªÂâµÂª∫Â†¥Âú∞"
  created: "&aÂ†¥Âú∞ '{0}' ÊàêÂäüÂâµÂª∫! Ë´ã‰ΩøÁî®Êåá‰ª§ '/arena edit {0}' ÂéªÁ∑®ËºØÂ†¥Âú∞"
  successfully-set: "&aÊàêÂäüË®≠ÁΩÆ &e{0}"
  saved: "&aÊàêÂäüÂÑ≤Â≠òÂ†¥Âú∞ &e{0} &aÂà∞ arena.yml"
  saved-all: "&aÊàêÂäüÂÑ≤Â≠òÊâÄÊúâÂ†¥Âú∞Âà∞ arena.yml"
  cannot-set-because-clone-found: "&cÂ†¥Âú∞ÂøÖÈ†àË¶ÅÊ≤íÊúâ‰ªª‰ΩïË§áË£ΩÂ†¥Âú∞ÊâçËÉΩ‰ΩøÁî®ÈÄôÂÄãÊåá‰ª§"
  generate:
    display: "&c[Â†¥Âú∞Ë§áË£Ω] - {0} Â†¥Âú∞Â∑≤Ë¢´Ë§áË£ΩÂà∞ {1}, {2}"
    hover: "&eÈªûÊìäÂÇ≥ÈÄÅÂà∞Ë©≤Ë§áË£ΩÂ†¥Âú∞"
    copying: "&eÊ≠£Âú®Ë§áË£ΩÂ†¥Âú∞..."
  remove:
    success-main: "&aÊàêÂäüÁßªÈô§! &eÊ≥®ÊÑè: Ë´ã‰ΩøÁî®Êåá‰ª§ '/arena saveall' ÂéªÂÑ≤Â≠òÁï∂ÂâçÁöÑÂ†¥Âú∞Ë®≠ÁΩÆ"
    success-duplicate: "&aÊàêÂäüÁßªÈô§! &eÊ≥®ÊÑè: Ë´ã‰ΩøÁî®Êåá‰ª§ '/arena save {0}' ÂéªÂÑ≤Â≠òÁï∂ÂâçÁöÑÂ†¥Âú∞Ë®≠ÁΩÆ"
  menu:
    title: "Â†¥Âú∞‰∏ÄË¶Ω"
    arena-edit:
      name: "&b&l{0} &7({1})"
      lore:
        - ""
        - "&e&nÈªûÊìäÈÄ≤Ë°åÂ†¥Âú∞Ë®≠ÁΩÆ!"
  allowed-kits-menu:
    title: "Ë®≠ÁΩÆÂ†¥Âú∞ÂÖÅË®±ËÅ∑Ê•≠"
    lore:
      click-to-select: "&eÈªûÊìäÂÖÅË®±Ë©≤ËÅ∑Ê•≠"
      selected: "&aÂ∑≤ÂÖÅË®±Ë©≤ËÅ∑Ê•≠"
  details-menu:
    title: "Â†¥Âú∞Ë≥áË®ä‰∏ÄË¶Ω"
    detail:
      name: "&b#{0}"
      lore:
        - ""
        - "&7AÈªû‰ΩçÁΩÆ: {0}"
        - "&7BÈªû‰ΩçÁΩÆ: {1}"
        - "&7‰ΩéÈªû‰ΩçÁΩÆ: {2}"
        - "&7È´òÈªû‰ΩçÁΩÆ: {3}"
        - ""
      lore-not-duplicated: "&cÈÄôÂÄãÂ†¥Âú∞‰∏¶‰∏çÊòØË§áË£ΩÂ†¥Âú∞, ‰∏çËÉΩÂú®ÈÄôË£èÂà™Èô§!"
      click-to-delete: "&e&nÈªûÊìäÂ∑¶ÈçµÂà™Èô§ÈÄôÂÄãË§áË£ΩÂ†¥Âú∞"
      click-to-teleport: "&e&nÈªûÊìäÂè≥ÈçµÂÇ≥ÈÄÅÂà∞Ë©≤Â†¥Âú∞‰ΩçÁΩÆ"
      teleported: "&eÂ∑≤ÂÇ≥ÈÄÅÂà∞Â†¥Âú∞ &b{0} #{1}"
    create-duplicate:
      name: "&bÂª∫Á´ãË§áË£ΩÂ†¥Âú∞"
      lore:
        - "&cÊ≥®ÊÑè: Âª∫Á´ãË§áË£ΩÂ†¥Âú∞Âæå, ÊÇ®Â∞áÁÑ°Ê≥ïÊõ¥ÊîπÂ†¥Âú∞ÁöÑ‰ΩçÁΩÆ"
        - "&cË§áË£ΩÂ†¥Âú∞ÂæåË®òÂæó, ‰ΩøÁî®Êåá‰ª§ '/arena save {0}' ÂÑ≤Â≠òÂ†¥Âú∞"
        - ""
        - "&e&nÈªûÊìäÂª∫Á´ãË§áË£ΩÂ†¥Âú∞!"
  edit-menu:
    title: "Ê≠£Âú®Ë®≠ÁΩÆÂ†¥Âú∞ {0}..."
    click-to-edit: "ÈªûÊìä‰øÆÊîπ{0}ÁöÑÊï∏ÂÄº"
    display-name:
      name: "Â†¥Âú∞È°ØÁ§∫ÂêçÁ®±"
      description: "ÁèæÊôÇÈ°ØÁ§∫ÂêçÁ®±: {0}"
      action-description: "ÈªûÊìä‰øÆÊîπÂ†¥Âú∞È°ØÁ§∫ÂêçÁ®±"
      procedure:
        message: "&e&lÊ≠£Âú®Êõ¥Êîπ&b&lÂ†¥Âú∞È°ØÁ§∫ÂêçÁ®±&e&l... Ë´ãÂú®ËÅäÂ§©ÂÆ§Ëº∏ÂÖ•‰∏ÄÂÄãÊñ∞ÁöÑÊï∏ÂÄº"
        success: "&fË®≠ÁΩÆÂ†¥Âú∞ &b{0} &fÁöÑÈ°ØÁ§∫ÂêçÁ®±Âà∞ &b{1}"
    allowed-kits:
      name: "ÂÖÅË®±ËÅ∑Ê•≠"
      description: "ÁèæÊôÇÊï∏ÂÄº: {0}"
    a-position:
      name: "AÈªû‰ΩçÁΩÆ"
      description: "ÁèæÊôÇ‰ΩçÁΩÆ: {0}"
      action-description:
        - "&e&nÈªûÊìäÂ∑¶ÈçµÊääAÈªû‰ΩçÁΩÆÂèñ‰ª£ÁÇ∫‰Ω†ÁèæÊôÇÁöÑ‰ΩçÁΩÆ"
        - "&e&nÈªûÊìäÂè≥ÈçµÂÇ≥ÈÄÅÂà∞AÈªû‰ΩçÁΩÆ"
    b-position:
      name: "BÈªû‰ΩçÁΩÆ"
      description: "ÁèæÊôÇ‰ΩçÁΩÆ: {0}"
      action-description:
        - "&e&nÈªûÊìäÂ∑¶ÈçµÊääBÈªû‰ΩçÁΩÆÂèñ‰ª£ÁÇ∫‰Ω†ÁèæÊôÇÁöÑ‰ΩçÁΩÆ"
        - "&e&nÈªûÊìäÂè≥ÈçµÂÇ≥ÈÄÅÂà∞BÈªû‰ΩçÁΩÆ"
    spectator-position:
      name: "ËßÄÂØüËÄÖ‰ΩçÁΩÆ"
      description: "ÁèæÊôÇ‰ΩçÁΩÆ: {0}"
      action-description:
        - "&e&nÈªûÊìäÂ∑¶ÈçµÊääËßÄÂØüËÄÖ‰ΩçÁΩÆÂèñ‰ª£ÁÇ∫‰Ω†ÁèæÊôÇÁöÑ‰ΩçÁΩÆ"
        - "&e&nÈªûÊìäÂè≥ÈçµÂÇ≥ÈÄÅÂà∞ËßÄÂØüËÄÖ‰ΩçÁΩÆ"
    min:
      name: "‰ΩéÈªû‰ΩçÁΩÆ"
      description: "ÁèæÊôÇ‰ΩçÁΩÆ: {0}"
      action-description:
        - "&e&nÈªûÊìäÂ∑¶ÈçµÊõ¥Êîπ‰ΩéÈªû‰ΩçÁΩÆ"
        - "&e&nÈªûÊìäÂè≥ÈçµÂÇ≥ÈÄÅÂà∞‰ΩéÈªû‰ΩçÁΩÆ"
    max:
      name: "È´òÈªû‰ΩçÁΩÆ"
      description: "ÁèæÊôÇ‰ΩçÁΩÆ: {0}"
      action-description:
        - "&e&nÈªûÊìäÂ∑¶ÈçµÊõ¥ÊîπÈ´òÈªû‰ΩçÁΩÆ"
        - "&e&nÈªûÊìäÂè≥ÈçµÂÇ≥ÈÄÅÂà∞È´òÈªû‰ΩçÁΩÆ"
    y-limit:
      name: "Ê≠ª‰∫°YËª∏"
      description: "ÁèæÊôÇ‰ΩçÁΩÆ: {0}"
    build-max:
      name: "Âª∫ÁØâÈ´òÂ∫¶ÈôêÂà∂"
      description: "ÁèæÊôÇÊï∏ÂÄº: {0}"
    portal-protection-radius:
      name: "ÂÇ≥ÈÄÅÈñÄ‰øùË≠∑ÂçäÂæë"
      description: "ÁèæÊôÇÊï∏ÂÄº: {0}"
    clone:
      name: "Ë§áË£ΩÂ†¥Âú∞"
      description: "Ê≥®ÊÑè: ÊìÅÊúâË§áË£ΩÂ†¥Âú∞ÂæåÂ∞±‰∏çËÉΩÊõ¥ÊîπÊú¨Â†¥Âú∞ÁöÑÊï∏ÂÄº"
      action-description: "ÈªûÊìäÁÆ°ÁêÜË§áË£ΩÂ†¥Âú∞"
    delete:
      name: "ÁßªÈô§Â†¥Âú∞"
      description: "Ê≥®ÊÑè: Êú¨Ê≠•È©üÁÑ°Ê≥ïÈÇÑÂéü, Âª∫Ë≠∞ÂÖàÂÇô‰ªΩ, ÁÑ∂ÂæåÂÜç‰ΩøÁî®Êú¨ÊåâÈàï"
      action-description: "ÈªûÊìäÁßªÈô§Â†¥Âú∞"
      action-description-has-clone: "&c‰Ω†ÂøÖÈ†àË¶ÅÂà™Èô§Êú¨Â†¥Âú∞ÁöÑÂÖ∂ÂÆÉË§áË£ΩÂ†¥Âú∞, ÊâçËÉΩÁßªÈô§‰∏ªÂ†¥Âú∞"
    save:
      name: "ÂÑ≤Â≠òÂ†¥Âú∞"
      action-description: "ÈªûÊìäÂÑ≤Â≠òÂ†¥Âú∞"
    toggle:
      name: "Â†¥Âú∞ÁãÄÊÖã"
      description: "ÁèæÊôÇÁãÄÊÖã: {0}"
      need-restart: "&eÈúÄË¶ÅÈáçÂïü"
      action-description: "ÈªûÊìäÂàáÊèõÂ†¥Âú∞ÁãÄÊÖã"
      action-description-not-finished-setup: "&c‰Ω†ÈúÄË¶ÅÂÆåÊàêË®≠ÁΩÆÂ†¥Âú∞ÊâçËÉΩÊõ¥ÊîπÊú¨Ë®≠ÂÆö"
      action-description-need-restart: "&c‰Ω†ÈúÄË¶ÅÈáçÂïü‰º∫ÊúçÂô®ÊâçËÉΩÊõ¥ÊîπÊú¨Ë®≠ÂÆö"
    icon:
      name: "Ë®≠ÁΩÆÂ†¥Âú∞ÂúñÊ®ô"
      description: "ÁèæÊôÇÁÇ∫: {0}"
      action-description: "ÈªûÊìä‰ΩøÁî®‰Ω†ÁèæÊôÇÊãøËëóÁöÑÁâ©ÂìÅ‰ΩúÁÇ∫Â†¥Âú∞ÂúñÊ®ô"
      cannot-be-air: "&c‰Ω†Êâã‰∏äÊãøËëóÁöÑÁâ©ÂìÅ‰∏çËÉΩÁÇ∫Á©∫"
  edit:
    min: "&e&lÊ≠£Âú®Êõ¥ÊîπÂ†¥Âú∞ &b&l{0} &e&lÁöÑ‰ΩéÈªû‰ΩçÁΩÆ... Ë´ãÂ∑¶ÈçµÈªûÊìäÊñπÂ°äÂéªË®≠ÁΩÆ‰ΩçÁΩÆ"
    max: "&e&lÊ≠£Âú®Êõ¥ÊîπÂ†¥Âú∞ &b&l{0} &e&lÁöÑÈ´òÈªû‰ΩçÁΩÆ... Ë´ãÂ∑¶ÈçµÈªûÊìäÊñπÂ°äÂéªË®≠ÁΩÆ‰ΩçÁΩÆ"
    y-limit: "&e&lÊ≠£Âú®Êõ¥ÊîπÂ†¥Âú∞ &b&l{0} &e&lÁöÑÊ≠ª‰∫°YËª∏... Ë´ãÂú®ËÅäÂ§©ÂÆ§Ëº∏ÂÖ•‰∏ÄÂÄãÊñ∞ÁöÑÊï∏ÂÄº"
    build-max: "&e&lÊ≠£Âú®Êõ¥ÊîπÂ†¥Âú∞ &b&l{0} &e&lÁöÑÂª∫ÁØâÈ´òÂ∫¶‰∏äÈôê... Ë´ãÂú®ËÅäÂ§©ÂÆ§Ëº∏ÂÖ•‰∏ÄÂÄãÊñ∞ÁöÑÊï∏ÂÄº"
    portal-protection-radius: "&e&lÊ≠£Âú®Êõ¥ÊîπÂ†¥Âú∞ &b&l{0} &e&lÁöÑÂÇ≥ÈÄÅÈñÄ‰øùË≠∑ÂçäÂæë... Ë´ãÂú®ËÅäÂ§©ÂÆ§Ëº∏ÂÖ•‰∏ÄÂÄãÊñ∞ÁöÑÊï∏ÂÄº"
    allowed-kits: "&e&lÊ≠£Âú®Êõ¥ÊîπÂ†¥Âú∞ &b&l{0} &e&lÁöÑÂèØ‰ΩøÁî®ËÅ∑Ê•≠... Ë´ãÂú®ËÅäÂ§©ÂÆ§Ëº∏ÂÖ•‰∏ÄÂÄãÁèæÊúâÁöÑËÅ∑Ê•≠ÂêçÁ®±"
    allowed-kits-removed: "&aÊàêÂäüÁßªÈô§ÂèØ‰ΩøÁî®ËÅ∑Ê•≠ '{0}' Âà∞Â†¥Âú∞ {1}"
    allowed-kits-added: "&aÊàêÂäüÊñ∞Â¢ûÂèØ‰ΩøÁî®ËÅ∑Ê•≠ '{0}' Âà∞Â†¥Âú∞ {1}"
    cannot-edit-not-finished-setup: "&cÁî±ÊñºÂ†¥Âú∞ÈÇÑÊ≤íË®≠ÁΩÆÂÆåÊàê, Êú¨Ë®≠ÁΩÆ‰∏çËÉΩÊõ¥Êîπ"
    cannot-edit-need-restart: "&c‰Ω†ÈúÄË¶ÅÈáçÂïü‰º∫ÊúçÂô®ÊâçËÉΩÈñãÂïüÂ†¥Âú∞"
duel:
  cannot-find-player: "&cÊú™ËÉΩÊâæÂà∞Áé©ÂÆ∂ '{0}'"
  cannot-duel-self: "&c‰Ω†‰∏çËÉΩË∑üËá™Â∑±Â∞çÊà∞!"
  cannot-duel-not-in-party: "&cÂ∞çÊñπ‰∏çÂú®‰∏ÄÂÄãÈöä‰ºç"
  has-pending-duel-request: "&c‰Ω†ÁõÆÂâçÂ∑≤Êúâ‰∏ÄÂÄãÊ≠£Âú®Á≠âÂæÖÂ∞çÊâãÊé•ÂèóÁöÑÁöÑÊ±∫È¨•ÈÇÄË´ã, Ë´ãÂú®30ÁßíÂæåÂÜçÁôºÈÄÅ"
  invalid-player: "&cÁÑ°ÊïàÁöÑÁé©ÂÆ∂ '{0}'"
  invalid-kit: "&cÁÑ°ÊïàÁöÑËÅ∑Ê•≠ '{0}'"
  invalid-arena: "&cÁÑ°ÊïàÁöÑÂ†¥Âú∞ '{0}'"
  invalid-duel-request: "&cÁÑ°ÊïàÁöÑÊ±∫È¨•ÈÇÄË´ã! Ê±∫È¨•ÈÇÄË´ãÂèØËÉΩÂ∑≤Á∂ìÈÅéÊúü!"
  help-message:
    - "&cÊåá‰ª§Áî®Ê≥ï:"
    - "&c/duel <Áé©ÂÆ∂ÂêçÁ®±> [ËÅ∑Ê•≠] [Â†¥Âú∞] - Ë∑ü‰∏Ä‰ΩçÁé©ÂÆ∂Ê±∫È¨•/Ë∑üÂ∞çÊñπÁöÑÈöä‰ºçÊ±∫È¨•"
    - "&c/duel accept <UUID> - Êé•ÂèóÁé©ÂÆ∂ÁöÑÊ±∫È¨•ÈÇÄË´ã"
  choose-arena-menu:
    name: "ÈÅ∏ÊìáÂ†¥Âú∞"
    button:
      name: "&b{0}"
      random: "&bÈö®Ê©üÂú∞Âúñ"
      lore:
        - ""
        - "&e&nÈªûÊàëÈÅ∏ÊìáÊ≠§Â†¥Âú∞!"
  choose-kit-menu:
    name: "ÈÅ∏ÊìáËÅ∑Ê•≠"
    button:
      name: "&b{0}"
      lore:
        - ""
        - "&e&nÈªûÊìäÈÅ∏ÊìáÊ≠§ËÅ∑Ê•≠!"
  duel-request:
    cannot-find-target: "&cË©≤Áé©ÂÆ∂‰∏çÂú®Á∑ö‰∏ä"
    display-1v1: "&b{0} &fÁôºÈÄÅ‰∫Ü‰∏ÄÂÄãËÅ∑Ê•≠ÁÇ∫ &b{1}&f, Â†¥Âú∞ÁÇ∫ &b{2} &fÁöÑÊà∞È¨•ÈÇÄË´ãÁµ¶‰Ω† "
    display-party: "&b{0}ÁöÑÈöä‰ºç&9({3}) &fÁôºÈÄÅ‰∫Ü‰∏ÄÂÄãËÅ∑Ê•≠ÁÇ∫ &b{1}&f, Â†¥Âú∞ÁÇ∫ &b{2} &fÁöÑÊà∞È¨•ÈÇÄË´ãÁµ¶‰Ω† "
    click-to-accept: "&a[ÈªûÊàëÊé•ÂèóÈÇÄË´ã]"
    click-to-accept-hover: "&aÈªûÊàëÊé•ÂèóÈÇÄË´ã"
    click-to-view-ping: "&a[ÈªûÊàëÊü•ÁúãÂ∞çÊâãÁöÑÂª∂ÈÅ≤]"
    click-to-view-ping-hover: "&f{0}ÁöÑÂª∂ÈÅ≤: &b{1}ms"
    success-1v1: "&f‰Ω†ÊàêÂäüÁôºÈÄÅ‰∫Ü‰∏ÄÂÄãËÅ∑Ê•≠ÁÇ∫ &b{0}&f, Â†¥Âú∞ÁÇ∫ &b{1} &f ÁöÑÊà∞È¨•ÈÇÄË´ãÁµ¶ &b{2}"
    success-party: "&f‰Ω†ÊàêÂäüÁôºÈÄÅ‰∫Ü‰∏ÄÂÄãËÅ∑Ê•≠ÁÇ∫ &b{0}&f, Â†¥Âú∞ÁÇ∫ &b{1} &f ÁöÑÊà∞È¨•ÈÇÄË´ãÁµ¶ &b{2}ÁöÑÈöä‰ºç"
  verify:
    target-not-found: "&cÂ∞çÊ±∫Áé©ÂÆ∂‰∏çÂú®Á∑ö‰∏ä"
    need-to-be-in-lobby: "&c‰Ω†ÂøÖÈ†àË¶ÅÂú®Â§ßÂª≥ÁãÄÊÖãÊâçËÉΩË∑üÁé©ÂÆ∂Â∞çÊ±∫"
    target-need-to-be-in-lobby: "&cÂ∞çÊñπÂøÖÈ†àË¶ÅÂú®Â§ßÂª≥ÁãÄÊÖãÊâçËÉΩË∑ü‰Ω†Â∞çÊ±∫"
    target-duel-request-disabled: "&cÂ∞çÊñπÊ≤íÊúâÈñãÂïüÊ±∫È¨•ÈÇÄË´ã"
    arena-disabled: "&cÈåØË™§: Â†¥Âú∞Ê≤íÊúâÈñãÂïü"
    cannot-find-arena: "&cÈåØË™§: Êú™ËÉΩÊâæÂà∞ÂêàÈÅ©ÁöÑÂ†¥Âú∞"
    target-in-a-party: "&cË©≤Áé©ÂÆ∂Â∑≤Á∂ìÂú®Èöä‰ºç‰∏≠"
    target-not-in-a-party: "&cË©≤Áé©ÂÆ∂Ê≤íÊúâ‰∏ÄÂÄãÈöä‰ºç"
    cannot-duel-same-party: "&c‰Ω†‰∏çËÉΩÂ∞çÊ±∫Ëá™Â∑±ÁöÑÈöä‰ºç"
    player-not-in-lobby: "&c{0} ÁöÑÈöä‰ºçË£èÁöÑÊâÄÊúâÁé©ÂÆ∂ÂøÖÈ†àË¶ÅÂú®Âêå‰∏ÄÂÄã‰º∫ÊúçÂô®, ‰∏¶‰∏îË¶ÅÂú®Â§ßÂª≥ÁãÄÊÖã/Á∑®ËºØËÅ∑Ê•≠ÁãÄÊÖãÊâçËÉΩÊé•ÂèóÊ±∫È¨•ÈÇÄË´ã"
event:
  event-is-running: "&cÁèæÊôÇÊúâ‰∏ÄÂÄãÊ≠£Âú®ÈÄ≤Ë°åÁöÑÊ¥ªÂãï!"
  event-is-not-running: "&cÁèæÊôÇ‰∏¶Ê≤íÊúâ‰∏ÄÂÄãÊ≠£Âú®ÈÄ≤Ë°åÁöÑÊ¥ªÂãï!"
  event-already-started: "&cÊ¥ªÂãïÂ∑≤Á∂ìÈñãÂßã!"
  no-available-status: "&cÈÄôÂÄãÊ¥ªÂãïÊ≤íÊúâÁãÄÊÖãÂèØ‰ª•Êü•Áúã!"
  wrong-state: "&c‰Ω†ÂøÖÈ†àË¶ÅÂú®Â§ßÂª≥ÊâçËÉΩÂä†ÂÖ•Ê¥ªÂãï!"
  auto-create-party-because-need-a-party: "&7[&bÊ¥ªÂãï&7] &eÊ¥ªÂãïÈúÄË¶ÅÊìÅÊúâ‰∏ÄÂÄãÊ¥æÂ∞çÊâçËÉΩÂèÉÂä†, ‰Ω†Â∑≤Ëá™ÂãïÂâµÂª∫‰∫Ü‰∏ÄÂÄãÊ¥æÂ∞ç"
  party-size-over: "&c‰Ω†ÁöÑÈöä‰ºç‰∫∫Êï∏Ë∂ÖÂá∫ÈôêÂà∂! Êú¨Ê¥ªÂãïÊúÄÂ§ß‰∫∫Êï∏ÁÇ∫ {0}"
  auto-set-party-size: "&7[&bÊ¥ªÂãï&7] &e‰Ω†Âú®‰∏ÄÂÄãÈöä‰ºçÁöÑÊÉÖÊ≥Å‰∏ãÂä†ÂÖ•‰∫ÜÊ¥ªÂãï, Â∑≤Êää‰Ω†ÁöÑÊ¥æÂ∞çÊúÄÂ§ß‰∫∫Êï∏ÊîπÁÇ∫ &b&l{0}"
  cannot-use-this-command: "&c‰Ω†‰∏çËÉΩÂú®Ê¥ªÂãïÁöÑÊôÇÂÄô‰ΩøÁî®ÈÄôÂÄãÊåá‰ª§"
  leave-event-because-party-disband: "&eÁî±ÊñºÈöä‰ºçÂ∑≤Ëß£Êï£, ‰Ω†ÁöÑÈöä‰ºçÂ∑≤Ëá™ÂãïÈÄÄÂá∫Ê¥ªÂãï"
  cannot-join-party-because-in-event: "&c‰Ω†‰∏çËÉΩÈÄ≤ÂéªË©≤Èöä‰ºç, Âõ†ÁÇ∫Ë©≤Èöä‰ºçÂú®‰∏ÄÂÄãÊ¥ªÂãïË£èÈù¢"
  leave-event-because-error: "&cÈåØË™§: ‰Ω†Â∑≤Ë¢´Êú¨Ê¥ªÂãïÁßªÈô§, ÈÄôÊòØ‰∏ÄÂÄãÁ≥ªÁµ±ÈåØË™§, Ë´ãÂõûÂ†±Áµ¶Á≥ªÁµ±ÁÆ°ÁêÜÂì°"
  force-cancel-event: "&c{0}Â∑≤Ë¢´ÁÆ°ÁêÜÂì°Âº∑Âà∂ÁµêÊùü"
  no-winner-because-no-party: "&7[&bÊ¥ªÂãï&7] &cÊ≤íÊúâÊ¥æÂ∞çÁîüÈÇÑ, Êú¨Ê¨°Ê¥ªÂãïÊ≤íÊúâÂãùÂà©ËÄÖ"
  winner-announce:
    message: "&7[&bÊ¥ªÂãï&7] &aÂãùÂà©ËÄÖ: &b{0}"
    split-format: "&7, &b"
  event-create-menu:
    title: "Âª∫Á´ãÊ¥ªÂãï"
    button:
      name: "&b{0}"
      lore:
        click-to-create-event: "&e&nÈªûÊìäÈÄ≤ÂÖ•Ê¥ªÂãïË®≠ÁΩÆÁïåÈù¢!"
        no-permission: "&c‰Ω†Ê≤íÊúâÊ¨äÈôêÂâµÂª∫ÈÄôÂÄãÊ¥ªÂãï!"
  event-select-kit-menu:
    title: "ÈÅ∏ÊìáÊ¥ªÂãïËÅ∑Ê•≠"
    button:
      name: "{0}"
      lore:
        - ""
        - "&e&nÈªûÊìäÈÅ∏ÊìáË©≤ËÅ∑Ê•≠ÁÇ∫Êú¨Ê¨°Ê¥ªÂãïÁöÑËÅ∑Ê•≠!"
  event-settings-menu:
    title: "Ê¥ªÂãïË®≠ÁΩÆ"
    max-players-button:
      name: "&bÊúÄÂ§ß‰∫∫Êï∏"
      lore:
        - ""
        - "&fÁèæÊôÇÊúÄÂ§ß‰∫∫Êï∏: &b{0}"
        - ""
        - "&aÂ∑¶Èçµ&fÈªûÊìäÊääÊúÄÂ§ß‰∫∫Êï∏ÊèêÂçá 1"
        - "&aShift + Â∑¶Èçµ&fÈªûÊìäÊääÊúÄÂ§ß‰∫∫Êï∏ÊèêÂçá 10"
        - ""
        - "&cÂè≥Èçµ&fÈªûÊìäÊääÊúÄÂ§ß‰∫∫Êï∏Èôç‰Ωé 1"
        - "&cShift + Âè≥Èçµ&fÈªûÊìäÊääÊúÄÂ§ß‰∫∫Êï∏Èôç‰Ωé 10"
        - ""
        - "&e&nÈªûÊìäÊõ¥ÊîπÊúÄÂ§ß‰∫∫Êï∏!"
    party-size-button:
      name: "&bÈöä‰ºç‰∫∫Êï∏"
      lore:
        - ""
        - "&fÁèæÊôÇÈöä‰ºç‰∫∫Êï∏: &b{0}"
        - ""
        - "&aÂ∑¶Èçµ&fÈªûÊìäÊääÈöä‰ºç‰∫∫Êï∏ÊèêÂçá 1"
        - "&cÂè≥Èçµ&fÈªûÊìäÊääÊúÄÂ§ß‰∫∫Êï∏Èôç‰Ωé 1"
        - ""
        - "&e&nÈªûÊìäÊõ¥ÊîπÈöä‰ºç‰∫∫Êï∏!"
    kit-button:
      name: "&bËÅ∑Ê•≠ÈÅ∏Êìá"
      lore:
        - ""
        - "&fÂ∑≤ÈÅ∏ÊìáËÅ∑Ê•≠: &b{0}"
        - ""
        - "&e&nÈªûÊìäÈÅ∏Êìá‰∏ÄÂÄãËÅ∑Ê•≠!"
    start-button:
      name: "&bÈñãÂßãÊ¥ªÂãï"
      lore:
        - ""
        - "&fÊ¥ªÂãï: &b{0}"
        - "&fÊúÄÂ§ß‰∫∫Êï∏: &b{1}"
        - "&fÊúÄÂ∞è‰∫∫Êï∏: &b{2}"
        - ""
        - "&e&nÈªûÊìäÈñãÂßãÊ¥ªÂãï!"
  event-create:
    message: "&7[&bÊ¥ªÂãï&7] &b{0} &fÊ≠£Âú®ËàâËæ¶‰∏ÄÂÄã &b{1} &fÊ¥ªÂãï! "
    clickable:
      message: "&a(ÈªûÊàëÂä†ÂÖ•Ê¥ªÂãï)"
      hover: "&eÈªûÊìäÂä†ÂÖ•Ê¥ªÂãï!"
  party-name-format: "ÁöÑÈöä‰ºç"
  event-join:
    message: "&7[&bÊ¥ªÂãï&7] &b{0} &fÂä†ÂÖ•‰∫Ü&b{1} &7(&b{2}&7/&b{3}&7) "
    clickable:
      message: "&a(ÈªûÊàëÂä†ÂÖ•Ê¥ªÂãï)"
      hover: "&eÈªûÊìäÂä†ÂÖ•Ê¥ªÂãï!"
  starting-full: "&7[&bÊ¥ªÂãï&7] &fÊ¥ªÂãï‰∫∫Êï∏Â∑≤Êªø, Ê∫ñÂÇôÈñãÂßãÊ¥ªÂãï..."
  event-leave:
    message: "&7[&bÊ¥ªÂãï&7] &b{0} &cÈõ¢Èñã‰∫Ü&b{1} &7(&b{2}&7/&b{3}&7)"
  event-start-countdown:
    message: "&7[&bÊ¥ªÂãï&7] &b{0}&fÂ∞áÊúÉÂú® &b&l{1} &fÁßíÂæåÈñãÂßã "
    clickable:
      message: "&a(ÈªûÊàëÂä†ÂÖ•Ê¥ªÂãï)"
      hover: "&eÈªûÊìäÂä†ÂÖ•Ê¥ªÂãï!"
  cancel-not-enough-players: "&7[&bÊ¥ªÂãï&7] &cÂèÉÂä†‰∫∫Êï∏‰∏çË∂≥! Ê¥ªÂãïÂ∑≤Âº∑Âà∂ÁµÇÊ≠¢"
  tournament:
    name: "Èå¶Ê®ôË≥Ω"
    match-end-message: "&7[&bÊ¥ªÂãï&7] &a{0} &fÊìäÊïó‰∫Ü &c{1} &7(Ââ©È§ò {2} &7Â†¥Êà∞È¨•)"
    scoreboard:
      starting-event:
        - ""
        - "&b&l‚îÉ &b&l{event-uncolored-name}"
        - "&b&l‚îÉ  &fÁèæÊôÇ‰∫∫Êï∏: &b{event-total-players}&7/&b{event-max-players}"
        - "&b&l‚îÉ  &fÂ∞áÊúÉÂú® &b&l{event-countdown} &fÁßíÂæåÈñãÂßã"
      starting-new-round:
        - ""
        - "&b&l‚îÉ &b&l{event-uncolored-name}"
        - "&b&l‚îÉ  &fÁ¨¨ &b&l{0} &fÂõûÂêà"
        - "&b&l‚îÉ  &fÂ∞áÊúÉÂú® &b&l{event-countdown} &fÁßíÂæåÈñãÂßã"
      fighting:
        - ""
        - "&b&l‚îÉ &b&l{event-uncolored-name}"
        - "&b&l‚îÉ  &fÁ¨¨ &b&l{0} &fÂõûÂêà"
        - "&b&l‚îÉ  &fÂâ©È§òÊà∞È¨•: &b{1}"
    status:
      starting-event:
        - ""
        - "&b&l{0}"
        - "&fÊ≠£Âú®Ê∫ñÂÇôÈñãÂßã..."
        - ""
      starting-new-round:
        - ""
        - "&b&l{0}"
        - "&fÁ¨¨ &b&l{1} &fÂõûÂêàÊ≠£Âú®Ê∫ñÂÇôÈñãÂßã"
        - ""
      fighting:
        - ""
        - "&b&l{0}"
        - "&fÊ≠£Âú®ÈÄ≤Ë°åÁ¨¨ &b&l{1} &fÂõûÂêà"
        - ""
        - "{2}"
        - ""
      fighting-team-format: "&b{0} &fvs &b{1}"
    new-round:
      countdown: "&7[&bÊ¥ªÂãï&7] &fÁ¨¨ &b&l{0} &fËº™Èå¶Ê®ôË≥ΩÂ∞áÊúÉÂú® &b&l{1} &fÁßíÂæåÈñãÂßã..."
      start:
        - ""
        - "&7[&bÊ¥ªÂãï&7] &fÁ¨¨ &b&l{0} &fÂõûÂêàÂ∑≤Á∂ìÈñãÂßã!"
        - "&7[&bÊ¥ªÂãï&7] &f‰ΩøÁî®Êåá‰ª§ &7'&b/event status&7' &fÂéªÊü•ÁúãÊú¨Ëº™Êà∞È¨•!"
        - ""
      no-available-arena: "&7[&bÊ¥ªÂãï&7] &cÈåØË™§: Â†¥Âú∞‰∏çË∂≥, ‰Ω†ÁöÑÊ¥æÂ∞çÂ∞áÊúÉÊîæÁΩÆÂà∞‰∏ã‰∏ÄÂÄãÂõûÂêàÊâçÊúÉÈñãÂßã"
      auto-promotion: "&7[&bÊ¥ªÂãï&7] &eÊú¨ÂõûÂêàÊ¥æÂ∞çÁ∏ΩÊï∏ÁÇ∫ÂñÆÊï∏, ‰Ω†ÁöÑÈöä‰ºçÂ∑≤Ë¢´Ëá™ÂãïÊôâÁ¥ö &a:)"
  sumo-event:
    name: "Áõ∏Êí≤Â§ßË≥Ω"
    match-end-message: "&7[&bÊ¥ªÂãï&7] &a{0} &fÊìäÊïó‰∫Ü &c{1}"
    lobby-scoreboard:
      starting-event:
        - ""
        - "&b&l‚îÉ &b&l{event-uncolored-name}"
        - "&b&l‚îÉ  &fÁèæÊôÇ‰∫∫Êï∏: &b{event-total-players}&7/&b{event-max-players}"
        - "&b&l‚îÉ  &fÂ∞áÊúÉÂú® &b&l{event-countdown} &fÁßíÂæåÈñãÂßã"
      fighting:
        - ""
        - "&b&l‚îÉ &b&l{event-uncolored-name}"
        - "&b&l‚îÉ  &fÁ¨¨ &b&l{0} &fÂõûÂêà"
        - "&b&l‚îÉ  &f{1} &bvs &f{2}"
    in-game-scoreboard:
      starting-match:
        - "&7&m----------------------"
        - "&b&l‚îÉ  &7&oÊ¥ªÂãïÂç≥Â∞áÈñãÂßã..."
        - ""
        - "&bdiamond.rip"
        - "&7&m----------------------"
      fighting:
        - "&7&m----------------------"
        - "&b&l‚îÉ &fÊ¥ªÂãï: &b{match-event-type}"
        - "&b&l‚îÉ &fÊôÇÈñì: &b{match-duration}"
        - "&b&l‚îÉ &fÂõûÂêà: &b{match-event-round}"
        - ""
        - "&b&l‚îÉ &b{0}"
        - "&b&l‚îÉ &7vs"
        - "&b&l‚îÉ &b{1}"
        - ""
        - "&bdiamond.rip"
        - "&7&m----------------------"
      ending:
        - "&7&m----------------------"
        - "&b&l‚îÉ &aÊú¨Â†¥Êà∞È¨•Â∑≤ÁµêÊùü!"
        - "&b&l‚îÉ &fÂãùÂà©ËÄÖ: &b{match-event-winner}"
        - ""
        - "&bdiamond.rip"
        - "&7&m----------------------"
    status:
      starting-event:
        - ""
        - "&b&l{0}"
        - "&fÊ≠£Âú®Ê∫ñÂÇôÈñãÂßã..."
        - ""
      starting-new-round:
        - ""
        - "&b&l{0}"
        - "&fÁ¨¨ &b&l{1} &fÂõûÂêàÊ≠£Âú®Ê∫ñÂÇôÈñãÂßã"
        - ""
      fighting:
        - ""
        - "&b&l{0}"
        - "&fÊ≠£Âú®ÈÄ≤Ë°åÁ¨¨ &b&l{1} &fÂõûÂêà"
        - "{2} vs {3}"
        - ""
    new-round:
      countdown: "&7Á¨¨ &b&l{0} &7ÂõûÂêàÂ∞áÊúÉÂú® &b&l{1} &7ÁßíÂæåÈñãÂßã..."
      started: "&bÂõûÂêàÈñãÂßã!"
hook:
  found-custom-spigot: "&aÂÅµÊ∏¨Âà∞‰º∫ÊúçÂô®Ê≠£Âú®ÈÅãË°å &b{0}&a, ÊìäÈÄÄÈÅã‰ΩúÂ∞áÊúÉ‰ΩøÁî®ÈÄôÂÄã‰º∫ÊúçÂô®Ê†∏ÂøÉ"
  cannot-find-custom-spigot: "&eÊú™ËÉΩÊâæÂà∞ÁâπÂÆö‰º∫ÊúçÂô®Ê†∏ÂøÉ, Â∞á‰∏çÊúÉÈÄ≤Ë°å‰ªª‰ΩïÁöÑÊìäÈÄÄÊõ¥Êîπ"
  error-knockback-not-found: "&cÈåØË™§: Ë´ãÂõûÂ†±Áµ¶‰º∫ÊúçÂô®ÁÆ°ÁêÜÂì° (ERROR_KNOCKBACK_NOT_FOUND)"
kit-editor:
  cannot-edit-wrong-state: "&c‰Ω†‰∏çËÉΩÂú®ÈÄôÂÄãÊÉÖÊ≥Å‰∏ãÁ∑®ËºØËÅ∑Ê•≠ÊéíÁâà"
  extra-item-menu-name: "È°çÂ§ñÁâ©ÂìÅ"
  save-menu:
    name: "ÂÑ≤Â≠òËÅ∑Ê•≠"
    save-loadout-button-name: "&fÂÑ≤Â≠òÊéíÁâà &b{0}"
    load-loadout-button-name: "&fÂä†ËºâÊéíÁâà &b{0}"
    rename-loadout-button-name: "&fÂëΩÂêçÊéíÁâà &b{0}"
    delete-loadout-button-name: "&cÁßªÈô§ÊéíÁâà &b{0}"
    rename-instructions: "&e&lÊ≠£Âú®ÈáçÊñ∞ÂëΩÂêç &b{0}&e&l... Ë´ãÂú®ËÅäÂ§©ÂÆ§Ëº∏ÂÖ•‰∏ÄÂÄãÊñ∞ÁöÑÊï∏ÂÄº"
    invalid-character: "&cË©≤ÂêçÁ®±ÊìÅÊúâ‰∏çÊ≠£Áï∂Á¨¶Ëôü"
  select-kit-menu:
    name: "ÈÅ∏Êìá‰∏ÄÂÄãËÅ∑Ê•≠"
    button:
      name: "&b{0}"
      lore:
        - ""
        - "&e&nÈªûÊìäÈñãÂßãË®≠ÁΩÆËÅ∑Ê•≠ÊéíÁâà!"
  cannot-use-command-while-editing: "&cË´ãÂÖàÈÄÄÂá∫Ëá™ÂÆöÁæ©ÊéíÁâàÁ∑®ËºØ, Êâç‰ΩøÁî®ÂÖ∂‰ªñÊåá‰ª§"
  disallow-extra-item: "&cÈÄôÂÄãËÅ∑Ê•≠‰∏çÂÖÅË®±ÊìÅÊúâÈ°çÂ§ñÁâ©ÂìÅ"
  cannot-find-editor-location: "&cÈåØË™§: Êú™ËÉΩÊâæÂà∞ËÅ∑Ê•≠Á∑®ËºØÂô®ÂùêÊ®ô"
  editing:
    - ""
    - "&f‰Ω†ÁèæÂú®Ê≠£Âú®Á∑®ËºØ &b{0} &fÁöÑËá™ÂÆöÁæ©ÊéíÁâà"
    - ""
    - "&9 ‚Ä¢ &fÂè≥ÈçµÈªûÊìäÈêµÁ†ßÂéªÂÑ≤Â≠òÊÇ®ÁöÑËá™ÂÆöÁæ©ÊéíÁâà"
    - "&9 ‚Ä¢ &fÂè≥ÈçµÈªûÊìäÁÆ±Â≠êÂèØ‰ª•Áç≤ÂèñÊõ¥Â§öÁöÑÁâ©ÂìÅ (Âè™ÈôêÁâπÂÆöËÅ∑Ê•≠)"
    - "&9 ‚Ä¢ &fÂè≥ÈçµÈªûÊìäÂëäÁ§∫ÁâåÂéªÈõ¢ÈñãÊéíÁâàÁãÄÊÖã"
    - ""
kit:
  not-exists: "&cËÅ∑Ê•≠ '{0}' ‰∏çÂ≠òÂú®!"
  no-kits-found: "&c‰Ω†Ê≤íÊúâ‰ªª‰ΩïËÅ∑Ê•≠! Ë´ãÂÖà‰ΩøÁî®Êåá‰ª§ '/kit create <ID>' ÂâµÂª∫‰∏ÄÂÄãËÅ∑Ê•≠!"
  saved: "&aÊàêÂäüÂÑ≤Â≠òËÅ∑Ê•≠ &e{0} &aÂà∞Ë≥áÊñôÂ∫´!"
  saved-all-kits: "&aÊàêÂäüÂÑ≤Â≠òÊâÄÊúâËÅ∑Ê•≠!"
  kit-already-exists: "&cËÅ∑Ê•≠ '{0}' Â∑≤Á∂ìÂ≠òÂú®, ‰∏çËÉΩÂâµÂª∫ÂêåÊ®£ ID ÁöÑËÅ∑Ê•≠"
  successfully-create: "&aÊàêÂäüÂâµÂª∫ËÅ∑Ê•≠ '{0}'!"
  successfully-delete: "&aÊàêÂäüÂà™Èô§ËÅ∑Ê•≠ '{0}!"
  successfully-clone: "&aÊàêÂäüÊääËÅ∑Ê•≠ '{0}' ÁöÑÈÅäÊà≤Ë¶èÂâáË§áË£ΩÂà∞ '{1}'"
  cannot-save-extra-items: "&cÁÑ°Ê≥ïÂÑ≤Â≠òËÅ∑Ê•≠È°çÂ§ñÁâ©ÂìÅ, '{0}' == null"
  successfully-updated-extra-items: "&aÊàêÂäüÊõ¥Êñ∞ËÅ∑Ê•≠ &b{0} &aÁöÑÈ°çÂ§ñÁâ©ÂìÅ!"
  button:
    edit-damage-ticks:
      name: "&b&l‰øÆÊîπËÅ∑Ê•≠ÂÇ∑ÂÆ≥ÂÜ∑Âçª"
      lore:
        - ""
        - "&7ÁèæÊôÇËÅ∑Ê•≠ÂÇ∑ÂÆ≥ÂÜ∑Âçª: {0}"
        - "&cÊ≥®ÊÑè: Â¶ÇÊûúÊÇ®Ê≠£Âú®‰ΩøÁî®Ëá™ÂÆöÁæ©SpigotÊ†∏ÂøÉ, ÈÄôÂÄãË®≠ÂÆöÂèØËÉΩÊúÉÊ≤íÊúâÁî®"
        - ""
        - "&e&nÈªûÊìä‰øÆÊîπËÅ∑Ê•≠ÂÇ∑ÂÆ≥ÂÜ∑Âçª!"
      procedure:
        message: "&e&lÊ≠£Âú®Êõ¥Êîπ&b&lËÅ∑Ê•≠ÂÇ∑ÂÆ≥ÂÜ∑Âçª&e&l... Ë´ãÂú®ËÅäÂ§©ÂÆ§Ëº∏ÂÖ•‰∏ÄÂÄãÊñ∞ÁöÑÊï∏ÂÄº"
        success: "&fË®≠ÁΩÆ &b{0} &fÁöÑËÅ∑Ê•≠ÂÇ∑ÂÆ≥ÂÜ∑ÂçªÂà∞Âà∞ &b{1}"
        additional-message: "&c‰Ω†ÁöÑË®äÊÅØÂøÖÈ†àÁÇ∫Êï∏Â≠ó"
    edit-description:
      name: "&b&l‰øÆÊîπËÅ∑Ê•≠‰ªãÁ¥π"
      lore-start:
        - ""
        - "&7ÁèæÊôÇËÅ∑Ê•≠‰ªãÁ¥π: "
      lore-end:
        - ""
        - "&e&nÈªûÊìäÊõ¥ÊîπËÅ∑Ê•≠‰ªãÁ¥π!"
        - "&e&nÊîæ‰∏ãÂà™Èô§Áï∂ÂâçËÅ∑Ê•≠‰ªãÁ¥π!"
      procedure:
        message: "&e&lÊ≠£Âú®Êõ¥Êîπ&b&lËÅ∑Ê•≠‰ªãÁ¥π&e&l... Ë´ãÂú®ËÅäÂ§©ÂÆ§Ëº∏ÂÖ•‰∏ÄÂÄãÊñ∞ÁöÑÊï∏ÂÄº"
        success: "&fË®≠ÁΩÆ &b{0} &fÁöÑËÅ∑Ê•≠‰ªãÁ¥πÂà∞ &b{1}"
        additional-message: "&e‰Ω†ÂèØ‰ª•‰ΩøÁî® ';' ÂéªÂàÜÈöîË°åÊï∏"
    edit-display-name:
      name: "&b&l‰øÆÊîπËÅ∑Ê•≠È°ØÁ§∫ÂêçÁ®±"
      lore:
        - ""
        - "&7ÁèæÊôÇËÅ∑Ê•≠ÂêçÁ®±: {0}"
        - ""
        - "&e&nÈªûÊìäÊõ¥ÊîπËÅ∑Ê•≠È°ØÁ§∫ÂêçÁ®±!"
      procedure:
        message: "&e&lÊ≠£Âú®Êõ¥Êîπ&b&lËÅ∑Ê•≠ÂêçÁ®±&e&l... Ë´ãÂú®ËÅäÂ§©ÂÆ§Ëº∏ÂÖ•‰∏ÄÂÄãÊñ∞ÁöÑÊï∏ÂÄº"
        success: "&fË®≠ÁΩÆ &b{0} &fÁöÑËÅ∑Ê•≠ÂêçÁ®±Âà∞ &b{1}"
    edit-extra-items:
      name: "&b&l‰øÆÊîπËÅ∑Ê•≠È°çÂ§ñÁâ©ÂìÅ"
      lore:
        - ""
        - "&e&nÈªûÊìä‰øÆÊîπËÅ∑Ê•≠È°çÂ§ñÁâ©ÂìÅ!"
    edit-icon:
      name: "&b&l‰øÆÊîπËÅ∑Ê•≠ÂúñÊ®ô"
      lore:
        - ""
        - "&7ÁèæÊôÇÂúñÊ®ô: {0}"
        - "&7ÁèæÊôÇÂúñÊ®ôËÄê‰πÖ: {1}"
        - ""
        - "&e&nÈªûÊìäÊää‰Ω†Êâã‰∏äÁöÑÁâ©ÂìÅ‰øÆÊîπÁÇ∫Êú¨ËÅ∑Ê•≠ÂúñÊ®ô!"
      procedure:
        air: "&c‰Ω†‰∏çËÉΩÊääËÅ∑Ê•≠ÂúñÊ®ôË®≠ÁΩÆÁÇ∫Á©∫Ê∞£!"
        success: "&fË®≠ÁΩÆ &b{0} &fÁöÑËÅ∑Ê•≠ÂúñÊ®ôÂà∞Âà∞ &b{1}"
    edit-match-type:
      name: "&b&l‰øÆÊîπÊà∞È¨•ÂÖÅË®±È°ûÂûã"
      lore-click-left: "&e(ÈªûÊìäÂ∑¶Èçµ)"
      lore-click-middle: "&e(ÈªûÊìäÊªëËº™Èçµ)"
      lore-click-right: "&e(ÈªûÊìäÂè≥Èçµ)"
      lore:
        - ""
        - "&e&nÈªûÊìäÂàáÊèõÊà∞È¨•ÂÖÅË®±È°ûÂûã"
    edit-potion-effect:
      name: "&b&l‰øÆÊîπËó•Ê∞¥ÊïàÊûú"
      lore-start:
        - ""
        - "&7ÁèæÊôÇËó•Ê∞¥ÊïàÊûú: &9({0})"
      lore-end:
        - ""
        - "&e&nÈªûÊìä‰øÆÊîπËó•Ê∞¥ÊïàÊûú!"
      procedure:
        message: "&e&lÊ≠£Âú®Êõ¥Êîπ&b&lËó•Ê∞¥ÊïàÊûú&e&l... Ë´ãÂú®ËÅäÂ§©ÂÆ§Ëº∏ÂÖ•‰∏ÄÂÄãÊñ∞ÁöÑÊï∏ÂÄº"
        already-have-potion-effect:
          - "&cËÅ∑Ê•≠ &b'{0}' &cÂ∑≤ÊìÅÊúâËó•Ê∞¥ÊïàÊûú &9{1}"
          - "&cÂ¶ÇÊûú‰Ω†ÊÉ≥ÂèñÊõøÂéüÊú¨ÁöÑÊïàÊûú, Ë´ãÂÖàÁßªÈô§ÂéüÊú¨ÁöÑÊïàÊûú, ÁÑ∂ÂæåÂÜçÂä†ÂÖ•Êñ∞ÁöÑÊïàÊûú"
        success-add: "&fÊàêÂäüÂú®ËÅ∑Ê•≠ &b{0} &fÊñ∞Â¢ûËó•Ê∞¥ÊïàÊûú &b{1}"
        success-remove: "&fÊàêÂäüÂú®ËÅ∑Ê•≠ &b{0} &fÁßªÈô§Ëó•Ê∞¥ÊïàÊûú &b{1}"
        additional-message:
          - "&e‰Ω†ÁöÑË®äÊÅØÂøÖÈ†àÁÇ∫ '{effect name};{amplifier};{duration (Áî®TicksË®àÁÆó)}'"
          - "&Â¶ÇÊûú‰Ω†ÊÉ≥ÁßªÈô§‰∏ÄÂÄãËó•Ê∞¥ÊïàÊûú, Ë´ãËº∏ÂÖ• '-{Ëó•Ê∞¥ÊïàÊûúÂêçÁ®±}'"
    edit-priority:
      name: "&b&l‰øÆÊîπËÅ∑Ê•≠ÊéíÂ∫è"
      lore:
        - ""
        - "&7ÁèæÊôÇËÅ∑Ê•≠ÊéíÂ∫è: {0}"
        - ""
        - "&e&nÈªûÊìä‰øÆÊîπËÅ∑Ê•≠ÊéíÂ∫è!"
      procedure:
        message: "&e&lÊ≠£Âú®Êõ¥Êîπ&b&lËÅ∑Ê•≠ÊéíÂ∫è&e&l... Ë´ãÂú®ËÅäÂ§©ÂÆ§Ëº∏ÂÖ•‰∏ÄÂÄãÊñ∞ÁöÑÊï∏ÂÄº"
        success: "&fË®≠ÁΩÆ &b{0} &fÁöÑËÅ∑Ê•≠ÊéíÂ∫èÂà∞Âà∞ &b{1}"
        additional-message: "&c‰Ω†ÁöÑË®äÊÅØÂøÖÈ†àÁÇ∫Êï∏Â≠ó"
    preview:
      lore:
        - ""
        - "&e&nÂ∑¶ÈçµÈ†êË¶ΩËÅ∑Ê•≠"
        - "&e&nÂè≥ÈçµÁç≤ÂèñËÅ∑Ê•≠ÊéíÁâà"
    save:
      name: "&b&lÂÑ≤Â≠òËÅ∑Ê•≠Ë®≠ÂÆö"
      lore:
        - ""
        - "&e&nÈªûÊìäÂÑ≤Â≠òËÅ∑Ê•≠Ë®≠ÂÆö"
    rules-toggle:
      success: "&fË®≠ÁΩÆ &b{0} &f{1}Âà∞&b{2}"
    rules-set-value:
      name: "&b&l{0}"
      lore:
        - ""
        - "&7{0}"
        - ""
        - "&7ÁèæÊôÇÊï∏ÂÄº: {1}"
        - ""
        - "&e&nÈªûÊìäÊõ¥ÊîπÊï∏ÂÄº!"
      procedure:
        message: "&e&lÊ≠£Âú®Êõ¥Êîπ&b&l{0}&e&l... Ë´ãÂú®ËÅäÂ§©ÂÆ§Ëº∏ÂÖ•‰∏ÄÂÄãÊñ∞ÁöÑÊï∏ÂÄº"
        success: "&fË®≠ÁΩÆ &b{0} &fÂà∞ &b{1}"
        additional-message: "&c‰Ω†ÁöÑË®äÊÅØÂøÖÈ†àÁÇ∫Êï∏Â≠ó"
    save-loadout:
      name: "&b&lÂÑ≤Â≠òËÅ∑Ê•≠È†êË®≠ÊéíÁâà"
      lore:
        - ""
        - "&7Ê≥®ÊÑè: ÈÄôÂ∞áÊúÉÊää‰Ω†ÁèæÊôÇË∫´‰∏äÁöÑ"
        - "&7Áâ©ÂìÅË®≠ÁΩÆÂÅâÊú¨ËÅ∑Ê•≠ÁöÑÊéíÁâà"
        - ""
        - "&e&nÈªûÊìäÂÑ≤Â≠òËÅ∑Ê•≠È†êË®≠ÊéíÁâà!"
      success: "&aÊàêÂäüÊõ¥Êñ∞ËÅ∑Ê•≠ {0} ÁöÑÈ†êË®≠ÊéíÁâà"
    toggle:
      name: "&b&lÁãÄÊÖã"
      description: "&7Áï∂ÂâçÁãÄÊÖã: {0}"
      success: "&fË®≠ÁΩÆ &b{0} &fÁöÑÁãÄÊÖãÂà∞ &b{1}"
    toggle-ranked:
      name: "&b&lÊéí‰ΩçÊ®°Âºè"
      description: "&7Áï∂ÂâçÁãÄÊÖã: {0}"
      success: "&fË®≠ÁΩÆ 7b{0} &fÁöÑÊéí‰ΩçÊ®°ÂºèÁÇ∫ &b{1}"
  kit-detail-menu:
    title: "Ê≠£Âú®Á∑®ËºØ {0}..."
  kit-preview-menu:
    title: "Ê≠£Âú®È†êË¶Ω {0}..."
  kit-management-menu:
    title: "ËÅ∑Ê•≠ÁÆ°ÁêÜ"
    button:
      name: "&b&l{0} &7({1})"
      lore:
        - ""
        - "&e&nÈªûÊìäË®≠ÁΩÆËÅ∑Ê•≠Ë≥áÊñô!"
  game-rules:
    receive-kit-loadout-book:
      rules: "Áç≤ÂèñÊéíÁâàÊõ∏Êú¨"
      description: "Ë®≠ÁΩÆË©≤ËÅ∑Ê•≠ÊòØÂê¶Âú®ÈÅäÊà≤ÈñãÂßãÊôÇÁµ¶‰∫àÊéíÁâàÊõ∏Êú¨, Â¶ÇÊûúÈóúÈñâ, Áé©ÂÆ∂ÊúÉÂú®ÈÅäÊà≤ÈñãÂßãÊôÇËá™ÂãïÁç≤ÂèñÈ†êË®≠ÊéíÁâàË®≠ÁΩÆ"
    death-on-water:
      rules: "Ê∞¥‰∏äÂç≥Ê≠ª"
      description: "Ë®≠ÁΩÆË©≤ËÅ∑Ê•≠ÊòØÂê¶Á¢∞Ëß∏Ê∞¥Âæå‰æøÊúÉÁ´ãÂç≥Ê≠ª‰∫°"
    boxing:
      rules: "Boxing"
      description: "Ë®≠ÁΩÆË©≤ËÅ∑Ê•≠ÊòØÂê¶‰∏çÂÖÅË®±ÂÇ∑ÂÆ≥, ‰∏¶‰∏îË¶ÅÈÅîÂà∞100‰∏ãÊâçËÉΩÁµêÊùüÊà∞È¨•"
    bed:
      rules: "Â∫ä"
      description: "Ë®≠ÁΩÆËÅ∑Ê•≠ÊòØÂê¶ÈÇÑÂéªÂõ†ÁÇ∫Â∫äËÄåÈáçÁîü"
    break-goal:
      rules: "Á†¥Â£ûÁõÆÊ®ô"
      description: "Ë®≠ÁΩÆËÅ∑Ê•≠ÊòØÂê¶Á†¥Â£ûÂ∫äÁÇ∫‰πãÂãùÂà©"
    portal-goal:
      rules: "ÈÄ≤ÂÖ•ÁõÆÊ®ô"
      description: "Ë®≠ÁΩÆËÅ∑Ê•≠ÊòØÂê¶ÈÄ≤ÂÖ•ÁµÇÁïåÂÇ≥ÈÄÅÈñÄÁÇ∫‰πãÂãùÂà©"
    projectile-only:
      rules: "Âè™ÈôêÈÅ†Á®ãÊîªÊìä"
      description: "Ë®≠ÁΩÆË©≤ËÅ∑Ê•≠ÊòØÂê¶Âè™ÂÖÅË®±ÈÅ†Á®ãÊîªÊìäÂÇ∑ÂÆ≥"
    hypixelUHC:
      rules: "HypixelUHC"
      description: "Ë®≠ÁΩÆË©≤ËÅ∑Ê•≠ÊòØÂê¶ÊáâË©≤Âèñ‰ª£ÈáëËòãÊûúÁöÑÂõûÂæ©ÊïàÊûúÂà∞ÂõûÂæ©III, ÂíåÂÖÅË®±ÈáëÈ†≠È°±"
    spleef:
      rules: "ÈèüÈõ™"
      description: "Ë®≠ÁΩÆË©≤ËÅ∑Ê•≠ÊòØÂê¶ÂÖÅË®±Á†¥Â£ûÈõ™Âú∞ÂíåÊ≤ôÂ≠ê"
    health-regeneration:
      rules: "Ë°ÄÈáèÂõûÂæ©"
      description: "Ë®≠ÁΩÆË©≤ËÅ∑Ê•≠ÊòØÂê¶ÂÖÅË®±Ë°ÄÈáèËá™ÂãïÂõûÂæ©"
    show-health:
      rules: "È°ØÁ§∫Ë°ÄÈáè"
      description: "Ë®≠ÁΩÆË©≤ËÅ∑Ê•≠ÊòØÂê¶ÊúÉÈ°ØÁ§∫Áé©ÂÆ∂ÁöÑË°ÄÈáè"
    food-level-change:
      rules: "È£¢È§ìÂ∫¶ËΩâËÆä"
      description: "Ë®≠ÁΩÆË©≤ËÅ∑Ê•≠ÊòØÂê¶ÊúÉÂèóÂà∞È£¢È§ìÂ∫¶ÁöÑËΩâËÆä"
    point:
      rules: "ÂàÜÊï∏Ê©üÂà∂"
      description: "Ë®≠ÁΩÆË©≤ËÅ∑Ê•≠ÊòØÂê¶ÊáâË©≤‰ΩøÁî®ÂàÜÊï∏Ê©üÂà∂"
    ranked-point:
      rules: "ÂàÜÊï∏Ê©üÂà∂ (Êéí‰ΩçÈôêÂÆö)"
      description: "Ë®≠ÁΩÆË©≤ËÅ∑Ê•≠ÊòØÂê¶ÊáâË©≤Âú®Êéí‰ΩçË≥Ω‰ΩøÁî®ÂàÜÊï∏Ê©üÂà∂"
    reset-arena-when-get-point:
      rules: "Áç≤ÂèñÂàÜÊï∏ÂæåÈáçÁΩÆÂ†¥Âú∞"
      description: "Ë®≠ÁΩÆË©≤ËÅ∑Ê•≠ÊòØÂê¶Âú®Áé©ÂÆ∂Áç≤ÂèñÂàÜÊï∏ÂæåÈáçÁΩÆÂ†¥Âú∞"
    only-loser-reset-position-when-get-point:
      rules: "Áç≤ÂèñÂàÜÊï∏ÂæåÈáçÁΩÆÁé©ÂÆ∂‰ΩçÁΩÆ"
      description: "Ë®≠ÁΩÆË©≤ËÅ∑Ê•≠ÊòØÂê¶Âú®Áé©ÂÆ∂Áç≤ÂèñÂàÜÊï∏ÂæåÈáçÁΩÆÁé©ÂÆ∂‰ΩçÁΩÆ"
    build:
      rules: "Âª∫ÁØâ"
      description: "Ë®≠ÁΩÆË©≤ËÅ∑Ê•≠Êáâ‰∏çÊáâË©≤ÂÖÅË®±ÊîæÁΩÆ/Á†¥Â£ûÊñπÂ°ä"
    start-freeze:
      rules: "ÈñãÂßãÊôÇÂáçÁµê"
      description: "Ë®≠ÁΩÆË©≤ËÅ∑Ê•≠Êáâ‰∏çÊáâË©≤Âú®ÈÅäÊà≤ÈñãÂßãÊôÇÂÖÅË®±Áé©ÂÆ∂ÁßªÂãï"
    no-damage:
      rules: "Ê≤íÊúâÂÇ∑ÂÆ≥"
      description: "Ë®≠ÁΩÆË©≤ËÅ∑Ê•≠‰∏çÊúÉÈÄ†Êàê‰ªª‰ΩïÂÇ∑ÂÆ≥"
    instant-gapple:
      rules: "Áû¨ÈñìÊ≤ªÁôÇÈáëËòãÊûú"
      description: "Ë®≠ÁΩÆË©≤ËÅ∑Ê•≠ÁöÑÈáëËòãÊûúÊúÉÁû¨ÈñìÊ≤ªÁôÇÂà∞ÊªøË°Ä"
    ender-pearl-cooldown:
      rules: "ÁµÇÁïåÁèçÁè†ÂÜ∑Âçª"
      description: "Ë®≠ÁΩÆË©≤ËÅ∑Ê•≠Êáâ‰∏çÊáâË©≤Âú®Áé©ÂÆ∂‰ΩøÁî®ÁµÇÁïåÁèçÁè†ÂæåÊîæÁΩÆ‰∏ÄÂÄã16ÁßíÁöÑÂÜ∑ÂçªÊôÇÈñì"
    clear-block:
      rules: "ÊñπÂ°äÊ∏ÖÈô§"
      description: "Ë®≠ÁΩÆË©≤ËÅ∑Ê•≠Êáâ‰∏çÊáâË©≤Ê∏ÖÈô§ÊâÄÊúâÂçÅÁßíÈÅéÂæåË¢´ÊîæÁΩÆÁöÑÊñπÂ°ä"
    drop-item-when-die:
      rules: "Ê≠ª‰∫°ÊéâËêΩ"
      description: "Ë®≠ÁΩÆË©≤ËÅ∑Ê•≠Âú®Áé©ÂÆ∂Ê≠ª‰∫°ÂæåÊáâ‰∏çÊáâË©≤ÊéâËêΩÁâ©ÂìÅ"
    no-fall-damage:
      rules: "Èò≤Ê≠¢ÊéâËêΩÂÇ∑ÂÆ≥"
      description: "Ë®≠ÁΩÆË©≤ËÅ∑Ê•≠Âú®Áé©ÂÆ∂ÊéâËêΩÊôÇ‰∏çÊúÉÂèóÂà∞ÊéâËêΩÂÇ∑ÂÆ≥"
    give-back-arrow:
      rules: "Áµ¶ÂõûÁÆ≠Áü¢"
      description: "Ë®≠ÁΩÆË©≤ËÅ∑Ê•≠Âú®Áé©ÂÆ∂‰ΩøÁî®ÁÆ≠Áü¢ÂæåÊúÉÂú®3.5ÁßíÂæåÁµ¶ÂõûÁÆ≠Áü¢"
    drop-items:
      rules: "ÊéâËêΩÁâ©ÂìÅ"
      description: "Ë®≠ÁΩÆË©≤ËÅ∑Ê•≠ÊòØÂê¶ÂÖÅË®±Áé©ÂÆ∂ÊéâËêΩÁâ©ÂìÅ"
    team-projectile:
      rules: "Èöä‰ºçÊããÊì≤Áâ©"
      description: "Ë®≠ÁΩÆË©≤ËÅ∑Ê•≠ÊòØÂê¶ÂÖÅË®±Áé©ÂÆ∂‰ΩøÁî®ÊããÊì≤Áâ©ÊîªÊìäÈöäÂèã"
    bow-boosting:
      rules: "ÂºìÁÆ≠ÊîªÊìäËá™Â∑±"
      description: "Ë®≠ÁΩÆË©≤ËÅ∑Ê•≠ÊòØÂê¶ÂÖÅË®±Áé©ÂÆ∂‰ΩøÁî®ÂºìÁÆ≠ÊîªÊìäËá™Â∑±"
    respawn-time:
      rules: "ÈáçÁîüÊôÇÈñì"
      description: "Ë®≠ÁΩÆË©≤ËÅ∑Ê•≠Âú®Áé©ÂÆ∂Ê≠ª‰∫°ÂæåÁöÑÈáçÁîüÊôÇÈñì (Âè™ÊúâÂú® 'ÈÄ≤ÂÖ•ÁõÆÊ®ô' Êàñ 'Â∫ä' ÈñãÂïüÊâçÊúÉÊúâÊïà)"
    maximum-points:
      rules: "ÊúÄÂ§ßÂàÜÊï∏"
      description: "Ë®≠ÁΩÆË©≤ËÅ∑Ê•≠ÁöÑÊúÄÂ§ßÂàÜÊï∏ (Âè™ÊúâÂú® 'ÂàÜÊï∏Ê©üÂà∂' ÈñãÂïüÊâçÊúÉÊúâÊïà)"
    match-countdown-duration:
      rules: "Êà∞È¨•ÈñãÂßãÂÄíÊï∏ÊôÇÈñì"
      description: "Ë®≠ÁΩÆË©≤ËÅ∑Ê•≠ÁöÑÊà∞È¨•ÈñãÂßãÂÄíÊï∏ÊôÇÈñì"
    new-round-time:
      rules: "Êñ∞ÂõûÂêàÁ≠âÂæÖÊôÇÈñì"
      description: "Ë®≠ÁΩÆË©≤ËÅ∑Ê•≠ÁöÑÊñ∞ÂõûÂêàÁ≠âÂæÖÊôÇÈñì (Âè™ÊúâÂú® 'ÂàÜÊï∏Ê©üÂà∂' ÈñãÂïüÊâçÊúÉÊúâÊïà)"
    clear-block-time:
      rules: "Ê∏ÖÈô§ÊñπÂ°äÊôÇÈñì"
      description: "Ë®≠ÁΩÆË©≤ËÅ∑Ê•≠ÁöÑÊ∏ÖÈô§ÊñπÂ°äÊôÇÈñì (Âè™ÊúâÂú® 'ÊñπÂ°äÊ∏ÖÈô§' ÈñãÂïüÊâçÊúÉÊúâÊïà)"
    knockback-name:
      rules: "ÊìäÈÄÄÈÖçÁΩÆ"
      description: "Ë®≠ÁΩÆË©≤ËÅ∑Ê•≠ÁöÑÊìäÈÄÄÈÖçÁΩÆ (Âè™ÊúâÂú®‰ΩøÁî®ÁâπÂÆöÁöÑ Spigot Forks ÊâçÊúâÊïà)"
leaderboard:
  reload: "&eÊ≠£Âú®Âº∑Âà∂Êõ¥Êñ∞ÊéíË°åÊ¶ú..."
  top10-display:
    name: "&a{0} &7| &fÂâç10Âêç"
    lore: "&f#{0}: &b{1} &f- &b{2}"
  best-winstreak-menu-title: "ÊúÄÈ´òÈÄ£ÂãùÊéíË°åÊ¶ú"
  elo-menu-title: "Á©çÂàÜÊéíË°åÊ¶ú"
  wins-menu-title: "ÂãùÂà©Â†¥Êï∏ÊéíË°åÊ¶ú"
  winstreak-menu-title: "ÈÄ£ÂãùÊéíË°åÊ¶ú"
  kit-stats-menu:
    title: "{0} ÁöÑÊàêÁ∏æË≥áÊñô"
    global-stats:
      name: "&bÂÖ®ËÅ∑Ê•≠Áµ±Ë®à"
      lore:
        - "&bÊôÆÈÄöÊ®°Âºè:"
        - " &f‚Ä¢ ÂãùÂà©Ê¨°Êï∏: &b{0}"
        - " &f‚Ä¢ Â§±ÊïóÊ¨°Êï∏: &b{1}"
        - " &f‚Ä¢ W/L: &b{2}"
        - ""
        - "&bÊéí‰ΩçÊ®°Âºè:"
        - " &f‚Ä¢ Á©çÂàÜ: &b{3}"
        - " &f‚Ä¢ ÂãùÂà©Ê¨°Êï∏: &b{4}"
        - " &f‚Ä¢ Â§±ÊïóÊ¨°Êï∏: &b{5}"
        - " &f‚Ä¢ W/L: &b{6}"
    kit-stats:
      name: "&b{0}"
      lore:
        - "&bÊôÆÈÄöÊ®°Âºè:"
        - " &f‚Ä¢ ÂãùÂà©Ê¨°Êï∏: &b{0}"
        - " &f‚Ä¢ Â§±ÊïóÊ¨°Êï∏: &b{1}"
        - " &f‚Ä¢ ÈÄ£ÂãùÊ¨°Êï∏: &b{2}"
        - " &f‚Ä¢ ÊúÄÈ´òÈÄ£Âãù: &b{3}"
        - " &f‚Ä¢ W/L: &b{4}"
        - ""
        - "&bÊéí‰ΩçÊ®°Âºè:"
        - " &f‚Ä¢ Á©çÂàÜ: &b{5}"
        - " &f‚Ä¢ ÊúÄÈ´òÁ©çÂàÜÁ¥ÄÈåÑ: &b{6}"
        - " &f‚Ä¢ ÂãùÂà©Ê¨°Êï∏: &b{7}"
        - " &f‚Ä¢ Â§±ÊïóÊ¨°Êï∏: &b{8}"
        - " &f‚Ä¢ W/L: &b{9}"
  error-not-enough-slot: "&cÈåØË™§: ‰∏çË∂≥Â§†ÁöÑÁâ©ÂìÅÊ¨Ñ‰Ωç"
  switch-leaderboard-button:
    view-stats-button:
      name: "Êü•ÁúãÊàêÁ∏æ"
      lore:
        - ""
        - "&e&nÈªûÊìäÊü•Áúã!"
match:
  separate: "&7, &b"
  start-unranked:
    - ""
    - "&b{0}"
    - "&9 ‚Ä¢ &7ËÅ∑Ê•≠: &b{1}"
    - "&9 ‚Ä¢ &7Âú∞Âúñ: &b{2}"
    - "&9 ‚Ä¢ &7Â∞çÊâã: &b{3}"
    - ""
  start-ranked:
    - ""
    - "&b{0}"
    - "&9 ‚Ä¢ &7ËÅ∑Ê•≠: &b{1}"
    - "&9 ‚Ä¢ &7Âú∞Âúñ: &b{2}"
    - "&9 ‚Ä¢ &7Â∞çÊâã: &b{3}"
    - "&9 ‚Ä¢ &7Á©çÂàÜ: &b{4}"
    - ""
    - "&cÊ≥®ÊÑè: Êú¨Â†¥ÈÅäÊà≤ÁÇ∫Êéí‰ΩçË≥Ω, ÈÅäÊà≤ÁµêÊûúÂ∞áÊúÉÂΩ±Èüø‰Ω†ÁöÑÊéí‰ΩçË≥ΩÁ©çÂàÜ!"
    - ""
  join-spectate: "&b{0} &eÂ∑≤Âä†ÂÖ•ËßÄÊà∞"
  leave-spectate: "&b{0} &eÂ∑≤Èõ¢ÈñãËßÄÊà∞"
  cannot-drop-weapon: "&c‰Ω†‰∏çËÉΩÂú®Êà∞È¨•ÁöÑÊôÇÂÄôÊää‰Ω†ÁöÑÊ≠¶Âô®‰∏üÊéâ"
  use-again-golden-head: "&c‰Ω†ÂèØ‰ª•Âú® &c&l{0} &cÁßíÂæåÂÜç‰ΩøÁî®ÈáëÈ†≠È°±"
  use-again-ender-pearl: "&c‰Ω†ÂèØ‰ª•Âú® &c&l{0} &cÁßíÂæåÂÜç‰ΩøÁî®ÁµÇÁïåÁèçÁè†"
  use-again-fireball: "&c‰Ω†ÂèØ‰ª•Âú® &c&l{0} &cÁßíÂæåÂÜç‰ΩøÁî®ÁÅ´ÁêÉ"
  received-kit-loadout: "&fÊàêÂäüÁç≤Âèñ &b{0} &fÁöÑÊéíÁâàË®≠ÁΩÆ"
  received-kit-loadout-because-timeout: "ÈÅäÊà≤ÈñãÂßãÊôÇÊ≤íÊúâÈÅ∏ÊìáÊéíÁâàË®≠ÁΩÆ, Â∑≤Ëá™ÂãïË£ùÂÇô&bÈ†êË®≠ÊéíÁâà"
  cannot-break-own-bed: "&c‰Ω†‰∏çËÉΩÁ†¥Â£ûËá™Â∑±ÁöÑÂ∫ä!"
  can-use-enderpearl: "&a‰Ω†ÁèæÂú®ÂèØ‰ª•‰ΩøÁî®ÁµÇÁïåÁèçÁè†"
  arrow-damage: "&c{0} &7ÁèæÂú®ÁöÑË°ÄÈáèÊòØ &c{1}‚ù§ &e{2}‚ù§"
  requeue-not-in-match: "&cÈåØË™§: ‰∏çÂú®‰∏ÄÂÄãÊà∞È¨•‰∏≠"
  cannot-prefire: "&c‰Ω†ÁõÆÂâç‰∏çËÉΩÁôºÂ∞ÑÊäïÊì≤Áâ©"
  bed-break:
    title: "&cÂ∫äÈÅ≠Âà∞Á†¥Â£û‰∫ÜÔºÅ"
    subtitle: "&fÊ≠ªÂæåÊÇ®Â∞áÁÑ°Ê≥ïÈáçÁîüÔºÅ"
    message:
      - ""
      - "&f&lÂ∫äÈÅ≠Âà∞Á†¥Â£û > {0}ÁöÑÂ∫ä&7Â∑≤Ë¢´ {1}{2} &7Á†¥Â£ûÔºÅ"
      - ""
  death-message:
    disconnect: "{0}{1} &7Â∑≤Èõ¢Á∑ö"
    killed: "{0}{1} &7Ë¢´ {2}{3} &7ÊìäÊÆ∫‰∫Ü"
    default: "{0}{1} &7Â∑≤Ê≠ª‰∫°"
  post-match-inventory:
    winner: "&aÂãùÂà©ËÄÖ: &e"
    loser: "&cÂ§±ÊïóËÄÖ: &e"
    hover: "&aÈªûÊìäÊü•Áúã &6{0} &aÁöÑÁâ©ÂìÅÊ¨Ñ"
    message:
      - "&7&m------------------------------------------------"
      - "&bÊà∞È¨•ÊúÄÁµÇÁµêÊûú &7(ÈªûÊìäÂêçÁ®±Êü•ÁúãÁâ©ÂìÅÊ¨Ñ)"
      - "{post-match-inventories}"
      - "&7&m------------------------------------------------"
    rating-changes: "&eÁ©çÂàÜËΩâËÆä: &a{0} +{1} ({2})  &c{3} -{4} ({5})"
  force-end:
    message: "&cÊú¨Â†¥Êà∞È¨•Â∑≤Âº∑Âà∂ÁµÇÊ≠¢! ÂéüÂõ†: {0} (Êú¨Â†¥Êà∞È¨•‰∏¶‰∏çÊúÉË®àÁÆóÂú®ÊàêÁ∏æË£è)"
    not-online: "&cÁé©ÂÆ∂‰∏çÂú®Á∑ö‰∏ä"
    profile-not-found: "&cÁÑ°Ê≥ïÊâæÂà∞Ë©≤Áé©ÂÆ∂ÁöÑË≥áÊñô"
    not-in-match: "&cÁé©ÂÆ∂‰∏çÂú®Êà∞È¨•‰∏≠"
    reason: "&cÁÆ°ÁêÜÂì°Êåá‰ª§"
    success: "&aÊàêÂäüËÆì {0} ÁöÑÊà∞È¨•Âº∑Âà∂ÁµêÊùü"
  spectate:
    wrong-state: "&c‰Ω†‰∏çËÉΩÂú®ÈÄôÂÄãÊÉÖÊ≥Å‰∏ãËßÄÂØüÊà∞È¨•"
    have-party: "&c‰Ω†‰∏çËÉΩÂú®ÊìÅÊúâÈöä‰ºçÁöÑÊÉÖÊ≥Å‰∏ãËßÄÂØüÊà∞È¨•"
    not-online: "&cÁé©ÂÆ∂‰∏çÂú®Á∑ö‰∏ä"
    profile-not-found: "&cÁÑ°Ê≥ïÊâæÂà∞Ë©≤Áé©ÂÆ∂ÁöÑË≥áÊñô"
  no-speed:
    not-in-match: "&cÁé©ÂÆ∂‰∏çÂú®Êà∞È¨•‰∏≠"
    not-boxing: "&cÊ≠£Âú®ÈÅäÁé©ÁöÑËÅ∑Ê•≠‰∏¶‰∏çÊòØ Boxing"
    success-removed: "&aÊàêÂäüÁßªÈô§ÈÄüÂ∫¶Ëó•Ê∞¥ÊïàÊûú"
    success-added: "&aÊàêÂäüÊñ∞Â¢ûÈÄüÂ∫¶Ëó•Ê∞¥ÊïàÊûú"
  view-inventory:
    wrong-state: "&c‰Ω†Âè™ËÉΩÂú®Â§ßÂª≥ÁãÄÊÖã‰∏ã‰ΩøÁî®ÈÄôÂÄãÊåá‰ª§"
    usage: "&cÊåá‰ª§Áî®Ê≥ï: /viewinventory <UUID>"
    invalid-uuid: "&cÁÑ°ÊïàÁöÑUUID!"
    cannot-find: "&cÊú™ËÉΩÊâæÂà∞Âê´ÊúâË©≤ UUID ÁöÑÁâ©ÂìÅÊ¨Ñ"
  spectate-menu:
    title: "ËßÄÂØüÊà∞È¨•"
    button:
      name-solo: "&b{0} &7vs &b{1}"
      name-split: "&b{0}ÁöÑÈöä‰ºç &7vs &b{0}ÁöÑÈöä‰ºç"
      name-ffa: "&b{0}‰∫∫&7FFA"
      name-sumo-event: "&bÁõ∏Êí≤Â§ßË≥Ω"
      name-error: "&cÈåØË™§"
      lore:
        - "&bÊà∞È¨•Ë≥áË®ä"
        - " &7‚Ä¢ &fÊôÇÈñì: &b{0}"
        - " &7‚Ä¢ &fËÅ∑Ê•≠: &b{1}"
        - " &7‚Ä¢ &fÂ†¥Âú∞: &b{2}"
        - " &7‚Ä¢ &fÊ®°Âºè: &b{3}"
        - " &7‚Ä¢ &fÁé©ÂÆ∂: &b{4}"
        - " &7‚Ä¢ &fËßÄÂØüËÄÖ: &b{5}"
        - ""
        - "&e&nÈªûÊìäËßÄÂØüË©≤Â†¥Êà∞È¨•!"
    error-button:
      name: "&cÁÑ°Ê≥ïËÆÄÂèñË≥áÊñô!"
      lore:
        - "&7Âú®ËÆÄÂèñ {0} ÁöÑÊà∞È¨•Ë≥áÊñô"
        - "&7ÊôÇÁôºÁîü‰∫ÜÈåØË™§, Ë´ãÂâçÂæÄÂæåÂè∞Êü•ÁúãÈåØË™§"
  spectate-teleport-menu:
    title: "ËßÄÂØüËÄÖÂÇ≥ÈÄÅÂàóË°®"
    button:
      name: "&b{0}"
      lore:
        - ""
        - "&e&nÈªûÊìäÂÇ≥ÈÄÅÂà∞Ë©≤Áé©ÂÆ∂!"
    wrong-state: "&c‰Ω†ÁöÑÁãÄÊÖãÈåØË™§, Ë´ãÈáçË©¶"
    already-died: "&cË©≤Áé©ÂÆ∂Â∑≤Ê≠ª‰∫°, ÁÑ°Ê≥ïÂÇ≥ÈÄÅ"
    not-online: "&cÁé©ÂÆ∂‰∏çÂú®Á∑ö‰∏ä"
    target-wrong-state: "&cÊåáÂÆöÁé©ÂÆ∂ÁöÑÁãÄÊÖãÈåØË™§, Ë´ãÈáçË©¶"
    not-same-match: "&cÈåØË™§: Êà∞È¨•‰∏ç‰∏ÄÊ®£"
  view-inventory-menu:
    title: "{0} ÁöÑÁâ©ÂìÅÊ¨Ñ"
    open-message: "&f‰Ω†Ê≠£Âú®ËßÄÁúã &b{0} &fÁöÑÁâ©ÂìÅÊ¨Ñ"
    switch-inventory-button:
      name: "&eËΩâÊèõËá≥ {0} ÁöÑÁâ©ÂìÅÊ¨Ñ"
    player-information-button:
      name: "&bÁé©ÂÆ∂Ë≥áË®ä"
      lore:
        - ""
        - "&fË°ÄÈáè: &b{0}/{1} &4‚ù§"
        - "&fÈ£¢È§ìÂ∫¶: &b{2}/20"
        - ""
    effects-button:
      name: "&bËó•Ê∞¥ÊïàÊûú"
      no-effects-lore:
        - ""
        - "&fÊ≤íÊúâ‰ªª‰ΩïËó•Ê∞¥ÊïàÊûú"
        - ""
      effects-format: "&f{0} &7- &b{1}"
    healing-button:
      name: "&bÊ≤ªÁôÇÁâ©ÂìÅË≥áË®ä"
      no-healing-lore:
        - ""
        - "&cÊú™ËÉΩÊâæÂà∞‰ªª‰ΩïÊ≤ªÁôÇÁâ©ÂìÅ"
        - ""
      healing-lore:
        - ""
        - "&b{0} &fÈÇÑÊúâ &b{1} &fÂÄã{2}"
        - ""
    statistics-button:
      name: "&bÊà∞È¨•Áµ±Ë®à"
      lore:
        - ""
        - "&fÊìä‰∏≠Ê¨°Êï∏: &b{0}"
        - "&fÈò≤ÂÆàÊ¨°Êï∏: &b{1}"
        - "&fÊúÄÈ´òÈÄ£Êìä: &b{2}"
        - "&fÊããÊì≤Ëó•Ê∞¥Ê¨°Êï∏: &b{3}"
        - "&fÈåØÈÅéÁöÑËó•Ê∞¥: &b{4}"
        - "&fÊããÊì≤Ëó•Ê∞¥Ê∫ñÁ¢∫Â∫¶: &b{5}%"
        - ""
  healing-method:
    potion: "ÂõûÂæ©Ëó•Ê∞¥"
    soup: "ËòëËèáÊπØ"
    golden-apple: "ÈáëËòãÊûú"
    god-apple: "ÈáëËòãÊûú"
  new-round-start:
    countdown: "&e{0}..."
    title: "&e{0}..."
    message: "&aÊà∞È¨•ÈñãÂßã!"
    scored-title: "{0}{1} &eÊàêÂäüÂæóÂàÜ!"
    scored-subtitle: "{0}{1} &7- {2}{3}"
    score:
      - "&b‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨"
      - ""
      - "{0}&l{1}&7({2}&c‚ù§&7) &eÊàêÂäüÂæóÂàÜÔºÅ"
      - "{0}&l{3} &7- {4}&l{5}"
      - ""
      - "&b‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨"
  respawn:
    title: "&c‰Ω†Â∑≤Ê≠ª‰∫°!"
    subtitle: "&e{0}..."
    countdown: "&e{0}..."
    message: "&a‰Ω†Â∑≤ÈáçÁîü!"
  ## As of right now, only red and blue are going to be usable.
  ## Not sure what I should do to the rest, but just in case
  team-color:
    red:
      name: "&cÁ¥ÖÈöä"
      logo: "&c[Á¥Ö]"
    blue:
      name: "&9ËóçÈöä"
      logo: "&9[Ëóç]"
    green:
      name: "&aÁ∂†Èöä"
      logo: "&a[Á∂†]"
    yellow:
      name: "&eÈªÉÈöä"
      logo: "&e[ÈªÉ]"
    aqua:
      name: "&bÈùíÈöä"
      logo: "&b[Èùí]"
    white:
      name: "&fÁôΩÈöä"
      logo: "&f[ÁôΩ]"
    pink:
      name: "&dÁ≤âÈöä"
      logo: "&d[Á≤â]"
    gray:
      name: "&8ÁÅ∞Èöä"
      logo: "&8[ÁÅ∞]"
  ##Please don't put color code into these
  match-type:
    solo: "ÂñÆ‰∫∫Â∞çÊ±∫"
    ffa: "Èöä‰ºçÂ∞çÊ±∫"
    split: "Èöä‰ºçÂ§ß‰∫ÇÈ¨•"
    sumo-event: "Áõ∏Êí≤Â§ßË≥Ω"
  end-title:
    win:
      title: "&aÂãùÂà©!"
      subtitle: "&a{0} &fÁç≤ÂæóÊú¨Â†¥Êà∞È¨•ÁöÑÂãùÂà©!"
    lose:
      title: "&cÂ§±Êïó!"
      subtitle: "&c{0} &fÁç≤ÂæóÊú¨Â†¥Êà∞È¨•ÁöÑÂãùÂà©!"
party:
  created: "&f‰Ω†Â∑≤ÂâµÁ´ã‰∏ÄÂÄãÊñ∞ÁöÑ&bÈöä‰ºç"
  successfully-set-max-size: "&fÊàêÂäüË®≠ÁΩÆÈöä‰ºçÊúÄÂ§ß‰∫∫Êï∏‰∏äÈôêÁÇ∫ &b{0} &f‰∫∫"
  successfully-set-chat: "&fÊàêÂäüË®≠ÁΩÆÈöä‰ºçËÅäÂ§©ÂÆ§ÁÇ∫ &b{0}"
  announce:
    message: "&7[&bÈöä‰ºç&7] &b{0} &fÈÇÄË´ã&eÂú®Á∑ö‰∏äÁöÑÂêÑ‰Ωç&fÂä†ÂÖ•Èöä‰ºç! "
    clickable: "&a(ÈªûÊàëÂä†ÂÖ•)"
    hover: "&aÈªûÊàëÂä†ÂÖ•Èöä‰ºç"
  privacy:
    message: "&f‰Ω†ÁöÑÈöä‰ºçÈö±ÁßÅË®≠ÂÆöÂ∑≤Ë®≠ÂÆöÁÇ∫: &b{0}"
    open: "ÂÖ¨Èñã"
    closed: "Âè™ÈôêÈÇÄË´ã"
  broadcast-format: "&f[&bÈöä‰ºç&f] &r{0}"
  ##Party chat is a party broadcast, meaning it will use the broadcast format above
  party-chat-format: "&d{0}&7: &f{1}"
  own-profile-not-found: "&cÈåØË™§: Êú™ËÉΩÊâæÂà∞‰Ω†ÁöÑË≥áÊñô"
  cannot-interact-self: "&cÈåØË™§: ÁÑ°Ê≥ïËàáËá™Â∑±‰∫íÂãï"
  join-message:
    normal: "&b{0} &fÂä†ÂÖ•‰∫Ü‰Ω†ÁöÑÈöä‰ºç"
    force: "&b{0} &cÈß≠ÈÄ≤‰∫Ü&f‰Ω†ÁöÑÈöä‰ºç"
  leave-message:
    normal: "&b{0} &fÂ∑≤Âæû‰Ω†ÁöÑÈöä‰ºçË£°Ë¢´Ë∏¢Èô§‰∫Ü"
    force: "&b{0} Èõ¢Èñã‰∫ÜÈöä‰ºç"
  disband: "&fÈöä‰ºç&cÂ∑≤Ëß£Êï£"
  invite:
    team-message: "&b{0} &fÈÇÄË´ã‰∫Ü &b{1} &fÂä†ÂÖ•Èöä‰ºç! ‰ªñÂÄëÊúâ &b30 &fÁßíÁöÑÊôÇÈñìÂõûË¶Ü"
    invite-message: "&7[&bÈöä‰ºç&7] &b{0} &fÈÇÄË´ã‰Ω†Âä†ÂÖ•Èöä‰ºç! "
    clickable: "&a(ÈªûÊàëÂä†ÂÖ•)"
    hover: "&aÈªûÊàëÂä†ÂÖ•Èöä‰ºç"
  information:
    - "&7&m------------------------------------------------"
    - "&fÈöä‰ºçË≥áË®ä"
    - "&fÈöäÈï∑: &b{0}"
    - "&fÈöä‰ºç‰∫∫Êï∏: &7(&b{1}&7/&b{2}&7)"
    - "&fÈöä‰ºçÊàêÂì°: &b{3}"
    - "&fÈö±ÁßÅË®≠ÂÆö: &b{4}"
    - "&fÈöä‰ºçËÅäÂ§©ÂÆ§: &b{5}"
    - "&7&m------------------------------------------------"
  chat-off: "&cÈöä‰ºçËÅäÂ§©ÂÆ§Â∑≤Ë¢´ÈóúÈñâ, ÁÑ°Ê≥ïÂú®Èöä‰ºçËÅäÂ§©ÂÆ§Ë™™Ë©±"
  toggle-party-chat: "&f‰Ω†ÁöÑÊ¥æÂ∞çËÅäÂ§©ÂÆ§ÁãÄÊÖãÂ∑≤ËÆäÊõ¥ÁÇ∫&b{0}"
  disband-leader-left: "&cÂõ†ÁÇ∫ÈöäÈï∑Â∑≤Èõ¢Èñã‰º∫ÊúçÂô®, ÊâÄ‰ª•Èöä‰ºçÂ∞áÊúÉËß£Êï£"
  quit: "&b{0} &fÂ∑≤Èõ¢Èñã‰º∫ÊúçÂô®"
  only-leader: "&cÈÄôÂÄãÊåá‰ª§ÈúÄË¶ÅÈöä‰ºçÈöäÈï∑ÊâçËÉΩ‰ΩøÁî®"
  in-a-party: "&c‰Ω†Â∑≤Á∂ìÂú®‰∏ÄÂÄãÈöä‰ºç, ÁÑ°Ê≥ïÂü∑Ë°åÈÄôÂÄãÊåá‰ª§"
  not-in-a-party: "&c‰Ω†ÁèæÂú®‰∏çÂú®‰∏ÄÂÄãÈöä‰ºç, ÁÑ°Ê≥ïÂü∑Ë°åÈÄôÂÄãÊåá‰ª§"
  wrong-state: "&c‰Ω†ÂøÖÈ†àË¶ÅÂú®Â§ßÂª≥Ë£èÊâçËÉΩÂâµÂª∫‰∏ÄÂÄãÈöä‰ºç"
  party-not-open: "&c‰Ω†ÁöÑÈöä‰ºçÂøÖÈ†àÁÇ∫ÂÖ¨ÈñãÁãÄÊÖãÊâçËÉΩ‰ΩøÁî®ÈÄôÂÄãÊåá‰ª§, ÊÇ®ÂèØ‰ª•‰ΩøÁî®Êåá‰ª§ '/party open' ÊääÈöä‰ºçË®≠ÁΩÆÁÇ∫Â∞çÂ§ñÂÖ¨ÈñãÁãÄÊÖã"
  announce-cooldown: "&cÊåá‰ª§Ê≠£Âú®ÂÜ∑Âçª, Ë´ãÁ≠âÂæÖ {0} ÁßíÂÜç‰ΩøÁî®Ë©≤Êåá‰ª§ {0}"
  player-not-found: "&cÊú™ËÉΩÊâæÂà∞Áé©ÂÆ∂ '{0}'"
  party-not-found: "&cÊú™ËÉΩÊâæÂà∞ '{0}' ÁöÑÈöä‰ºç"
  full: "&cÈöä‰ºç‰∫∫Êï∏Â∑≤Êªø"
  already-in-party: "&c‰Ω†Â∑≤Á∂ìÂú®Ë©≤Èöä‰ºç"
  target-already-in-party: "&cÂ∞çÊñπÂ∑≤Á∂ìÂú®ÂÖ∂‰ªñÈöä‰ºç"
  not-invited: "&c‰Ω†Ê≤íÊúâË¢´ÈÇÄË´ãÈÄ≤ÂÖ•Èöä‰ºç!"
  disabled-party-invite: "&cË©≤Áé©ÂÆ∂Â∑≤ÈóúÈñâÈöä‰ºçÈÇÄË´ã!"
  not-integer: "'{0}' ‰∏¶‰∏çÊòØ‰∏ÄÂÄãÊúâÊïàÁöÑÊï∏Â≠ó!"
  size-below-1: "&cÈöä‰ºçÊúÄÂ§ß‰∫∫Êï∏‰∏çËÉΩÂ∞ëÊñº1"
  error-leader-not-found: "&cÈåØË™§: Ë´ãË∑üÁÆ°ÁêÜÂì°ÂõûÂ†±ÈåØË™§ (ERROR_LEADER_PLAYER_NULL)"
  max-size: "&cÊÇ®ÂâµÂª∫ÁöÑÈöä‰ºçÊúÄÂ§ß‰∫∫Êï∏Âè™ÂèØ‰ª•ÁÇ∫ {0}!"
  already-invite: "&cÂ∑≤Á∂ìÊúâ‰∏ÄÂÄãÊ≠£Âú®ÈÄ≤Ë°åÁöÑÈÇÄË´ãË´ãÊ±Ç„ÄÇ Â¶ÇÊûúÊÇ®ÊÉ≥ÂÜçÊ¨°ÈÇÄË´ãÂêå‰∏ÄÂÄãÁé©ÂÆ∂ÔºåË´ãÁ≠âÂæÖ30Áßí„ÄÇ"
  invalid-match-type: "&cÁÑ°ÊïàÁöÑÊ®°Âºè '{0}'"
  invalid-kit: "&cÁÑ°ÊïàÁöÑËÅ∑Ê•≠ '{0}'"
  invalid-arena: "&cÁÑ°ÊïàÁöÑÂ†¥Âú∞ '{0}'"
  help-message:
    - "&6&m------------------------------------------------"
    - "&dÈöä‰ºçÂπ´Âä© &7- &fÂ¶Ç‰Ωï‰ΩøÁî®Èöä‰ºçÊåá‰ª§"
    - "&6&m------------------------------------------------"
    - "&9Èöä‰ºçÊåá‰ª§:"
    - "&b/party leave &7- &eÈõ¢Èñã‰Ω†ÊâÄÂú®ÁöÑÈöä‰ºç"
    - "&b/party join <Áé©ÂÆ∂> &7- &eÂä†ÂÖ•Èöä‰ºç/Êé•ÂèóÈöä‰ºçÈÇÄË´ã"
    - "&b/party list <Áé©ÂÆ∂> &7- &eÊü•ÁúãË©≤Áé©ÂÆ∂ÊâÄÂú®ÁöÑÈöä‰ºçË≥áË®ä"
    - ""
    - "&9Èöä‰ºçÈöäÈï∑Êåá‰ª§:"
    - "&b/party invite <Áé©ÂÆ∂> &7- &eÈÇÄË´ã‰∏Ä‰ΩçÁé©ÂÆ∂ÈÄ≤ÂÖ•‰Ω†ÊâÄÂú®ÁöÑÈöä‰ºç"
    - "&b/party mute &7- &eÈóúÈñâ/ÈñãÂïüÈöä‰ºçËÅäÂ§©ÂÆ§"
    - "&b/party chat &7- &eÈóúÈñâ/ÈñãÂïüËá™ÂãïÊ¥æÂ∞çËÅäÂ§©ÂÆ§"
    - "&b/party kick <Áé©ÂÆ∂> &7- &eÂæû‰Ω†ÁöÑÈöä‰ºçË£°Ë∏¢Ëµ∞‰∏Ä‰ΩçÁé©ÂÆ∂"
    - "&b/party disband &7- &eËß£Êï£Èöä‰ºç"
    - "&b/party open &7- &eÈñãÊîæÈöä‰ºç, ËÆìÂÖ∂‰ªñÁé©ÂÆ∂ÈÄ≤ÂÖ•"
    - "&b/party close &7- &eÈóúÈñâÈöä‰ºç, Âè™ÊúâË¢´ÈÇÄË´ãÁöÑÁé©ÂÆ∂ÊâçËÉΩÈÄ≤ÂÖ•"
    - "&b/party size <Èöä‰ºçÊúÄÂ§ß‰∫∫Êï∏> &7- &eË®≠ÁΩÆÈöä‰ºçÊúÄÂ§ß‰∫∫Êï∏"
    - "&b/party announce &7- &eÁôº‰Ωà‰∏ÄÊ¢ùÂÆ£ÂÇ≥‰Ω†Èöä‰ºçÁöÑÂÖ¨Âëä"
    - ""
    - "&9ÂÖ∂‰ªñÂπ´Âä©:"
    - "&bÂ¶ÇÊûúÊÉ≥Áî®&eÈöä‰ºçËÅäÂ§©ÂÆ§&b, Âú®‰Ω†ÁöÑË®äÊÅØÂâçÈù¢Êâì‰∏ä &7'&b@&7' &bÊàñ &7'&b!&7' &bÁ¨¶ËôüÂç≥ÂèØ"
    - "&6&m------------------------------------------------"
  choose-arena-menu:
    title: "ÈÅ∏ÊìáÂ†¥Âú∞"
    button:
      name: "&b{0}"
      random: "&bÈö®Ê©üÂú∞Âúñ"
      lore:
        - ""
        - "&e&nÈªûÊàëÈÅ∏ÊìáÊ≠§Â†¥Âú∞!"
  choose-kit-menu:
    title: "ÈÅ∏ÊìáËÅ∑Ê•≠"
    button:
      name: "&b{0}"
      lore:
        - ""
        - "&e&nÈªûÊìäÈÅ∏ÊìáÊ≠§ËÅ∑Ê•≠!"
  choose-match-type-menu:
    title: "ÈÅ∏ÊìáÊ®°Âºè"
    split-button:
      name: "&bÈöä‰ºçÂ∞çÊ±∫"
      lore:
        - "&7Êää‰Ω†ÁöÑÈöä‰ºçÂàÜÊàêÂÖ©Èöä"
        - "&7ÁÑ∂ÂæåÈñãÂßãÂ∞çÊ±∫"
        - ""
        - "&e&nÈªûÊìäÈÅ∏ÊìáÊ≠§ÈÅäÊà≤Ê®°Âºè!"
    ffa-button:
      name: "&bÈöä‰ºçÂ§ß‰∫ÇÈ¨•"
      lore:
        - "&7Èöä‰ºçÁöÑÊØèÂÄãÊàêÂì°ÈÉΩÊòØ‰Ω†ÁöÑÊïµ‰∫∫"
        - "&7ÊÉ≥Ëæ¶Ê≥ïÁîüÂ≠òÂà∞ÊúÄÂæå, ‰∏¶‰∏îÂãùÂà©"
        - ""
        - "&e&nÈªûÊìäÈÅ∏ÊìáÊ≠§ÈÅäÊà≤Ê®°Âºè!"
  other-parties-menu:
    title: "ÂÖ∂‰ªñÈöä‰ºç"
    button:
      name: "&b{0} &fÁöÑÈöä‰ºç"
      lore-start:
        - "&bÈöä‰ºçË≥áË®ä"
        - " &fÈöäÈï∑: &b{0}"
        - " &fÈöä‰ºç‰∫∫Êï∏: &b{1}&7/&b{2}"
        - ""
        - " &fÈöä‰ºçÊàêÂì°:"
      lore-end:
        - ""
        - "&e&nÈªûÊàëÁôºÈÄÅÊ±∫È¨•ÈÇÄË´ã!"
  start-party-fight:
    only-leader: "&cÈúÄË¶ÅÈöä‰ºçÈöäÈï∑ÊâçËÉΩÂü∑Ë°å"
    need-more-than-2: "&c‰Ω†ÁöÑÈöä‰ºçÂøÖÈ†àË¶ÅÊúâ 2 ‰∫∫Êàñ‰ª•‰∏äÊâçËÉΩÈÄ≤Ë°åÈÄôÂÄãÊ¥ªÂãï"
    arena-disabled: "&cÈåØË™§: Â†¥Âú∞Ê≤íÊúâÈñãÂïü"
    cannot-find-arena: "&cÈåØË™§: Êú™ËÉΩÊâæÂà∞ÂêàÈÅ©ÁöÑÂ†¥Âú∞"
    players-not-in-lobby: "&c{0} ‰∏çÂú®Â§ßÂª≥"
profile:
  cannot-find-player: "&cÊú™ËÉΩÊâæÂà∞Ë©≤Áé©ÂÆ∂, Ë©≤Áé©ÂÆ∂ÂøÖÈ†àËá≥Â∞ëÁôªÂÖ•ÈÅéÊú¨‰º∫ÊúçÂô®ÂàÜÊµÅ‰∏ÄÊ¨°, ÊâçËÉΩÂÖÅË®±Êü•ÁúãÊàêÁ∏æ"
  error-cannot-load-player: "&cÈåØË™§: Êú™ËÉΩÂä†ËºâË©≤Áé©ÂÆ∂ÁöÑË≥áÊñô"
  kit-right-click-to-receive:
    - "&7Âè≥ÈçµÈªûÊìä"
    - "&7Áç≤Âèñ‰Ω†ÁöÑÂ•ó‰ª∂"
  settings-menu:
    title: "Ë®≠ÂÆö"
    click-to-switch-settings: "&e&nÈªûÊìäÂàáÊèõÊ≠§Ë®≠ÂÆö!"
    no-permission: "&c‰Ω†Ê≤íÊúâÊ¨äÈôêÊõ¥ÊîπÈÄôÂÄãË®≠ÂÆö"
  procedure:
    enter-cancel-to-cancel: "&e&lËº∏ÂÖ• &c&lcancel &e&lÂéªÂº∑Âà∂ÁµÇÊ≠¢ÈÅéÁ®ã"
    success-cancel: "&aÊàêÂäüÂèñÊ∂àÁ®ãÂ∫è"
  settings:
    successfully-changed: "&a{0}ÊàêÂäüÊõ¥ÊîπÁÇ∫: {1}"
    time-changer:
      name: "ÊôÇÈñì"
      lore:
        - ""
        - "&7ÊîπËÆä‰Ω†ÈÅäÊà≤‰∏≠ÁöÑÊôÇÈñì"
        - ""
      normal-server-time: "Êó•Â§ú‰∫§Êõø"
      day: "Êó©‰∏ä"
      afternoon: "‰∏ãÂçà"
      night: "Êôö‰∏ä"
      midnight: "Ê∑±Â§ú"
    arena-selection:
      name: "Â†¥Âú∞ÈÅ∏Êìá"
      lore:
        - ""
        - "&7ÈÅ∏Êìá‰Ω†ÊÉ≥‰∏çÊÉ≥ÈÅ∏ÊìáÂ†¥Âú∞"
        - ""
    match-scoreboard:
      name: "Êà∞È¨•Ë®òÂàÜÊùø"
      lore:
        - ""
        - "&7Êà∞È¨•ÊôÇË¶Å‰∏çË¶ÅÈ°ØÁ§∫Ë®òÂàÜÊùø"
        - ""
    allow-duel-request:
      name: "Ê±∫È¨•ÈÇÄË´ã"
      lore:
        - ""
        - "&7Âú®Â§ßÂª≥Êáâ‰∏çÊáâË©≤ÂÖÅË®±Ê±∫È¨•ÈÇÄË´ã"
        - ""
    allow-party-invite:
      name: "Èöä‰ºçÈÇÄË´ã"
      lore:
        - ""
        - "&7Âú®Â§ßÂª≥Êáâ‰∏çÊáâË©≤ÂÖÅË®±Èöä‰ºçÈÇÄË´ã"
        - ""
    spectator-visibility:
      name: "ËßÄÂØüËÄÖÁãÄÊÖã"
      lore:
        - ""
        - "&7ËßÄÂØüÊà∞È¨•ÊôÇÊòØÂê¶ËÉΩÁúãÂà∞ÂÖ∂‰ªñËßÄÂØüËÄÖ"
        - ""
    spectator-join-leave-message:
      name: "Êü•ÁúãËßÄÂØüËÄÖÂä†ÂÖ•/Èõ¢ÈñãË®äÊÅØ"
      lore:
        - ""
        - "&7ÊòØÂê¶ËÉΩÁúãÂà∞ËßÄÂØüËÄÖÂä†ÂÖ•/Èõ¢ÈñãË®äÊÅØ"
        - ""
    event-announcement:
      name: "Ê¥ªÂãïÂª£Êí≠"
      lore:
        - ""
        - "&7Êáâ‰∏çÊáâË©≤Â∞ç‰Ω†ÁôºÈÄÅÊ¥ªÂãïÂª£Êí≠"
        - ""
    ping-range:
      name: "Âª∂ÈÅ≤ÁØÑÂúç"
      lore:
        - ""
        - "&7ÈÅ∏ÊìáÂÖÅË®±ÂåπÈÖçÁöÑÁé©ÂÆ∂Âª∂ÈÅ≤"
        - ""
      unlimited: "ÁÑ°ÈôêÂà∂"
queue:
  usage: "&cÊåá‰ª§Áî®Ê≥ï: /queue <ÂåπÈÖçÈ°ûÂûã>"
  cannot-quit-queue: "&c‰Ω†‰∏¶Ê≤íÊúâÂú®ÂåπÈÖç, ‰∏çËÉΩÈÄÄÂá∫ÂåπÈÖç"
  cannot-queue: "&c‰Ω†ÁèæÊôÇ‰∏çËÉΩÈñãÂßãÂåπÈÖç"
  type:
    unranked: "Á∂ìÂÖ∏"
    ranked: "Êéí‰Ωç"
  menu:
    title: "ÈÅ∏Êìá{0}Ê®°Âºè"
    button:
      lore:
        - ""
        - "&fÊ≠£Âú®Á≠âÂÄô: &b{0}"
        - "&fÊ≠£Âú®Êà∞È¨•: &b{1}"
        - ""
        - "&fÈªûÊìäÈÄ≤ÂÖ• &b{2} &fÁöÑÊéíÈöäÈöäÂàó!"
        - ""
  error-found-queue-profile: "&cÈåØË™§: ÊâæÂà∞ QueueProfile, Êú™ËÉΩÊàêÂäüÂä†ÂÖ•ÈöäÂàó"
  error-not-found-queue-profile: "&cÈåØË™§: Êú™ËÉΩÊàêÂäüÊâæÂà∞ QueueProfile"
  wrong-state: "&cÁÑ°Ê≥ïÂú®Ê≠§ÊÉÖÊ≥Å‰∏ãÂä†ÂÖ•ÈöäÂàó"
  error-kit-data-not-found: "&cÁÑ°Ê≥ïÂä†ÂÖ•ÈöäÂàó, Ë´ãÈáçÊñ∞ÁôªÂÖ•‰º∫ÊúçÂô®"
  error-not-enough-wins: "&c‰Ω†ÈúÄË¶Å {0} Â†¥ÂãùÂà©Â†¥Êï∏ÊâçËÉΩÂåπÈÖçÊéí‰ΩçË≥Ω, ‰Ω†ÁèæÂú®Êúâ {1} ÂãùÂà©Â†¥Êï∏"
  success-join: "&f‰Ω†Â∑≤Ë¢´Âä†ÈÄ≤‰∫Ü &b{0} &fÁöÑÁ≠âÂÄôÈöäÂàó"
  success-quit: "&f‰Ω†Â∑≤ÈÄÄÂá∫ &b{0} &fÁöÑÁ≠âÂÄôÈöäÂàó"
button:
  back:
    name: "&c&lËøîÂõû"
    lore:
      - "&7ÈªûÊìäÂõûÂà∞‰∏ä‰∏ÄÈ†Å"
  confirm:
    name-confirm: "&aÁ¢∫ÂÆö"
    name-cancel: "&cÂèñÊ∂à"
  toggle:
    name: "&b&l{0}"
  jump-to-page:
    name: "&eÁ¨¨ {0} È†Å"
    current-page-lore:
      - ""
      - "&aÁèæÊôÇ‰Ω†Ê≠£Âú®Ê≠§È†ÅÈù¢!"
  page:
    next-page-available:
      name: "&a‰∏ã‰∏ÄÈ†Å"
      lore:
        - ""
        - "&eÈªûÊìäÈÄôË£èË∑≥Âà∞‰∏ã‰∏ÄÈ†Å"
    next-page-current:
      name: "&7‰∏ã‰∏ÄÈ†Å"
      lore:
        - ""
        - "&eÊ≤íÊúâ‰∏ã‰∏ÄÈ†Å‰∫Ü!"
    previous-page-available:
      name: "&a‰∏ä‰∏ÄÈ†Å"
      lore:
        - ""
        - "&eÈªûÊìäÈÄôË£èË∑≥Âà∞‰∏ä‰∏ÄÈ†Å"
    previous-page-current:
      name: "&7‰∏ä‰∏ÄÈ†Å"
      lore:
        - ""
        - "&eÊ≤íÊúâ‰∏ä‰∏ÄÈ†Å‰∫Ü!"
  page-filter:
    name: "&bÁØ©ÈÅ∏Âô®"
    lore:
      - ""
      - "&eÈªûÊìäÂ∑¶ÈçµÂéªÂàáÊèõÁØ©ÈÅ∏Âô®"
      - "&eÈªûÊìäÂè≥ÈçµÂàáÊèõÁèæÊôÇÁØ©ÈÅ∏Âô®ÁöÑÁãÄÊÖã"
      - ""
    no-filters: "&cÊ≤íÊúâÁØ©ÈÅ∏Âô®ÂèØ‰æõÈÅ∏Êìá"
menu:
  view-all-pages:
    title: "&bÈ†ÅÈù¢Ë∑≥ËΩâ"
tablist:
  ## If you don't want header or footer, just simply put null
  ## Note that you cannot only keep the header and disable the footer, you have to enable both or disable both
  header: "&bÊà∞È¨•Á∑¥Áøí"
  footer: "&bdiamond.rip"

Filename: .\main\resources\language.yml
scoreboard:
  title: "&bPractice"
  boxing-counter:
    no-combo: "&fNo Combo"
    text-solo: "{0}{1} Combo"
    text-team: "{0}{1} Combo"
  loading:
    - "&7&m----------------------"
    - "&cYour data is loading..."
    - "&cPlease wait, if player data fail to load"
    - "&c please contact a moderator and rejoin"
    - "&7&m----------------------"
  in-lobby:
    - "&7&m----------------------"
    - "&b&l‚îÉ &fOnline: &b{online-players}"
    - "&b&l‚îÉ &fIn Queue: &b{queue-players}"
    - "&b&l‚îÉ &fIn Fights: &b{match-players}"
    - "{event-information}"
    - "&7&m----------------------"
  in-party:
    - "&7&m----------------------"
    - "&b&l‚îÉ &fOnline: &b{online-players}"
    - "&b&l‚îÉ &fIn Queue: &b{queue-players}"
    - "&b&l‚îÉ &fIn Fights: &b{match-players}"
    - ""
    - "&b&l‚îÉ &fTeam:"
    - "&b&l‚îÉ &f Leader: &b{party-leader}"
    - "&b&l‚îÉ &f Member(s): &b{party-members}&7/&b{party-max}"
    - "{event-information}"
    - "&7&m----------------------"
  in-edit:
    - "&7&m----------------------"
    - "&b&l‚îÉ &fRight click the &banvil &fto save,"
    - "&b&l‚îÉ &f load or delete your layout."
    - ""
    - "&b&l‚îÉ &fSome class allows allows extra "
    - "&b&l‚îÉ &f item, right click the &bchest"
    - "&b&l‚îÉ &f to obtain extra items"
    - ""
    - "&b&l‚îÉ &fAfter editing your layout,"
    - "&b&l‚îÉ &f right click the &bsign &fto"
    - "&b&l‚îÉ &f return to lobby"
    - "&7&m----------------------"
  in-edit-gui:
    - "&7&m----------------------"
    - "&b&l‚îÉ &fUse the &bmenu &fto save,"
    - "&b&l‚îÉ &f load, rename or delete"
    - "&b&l‚îÉ &f your kit layouts."
    - ""
    - "&b&l‚îÉ &fClick &bExtra Items &fif"
    - "&b&l‚îÉ &f available for this kit"
    - ""
    - "&b&l‚îÉ &fPress &bESC &for click &bBack"
    - "&b&l‚îÉ &f to return to kit selector"
    - "&7&m----------------------"
  in-queue-unranked:
    - "&7&m----------------------"
    - "&b&l‚îÉ &fOnline: &b{online-players}"
    - "&b&l‚îÉ &fIn Queue: &b{queue-players}"
    - "&b&l‚îÉ &fIn Fights: &b{match-players}"
    - ""
    - "&b&l‚îÉ &fQueuing: &b{queue-kit}"
    - "&b&l‚îÉ &fTime: &b{queue-time}"
    - "&b&l‚îÉ &fPing Range: &b{ping-range}"
    - "{event-information}"
    - "&7&m----------------------"
  in-queue-ranked:
    - "&7&m----------------------"
    - "&b&l‚îÉ &fOnline: &b{online-players}"
    - "&b&l‚îÉ &fIn Queue: &b{queue-players}"
    - "&b&l‚îÉ &fIn Fights: &b{match-players}"
    - ""
    - "&b&l‚îÉ &fQueuing: &b{queue-kit}"
    - "&b&l‚îÉ &fTime: &b{queue-time}"
    - "&b&l‚îÉ &fPing Range: &b{ping-range}"
    - "&b&l‚îÉ &fRange: &7[&b{queue-ranked-min} &9-> &b{queue-ranked-max}&7]"
    - "{event-information}"
    - "&7&m----------------------"
  in-match-solo:
    fighting:
      - "&7&m----------------------"
      - "&b&l‚îÉ &fFighting: &b{match-solo-opponent}"
      - ""
      - "&b&l‚îÉ &fYour Ping: &b{match-solo-self-ping}ms"
      - "&b&l‚îÉ &fTheir Ping: &b{match-solo-opponent-ping}ms"
      - "&7&m----------------------"
    boxing:
      - "&7&m----------------------"
      - "&b&l‚îÉ &fFighting: &b{match-solo-opponent}"
      - ""
      - "&b&l‚îÉ &bHits: {match-solo-boxing-difference-color}({match-solo-boxing-difference-symbol}{match-solo-boxing-difference})"
      - "&b&l‚îÉ &a You: &f{match-solo-boxing-self-hit}"
      - "&b&l‚îÉ &c Them: &f{match-solo-boxing-opponent-hit}"
      - "&b&l‚îÉ &f {match-solo-boxing-difference-text}"
      - ""
      - "&b&l‚îÉ &fYour Ping: &b{match-solo-self-ping}ms"
      - "&b&l‚îÉ &fTheir Ping: &b{match-solo-opponent-ping}ms"
      - "&7&m----------------------"
    bed:
      - "&7&m----------------------"
      - "&b&l‚îÉ &fFighting: &b{match-solo-opponent}"
      - ""
      - "&b&l‚îÉ &f{match-team1-logo}&7: &f{match-team1-bed-status}"
      - "&b&l‚îÉ &f{match-team2-logo}&7: &f{match-team2-bed-status}"
      - ""
      - "&b&l‚îÉ &fBuild Height: &b{match-build-limit}{match-build-limit-difference}"
      - ""
      - "&b&l‚îÉ &fYour Ping: &b{match-solo-self-ping}ms"
      - "&b&l‚îÉ &fTheir Ping: &b{match-solo-opponent-ping}ms"
      - "&7&m----------------------"
    point:
      - "&7&m----------------------"
      - "&b&l‚îÉ &fFighting: &b{match-solo-opponent}"
      - ""
      - "&b&l‚îÉ &f{match-team1-logo}&7: &f{match-team1-points}"
      - "&b&l‚îÉ &f{match-team2-logo}&7: &f{match-team2-points}"
      - ""
      - "&b&l‚îÉ &fYour Ping: &b{match-solo-self-ping}ms"
      - "&b&l‚îÉ &fTheir Ping: &b{match-solo-opponent-ping}ms"
      - "&7&m----------------------"
    ending:
      - "&7&m----------------------"
      - "&b&l‚îÉ &aMatch Over!"
      - "&b&l‚îÉ &fWinner: &b{match-solo-winner}"
      - "&7&m----------------------"
  in-match-teams:
    fighting:
      - "&7&m----------------------"
      - "&b&l‚îÉ &aTeam: &7(&b{match-team-self-alive}&7/&b{match-team-self-size}&7)"
      - "&b&l‚îÉ &cOpponents: &7(&b{match-team-opponent-alive}&7/&b{match-team-opponent-size}&7)"
      - "&7&m----------------------"
    boxing:
      - "&7&m----------------------"
      - "&b&l‚îÉ &bHits: {match-team-boxing-difference-color}({match-team-boxing-difference-symbol}{match-team-boxing-difference})"
      - "&b&l‚îÉ &a You: &f{match-team-boxing-self-hit}"
      - "&b&l‚îÉ &c Them: &f{match-team-boxing-opponent-hit}"
      - "&b&l‚îÉ &f {match-team-boxing-difference-text}"
      - ""
      - "&b&l‚îÉ &aTeam: &7(&b{match-team-self-alive}&7/&b{match-team-self-size}&7)"
      - "&b&l‚îÉ &cOpponents: &7(&b{match-team-opponent-alive}&7/&b{match-team-opponent-size}&7)"
      - "&7&m----------------------"
    bed:
      - "&7&m----------------------"
      - "&b&l‚îÉ &f{match-team1-logo}&7: &f{match-team1-bed-status}"
      - "&b&l‚îÉ &f{match-team2-logo}&7: &f{match-team2-bed-status}"
      - ""
      - "&b&l‚îÉ &fBuild Height: &b{match-build-limit}{match-build-limit-difference}"
      - ""
      - "&b&l‚îÉ &aTeam: &7(&b{match-team-self-alive}&7/&b{match-team-self-size}&7)"
      - "&b&l‚îÉ &cOpponents: &7(&b{match-team-opponent-alive}&7/&b{match-team-opponent-size}&7)"
      - "&7&m----------------------"
    point:
      - "&7&m----------------------"
      - "&b&l‚îÉ &f{match-team1-logo}&7: &f{match-team1-points}"
      - "&b&l‚îÉ &f{match-team2-logo}&7: &f{match-team2-points}"
      - ""
      - "&b&l‚îÉ &aTeam: &7(&b{match-team-self-alive}&7/&b{match-team-self-size}&7)"
      - "&b&l‚îÉ &cOpponents: &7(&b{match-team-opponent-alive}&7/&b{match-team-opponent-size}&7)"
      - "&7&m----------------------"
    ending:
      - "&7&m----------------------"
      - "&b&l‚îÉ &aMatch Over!"
      - "&b&l‚îÉ &fWinners: &b{match-team-winner}'s Team"
      - "&7&m----------------------"
  in-match-ffa:
    fighting:
      - "&7&m----------------------"
      - "&b&l‚îÉ &fAlive: &7(&b{match-ffa-alive}&7/&b{match-ffa-player-size}&7)"
      - "&7&m----------------------"
    ending:
      - "&7&m----------------------"
      - "&b&l‚îÉ &aMatch Over!"
      - "&b&l‚îÉ &fWinner: &b{match-ffa-winner}"
      - "&7&m----------------------"
  in-spectate-solo:
    fighting:
      - "&7&m----------------------"
      - "&b&l‚îÉ &fKit: &b{spectate-kit}"
      - "&b&l‚îÉ &fTime: &b{spectate-duration}"
      - ""
      - "&b&l‚îÉ &f{spectate-solo-player1}'s ping: &b{spectate-solo-player1-ping}ms"
      - "&b&l‚îÉ &f{spectate-solo-player2}'s ping: &b{spectate-solo-player2-ping}ms"
      - "&7&m----------------------"
    boxing:
      - "&7&m----------------------"
      - "&b&l‚îÉ &fKit: &b{spectate-kit}"
      - "&b&l‚îÉ &fTime: &b{spectate-duration}"
      - ""
      - "&b&l‚îÉ &bHits:"
      - "&b&l‚îÉ &f {spectate-solo-player1}: &b{spectate-solo-boxing-player1-hit}"
      - "&b&l‚îÉ &f {spectate-solo-player2}: &b{spectate-solo-boxing-player2-hit}"
      - ""
      - "&b&l‚îÉ &f{spectate-solo-player1}'s ping: &b{spectate-solo-player1-ping}ms"
      - "&b&l‚îÉ &f{spectate-solo-player2}'s ping: &b{spectate-solo-player2-ping}ms"
      - "&7&m----------------------"
    bed:
      - "&7&m----------------------"
      - "&b&l‚îÉ &fKit: &b{spectate-kit}"
      - "&b&l‚îÉ &fTime: &b{spectate-duration}"
      - ""
      - "&b&l‚îÉ &f{spectate-team1-logo}&7: &f{spectate-team1-bed-status}"
      - "&b&l‚îÉ &f{spectate-team2-logo}&7: &f{spectate-team2-bed-status}"
      - ""
      - "&b&l‚îÉ &f{spectate-solo-player1}'s ping: &b{spectate-solo-player1-ping}ms"
      - "&b&l‚îÉ &f{spectate-solo-player2}'s ping: &b{spectate-solo-player2-ping}ms"
      - "&7&m----------------------"
    point:
      - "&7&m----------------------"
      - "&b&l‚îÉ &fKit: &b{spectate-kit}"
      - "&b&l‚îÉ &fTime: &b{spectate-duration}"
      - ""
      - "&b&l‚îÉ &f{spectate-team1-logo}&7: &f{spectate-team1-points}"
      - "&b&l‚îÉ &f{spectate-team2-logo}&7: &f{spectate-team2-points}"
      - ""
      - "&b&l‚îÉ &f{spectate-solo-player1}'s ping: &b{spectate-solo-player1-ping}ms"
      - "&b&l‚îÉ &f{spectate-solo-player2}'s ping: &b{spectate-solo-player2-ping}ms"
      - "&7&m----------------------"
    ending:
      - "&7&m----------------------"
      - "&b&l‚îÉ &aMatch Over!"
      - "&b&l‚îÉ &fWinner: &b{spectate-solo-winner}"
      - "&7&m----------------------"
  in-spectate-teams:
    fighting:
      - "&7&m----------------------"
      - "&b&l‚îÉ &f{spectate-team1-leader}'s team: &7(&b{spectate-team1-alive}&7/&b{spectate-team1-size}&7)"
      - "&b&l‚îÉ &f{spectate-team2-leader}'s team: &7(&b{spectate-team2-alive}&7/&b{spectate-team2-size}&7)"
      - "&7&m----------------------"
    boxing:
      - "&7&m----------------------"
      - "&b&l‚îÉ &bHits:"
      - "&b&l‚îÉ &f {spectate-team1-leader}'s team: &b{spectate-team1-boxing-hit}"
      - "&b&l‚îÉ &f {spectate-team2-leader}'s team: &b{spectate-team2-boxing-hit}"
      - ""
      - "&b&l‚îÉ &f{spectate-team1-leader}'s team: &7(&b{spectate-team1-alive}&7/&b{spectate-team1-size}&7)"
      - "&b&l‚îÉ &f{spectate-team2-leader}'s team: &7(&b{spectate-team2-alive}&7/&b{spectate-team2-size}&7)"
      - "&7&m----------------------"
    bed:
      - "&7&m----------------------"
      - "&b&l‚îÉ &f{spectate-team1-logo}&7: &f{spectate-team1-bed-status}"
      - "&b&l‚îÉ &f{spectate-team2-logo}&7: &f{spectate-team2-bed-status}"
      - ""
      - "&b&l‚îÉ &f{spectate-team1-leader}'s team: &7(&b{spectate-team1-alive}&7/&b{spectate-team1-size}&7)"
      - "&b&l‚îÉ &f{spectate-team2-leader}'s team: &7(&b{spectate-team2-alive}&7/&b{spectate-team2-size}&7)"
      - "&7&m----------------------"
    point:
      - "&7&m----------------------"
      - "&b&l‚îÉ &f{spectate-team1-logo}&7: &f{spectate-team1-points}"
      - "&b&l‚îÉ &f{spectate-team2-logo}&7: &f{spectate-team2-points}"
      - ""
      - "&b&l‚îÉ &f{spectate-team1-leader}'s team: &7(&b{spectate-team1-alive}&7/&b{spectate-team1-size}&7)"
      - "&b&l‚îÉ &f{spectate-team2-leader}'s team: &7(&b{spectate-team2-alive}&7/&b{spectate-team2-size}&7)"
      - "&7&m----------------------"
    ending:
      - "&7&m----------------------"
      - "&b&l‚îÉ &aMatch Over!"
      - "&b&l‚îÉ &fWinners: &b{spectate-team-winner}'s team"
      - "&7&m----------------------"
  in-spectate-ffa:
    fighting:
      - "&7&m----------------------"
      - "&b&l‚îÉ &fPlayers-Alive: &7(&b{spectate-ffa-alive}&7/&b{spectate-ffa-player-size}&7)"
      - "&7&m----------------------"
    ending:
      - "&7&m----------------------"
      - "&b&l‚îÉ &aMatch Over!"
      - "&b&l‚îÉ &fWinner: &b{spectate-ffa-winner}"
      - "&7&m----------------------"
join-message:
  - "&7&m------------------------------------------------"
  - ""
  - "&fWelcome to NA Practice"
  - ""
  - "&7&m------------------------------------------------"
loading-profile: "&c[Eden] System is loading your profile... Please wait for a few seconds."
invalid-syntax: "&cIncorrect format. Please try again."
location-not-found: "&cLocation not found"
location-changed: "&aSuccessfully changed {0}"
no-permission: "&cNo permission."
enabled: "Enabled"
disabled: "Disabled"
confirm-title: "Confirm?"
reached-build-limit: "Reached Limit"
banned-command: "&cYou can only use this command in lobby"
arena:
  exists: "&cArena '{0}' already exists!"
  not-exists: "&cArena '{0}' does NOT exist! Please use command '/arena create {0}' to create one"
  created: "&aArena '{0}' created! Please use command '/arena edit {0}' to edit"
  successfully-set: "&e{0} &asuccessfully set!"
  saved: "&aSaved arena &e'{0}' &ato arena.yml"
  saved-all: "&aSaved all arenas to arena.yml"
  cannot-set-because-clone-found: "&cThis command can only be used when the selected arena doesn't have any duplicates"
  generate:
    display: "&c[Arena] - {0} arena has been pasted to {1}, {2}"
    hover: "&eClick here to teleport to the arena"
    copying: "&eCopying arena..."
  remove:
    success-main: "&aArena removed! &eWarning: use command '/arena saveall' to save the current arena setting"
    success-duplicate: "&aArena removed! &eWarning: use command '/arena save {0}' to save the current arena setting"
  menu:
    title: "Arenas Preview"
    arena-edit:
      name: "&b&l{0} &7({1})"
      lore:
        - ""
        - "&e&nClick to edit arena settings!"
  allowed-kits-menu:
    title: "Arena Allowed Kits"
    lore:
      click-to-select: "&eClick to allow"
      selected: "&aAllowed!"
  details-menu:
    title: "Arenas Info"
    detail:
      name: "&b#{0}"
      lore:
        - ""
        - "&7Point-A-Position: {0}"
        - "&7Point-B-Position: {1}"
        - "&7Minimum-Position: {2}"
        - "&7Maximum-Position: {3}"
        - ""
      lore-not-duplicated: "&cThis is not a duplicate, can't remove!"
      click-to-delete: "&e&nLeft click to remove the arena"
      click-to-teleport: "&e&nRight click to teleport to the arena"
      teleported: "&eTeleported to arena &b{0} #{1}"
    create-duplicate:
      name: "&bCreate arena duplicate"
      lore:
        - "&cWarning: After creating arena duplicates, you can no longer change its location"
        - "&cUse command '/arena save {0}' after create or change anything"
        - ""
        - "&e&nClick to create the arena copy!"
  edit-menu:
    title: "Editing Arena {0}..."
    click-to-edit: "Click to edit {0}'s value"
    display-name:
      name: "Arena Display Name"
      description: "Current Display Name: {0}"
      action-description: "Click to change arena display name"
      procedure:
        message: "&e&lChanging &b&larena display name&e&l... Please enter a new value in chat"
        success: "&fChanged arena &b{0} &fdisplay name to &b{1}"
    allowed-kits:
      name: "Allowed Kits"
      description: "Current value: {0}"
    a-position:
      name: "Position A Location"
      description: "Current location: {0}"
      action-description:
        - "&e&nLeft-Click to set position A to your current location"
        - "&e&nRight-Click to teleport to position A"
    b-position:
      name: "Position B Location"
      description: "Current location: {0}"
      action-description:
        - "&e&nLeft-Click to set position B to your current location"
        - "&e&nRight-Click to teleport to position B"
    spectator-position:
      name: "Position Spectator Location"
      description: "Current location: {0}"
      action-description:
        - "&e&nLeft-Click to set spectator position to your current location"
        - "&e&nRight-Click to teleport to spectator position"
    min:
      name: "Minimum Location"
      description: "Current value: {0}"
      action-description:
        - "&e&nLeft-Click to edit minimum location value"
        - "&e&nRight-Click to teleport to minimum location"
    max:
      name: "Maximum Location"
      description: "Current value: {0}"
      action-description:
        - "&e&nLeft-Click to edit maximum location value"
        - "&e&nRight-Click to teleport to maximum location"
    y-limit:
      name: "Y Limit"
      description: "Current value: {0}"
    build-max:
      name: "Build Limit"
      description: "Current value: {0}"
    portal-protection-radius:
      name: "Portal Protection Radius"
      description: "Current value: {0}"
    clone:
      name: "Arena Clone"
      description: "Warning: Arena's value cannot be edited after a clone of the arena has been made"
      action-description: "Click here to manage arena clones"
    delete:
      name: "Remove Arena"
      description: "Warning: This step cannot be undone, backup is recommended before using this command"
      action-description: "Click here to remove the arena"
      action-description-has-clone: "&cYou need to remove the current arena to make new clone, to remove the main arena"
    save:
      name: "Save arena"
      action-description: "Click here to save arena"
    toggle:
      name: "Arena status"
      description: "Current status: {0}"
      need-restart: "&eRestart is required"
      action-description: "Click here to change arena status"
      action-description-not-finished-setup: "&cYou need to complete arena setup to edit this setting"
      action-description-need-restart: "&cRestart is required to change this setting"
    icon:
      name: "Arena Icon"
      description: "Current icon: {0}"
      action-description: "Click to use your hand item to become arena icon"
      cannot-be-air: "&cCannot set arena icon as air"
  edit:
    min: "&e&lEditing the arena &b&l{0} &e&l's lowest position... Please left click a block to set the position"
    max: "&e&lEditing the arena &b&l{0} &e&l's highest position... Please left click a block to set the position"
    y-limit: "&e&lEditing the arena &b&l{0} &e&l's y limit... Please type a new value in chat"
    build-max: "&e&lEditing the arena &b&l{0} &e&l's build height... Please type a new value in chat"
    portal-protection-radius: "&e&lEditing the arena &b&l{0} &e&l's portal protection radius'... Please type a new value in chat"
    allowed-kits: "&e&lEditing the arena &b&l{0} &e&l's available kits... Please enter then name of an existing kit"
    allowed-kits-removed: "&aSuccessfully removed kit '{0}' to arena {1}"
    allowed-kits-added: "&aSuccessfully added kit '{0}' to arena {1}"
    cannot-edit-not-finished-setup: "&cThis setting can not be edited before arena has been fully setup"
    cannot-edit-need-restart: "&cRestart is required to use the arena"
duel:
  cannot-find-player: "&cPlayer '{0}' cannot be found"
  cannot-duel-self: "&cYou cannot duel yourself!"
  cannot-duel-not-in-party: "&cYour opponent is not in a party"
  has-pending-duel-request: "&cYou already have a pending duel request, please try again in 30 seconds"
  invalid-player: "&cInvalid player with name '{0}'"
  invalid-kit: "&cInvalid kit with name '{0}'"
  invalid-arena: "&cInvalid arena with name '{0}'"
  invalid-duel-request: "&cInvalid duel request! It may have already expired!"
  help-message:
    - "&cCommand usage:"
    - "&c/duel <Player> [Kit] [Arena] - Duel a player/party"
    - "&c/duel accept <UUID> - Accept a duel"
  choose-arena-menu:
    name: "Select Arena"
    button:
      name: "&b{0}"
      random: "&bRandom Map"
      lore:
        - ""
        - "&e&nClick to select the arena!"
  choose-kit-menu:
    name: "Select Kit"
    button:
      name: "&b{0}"
      lore:
        - ""
        - "&e&nClick to select this kit!"
  duel-request:
    cannot-find-target: "&cThis player is offline"
    display-1v1: "&b{0} &fsent a duel request to you with &b{1} kit&f, arena &b{2} "
    display-party: "&b{0}'s team&9({3}) &fsent a duel request to you with &b{1} kit&f, arena &b{2} "
    click-to-accept: "&a[Click to accept]"
    click-to-accept-hover: "&aClick to accept"
    click-to-view-ping: "&a[Click to see enemy's ping]"
    click-to-view-ping-hover: "&f{0}'s ping: &b{1}ms"
    success-1v1: "&fYou sent a duel to &b{2} &fwith kit &b{0}&f, arena &b{1}"
    success-party: "&fYou sent a duel to &b{2}'s party &fwith kit &b{0}&f, arena &b{1}"
  verify:
    target-not-found: "&cPlayer is offline"
    need-to-be-in-lobby: "&cYou need to be in a lobby to send duel requests"
    target-need-to-be-in-lobby: "&cPlayer needs to be in a lobby to receive your duel request"
    target-duel-request-disabled: "&This player has duel requests disabled"
    arena-disabled: "&cError: Arena disabled"
    cannot-find-arena: "&cError: cannot find arena"
    target-in-a-party: "&cplayer is already in a party"
    target-not-in-a-party: "&cPlayer is NOT in a party"
    cannot-duel-same-party: "&cYou can not duel your own party"
    player-not-in-lobby: "&c{0}'s party needs to be in the same lobby to accept duel requests"
event:
  event-is-running: "&cThere's already an active event!"
  event-is-not-running: "&cThere's no active event!"
  event-already-started: "&cEvent already started!"
  no-available-status: "&cThis event has no available status to view!"
  wrong-state: "&cYou must be in lobby to do this!"
  auto-create-party-because-need-a-party: "&7[&bEvent&7] &eYou have been automatically created a party because event requires to be in a party to join!"
  party-size-over: "&cYour party team members count is higher than {0}. The current event only allows maximum {0} player(s) per team"
  auto-set-party-size: "&7[&bEvent&7] &eYour party maximum size has been corrected to &b&l{0} &ebecause you joined an event."
  cannot-use-this-command: "&cYou cannot use this command when you are in an event"
  leave-event-because-party-disband: "&eBecause of your party disbanded, your party has been automatically removed from the event"
  cannot-join-party-because-in-event: "&cYou cannot join a party which is in the event!"
  leave-event-because-error: "&cError: System Error. You have been automatically remove from the event"
  force-cancel-event: "&c{0} has been cancelled by administrator"
  no-winner-because-no-party: "&7[&bEvent&7] &cThis event doesn't have any winners due to no party was alive."
  winner-announce:
    message: "&7[&bEvent&7] &aWinners: &b{0}"
    split-format: "&7, &b"
  event-create-menu:
    title: "Create an Event"
    button:
      name: "&b{0}"
      lore:
        click-to-create-event: "&e&nClick me to setup the Event!"
        no-permission: "&cYou don't have permission to host this event!"
  event-select-kit-menu:
    title: "Choose Event's Kit"
    button:
      name: "{0}"
      lore:
        - ""
        - "&e&nClick me to choose this kit!"
  event-settings-menu:
    title: "Event Settings"
    max-players-button:
      name: "&bMaximum Players"
      lore:
        - ""
        - "&fCurrent Maximum Players: &b{0}"
        - ""
        - "&aLEFT CLICK &fto increase Maximum Players by 1"
        - "&aSHIFT + LEFT CLICK &fto increase Maximum Players by 10"
        - ""
        - "&cRIGHT CLICK &fto decrease Maximum Players by 1"
        - "&cSHIFT + RIGHT CLICK &fto decrease Maximum Players by 10"
        - ""
        - "&e&nClick to change Maximum Players!"
    party-size-button:
      name: "&bTeam Size"
      lore:
        - ""
        - "&fCurrent Team Size: &b{0}"
        - ""
        - "&aLEFT CLICK &fto increase Team Size by 1"
        - "&cRIGHT CLICK &fto decrease Team Size by 1"
        - ""
        - "&e&nClick to change Team Size!"
    kit-button:
      name: "&bKit"
      lore:
        - ""
        - "&fCurrent Selected Kit: &b{0}"
        - ""
        - "&e&nClick to change a Kit!"
    start-button:
      name: "&bStart Event"
      lore:
        - ""
        - "&fEvent: &b{0}"
        - "&fMinimum Players: &b{1}"
        - "&fMaximum Players: &b{2}"
        - ""
        - "&e&nClick to start Event!"
  event-create:
    message: "&7[&bEvent&7] &b{0} &fis hosting a &b{1} &fevent! "
    clickable:
      message: "&a(Click To Join)"
      hover: "&eClick Me To Join!"
  party-name-format: "'s Team"
  event-join:
    message: "&7[&bEvent&7] &b{0} &fjoined &b{1} &7(&b{2}&7/&b{3}&7) "
    clickable:
      message: "&a(Click To Join)"
      hover: "&eClick Me To Join!"
  starting-full: "&7[&bEvent&7] &fEvent is full. Starting event right now..."
  event-leave:
    message: "&7[&bEvent&7] &b{0} &cleft &b{1} &7(&b{2}&7/&b{3}&7)"
  event-start-countdown:
    message: "&7[&bEvent&7] &b{0} &fis starting in &b&l{1} &fseconds "
    clickable:
      message: "&a(Click To Join)"
      hover: "&eClick Me To Join!"
  cancel-not-enough-players: "&7[&bEvent&7] &cEvent is cancelled due to not enough participants"
  tournament:
    name: "Tournament"
    match-end-message: "&7[&bEvent&7] &a{0} &fkilled &c{1} &7({2} &7matches left)"
    scoreboard:
      starting-event:
        - ""
        - "&b&l‚îÉ &b&l{event-uncolored-name}"
        - "&b&l‚îÉ  &fPlayers: &b{event-total-players}&7/&b{event-max-players}"
        - "&b&l‚îÉ  &fStarting at &b&l{event-countdown} &fseconds"
      starting-new-round:
        - ""
        - "&b&l‚îÉ &b&l{event-uncolored-name}"
        - "&b&l‚îÉ  &fRound &b&l{0}"
        - "&b&l‚îÉ  &fStarting at &b&l{event-countdown} &fseconds"
      fighting:
        - ""
        - "&b&l‚îÉ &b&l{event-uncolored-name}"
        - "&b&l‚îÉ  &fRound &b&l{0}"
        - "&b&l‚îÉ  &fMatches left: &b{1}"
    status:
      starting-event:
        - ""
        - "&b&l{0}"
        - "&fStarting soon..."
        - ""
      starting-new-round:
        - ""
        - "&b&l{0}"
        - "&fRound &b&l{1} &fis starting soon..."
        - ""
      fighting:
        - ""
        - "&b&l{0}"
        - "&fRound &b&l{1} &fis started!"
        - ""
        - "{2}"
        - ""
      fighting-team-format: "&b{0} &fvs &b{1}"
    new-round:
      countdown: "&7[&bEvent&7] &fRound &b&l{0} &fis starting in &b&l{1} &fseconds..."
      start:
        - ""
        - "&7[&bEvent&7] &fRound &b&l{0} &fis started!"
        - "&7[&bEvent&7] &fUse command &7'&b/event status&7' &fto see who is fighting!"
        - ""
      no-available-arena: "&7[&bEvent&7] &cError: Not enough arena. Your party have been automatically promoted to next round."
      auto-promotion: "&7[&bEvent&7] &eThere were an odd number of teams in this round - so your team has advanced to the next round. &a:)"
  sumo-event:
    name: "Sumo Event"
    match-end-message: "&7[&bEvent&7] &a{0} &fkilled &c{1}"
    lobby-scoreboard:
      starting-event:
        - ""
        - "&b&l‚îÉ &b&l{event-uncolored-name}"
        - "&b&l‚îÉ  &fPlayers: &b{event-total-players}&7/&b{event-max-players}"
        - "&b&l‚îÉ  &fStarting at &b&l{event-countdown} &fseconds"
      fighting:
        - ""
        - "&b&l‚îÉ &b&l{event-uncolored-name}"
        - "&b&l‚îÉ  &fRound &b&l{0}"
        - "&b&l‚îÉ  &f{1} &bvs &f{2}"
    in-game-scoreboard:
      starting-match:
        - "&7&m----------------------"
        - "&b&l‚îÉ  &7&oStarting soon..."
        - "&7&m----------------------"
      fighting:
        - "&7&m----------------------"
        - "&b&l‚îÉ &fEvent: &b{match-event-type}"
        - "&b&l‚îÉ &fDuration: &b{match-duration}"
        - "&b&l‚îÉ &fRound: &b{match-event-round}"
        - ""
        - "&b&l‚îÉ &b{0}"
        - "&b&l‚îÉ &7vs"
        - "&b&l‚îÉ &b{1}"
        - "&7&m----------------------"
      ending:
        - "&7&m----------------------"
        - "&b&l‚îÉ &aMatch Over!"
        - "&b&l‚îÉ &fWinner: &b{match-event-winner}"
        - "&7&m----------------------"
    status:
      starting-event:
        - ""
        - "&b&l{0}"
        - "&fStarting soon..."
        - ""
      starting-new-round:
        - ""
        - "&b&l{0}"
        - "&fRound &b&l{1} &fis starting soon..."
        - ""
      fighting:
        - ""
        - "&b&l{0}"
        - "&fRound &b&l{1} &fis started!"
        - "{2} vs {3}"
        - ""
    new-round:
      countdown: "&7Round &b&l{0} &7will be starting in &b&l{1}&7..."
      started: "&bRound started!"
hook:
  found-custom-spigot: "&aRunning spigot version: &b{0}&a, custom knockback will be applied"
  cannot-find-custom-spigot: "&eCannot find the custom spigot, vanilla knockback will be applied"
  error-knockback-not-found: "&cError: please report this issue to a moderator (ERROR_KNOCKBACK_NOT_FOUND)"
kit-editor:
  cannot-edit-wrong-state: "&cYou cannot edit kits in this state"
  extra-item-menu-name: "Extra Items"
  save-menu:
    name: "Save kit"
    save-loadout-button-name: "&fSave layout &b{0}"
    load-loadout-button-name: "&fLoad layout &b{0}"
    rename-loadout-button-name: "&fRename layout &b{0}"
    delete-loadout-button-name: "&cRemove layout &b{0}"
    rename-instructions: "&e&lRenaming &b{0}&e&l... Please enter a new value in chat"
    invalid-character: "&cID cannot contain special characters"
  select-kit-menu:
    name: "Select a kit"
    button:
      name: "&b{0}"
      lore:
        - ""
        - "&e&nClick to edit kit layout!"
  cannot-use-command-while-editing: "&cPlease exit your layout editor to use other commands"
  disallow-extra-item: "&cThis kit does not allow extra items"
  cannot-find-editor-location: "&cError: cannot find kit editor location"
  editing:
    - ""
    - "&fYou are editing &b{0} &f's layout"
    - ""
    - "&9 ‚Ä¢ &fRight click the anvil to save your layout"
    - "&9 ‚Ä¢ &fRight click the chest to obtain extra item (Does not apply to all kits)"
    - "&9 ‚Ä¢ &fRight click the sign to exit layout editor"
    - ""
kit:
  not-exists: "&cKit '{0}' does NOT exist!"
  no-kits-found: "&cNo kit found! Use the command '/kit create <ID>' to create one!"
  saved: "&aSaved kit &e'{0}' &ato database"
  saved-all-kits: "&aKits saved!"
  kit-already-exists: "&cKit '{0}' already exsits, cannot create kits with the same ID"
  successfully-create: "&aKit created '{0}'!"
  successfully-delete: "&aKit deleted '{0}!"
  successfully-clone: "&aKit '{0}' game rules has been cloned to '{1}'"
  cannot-save-extra-items: "&cannot save extra item, '{0}' == null"
  successfully-updated-extra-items: "&aUpdated &b{0} &a's extra item!"
  button:
    edit-damage-ticks:
      name: "&b&lEdit kit damage cooldown"
      lore:
        - ""
        - "&7Current kit damage cooldown: {0}"
        - "&cWarning: If you are using a custom spigot core, this setting may not function properly"
        - ""
        - "&e&nClick to edit kit damange cooldown!"
      procedure:
        message: "&e&lChanging &b&lkit damage cooldown&e&l... Please enter a new value in chat"
        success: "&fChanged &b{0} &fkit damage cooldown to &b{1}"
        additional-message: "&cYour message must be a number"
    edit-description:
      name: "&b&lEdit kit description"
      lore-start:
        - ""
        - "&7Current kit description: "
      lore-end:
        - ""
        - "&e&nClick to edit kit description!"
        - "&e&nDrop to remove current description!"
      procedure:
        message: "&e&lEditing &b&lkit description&e&l... Please enter a new value in chat"
        success: "&fChanged &b{0} &fkit description to &b{1}"
        additional-message: "&eYou may use ';' to separate the lines"
    edit-display-name:
      name: "&b&lEdit kit display name"
      lore:
        - ""
        - "&7Current kit display name: {0}"
        - ""
        - "&e&nClick to edit kit's display name!"
      procedure:
        message: "&e&lChanging &b&lkit name&e&l... Please enter a new value in chat"
        success: "&fChanged &b{0} &fkit name to &b{1}"
    edit-extra-items:
      name: "&b&lEdit extra items"
      lore:
        - ""
        - "&e&nClick to edit extra item!"
    edit-icon:
      name: "&b&lEdit kit icon"
      lore:
        - ""
        - "&7Current icon: {0}"
        - "&7Current icon durability: {1}"
        - ""
        - "&e&nClick to set your hand item as kit icon!"
      procedure:
        air: "&cYou cannot change your kit icon to air!"
        success: "&fChanged &b{0} &fkit icon to &b{1}"
    edit-match-type:
      name: "&b&lEdit match type"
      lore-click-left: "&e(Left click)"
      lore-click-middle: "&e(Middle click)"
      lore-click-right: "&e(Right click)"
      lore:
        - ""
        - "&e&nClick to change match type"
    edit-potion-effect:
      name: "&b&lEdit potion effect"
      lore-start:
        - ""
        - "&7Current potion effect: &9({0})"
      lore-end:
        - ""
        - "&e&nClick to edit potion effect!"
      procedure:
        message: "&e&lChanging &b&lpotion effect&e&l... Please enter a new value in chat"
        already-have-potion-effect:
          - "&cKit &b'{0}' &calready has the potion effect &9{1}"
          - "&cIf you want to replace the effect, please remove the current one before applying the new effect"
        success-add: "&fAdded potion effect &b{1} to kit &b{0}"
        success-remove: "&fRemoved potion effect &b{1} to kit &b{0}"
        additional-message:
          - "&eYour message must be '{effect name};{amplifier};{duration (in ticks)}'"
          - "&eIf you want to remove a potion effect, enter '-{potion effect ID}'"
    edit-priority:
      name: "&b&lEdit kit priority"
      lore:
        - ""
        - "&7Current kit priority: {0}"
        - ""
        - "&e&nClick to edit kit priority!"
      procedure:
        message: "&e&lChanging &b&lkit priority&e&l... Please enter a new value in chat"
        success: "&fChanged kit &b{0} &f's kit priority to &b{1}"
        additional-message: "&cYour message must be in numbers"
    preview:
      lore:
        - ""
        - "&e&nLeft click to preview this kit"
        - "&e&nRight click to get the kit preview"
    save:
      name: "&b&lSave Kit"
      lore:
        - ""
        - "&e&nClick to save kit settings"
    rules-toggle:
      success: "&fChanged &b{0} &f{1} to &b{2}"
    rules-set-value:
      name: "&b&l{0}"
      lore:
        - ""
        - "&7{0}"
        - ""
        - "&7Current value: {1}"
        - ""
        - "&e&nClick to edit value!"
      procedure:
        message: "&e&lChanging &b&l{0}&e&l... Please enter a new value in chat"
        success: "&fChanged kit's &b{0} &fto &b{1}"
        additional-message: "&cYour message must be in numbers"
    save-loadout:
      name: "&b&lSave kit layout"
      lore:
        - ""
        - "&7Warning: this will change your current inventory item layout"
        - "&7to the current kit's layout"
        - ""
        - "&e&nClick to save kit layout!"
      success: "&aUpdated kit {0} 's layout"
    toggle:
      name: "&b&lStatus"
      description: "&7Current Status: {0}"
      success: "&fChanged &b{0} &f's status to &b{1}"
    toggle-ranked:
      name: "&b&lRanked mode"
      description: "&7Current status: {0}"
      success: "&fChanged &b{0} &f's ranked mode to &b{1}"
  kit-detail-menu:
    title: "Editing {0}..."
  kit-preview-menu:
    title: "Previewing {0}..."
  kit-management-menu:
    title: "Kit Manager"
    button:
      name: "&b&l{0} &7({1})"
      lore:
        - ""
        - "&e&nClick to edit kit's information!"
  game-rules:
    receive-kit-loadout-book:
      rules: "Receive Kit Loadout Book"
      description: "Setting for players to receive kit loadout book in the beginning of a match, if disabled, player will automatically receive layout settings"
    death-on-water:
      rules: "Death on Water"
      description: "Setting for death upon touching water"
    boxing:
      rules: "Boxing"
      description: "Setting to disable damage and end after 100 hits"
    bed:
      rules: "Bed"
      description: "Setting for players to respawn before bed break"
    break-goal:
      rules: "Break Goal"
      description: "Setting for wins after breaking the bed"
    portal-goal:
      rules: "Portal Goal"
      description: "Setting for wins after enter into ender portal"
    projectile-only:
      rules: "Ranged Damage Only"
      description: "Setting for this duel mode to only receive ranged damage"
    hypixelUHC:
      rules: "HypixelUHC"
      description: "Setting for match to replace golden apple's regeneration to Regeneration III, and enable golden head"
    spleef:
      rules: "Spleef"
      description: "Setting for match to allow breaking snow and sand"
    health-regeneration:
      rules: "Health Regeneration"
      description: "Setting for match to allow auto regeneration"
    show-health:
      rules: "Show Health"
      description: "Setting for match to show player's health"
    food-level-change:
      rules: "Hunger Bar Change"
      description: "Setting for match for players to lose hunger bar"
    point:
      rules: "Point System"
      description: "Setting for match to apply a point system"
    ranked-point:
      rules: "Point System (Ranked)"
      description: "Setting for ranked match to apply a point system"
    reset-arena-when-get-point:
      rules: "Reset Arena After Get A Point"
      description: "Settings for match to reset arena after player get a point"
    only-loser-reset-position-when-get-point:
      rules: "Only Loser Reset Position After Get A Point"
      description: "Settings for match to reset player position after player get a point"
    build:
      rules: "Build"
      description: "Setting for match to allow block placement/destruction"
    start-freeze:
      rules: "Start Freeze"
      description: "Setting for match to freeze player movement on start"
    no-damage:
      rules: "No Damage"
      description: "Setting for match to disable damage"
    instant-gapple:
      rules: "Instant Golden Apple"
      description: "Setting for match to instant regeneration to full health with golden apple"
    ender-pearl-cooldown:
      rules: "Ender Pearl Cooldown"
      description: "Setting for match to set a cooldown of 16 seconds on ender pearls"
    clear-block:
      rules: "Clear Block"
      description: "Setting for match to remove all blocks placed in the past 10 seconds"
    drop-item-when-die:
      rules: "Item Drop On Death"
      description: "Setting for players to drop items on death"
    no-fall-damage:
      rules: "No Fall Damage"
      description: "Setting for disabling fall damage"
    give-back-arrow:
      rules: "Give Back Arrow"
      description: "Settings for player who uses arrow will give back after 3.5 seconds"
    drop-items:
      rules: "Drop Items"
      description: "Settings for player to drop item using 'Q' button"
    team-projectile:
      rules: "Team Projectile"
      description: "Settings for player to allow to use projectile to shoot their teammate"
    bow-boosting:
      rules: "Bow Boosting"
      description: "Settings for player to allow arrow to damage themselves"
    respawn-time:
      rules: "Respawn Time"
      description: "Settings for the respawn timer (Only works if bed or goal is on)"
    maximum-points:
      rules: "Maximum Points"
      description: "Settings for the maximum points (Only works if point system is on)"
    match-countdown-duration:
      rules: "Match Countdown Duration"
      description: "Settings for the match countdown duration"
    new-round-time:
      rules: "New Round Time"
      description: "Settings for the new round countdown time (Only works if point system is on)"
    clear-block-time:
      rules: "Clear Block Time"
      description: "Settings for the clear block time (Only works if clear block is on)"
    knockback-name:
      rules: "Knockback Profile"
      description: "Settings for the knockback profile (Only works if using specific spigot forks)"
leaderboard:
  reload: "&eReloading leaderboard..."
  top10-display:
    name: "&a{0} &7| &fTop 10"
    lore: "&f#{0}: &b{1} &f- &b{2}"
  best-winstreak-menu-title: "Best Winstreak Leaderboard"
  elo-menu-title: "ELO Leaderboard"
  wins-menu-title: "Total Wins Leaderbaord"
  winstreak-menu-title: "Winstreak Leaderboard"
  kit-stats-menu:
    title: "{0}'s stats"
    global-stats:
      name: "&bDuel stats"
      lore:
        - "&bUnranked:"
        - " &f‚Ä¢ Wins: &b{0}"
        - " &f‚Ä¢ Losses: &b{1}"
        - " &f‚Ä¢ W/L: &b{2}"
        - ""
        - "&bRanked:"
        - " &f‚Ä¢ Elo: &b{3}"
        - " &f‚Ä¢ Wins: &b{4}"
        - " &f‚Ä¢ Loses: &b{5}"
        - " &f‚Ä¢ W/L: &b{6}"
    kit-stats:
      name: "&b{0}"
      lore:
        - "&bUnranked:"
        - " &f‚Ä¢ Wins: &b{0}"
        - " &f‚Ä¢ Losses: &b{1}"
        - " &f‚Ä¢ Win Streak: &b{2}"
        - " &f‚Ä¢ Highest Win Streak: &b{3}"
        - " &f‚Ä¢ W/L: &b{4}"
        - ""
        - "&bRanked:"
        - " &f‚Ä¢ Elo: &b{5}"
        - " &f‚Ä¢ Highest Elo Record: &b{6}"
        - " &f‚Ä¢ Wins: &b{7}"
        - " &f‚Ä¢ Loses: &b{8}"
        - " &f‚Ä¢ W/L: &b{9}"
  error-not-enough-slot: "&cError: Not enough item slots"
  switch-leaderboard-button:
    view-stats-button:
      name: "View Stats"
      lore:
        - ""
        - "&e&nClick to view!"
match:
  separate: "&7, &b"
  start-unranked:
    - ""
    - "&b{0}"
    - "&9 ‚Ä¢ &7Kit: &b{1}"
    - "&9 ‚Ä¢ &7Map: &b{2}"
    - "&9 ‚Ä¢ &7Opponent(s): &b{3}"
    - ""
  start-ranked:
    - ""
    - "&b{0}"
    - "&9 ‚Ä¢ &7Kit: &b{1}"
    - "&9 ‚Ä¢ &7Map: &b{2}"
    - "&9 ‚Ä¢ &7Opponent: &b{3}"
    - "&9 ‚Ä¢ &7ELO: &b{4}"
    - ""
    - "&cWarning: This match is a ranked match, the result is going to affect your ELO!"
    - ""
  join-spectate: "&b{0} &eis now spectating"
  leave-spectate: "&b{0} &eis no longer spectating"
  cannot-drop-weapon: "&cYou cannot drop your weapon"
  use-again-golden-head: "&cYou need to wait &c&l{0} &cseconds before using Golden Head again"
  use-again-ender-pearl: "&cYou need to wait &c&l{0} &cseconds before using ender pearl again"
  use-again-fireball: "&cYou need to wait &c&l{0} &cseconds before using fireball again"
  received-kit-loadout: "&fYou have received &b{0} &fkit loadout"
  received-kit-loadout-because-timeout: "No selected kit loadout. You have been automatically equipped &bdefault &fkit loadout"
  auto-equipped-kit: "&a{0} automatically equipped."
  kit-edit-saved: "&aChanges saved to {0}."
  cannot-break-own-bed: "&cYou cannot break your own bed!"
  can-use-enderpearl: "&aYou can now use Ender Pearl again."
  arrow-damage: "&c{0}&e's health: &c{1}‚ù§ &e{2}‚ù§"
  requeue-not-in-match: "&cError: You are not in a match"
  cannot-prefire: "&cYou cannot prefire in your current state"
  bed-break:
    title: "&cBed DestroyedÔºÅ"
    subtitle: "&fYou will not respawn after dieÔºÅ"
    message:
      - ""
      - "&f&lBed Destroyed > {0}'s bed &7has been destroyed by {1}{2}!"
      - ""
  death-message:
    ## {0} - Entity relation color
    ## {2} - Entity team color
    disconnect: "{0}{1} &7disconnected."
    ## {0} - Entity relation color
    ## {2} - Killer relation color
    ## {4} - Entity team color
    ## {5} - Killer team color
    killed: "{2}{3} &7killed {0}{1}&7."
    ## {0} - Entity relation color
    ## {2} - Entity team color
    default: "{0}{1} &7died."
  post-match-inventory:
    winner: "&aWinner: &e"
    loser: "&cLoser: &e"
    hover: "&aClick to view &6{0}'s &ainventory"
    message:
      - "&7&m------------------------------------------------"
      - "&bPost-Match Inventories &7(click to view)"
      - "{post-match-inventories}"
      - "&7&m------------------------------------------------"
    rating-changes: "&eELO changes: &a{0} +{1} ({2})  &c{3} -{4} ({5})"
  force-end:
    message: "&cThe match is cancelled! Reason: {0} (Your stats related to this match will not be saved)"
    not-online: "&cPlayer is not online!"
    profile-not-found: "&cError: Player profile not found"
    not-in-match: "&cPlayer is not in a match!"
    reason: "&cAdmin Command"
    success: "&aSuccessfully force ended {0}'s match"
  spectate:
    wrong-state: "&cYou cannot spectate match right now!"
    have-party: "&cYou cannot spectate match while in a party!"
    not-online: "&cPlayer is not online!"
    profile-not-found: "&cError: Player profile not found"
  no-speed:
    not-in-match: "&cPlayer is not in a match!"
    not-boxing: "&cThe current kit you are using is not boxing!"
    success-removed: "&aSuccessfully removed speed potion effect"
    success-added: "&aSuccessfully added speed potion effect"
  view-inventory:
    wrong-state: "&cYou can only view inventories in lobby"
    usage: "&cUsage: /viewinventory <UUID>"
    invalid-uuid: "&cInvalid UUID!"
    cannot-find: "&cCannot find the selected inventory. Is it expired?"
  spectate-menu:
    title: "Spectate Menu"
    button:
      name-solo: "&b{0} &7vs &b{1}"
      name-split: "&b{0}'s Team &7vs &b{0}'s Team"
      name-ffa: "&7FFA with &b{0} &7players"
      name-sumo-event: "&bSumo Event"
      name-error: "&cError"
      lore:
        - "&bMatch Information"
        - " &7‚Ä¢ &fDuration: &b{0}"
        - " &7‚Ä¢ &fKit: &b{1}"
        - " &7‚Ä¢ &fMap: &b{2}"
        - " &7‚Ä¢ &fGame-Mode: &b{3}"
        - " &7‚Ä¢ &fPlayer(s): &b{4}"
        - " &7‚Ä¢ &fSpectator: &b{5}"
        - ""
        - "&e&nClick to spectate match!"
    error-button:
      name: "&cCannot read match information!"
      lore:
        - "&7An error occurred when reading"
        - "&7 {0}'s information. Please view the"
        - "&7 error in the console and report"
        - "&7 it to developer"
  spectate-teleport-menu:
    title: "Spectator Teleportation"
    button:
      name: "&b{0}"
      lore:
        - ""
        - "&e&nClick to teleport!"
    wrong-state: "&cError: Wrong state"
    already-died: "&cThe selected player already died"
    not-online: "&cThe selected player is not online"
    target-wrong-state: "&cError: Selected player wrong state"
    not-same-match: "&cError: Incorrect match"
  view-inventory-menu:
    title: "Inventory of {0}"
    open-message: "&fYou are now viewing &b{0}'s &finventory"
    switch-inventory-button:
      name: "&eView {0}'s inventory"
    player-information-button:
      name: "&bPlayer Information"
      lore:
        - ""
        - "&fHearts: &b{0}/{1} &4‚ù§"
        - "&fHunger: &b{2}/20"
        - ""
    effects-button:
      name: "&bPotion Effects"
      no-effects-lore:
        - ""
        - "&fNo potion effects found"
        - ""
      effects-format: "&f{0} &7- &b{1}"
    healing-button:
      name: "&bHealing Count"
      no-healing-lore:
        - ""
        - "&cNo Healing Method found"
        - ""
      healing-lore:
        - ""
        - "&b{0} &fhad &b{1} &f{2} left"
        - ""
    statistics-button:
      name: "&bMatch Stats"
      lore:
        - ""
        - "&fHits: &b{0}"
        - "&fBlocked Hits: &b{1}"
        - "&fLongest Combo: &b{2}"
        - "&fPotion Thrown: &b{3}"
        - "&fPotion Missed: &b{4}"
        - "&fPotion Accuracy: &b{5}%"
        - ""
  healing-method:
    potion: "Health Potions"
    soup: "Soup"
    golden-apple: "Golden Apple"
    god-apple: "Golden Apple"
  new-round-start:
    countdown: "&e{0}..."
    title: "&e{0}..."
    message: "&aMatch started!"
    scored-title: "{0}{1} &escored!"
    scored-subtitle: "{0}{1} &7- {2}{3}"
    score:
      - "&b‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨"
      - ""
      - "{0}&l{1}&7(&c{2}‚ù§&7) &escored!"
      - "{0}&l{3} &7- {4}&l{5}"
      - ""
      - "&b‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨"
  respawn:
    title: "&cYOU DIED!"
    subtitle: "&e{0}..."
    countdown: "&e{0}..."
    message: "&aRespawned!"
  ## As of right now, only red and blue are going to be usable.
  ## Not sure what I should do to the rest, but just in case
  team-color:
    red:
      name: "&cRed"
      logo: "&c[R]"
    blue:
      name: "&9Blue"
      logo: "&9[B]"
    green:
      name: "&aGreen"
      logo: "&a[G]"
    yellow:
      name: "&eYellow"
      logo: "&e[Y]"
    aqua:
      name: "&bAqua"
      logo: "&b[A]"
    white:
      name: "&fWhite"
      logo: "&f[W]"
    pink:
      name: "&dPink"
      logo: "&d[P]"
    gray:
      name: "&8Gray"
      logo: "&8[G]"
  ##Please don't put color code into these
  match-type:
    solo: "Solo"
    ffa: "FFA"
    split: "Teams"
    sumo-event: "Sumo Event"
  end-title:
    win:
      title: "&aVICTORY!"
      subtitle: "&a{0} &fwin the match!"
    lose:
      title: "&cDEFEAT!"
      subtitle: "&c{0} win the match!"
party:
  created: "&fYou have created a new &bparty"
  successfully-set-max-size: "&fSuccessfully changed max party size to &b{0} "
  successfully-set-chat: "&fSuccessfully changed party chat to &b{0}"
  announce:
    message: "&7[&bParty&7] &b{0} &fhas invited &eall online players &fto join! "
    clickable: "&a(Click here to join)"
    hover: "&aClick here to join"
  privacy:
    message: "&fYour party privacy settings has been set to: &b{0}"
    open: "Public"
    closed: "Invites Only"
  broadcast-format: "&f[&bParty&f] &r{0}"
  ##Party chat is a party broadcast, meaning it will use the broadcast format above
  party-chat-format: "&d{0}&7: &f{1}"
  own-profile-not-found: "&cError: Profile cannot be found"
  cannot-interact-self: "&cError: Cannot interact self"
  join-message:
    normal: "&b{0} &fhas joined your party"
    force: "&b{0} &fhas &cHACKED &finto your party"
  leave-message:
    normal: "&b{0} &fhas left the party"
    force: "&b{0} &fhas been &ckicked &ffrom your party"
  disband: "&fParty &cdisbanded"
  invite:
    team-message: "&b{0} &finvited &b{1} &fto join the party! They have &b30 &fseconds to join"
    invite-message: "&7[&bParty&7] &b{0} &fhas invited you to join their party! "
    clickable: "&a(click here to join)"
    hover: "&aclick here to join"
  information:
    - "&7&m------------------------------------------------"
    - "&fParty Info:"
    - "&f Leader: &b{0}"
    - "&f Size: &7(&b{1}&7/&b{2}&7)"
    - "&f Members: &b{3}"
    - "&f Settings: &b{4}"
    - "&f Chat: &b{5}"
    - "&7&m------------------------------------------------"
  chat-off: "&cParty chat has been muted"
  toggle-party-chat: "&fYour party chat has been &b{0}"
  disband-leader-left: "&cParty has been disbanded since the party leader is offline"
  quit: "&b{0} &fhas left the server"
  only-leader: "&cThis command can only be used by party leaders"
  in-a-party: "&cYou are already in a party, cannot use this command"
  not-in-a-party: "&cYou are not in the same party, cannot use this command"
  wrong-state: "&cYou must be in a lobby to create a party"
  party-not-open: "&cYour party must be public to use this command, use '/party open' to set it to public"
  announce-cooldown: "&cThe announce command is in cooldown. Please wait {0} seconds to use it again"
  player-not-found: "&cCannot find player '{0}'"
  party-not-found: "&cCannot find '{0}' 's party"
  full: "&cParty is full"
  already-in-party: "&cYou are already in this party"
  target-already-in-party: "&cThe opponent is already in another party"
  not-invited: "&cYou have not been invited to this party!"
  disabled-party-invite: "&cThis player has disabled party invites!"
  not-integer: "'{0}' is not a valid number!"
  size-below-1: "&cParty size cannot be lower than 1"
  error-leader-not-found: "&cError: please report this issue to a moderator (ERROR_LEADER_PLAYER_NULL)"
  max-size: "&cYour party's max size is {0}!"
  already-invite: "&cThere's already an on-going invite request. If you want to invite the same player again, please wait 30 seconds."
  invalid-match-type: "&cInvalid match type '{0}'"
  invalid-kit: "&cInvalid kit with name '{0}'"
  invalid-arena: "&cInvalid arena with name '{0}'"
  help-message:
    - "&6&m------------------------------------------------"
    - "&dHelp party &7- &fHow to use party commands"
    - "&6&m------------------------------------------------"
    - "&9Party commands:"
    - "&b/party leave &7- &eLeave your current party"
    - "&b/party join <ID> &7- &eJoin/accept party requests"
    - "&b/party list <ID> &7- &eCheck a specific player`s party status"
    - ""
    - "&9Leader commands:"
    - "&b/party invite <ID> &7- &eInvite a player to your party"
    - "&b/party mute &7- &eEnable/disable party chat"
    - "&b/party chat &7- &eEnable/disable automatic party chat"
    - "&b/party kick <ID> &7- &eKick a player from your party"
    - "&b/party disband &7- &eDisband your party"
    - "&b/party open &7- &eSetting party status to public"
    - "&b/party close &7- &eSetting party status to invite-only"
    - "&b/party size <party max-size> &7- &eSet party's max-size"
    - "&b/party announce &7- &eMake an announcement in your party"
    - ""
    - "&9other tips:"
    - "&bIf you want to use &eparty chat&b, use &7'&b@&7' &bor &7'&b!&7' &bbefore your messages"
    - "&6&m------------------------------------------------"
  choose-arena-menu:
    title: "Select Arena"
    button:
      name: "&b{0}"
      random: "&bRandom Map"
      lore:
        - ""
        - "&e&nClick to select this arena!"
  choose-kit-menu:
    title: "Select Kit"
    button:
      name: "&b{0}"
      lore:
        - ""
        - "&e&nClick to select this kit!"
  choose-match-type-menu:
    title: "Select Mode"
    split-button:
      name: "&bParty Fight"
      lore:
        - "&7This will split your party to two teams"
        - "&7and start the match"
        - ""
        - "&e&nClick to select this mode!"
    ffa-button:
      name: "&bFFA"
      lore:
        - "&7Everyone in the party will be your enemy"
        - "&7Last to survive will be the winner"
        - ""
        - "&e&nClick to select this mode!"
  other-parties-menu:
    title: "Other Parties"
    button:
      name: "&b{0}'s &fTeam"
      lore-start:
        - "&bTeam Information"
        - " &fLeader: &b{0}"
        - " &fSize: &b{1}&7/&b{2}"
        - ""
        - " &fMembers:"
      lore-end:
        - ""
        - "&e&nClick to send duel request!"
  start-party-fight:
    only-leader: "&cThis can only be started by party leader"
    need-more-than-2: "&cYour party needs to have at least 2 players!"
    arena-disabled: "&cError: Arena disabled"
    cannot-find-arena: "&cError: Cannot find arena"
    players-not-in-lobby: "&cPlayer {0} is not in a lobby"
profile:
  cannot-find-player: "&cCannot find ID, player will need to have logged onto the server at least once to view profile"
  error-cannot-load-player: "&cError: could not load player profile"
  kit-right-click-to-receive:
    - "&7Right click"
    - "&7To receive your kit"
  settings-menu:
    title: "Settings"
    click-to-switch-settings: "&e&nClick to switch setting!"
    no-permission: "&cYou don't have permission to change this setting"
  procedure:
    enter-cancel-to-cancel: "&e&lEnter &c&lcancel &e&lto stop the procedure"
    success-cancel: "&aProcedure has been cancelled"
  settings:
    successfully-changed: "Successfully changed setting {0}"
    time-changer:
      name: "Time"
      lore:
        - ""
        - "&7Change your in-game time"
        - ""
      normal-server-time: "Default Time"
      day: "Day"
      afternoon: "Afternoon"
      night: "Evening"
      midnight: "Midnight"
      successfully-changed: "&aSuccessfully changed your client time to: {0}"
    arena-selection:
      name: "Arena Selection"
      lore:
        - ""
        - "&7Display and allow to choose arena"
        - ""
    match-scoreboard:
      name: "Match Scoreboard"
      lore:
        - ""
        - "&7Show/Hide scoreboard in matches"
        - ""
    allow-duel-request:
      name: "Duel Requests"
      lore:
        - ""
        - "&7Receive duel requests in lobby"
        - ""
    allow-party-invite:
      name: "Party Invites"
      lore:
        - ""
        - "&7Receive party invites in lobby"
        - ""
    spectator-visibility:
      name: "Spectator Visibility"
      lore:
        - ""
        - "&7See other spectators when spectating"
        - ""
    spectator-join-leave-message:
      name: "Spectator Join/Leave Message"
      lore:
        - ""
        - "&7See spectator join/leave message"
        - ""
    event-announcement:
      name: "Event Announcement"
      lore:
        - ""
        - "&7Receive event announcement"
        - ""
    ping-range:
      name: "Ping Range"
      lore:
        - ""
        - "&7Enable ping range for queuing"
        - ""
      unlimited: "Unlimited"
queue:
  usage: "&cCommand usage: /queue <Match-Type>"
  cannot-quit-queue: "&cYou are not in a queue"
  cannot-queue: "&cYou cannot start a queue right now"
  type:
    unranked: "Unranked"
    ranked: "Ranked"
  menu:
    title: "Select {0} Mode"
    button:
      lore:
        - ""
        - "&fIn-Queue: &b{0}"
        - "&fIn-Game: &b{1}"
        - ""
        - "&fClick to join &b{2} &f's Queue!"
        - ""
  error-found-queue-profile: "&cError: Found QueueProfile, cannot join the queue"
  error-not-found-queue-profile: "&cError: Cannot find QueueProfile"
  wrong-state: "&cCannot join a queue in the current state"
  error-kit-data-not-found: "&cCannot join a queue, please rejoin"
  error-not-enough-wins: "&cYou need at least {0} wins to queue ranked. You now have {1} wins."
  success-join: "&fYou have joined &b{0} &f's game queue"
  success-quit: "&fYou have left &b{0} &f's game queue"
button:
  back:
    name: "&c&lGo Back"
    lore:
      - "&7Click here to return to the last page"
  confirm:
    name-confirm: "&aConfirm"
    name-cancel: "&cCancel"
  toggle:
    name: "&b&l{0}"
  jump-to-page:
    name: "&ePage {0} "
    current-page-lore:
      - ""
      - "&aYou are already on this page!"
  page:
    next-page-available:
      name: "&aNext page"
      lore:
        - ""
        - "&eClick here to jump to the next page"
    next-page-current:
      name: "&7Next page"
      lore:
        - ""
        - "&eYou are already on the last page!"
    previous-page-available:
      name: "&aPrevious page"
      lore:
        - ""
        - "&eClick here to jump to the previous page"
    previous-page-current:
      name: "&7Previous page"
      lore:
        - ""
        - "&eYou are on the first page!"
  page-filter:
    name: "&bPage filter"
    lore:
      - ""
      - "&eLeft click to change page filter"
      - "&eRight click to switch page filter status"
      - ""
    no-filters: "&cNo filter available"
menu:
  view-all-pages:
    title: "&bView all pages"
tablist:
  ## If you want to disable header or footer, just simply put null
  ## Note that you cannot only keep the header and disable the footer, you have to enable both or disable both
  header: "&bPractice"
  footer: "&bdiamond.rip"

Filename: .\main\resources\locations.yml
spawn-location: ""
editor-location: ""

Filename: .\main\resources\menus.yml
kit-editor-menu:
  title: "&8Kit Editor"
  size: 54
  border:
    enabled: true
    material: STAINED_GLASS_PANE
    data: 7
  filler:
    enabled: true
    material: STAINED_GLASS_PANE
    data: 15
  items:
    # Armor Slots (Helmet, Chestplate, Leggings, Boots)
    armor:
      helmet: 9
      chestplate: 18
      leggings: 27
      boots: 36
      # Empty Armor Slot Placeholder
      # Set material to "" to disable placeholder (will show nothing when armor is AIR)
      # Otherwise, this item will be shown when the armor piece is AIR
      empty-placeholder:
        material: "STAINED_GLASS_PANE"
        data: 7
        name: "&7Empty Armor Slot"
        lore:
          - " "
    kit-slots:
      - 11
      - 12
      - 14
      - 15
    # Book Button Configuration
    # These are the main kit slot buttons that appear in the kit-slots positions
    # Placeholders: %slot% = slot number (1-8), %name% = custom kit name
    book-button:
      # Empty Slot (when no kit is saved in this slot)
      empty:
        material: BOOK
        data: 0
        name: "&cEmpty Slot %slot%"
        lore:
          - "&7Click to create a new kit."
      # Saved Kit (when a kit exists in this slot)
      saved:
        material: BOOK_AND_QUILL
        data: 0
        name: "&a%name%"
        lore:
          - "&7Click to load this kit into your inventory."
    # Dynamic Kit Action Buttons
    # These buttons appear below saved kits and can be enabled/disabled individually
    # The 'slot-offset' is added to the kit slot position to determine button placement
    dynamic-buttons:
      # Save Button (formerly Load Button) - Saves current inventory to the kit
      save:
        enabled: true
        slot-offset: 9  # 9 slots below the kit slot (1 row down)
        material: NAME_TAG
        data: 0
        name: "&aSave"
        lore:
          - "&7Click to save your current"
          - "&7inventory to this kit."
      # Rename Button - Opens chat prompt to rename the kit
      rename:
        enabled: false
        slot-offset: 18  # 18 slots below the kit slot (2 rows down)
        material: NAME_TAG
        data: 0
        name: "&eRename"
        lore:
          - "&7Click to rename this kit."
      # Reset Button - Resets kit to default layout
      reset:
        enabled: true
        slot-offset: 18  # 27 slots below the kit slot (3 rows down)
        material: STAINED_GLASS
        data: 4  # Dandelion yellow dye
        name: "&eReset to Default"
        lore:
          - "&7Click to reset this kit"
          - "&7to default layout."
      # Delete Button - Deletes the saved kit
      delete:
        enabled: true
        slot-offset: 27  # 36 slots below the kit slot (4 rows down)
        material: BARRIER
        data: 0  # Red
        name: "&cDelete"
        lore:
          - "&7Click to delete this kit."
    # Extra Items Button
    extra-items:
      slot: 4
      material: CHEST
      name: "&eExtra Items"
      lore:
        - "&7Click to view and edit"
        - "&7extra items for this kit."
    # Pagination
    previous-page:
      slot: 45
      material: ARROW
      name: "&cPrevious Page"
    next-page:
      slot: 53
      material: ARROW
      name: "&aNext Page"
    # Back to Kit Selector
    back-button:
      slot: 0
      material: BED
      name: "&cBack to Kit Selector"
      lore:
        - "&7Click to return to"
        - "&7the kit selector menu."

# Queue Menus (Ranked and Unranked)
queue-menu:
  # Title with placeholder: {queue-type} = "Unranked" or "Ranked"
  title: "&bQueue &7¬ª &f{queue-type}"
  # Size: use "dynamic" for auto-calculate or fixed size (9, 18, 27, 36, 45, 54)
  size: "dynamic"
  # Maximum size when using dynamic (won't grow beyond this)
  max-size: 54
  border:
    enabled: true
    material: STAINED_GLASS_PANE
    data: 7
  filler:
    enabled: true
    material: STAINED_GLASS_PANE
    data: 15
  items:
    # Kit button configuration (dynamically created for each kit)
    kit-button:
      # Uses kit's display icon as material
      # Name uses kit's display name
      # Lore template with placeholders:
      # {queue-count} - players in queue
      # {fighting-count} - players in fights
      # {kit-name} - kit display name
      lore:
        - ""
        - "{description}"
        - "&fIn Queue: &b{queue-count}"
        - "&fFighting: &b{fighting-count}"
        - ""
        - "&bTop 3 Daily Winstreak"
        - "&a{top3_name_1}: &7{top3_number_1}"
        - "&a{top3_name_2}: &7{top3_number_2}"
        - "&a{top3_name_3}: &7{top3_number_3}"
        - ""
        - "&e&nClick to join {kit-name} queue!"
    # Pagination buttons
    previous-page:
      enabled: true
      slot: 45
      material: ARROW
      name: "&cPrevious Page"
      lore:
        - ""
        - "&7Click to go back"
    next-page:
      enabled: true
      slot: 53
      material: ARROW
      name: "&aNext Page"
      lore:
        - ""
        - "&7Click for more kits"

# Kit Editor Select Kit Menu
kit-editor-select-kit-menu:
  title: "&bSelect a Kit"
  size: "dynamic"
  max-size: 54
  border:
    enabled: true
    material: STAINED_GLASS_PANE
    data: 7
  filler:
    enabled: true
    material: STAINED_GLASS_PANE
    data: 15
  items:
    # Kit button configuration (dynamically created for each editable kit)
    kit-button:
      # Uses kit's display icon as material
      # Name uses kit's display name  
      # Placeholder: {kit-name} - kit display name
      name: "&b{kit-name}"
      lore:
        - ""
        - "&e&nClick to edit kit layout!"

# Event Create Menu
event-create-menu:
  title: "&bCreate an Event"
  size: 27
  border:
    enabled: true
    material: STAINED_GLASS_PANE
    data: 7
  filler:
    enabled: true
    material: STAINED_GLASS_PANE
    data: 15
  items:
    # Event type buttons (one for each EventType)
    # Placeholders: {event-name} - event type name
    event-button:
      # Slot is dynamically assigned based on order
      # Material comes from EventType.getLogo()
      name: "&b{event-name}"
      lore-has-permission:
        - ""
        - "&e&n Click me to setup the Event!"
      lore-no-permission:
        - ""
        - "&cYou don't have permission to host this event!"

# Event Settings Menu
event-settings-menu:
  title: "&bEvent Settings"
  size: 27
  border:
    enabled: true
    material: STAINED_GLASS_PANE
    data: 7
  filler:
    enabled: true
    material: STAINED_GLASS_PANE
    data: 15
  items:
    max-players-button:
      slot: 10
      material: GHAST_TEAR
      name: "&bMaximum Players"
      lore:
        - ""
        - "&fCurrent Maximum Players: &b{max-players}"
        - ""
        - "&aLEFT CLICK &fto increase Maximum Players by 1"
        - "&aSHIFT + LEFT CLICK &fto increase Maximum Players by 10"
        - ""
        - "&cRIGHT CLICK &fto decrease Maximum Players by 1"
        - "&cSHIFT + RIGHT CLICK &fto decrease Maximum Players by 10"
        - ""
        - "&e&nClick to change Maximum Players!"
    party-size-button:
      slot: 12
      material: SKULL_ITEM
      data: 3
      name: "&bTeam Size"
      lore:
        - ""
        - "&fCurrent Team Size: &b{team-size}"
        - ""
        - "&aLEFT CLICK &fto increase Team Size by 1"
        - "&cRIGHT CLICK &fto decrease Team Size by 1"
        - ""
        - "&e&nClick to change Team Size!"
    kit-button:
      slot: 14
      material: BOOK
      name: "&bKit"
      lore:
        - ""
        - "&fCurrent Selected Kit: &b{kit-name}"
        - ""
        - "&e&nClick to change a Kit!"
    start-button:
      slot: 22
      material: STAINED_GLASS_PANE
      data: 5
      name: "&bStart Event"
      lore:
        - ""
        - "&fEvent: &b{event-name}"
        - "&fMinimum Players: &b{min-players}"
        - "&fMaximum Players: &b{max-players}"
        - ""
        - "&e&nClick to start Event!"

# Profile Settings Menu
profile-settings-menu:
  title: "&bSettings"
  size: 54
  border:
    enabled: true
    material: STAINED_GLASS_PANE
    data: 7
  filler:
    enabled: true
    material: STAINED_GLASS_PANE
    data: 15
  items:
    time-changer:
      slot: 10
      normal:
        material: WATCH
        data: 0
        glow: true
        name: "&bTime Changer"
        lore:
          - "&7Change your time."
          - ""
          - "&7Current: &fServer Time"
          - ""
          - "&eClick to switch to Day!"
      day:
        material: WATCH
        data: 0
        glow: true
        name: "&bTime Changer"
        lore:
          - "&7Change your time."
          - ""
          - "&7Current: &fDay"
          - ""
          - "&eClick to switch to Afternoon!"
      afternoon:
        material: WATCH
        data: 0
        glow: true
        name: "&bTime Changer"
        lore:
          - "&7Change your time."
          - ""
          - "&7Current: &fAfternoon"
          - ""
          - "&eClick to switch to Night!"
      night:
        material: WATCH
        data: 0
        glow: true
        name: "&bTime Changer"
        lore:
          - "&7Change your time."
          - ""
          - "&7Current: &fNight"
          - ""
          - "&eClick to switch to Midnight!"
      midnight:
        material: WATCH
        data: 0
        glow: true
        name: "&bTime Changer"
        lore:
          - "&7Change your time."
          - ""
          - "&7Current: &fMidnight"
          - ""
          - "&eClick to switch to Server Time!"
    arena-selection:
      slot: 11
      enabled:
        material: GRASS
        data: 0
        glow: true
        name: "&bArena Selection"
        lore:
          - "&7Toggle arena selection."
          - ""
          - "&7Status: &aEnabled"
          - ""
          - "&eClick to toggle!"
      disabled:
        material: GRASS
        data: 0
        glow: false
        name: "&bArena Selection"
        lore:
          - "&7Toggle arena selection."
          - ""
          - "&7Status: &cDisabled"
          - ""
          - "&eClick to toggle!"
    match-scoreboard:
      slot: 12
      enabled:
        material: ITEM_FRAME
        data: 0
        glow: true
        name: "&bMatch Scoreboard"
        lore:
          - "&7Toggle match scoreboard."
          - ""
          - "&7Status: &aEnabled"
          - ""
          - "&eClick to toggle!"
      disabled:
        material: ITEM_FRAME
        data: 0
        glow: false
        name: "&bMatch Scoreboard"
        lore:
          - "&7Toggle match scoreboard."
          - ""
          - "&7Status: &cDisabled"
          - ""
          - "&eClick to toggle!"
    allow-duel-request:
      slot: 13
      enabled:
        material: DIAMOND_SWORD
        data: 0
        glow: true
        name: "&bAllow Duel Requests"
        lore:
          - "&7Toggle duel requests."
          - ""
          - "&7Status: &aEnabled"
          - ""
          - "&eClick to toggle!"
      disabled:
        material: DIAMOND_SWORD
        data: 0
        glow: false
        name: "&bAllow Duel Requests"
        lore:
          - "&7Toggle duel requests."
          - ""
          - "&7Status: &cDisabled"
          - ""
          - "&eClick to toggle!"
    allow-party-invite:
      slot: 14
      enabled:
        material: NETHER_STAR
        data: 0
        glow: true
        name: "&bAllow Party Invites"
        lore:
          - "&7Toggle party invites."
          - ""
          - "&7Status: &aEnabled"
          - ""
          - "&eClick to toggle!"
      disabled:
        material: NETHER_STAR
        data: 0
        glow: false
        name: "&bAllow Party Invites"
        lore:
          - "&7Toggle party invites."
          - ""
          - "&7Status: &cDisabled"
          - ""
          - "&eClick to toggle!"
    spectator-visibility:
      slot: 15
      enabled:
        material: SKULL_ITEM
        data: 3
        glow: true
        name: "&bSpectator Visibility"
        lore:
          - "&7Toggle spectator visibility."
          - ""
          - "&7Status: &aEnabled"
          - ""
          - "&eClick to toggle!"
      disabled:
        material: SKULL_ITEM
        data: 3
        glow: false
        name: "&bSpectator Visibility"
        lore:
          - "&7Toggle spectator visibility."
          - ""
          - "&7Status: &cDisabled"
          - ""
          - "&eClick to toggle!"
    spectator-join-leave-message:
      slot: 16
      enabled:
        material: FEATHER
        data: 0
        glow: true
        name: "&bSpectator Messages"
        lore:
          - "&7Toggle spectator join/leave messages."
          - ""
          - "&7Status: &aEnabled"
          - ""
          - "&eClick to toggle!"
      disabled:
        material: FEATHER
        data: 0
        glow: false
        name: "&bSpectator Messages"
        lore:
          - "&7Toggle spectator join/leave messages."
          - ""
          - "&7Status: &cDisabled"
          - ""
          - "&eClick to toggle!"
    event-announcement:
      slot: 22
      enabled:
        material: EMERALD
        data: 0
        glow: true
        name: "&bEvent Announcements"
        lore:
          - "&7Toggle event announcements."
          - ""
          - "&7Status: &aEnabled"
          - ""
          - "&eClick to toggle!"
      disabled:
        material: EMERALD
        data: 0
        glow: false
        name: "&bEvent Announcements"
        lore:
          - "&7Toggle event announcements."
          - ""
          - "&7Status: &cDisabled"
          - ""
          - "&eClick to toggle!"
    ping-range:
      slot: 24
      material: STICK
      data: 0
      glow: true
      name: "&bPing Range"
      lore:
        - "&7Change ping range."
        - ""
        - "&7Current: &f{current}"
        - ""
        - "&eClick to switch to {next}!"

# Party - Other Parties Menu (Paginated)
party-other-parties-menu:
  title: "&bOther Parties"
  size: "dynamic"
  max-size: 54
  border:
    enabled: true
    material: STAINED_GLASS_PANE
    data: 7
  filler:
    enabled: true
    material: STAINED_GLASS_PANE
    data: 15
  items:
    # Party item configuration (dynamically created for each party)
    party-button:
      material: SKULL_ITEM
      data: 3
      # Placeholders:
      # {leader} - party leader name
      # {members} - current party size
      # {max-size} - max party size  
      # {member-list} - formatted list of members
      name: "&b{leader}'s Party"
      lore:
        - ""
        - "&fMembers: &b{members}&7/&b{max-size}"
        - ""
        - "{member-list}"
        - ""
        - "&e&nClick to join party!"
      member-format: " &7- &f{member}"
    # Pagination buttons
    previous-page:
      enabled: true
      slot: 45
      material: ARROW
      name: "&cPrevious Page"
      lore:
        - ""
        - "&7Click to go back"
    next-page:
      enabled: true
      slot: 53
      material: ARROW
      name: "&aNext Page"
      lore:
        - ""
        - "&7Click for more parties"

# Party Events Menu (Choose Match Type - FFA or Fight)
party-events-menu:
  title: "&bParty Events"
  size: 27
  border:
    enabled: true
    material: STAINED_GLASS_PANE
    data: 7
  filler:
    enabled: true
    material: STAINED_GLASS_PANE
    data: 15
  items:
    # Party Fight (Split) Button
    split-button:
      slot: 12
      material: DIAMOND_SWORD
      data: 0
      name: "&bParty Fight"
      lore:
        - ""
        - "&7Split your party into two teams"
        - "&7and fight against each other!"
        - ""
        - "&e&nClick to select kit!"
    # FFA Button
    ffa-button:
      slot: 14
      material: GOLD_AXE
      data: 0
      name: "&bFree For All"
      lore:
        - ""
        - "&7Everyone fights against"
        - "&7everyone in your party!"
        - ""
        - "&e&nClick to select kit!"

# Leaderboard Menu
leaderboard-menu:
  title: "&bLeaderboard"
  size: 54
  border:
    enabled: false
    material: STAINED_GLASS_PANE
    data: 7
  filler:
    enabled: true
    material: STAINED_GLASS_PANE
    data: 15
  items:
    # Allowed slots for leaderboard entries (where player heads appear)
    allowed-slots:
      - 10
      - 11
      - 12
      - 13
      - 14
      - 15
      - 16
      - 19
      - 20
      - 21
      - 22
      - 23
      - 24
      - 25
      - 28
      - 29
      - 30
      - 31
      - 32
      - 33
      - 34
    # Switch leaderboard buttons (bottom row)
    switch-buttons:
      wins:
        slot: 46
        material: CARPET
        data: 1
        name: "&bTotal Wins Leaderboard"
        lore:
          - ""
          - "&e&nClick to view!"
      elo:
        slot: 47
        material: CARPET
        data: 2
        name: "&bELO Leaderboard"
        lore:
          - ""
          - "&e&nClick to view!"
      view-stats:
        slot: 49
        material: DIAMOND
        data: 0
        name: "&bView Stats"
        lore:
          - ""
          - "&e&nClick to view!"
      winstreak:
        slot: 51
        material: CARPET
        data: 3
        name: "&bWinstreak Leaderboard"
        lore:
          - ""
          - "&e&nClick to view!"
      best-winstreak:
        slot: 52
        material: CARPET
        data: 4
        name: "&bBest Winstreak Leaderboard"
        lore:
          - ""
          - "&e&nClick to view!"

# Duel - Choose Kit Menu
duel-choose-kit-menu:
  title: "&bSelect a Kit"
  size: "dynamic"
  max-size: 54
  border:
    enabled: true
    material: STAINED_GLASS_PANE
    data: 7
  filler:
    enabled: true
    material: STAINED_GLASS_PANE
    data: 15
  items:
    # Kit button configuration
    kit-button:
      # Uses kit's display icon as material
      # Name uses kit's display name
      # Placeholders: {kit-name}
      lore:
        - ""
        - "&e&nClick to select this kit!"
    # Pagination buttons
    previous-page:
      enabled: true
      slot: 45
      material: ARROW
      name: "&cPrevious Page"
      lore:
        - ""
        - "&7Click to go back"
    next-page:
      enabled: true
      slot: 53
      material: ARROW
      name: "&aNext Page"
      lore:
        - ""
        - "&7Click for more kits"

# Duel - Choose Arena Menu
duel-choose-arena-menu:
  title: "&bSelect an Arena"
  size: "dynamic"
  max-size: 54
  border:
    enabled: true
    material: STAINED_GLASS_PANE
    data: 7
  filler:
    enabled: true
    material: STAINED_GLASS_PANE
    data: 15
  items:
    # Arena button configuration
    arena-button:
      # Uses arena's icon as material
      # Placeholders: {arena-name}
      name: "&b{arena-name}"
      lore:
        - ""
        - "&e&nClick to select this arena!"
    # Random Arena Button
    random-arena-button:
      slot: 4
      material: MAP
      name: "&bRandom Arena"
      lore:
        - ""
        - "&e&nClick to select a random arena!"
    # Go Back Button
    go-back:
      enabled: true
      slot: 0
      material: BED
      name: "&cGo Back"
      lore:
        - ""
        - "&7Return to kit selection"
    # Pagination buttons
    previous-page:
      enabled: true
      slot: 45
      material: ARROW
      name: "&cPrevious Page"
      lore:
        - ""
        - "&7Click to go back"
    next-page:
      enabled: true
      slot: 53
      material: ARROW
      name: "&aNext Page"
      lore:
        - ""
        - "&7Click for more arenas"

# Party - Choose Kit Menu
party-choose-kit-menu:
  title: "&bSelect a Kit"
  size: "dynamic"
  max-size: 54
  border:
    enabled: true
    material: STAINED_GLASS_PANE
    data: 7
  filler:
    enabled: true
    material: STAINED_GLASS_PANE
    data: 15
  items:
    # Kit button configuration
    kit-button:
      # Uses kit's display icon as material
      # Name uses kit's display name
      # Placeholders: {kit-name}
      lore:
        - ""
        - "&e&nClick to select this kit!"
    # Pagination buttons
    previous-page:
      enabled: true
      slot: 45
      material: ARROW
      name: "&cPrevious Page"
      lore:
        - ""
        - "&7Click to go back"
    next-page:
      enabled: true
      slot: 53
      material: ARROW
      name: "&aNext Page"
      lore:
        - ""
        - "&7Click for more kits"

# Party - Choose Arena Menu
party-choose-arena-menu:
  title: "&bSelect an Arena"
  size: "dynamic"
  max-size: 54
  border:
    enabled: true
    material: STAINED_GLASS_PANE
    data: 7
  filler:
    enabled: true
    material: STAINED_GLASS_PANE
    data: 15
  items:
    # Arena button configuration
    arena-button:
      # Uses arena's icon as material
      # Placeholders: {arena-name}
      name: "&b{arena-name}"
      lore:
        - ""
        - "&e&nClick to select this arena!"
    # Random Arena Button
    random-arena-button:
      slot: 4
      material: MAP
      name: "&bRandom Arena"
      lore:
        - ""
        - "&e&nClick to select a random arena!"
    # Go Back Button
    go-back:
      enabled: true
      slot: 0
      material: BED
      name: "&cGo Back"
      lore:
        - ""
        - "&7Return to kit selection"
    # Pagination buttons
    previous-page:
      enabled: true
      slot: 45
      material: ARROW
      name: "&cPrevious Page"
      lore:
        - ""
        - "&7Click to go back"
    next-page:
      enabled: true
      slot: 53
      material: ARROW
      name: "&aNext Page"
      lore:
        - ""
        - "&7Click for more arenas"


Filename: .\main\resources\plugin.yml
main: rip.diamond.practice.Eden
name: Eden
version: '${version}'
author: GoodestEnglish
description: The best practice plugin with premium features
website: https://youtube.com/c/goodestenglishpvp
depend: [WorldEdit, FastAsyncWorldEdit, ProtocolLib]
softdepend: [ViaVersion, PlaceholderAPI, Citizens]

Filename: .\main\resources\sound.yml
receive-duel-request: CHICKEN_EGG_POP;1;1
golden-head-eat: EAT;1;1
self-break-bed: ENDERDRAGON_GROWL;1;1
opponent-break-bed: WITHER_DEATH;1;1
new-round-countdown: CLICK;1;1
match-start: FIREWORK_BLAST;1;1

